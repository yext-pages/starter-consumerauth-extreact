import fs from "fs";
import path from "path";
import esbuild from "esbuild";
import { importFromString } from "module-from-string";
import glob from "glob";
import chalk from "chalk";
import os from "os";
const FUNCTIONS_PATH = path.resolve("functions");
const FUNCTION_METADATA_PATH = path.join(
  FUNCTIONS_PATH,
  "functionMetadata.json"
);
const TEMP_DIR = os.tmpdir();
const getFunctionMetadataMap = async () => {
  const filepaths = glob.sync(path.join(FUNCTIONS_PATH, "**/*.{js,ts}"), { nodir: true }).map((f) => path.resolve(f));
  const results = await Promise.allSettled(
    filepaths.map(generateFunctionMetadata)
  );
  const functionMetadataArray = results.filter((result) => {
    if (result.status === "fulfilled") {
      return true;
    } else {
      console.error(chalk.red(result.reason));
      return false;
    }
  }).map((result) => {
    return result.value;
  });
  return Object.fromEntries(functionMetadataArray);
};
async function generateFunctionMetadata(filepath) {
  const buildResult = await esbuild.build({
    entryPoints: [filepath],
    outdir: TEMP_DIR,
    write: false,
    format: "esm",
    bundle: true
  });
  const importedFile = await importFromString(buildResult.outputFiles[0].text);
  const relativePath = path.relative(process.cwd(), filepath);
  if (!importedFile.default) {
    throw new Error(`${relativePath} does not contain a default export.`);
  }
  return [relativePath, { entrypoint: importedFile.default.name }];
}
const generateFunctionMetadataFile = async () => {
  const functionMetadataMap = await getFunctionMetadataMap();
  fs.writeFileSync(
    FUNCTION_METADATA_PATH,
    JSON.stringify(functionMetadataMap, null, 2)
  );
};
const shouldGenerateFunctionMetadata = () => {
  return fs.existsSync(FUNCTIONS_PATH);
};
export {
  generateFunctionMetadataFile,
  shouldGenerateFunctionMetadata
};
