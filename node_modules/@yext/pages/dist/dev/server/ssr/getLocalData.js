import path from "path";
import fs from "fs";
import { readdir } from "fs/promises";
import { findTemplateModuleInternal } from "./findTemplateModuleInternal.js";
const LOCAL_DATA_PATH = "localData";
const getLocalDataManifest = async (vite, templateFilepaths) => {
  const localDataManifest = {
    static: [],
    entity: /* @__PURE__ */ new Map()
  };
  let dir;
  try {
    dir = await readdir(LOCAL_DATA_PATH);
  } catch (err) {
    if (err.code === "ENOENT") {
      return localDataManifest;
    } else {
      throw err;
    }
  }
  for (const fileName of dir) {
    const data = JSON.parse(
      fs.readFileSync(
        path.resolve(process.cwd(), `${LOCAL_DATA_PATH}/${fileName}`)
      ).toString()
    );
    const featureName = data.__?.name?.toString();
    if (!featureName) {
      continue;
    }
    const entityId = data.id?.toString();
    const slug = data.slug?.toString();
    if (entityId) {
      localDataManifest.entity.set(featureName, [
        ...localDataManifest.entity.get(featureName) || [],
        { entityId, slug }
      ]);
    } else {
      const templateModuleInternal = await findTemplateModuleInternal(
        vite,
        (t) => featureName === t.config.name,
        templateFilepaths
      );
      if (!templateModuleInternal) {
        console.error(
          `Could not find a static template for feature "${featureName}", skipping.`
        );
        continue;
      }
      localDataManifest.static.push({
        featureName,
        staticURL: templateModuleInternal.getPath({})
      });
    }
  }
  return localDataManifest;
};
const getLocalData = async (criterion) => {
  try {
    const dir = await readdir(LOCAL_DATA_PATH);
    for (const fileName of dir) {
      const data = JSON.parse(
        fs.readFileSync(
          path.resolve(process.cwd(), `${LOCAL_DATA_PATH}/${fileName}`)
        ).toString()
      );
      if (criterion(data)) {
        return data;
      }
    }
  } catch (err) {
    if (err.code === "ENOENT") {
      throw "No localData exists. Please run `yext sites generate-test-data`";
    } else {
      throw err;
    }
  }
};
const getLocalDataForEntityOrStaticPage = async ({
  locale,
  featureName,
  entityId
}) => {
  const localData = await getLocalData((data) => {
    if (entityId !== "" && data.id !== entityId) {
      return false;
    }
    return data.locale === locale && data.__.name === featureName;
  });
  if (!localData) {
    throw new Error(
      `No localData files match entityId, featureName, and locale: ${entityId}, ${featureName}, ${locale}`
    );
  }
  return localData;
};
const getLocalDataForSlug = async ({
  locale,
  slug
}) => {
  const localDataForSlug = (await getAllLocalData()).filter((d) => d.slug === slug);
  if (localDataForSlug.length === 0) {
    throw new Error(
      `No localData files match slug and locale: ${slug} ${locale}`
    );
  } else if (localDataForSlug.length > 1) {
    throw new Error(
      `Multiple localData files match slug and locale: ${slug} ${locale}, expected only a single file`
    );
  }
  return localDataForSlug[0];
};
const getAllLocalData = async () => {
  try {
    const dir = await readdir(LOCAL_DATA_PATH);
    return dir.map((fileName) => {
      const data = JSON.parse(
        fs.readFileSync(
          path.resolve(process.cwd(), `${LOCAL_DATA_PATH}/${fileName}`)
        ).toString()
      );
      return data;
    });
  } catch (err) {
    if (err.code === "ENOENT") {
      throw "No localData exists. Please run `yext sites generate-test-data`";
    } else {
      throw err;
    }
  }
};
export {
  getLocalDataForEntityOrStaticPage,
  getLocalDataForSlug,
  getLocalDataManifest
};
