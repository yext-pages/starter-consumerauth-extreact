"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.DropdownInput = void 0;
const jsx_runtime_1 = require("react/jsx-runtime");
const react_1 = require("react");
const DropdownContext_1 = require("./DropdownContext");
const FocusContext_1 = require("./FocusContext");
const generateDropdownId_1 = require("./generateDropdownId");
const InputContext_1 = require("./InputContext");
/**
 * An input component for use within a Dropdown.
 */
function DropdownInput(props) {
    const { className, placeholder, ariaLabel, onSubmit, onFocus, onChange, submitCriteria } = props;
    const inputRef = (0, react_1.useRef)(null);
    const { toggleDropdown, onSelect, screenReaderUUID } = (0, DropdownContext_1.useDropdownContext)();
    const { value = '', setLastTypedOrSubmittedValue } = (0, InputContext_1.useInputContext)();
    const { focusedIndex = -1, focusedItemData, focusedValue, updateFocusedItem } = (0, FocusContext_1.useFocusContext)();
    const [isTyping, setIsTyping] = (0, react_1.useState)(true);
    const handleChange = (0, react_1.useCallback)((e) => {
        setIsTyping(true);
        toggleDropdown(true);
        onChange === null || onChange === void 0 ? void 0 : onChange(e.target.value);
        updateFocusedItem(-1, e.target.value);
        setLastTypedOrSubmittedValue(e.target.value);
    }, [onChange, setLastTypedOrSubmittedValue, toggleDropdown, updateFocusedItem]);
    const handleKeyDown = (0, react_1.useCallback)((e) => {
        var _a;
        if (e.key === 'ArrowDown' || e.key === 'ArrowUp' || e.key === 'Tab') {
            setIsTyping(false);
        }
        if (e.key === 'Enter' && (!submitCriteria || submitCriteria(focusedIndex))) {
            updateFocusedItem(focusedIndex);
            toggleDropdown(false);
            (_a = inputRef.current) === null || _a === void 0 ? void 0 : _a.blur();
            onSubmit === null || onSubmit === void 0 ? void 0 : onSubmit(value, focusedIndex, focusedItemData);
            if (focusedIndex >= 0) {
                onSelect === null || onSelect === void 0 ? void 0 : onSelect(value, focusedIndex, focusedItemData);
            }
            updateFocusedItem(-1, focusedValue !== null && focusedValue !== void 0 ? focusedValue : undefined);
        }
    }, [
        focusedIndex,
        focusedValue,
        focusedItemData,
        onSelect,
        onSubmit,
        submitCriteria,
        toggleDropdown,
        updateFocusedItem,
        value
    ]);
    const handleFocus = (0, react_1.useCallback)(() => {
        toggleDropdown(true);
        updateFocusedItem(-1);
        onFocus === null || onFocus === void 0 ? void 0 : onFocus(value);
    }, [onFocus, toggleDropdown, updateFocusedItem, value]);
    return ((0, jsx_runtime_1.jsx)("input", { ref: inputRef, className: className, placeholder: placeholder, value: value, onChange: handleChange, onKeyDown: handleKeyDown, onFocus: handleFocus, id: (0, generateDropdownId_1.generateDropdownId)(screenReaderUUID, -1), autoComplete: 'off', "aria-describedby": screenReaderUUID, "aria-activedescendant": isTyping ? '' : (0, generateDropdownId_1.generateDropdownId)(screenReaderUUID, focusedIndex), "aria-label": ariaLabel }, void 0));
}
exports.DropdownInput = DropdownInput;
//# sourceMappingURL=DropdownInput.js.map