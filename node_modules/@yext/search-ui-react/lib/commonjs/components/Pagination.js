"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Pagination = void 0;
const jsx_runtime_1 = require("react/jsx-runtime");
const search_headless_react_1 = require("@yext/search-headless-react");
const useComposedCssClasses_1 = require("../hooks/useComposedCssClasses");
const ChevronIcon_1 = require("../icons/ChevronIcon");
const usePaginationAnalytics_1 = require("../hooks/usePaginationAnalytics");
const utils_1 = require("../utils");
const react_1 = require("react");
const classnames_1 = __importDefault(require("classnames"));
const builtInPaginationCssClasses = {
    paginationContainer: 'flex justify-center mb-4',
    paginationLoading: 'opacity-50',
    label: 'z-0 inline-flex items-center px-4 py-2 text-sm font-semibold border border-gray-300 text-neutral',
    selectedLabel: 'z-10 inline-flex items-center px-4 py-2 text-sm font-semibold border border-primary text-primary bg-primary-light',
    leftIconContainer: 'inline-flex items-center px-3.5 py-2 border border-gray-300 rounded-l-md',
    rightIconContainer: 'inline-flex items-center px-3.5 py-2 border border-gray-300 rounded-r-md',
    icon: 'w-3 text-gray-600'
};
/**
 * Renders a component that divide a series of vertical results into chunks
 * across multiple pages and enable user to navigate between those pages.
 *
 * @public
 */
function Pagination(props) {
    var _a;
    const { customCssClasses = {}, paginateAllOnNoResults = false } = props;
    const cssClasses = (0, useComposedCssClasses_1.useComposedCssClasses)(builtInPaginationCssClasses, customCssClasses);
    const searchActions = (0, search_headless_react_1.useSearchActions)();
    const verticalResultsCount = (0, search_headless_react_1.useSearchState)(state => state.vertical.resultsCount) || 0;
    const allResultsCountForVertical = (0, search_headless_react_1.useSearchState)(state => { var _a, _b; return (_b = (_a = state.vertical) === null || _a === void 0 ? void 0 : _a.noResults) === null || _b === void 0 ? void 0 : _b.allResultsForVertical.resultsCount; }) || 0;
    const isLoading = (0, search_headless_react_1.useSearchState)(state => state.searchStatus.isLoading);
    let resultsCount = verticalResultsCount;
    if (verticalResultsCount === 0 && paginateAllOnNoResults) {
        resultsCount = allResultsCountForVertical;
    }
    const offset = (0, search_headless_react_1.useSearchState)(state => state.vertical.offset) || 0;
    const limit = (0, search_headless_react_1.useSearchState)(state => state.vertical.limit) || 20;
    const currentPageNumber = (offset / limit) + 1;
    const maxPageCount = Math.ceil(resultsCount / limit);
    const reportAnalyticsEvent = (0, usePaginationAnalytics_1.usePaginationAnalytics)();
    const navigateToPage = (0, react_1.useCallback)((newPageNumber) => {
        const newOffset = limit * (newPageNumber - 1);
        searchActions.setOffset(newOffset);
        (0, utils_1.executeSearch)(searchActions);
        reportAnalyticsEvent(newPageNumber, currentPageNumber, maxPageCount);
    }, [searchActions, limit, maxPageCount, currentPageNumber, reportAnalyticsEvent]);
    if (maxPageCount <= 1) {
        return null;
    }
    const paginationLabels = generatePaginationLabels(currentPageNumber, maxPageCount);
    const paginationContainerClassNames = (0, classnames_1.default)(cssClasses.paginationContainer, {
        [(_a = cssClasses.paginationLoading) !== null && _a !== void 0 ? _a : '']: isLoading
    });
    return ((0, jsx_runtime_1.jsx)("div", Object.assign({ className: paginationContainerClassNames }, { children: (0, jsx_runtime_1.jsxs)("nav", Object.assign({ className: 'inline-flex shadow-sm -space-x-px', "aria-label": "Pagination" }, { children: [(0, jsx_runtime_1.jsx)(PaginationButton, Object.assign({ ariaLabel: 'Navigate to the previous results page', className: cssClasses.leftIconContainer, navigateToPage: navigateToPage, newPageNumber: currentPageNumber - 1, disabled: currentPageNumber === 1 }, { children: (0, jsx_runtime_1.jsx)(ChevronIcon_1.ChevronIcon, { className: cssClasses.icon + ' transform -rotate-90' }, void 0) }), void 0), paginationLabels.map((label, index) => {
                    switch (label) {
                        case '...':
                            return ((0, jsx_runtime_1.jsx)("div", Object.assign({ className: cssClasses.label }, { children: label }), index));
                        case `${currentPageNumber}`:
                            return ((0, jsx_runtime_1.jsx)(PaginationButton, Object.assign({ className: cssClasses.selectedLabel, navigateToPage: navigateToPage, newPageNumber: currentPageNumber }, { children: label }), index));
                        default:
                            return ((0, jsx_runtime_1.jsx)(PaginationButton, Object.assign({ className: cssClasses.label, navigateToPage: navigateToPage, newPageNumber: Number(label) }, { children: label }), index));
                    }
                }), (0, jsx_runtime_1.jsx)(PaginationButton, Object.assign({ ariaLabel: 'Navigate to the next results page', className: cssClasses.rightIconContainer, navigateToPage: navigateToPage, newPageNumber: currentPageNumber + 1, disabled: currentPageNumber === maxPageCount }, { children: (0, jsx_runtime_1.jsx)(ChevronIcon_1.ChevronIcon, { className: cssClasses.icon + ' transform rotate-90' }, void 0) }), void 0)] }), void 0) }), void 0));
}
exports.Pagination = Pagination;
function PaginationButton(props) {
    const { navigateToPage, newPageNumber } = props;
    const handleClick = (0, react_1.useCallback)(() => {
        navigateToPage(newPageNumber);
    }, [navigateToPage, newPageNumber]);
    return ((0, jsx_runtime_1.jsx)("button", Object.assign({ "aria-label": props.ariaLabel, className: props.className, onClick: handleClick, disabled: props.disabled }, { children: props.children }), void 0));
}
function generatePaginationLabels(currentPageNumber, maxPageCount) {
    const paginationLabels = [];
    const previousPageNumber = currentPageNumber - 1;
    const nextPageNumber = currentPageNumber + 1;
    if (previousPageNumber > 3) {
        paginationLabels.push('1', '...', `${previousPageNumber}`);
    }
    else if (previousPageNumber !== 0) {
        [...Array(previousPageNumber)].forEach((_, index) => paginationLabels.push(`${index + 1}`));
    }
    paginationLabels.push(`${currentPageNumber}`);
    if (maxPageCount - nextPageNumber > 2) {
        paginationLabels.push(`${nextPageNumber}`, '...', `${maxPageCount}`);
    }
    else if (nextPageNumber <= maxPageCount) {
        [...Array(maxPageCount - nextPageNumber + 1)]
            .forEach((_, index) => paginationLabels.push(`${nextPageNumber + index}`));
    }
    return paginationLabels;
}
//# sourceMappingURL=Pagination.js.map