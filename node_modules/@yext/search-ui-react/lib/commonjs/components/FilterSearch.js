"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.FilterSearch = void 0;
const jsx_runtime_1 = require("react/jsx-runtime");
const search_headless_react_1 = require("@yext/search-headless-react");
const react_1 = require("react");
const useComposedCssClasses_1 = require("../hooks/useComposedCssClasses");
const useSynchronizedRequest_1 = require("../hooks/useSynchronizedRequest");
const utils_1 = require("../utils");
const filterutils_1 = require("../utils/filterutils");
const Dropdown_1 = require("./Dropdown/Dropdown");
const DropdownInput_1 = require("./Dropdown/DropdownInput");
const DropdownItem_1 = require("./Dropdown/DropdownItem");
const DropdownMenu_1 = require("./Dropdown/DropdownMenu");
const processTranslation_1 = require("./utils/processTranslation");
const renderAutocompleteResult_1 = require("./utils/renderAutocompleteResult");
const builtInCssClasses = {
    filterSearchContainer: 'relative mb-2',
    label: 'mb-4 text-sm font-medium text-neutral-dark',
    inputElement: 'text-sm bg-white outline-none h-9 w-full p-2 rounded-md border border-gray-300 focus:border-primary text-neutral-dark placeholder:text-neutral',
    sectionLabel: 'text-sm text-neutral-dark font-semibold py-2 px-4',
    focusedOption: 'bg-gray-100',
    option: 'text-sm text-neutral-dark py-1 cursor-pointer hover:bg-gray-100 px-4'
};
/**
 * A component which allows a user to search for filters associated with specific entities and fields.
 *
 * @public
 *
 * @param props - {@link FilterSearchProps}
 * @returns A react component for Filter Search
 */
function FilterSearch({ searchFields, label, placeholder = 'Search here...', searchOnSelect, onSelect, sectioned = false, customCssClasses }) {
    const searchActions = (0, search_headless_react_1.useSearchActions)();
    const searchParamFields = searchFields.map((searchField) => {
        return Object.assign(Object.assign({}, searchField), { fetchEntities: false });
    });
    const matchingFieldIds = (0, react_1.useMemo)(() => {
        const fieldIds = new Set(searchFields.map(s => s.fieldApiName));
        if (fieldIds.has('builtin.location')) {
            ['builtin.region', 'address.countryCode'].forEach(s => fieldIds.add(s));
        }
        return fieldIds;
    }, [searchFields]);
    const cssClasses = (0, useComposedCssClasses_1.useComposedCssClasses)(builtInCssClasses, customCssClasses);
    const [currentFilter, setCurrentFilter] = (0, react_1.useState)();
    const [filterQuery, setFilterQuery] = (0, react_1.useState)();
    const staticFilters = (0, search_headless_react_1.useSearchState)(state => state.filters.static);
    const matchingFilters = (0, react_1.useMemo)(() => {
        var _a;
        return (_a = staticFilters === null || staticFilters === void 0 ? void 0 : staticFilters.filter(({ filter, selected }) => selected
            && filter.kind === 'fieldValue'
            && matchingFieldIds.has(filter.fieldId))) !== null && _a !== void 0 ? _a : [];
    }, [staticFilters, matchingFieldIds]);
    const [filterSearchResponse, executeFilterSearch, clearFilterSearchResponse] = (0, useSynchronizedRequest_1.useSynchronizedRequest)(inputValue => {
        setFilterQuery(inputValue);
        return searchActions.executeFilterSearch(inputValue !== null && inputValue !== void 0 ? inputValue : '', sectioned, searchParamFields);
    }, (e) => console.error('Error occured executing a filter search request.\n', e));
    (0, react_1.useEffect)(() => {
        if (matchingFilters.length > 1 && !onSelect) {
            console.warn('More than one selected static filter found that matches the filter search fields: ['
                + [...matchingFieldIds].join(', ')
                + ']. Please update the state to remove the extra filters.'
                + ' Picking one filter to display in the input.');
        }
        if (currentFilter && (staticFilters === null || staticFilters === void 0 ? void 0 : staticFilters.find(f => (0, filterutils_1.isDuplicateStaticFilter)(f.filter, currentFilter) && f.selected))) {
            return;
        }
        if (matchingFilters.length === 0) {
            clearFilterSearchResponse();
            setCurrentFilter(undefined);
            setFilterQuery('');
        }
        else {
            setCurrentFilter(matchingFilters[0].filter);
            executeFilterSearch(matchingFilters[0].displayName);
        }
    }, [
        clearFilterSearchResponse,
        currentFilter,
        staticFilters,
        executeFilterSearch,
        onSelect,
        matchingFilters,
        matchingFieldIds
    ]);
    const sections = (0, react_1.useMemo)(() => {
        var _a;
        return (_a = filterSearchResponse === null || filterSearchResponse === void 0 ? void 0 : filterSearchResponse.sections.filter(section => section.results.length > 0)) !== null && _a !== void 0 ? _a : [];
    }, [filterSearchResponse === null || filterSearchResponse === void 0 ? void 0 : filterSearchResponse.sections]);
    const hasResults = sections.flatMap(s => s.results).length > 0;
    const handleSelectDropdown = (0, react_1.useCallback)((_value, _index, itemData) => {
        const newFilter = itemData === null || itemData === void 0 ? void 0 : itemData.filter;
        const newDisplayName = itemData === null || itemData === void 0 ? void 0 : itemData.displayName;
        if (!newFilter || !newDisplayName) {
            return;
        }
        if (onSelect) {
            if (searchOnSelect) {
                console.warn('Both searchOnSelect and onSelect props were passed to the component.'
                    + ' Using onSelect instead of searchOnSelect as the latter is deprecated.');
            }
            return onSelect({
                newFilter,
                newDisplayName,
                currentFilter,
                setCurrentFilter,
                executeFilterSearch
            });
        }
        if (matchingFilters.length > 1) {
            console.warn('More than one selected static filter found that matches the filter search fields: ['
                + [...matchingFieldIds].join(', ')
                + ']. Unselecting all existing matching filters and selecting the new filter.');
        }
        matchingFilters.forEach(f => searchActions.setFilterOption({ filter: f.filter, selected: false }));
        if (currentFilter) {
            searchActions.setFilterOption({ filter: currentFilter, selected: false });
        }
        searchActions.setFilterOption({ filter: newFilter, displayName: newDisplayName, selected: true });
        setCurrentFilter(newFilter);
        executeFilterSearch(newDisplayName);
        if (searchOnSelect) {
            searchActions.setOffset(0);
            searchActions.resetFacets();
            (0, utils_1.executeSearch)(searchActions);
        }
    }, [
        currentFilter,
        searchActions,
        executeFilterSearch,
        onSelect,
        searchOnSelect,
        matchingFilters,
        matchingFieldIds
    ]);
    const meetsSubmitCritera = (0, react_1.useCallback)(index => index >= 0, []);
    const itemDataMatrix = (0, react_1.useMemo)(() => {
        return sections.map(section => {
            return section.results.map(result => ({
                filter: Object.assign(Object.assign({}, result.filter), { kind: 'fieldValue' }),
                displayName: result.value
            }));
        });
    }, [sections]);
    function renderDropdownItems() {
        return sections.map((section, sectionIndex) => {
            return ((0, jsx_runtime_1.jsxs)("div", Object.assign({ className: 'pb-2' }, { children: [section.label &&
                        (0, jsx_runtime_1.jsx)("div", Object.assign({ className: cssClasses.sectionLabel }, { children: section.label }), void 0), (0, jsx_runtime_1.jsx)("div", Object.assign({ className: cssClasses.optionsContainer }, { children: section.results.map((result, index) => ((0, jsx_runtime_1.jsx)(DropdownItem_1.DropdownItem, Object.assign({ focusedClassName: cssClasses.focusedOption, value: result.value, itemData: itemDataMatrix[sectionIndex][index] }, { children: (0, renderAutocompleteResult_1.renderAutocompleteResult)(result, cssClasses) }), index))) }), void 0)] }), sectionIndex));
        });
    }
    const handleInputFocus = (0, react_1.useCallback)((value = '') => {
        if (value) {
            executeFilterSearch(value);
        }
    }, [executeFilterSearch]);
    return ((0, jsx_runtime_1.jsxs)("div", Object.assign({ className: cssClasses.filterSearchContainer }, { children: [label && (0, jsx_runtime_1.jsx)("h1", Object.assign({ className: cssClasses.label }, { children: label }), void 0), (0, jsx_runtime_1.jsxs)(Dropdown_1.Dropdown, Object.assign({ screenReaderText: getScreenReaderText(sections), onSelect: handleSelectDropdown, alwaysSelectOption: true, parentQuery: filterQuery }, { children: [(0, jsx_runtime_1.jsx)(DropdownInput_1.DropdownInput, { className: cssClasses.inputElement, placeholder: placeholder, onChange: executeFilterSearch, onFocus: handleInputFocus, submitCriteria: meetsSubmitCritera }, void 0), (0, jsx_runtime_1.jsx)(DropdownMenu_1.DropdownMenu, { children: hasResults &&
                            (0, jsx_runtime_1.jsx)("div", Object.assign({ className: 'absolute z-10 w-full shadow-lg rounded-md border border-gray-300 bg-white pt-3 pb-1 mt-1' }, { children: renderDropdownItems() }), void 0) }, void 0)] }), void 0)] }), void 0));
}
exports.FilterSearch = FilterSearch;
function getScreenReaderText(sections) {
    let screenReaderText = (0, processTranslation_1.processTranslation)({
        phrase: '0 autocomplete option found.',
        pluralForm: '0 autocomplete options found.',
        count: 0
    });
    if (sections.length === 0) {
        return screenReaderText;
    }
    const screenReaderPhrases = sections.map(section => {
        const optionInfo = section.label
            ? `${section.results.length} ${section.label}`
            : `${section.results.length}`;
        return (0, processTranslation_1.processTranslation)({
            phrase: `${optionInfo} autocomplete option found.`,
            pluralForm: `${optionInfo} autocomplete options found.`,
            count: section.results.length
        });
    });
    screenReaderText = screenReaderPhrases.join(' ');
    return screenReaderText;
}
//# sourceMappingURL=FilterSearch.js.map