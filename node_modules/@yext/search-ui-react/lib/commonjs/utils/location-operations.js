"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getUserLocation = exports.updateLocationIfNeeded = void 0;
const search_headless_react_1 = require("@yext/search-headless-react");
const defaultGeolocationOptions = {
    enableHighAccuracy: false,
    timeout: 6000,
    maximumAge: 300000,
};
/**
 * If the provided search intents include a 'NEAR_ME' intent and there's no existing
 * user's location in state, retrieve and store user's location in headless state.
 *
 * @public
 */
async function updateLocationIfNeeded(searchActions, intents, geolocationOptions) {
    if (intents.includes(search_headless_react_1.SearchIntent.NearMe) && !searchActions.state.location.userLocation) {
        try {
            const position = await getUserLocation(geolocationOptions);
            searchActions.setUserLocation({
                latitude: position.coords.latitude,
                longitude: position.coords.longitude,
            });
        }
        catch (e) {
            console.error(e);
        }
    }
}
exports.updateLocationIfNeeded = updateLocationIfNeeded;
/**
 * Retrieves user's location using navigator.geolocation API.
 *
 * @public
 */
async function getUserLocation(geolocationOptions) {
    return new Promise((resolve, reject) => {
        if ('geolocation' in navigator) {
            navigator.geolocation.getCurrentPosition(position => resolve(position), err => {
                console.error('Error occured using geolocation API. Unable to determine user\'s location.');
                reject(err);
            }, Object.assign(Object.assign({}, defaultGeolocationOptions), geolocationOptions));
        }
        else {
            reject('No access to geolocation API. Unable to determine user\'s location.');
        }
    });
}
exports.getUserLocation = getUserLocation;
//# sourceMappingURL=location-operations.js.map