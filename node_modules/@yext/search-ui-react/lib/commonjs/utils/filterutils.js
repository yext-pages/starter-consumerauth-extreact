"use strict";
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getSelectableFieldValueFilters = exports.getSelectedNumericalFacetFields = exports.clearStaticRangeFilters = exports.parseNumberRangeInput = exports.findSelectableFieldValueFilter = exports.isDuplicateStaticFilter = exports.isDuplicateFieldValueFilter = exports.isNumericalFacet = exports.isStringFacet = exports.isNumberRangeValue = exports.isNearFilterValue = void 0;
const search_headless_react_1 = require("@yext/search-headless-react");
const lodash_1 = require("lodash");
const NumberRangeFilter_1 = require("../models/NumberRangeFilter");
/**
 * Check if the object follows NearFilterValue interface.
 */
function isNearFilterValue(obj) {
    return typeof obj === 'object' && !!obj && 'radius' in obj && 'lat' in obj && 'long' in obj;
}
exports.isNearFilterValue = isNearFilterValue;
/**
 * Checks if the object follows the NumberRangeValue interface.
 */
function isNumberRangeValue(obj) {
    return typeof obj === 'object' && !!obj && ('start' in obj || 'end' in obj);
}
exports.isNumberRangeValue = isNumberRangeValue;
/**
 * Checks if the facet is a string facet with string options.
 */
function isStringFacet(facet) {
    return facet.options.length > 0 && typeof facet.options[0].value === 'string';
}
exports.isStringFacet = isStringFacet;
/**
 * Checks if the facet is a numerical facet with number range filter options.
 */
function isNumericalFacet(facet) {
    return facet.options.length > 0 &&
        facet.options.some(option => (0, NumberRangeFilter_1.isNumberRangeFilter)(option));
}
exports.isNumericalFacet = isNumericalFacet;
/**
 * Returns true if the two given field value filters are the same.
 */
function isDuplicateFieldValueFilter(thisFilter, otherFilter) {
    if (thisFilter.fieldId !== otherFilter.fieldId) {
        return false;
    }
    if (thisFilter.matcher !== otherFilter.matcher) {
        return false;
    }
    if (!(0, lodash_1.isEqual)(thisFilter.value, otherFilter.value)) {
        return false;
    }
    return true;
}
exports.isDuplicateFieldValueFilter = isDuplicateFieldValueFilter;
/**
 * Returns true if the two given static filters are the same.
 */
function isDuplicateStaticFilter(thisFilter, otherFilter) {
    if (thisFilter.kind === 'fieldValue') {
        return otherFilter.kind === 'fieldValue'
            ? isDuplicateFieldValueFilter(thisFilter, otherFilter)
            : false;
    }
    if (otherFilter.kind === 'fieldValue') {
        return false;
    }
    return thisFilter.combinator === otherFilter.combinator
        && thisFilter.filters.length === otherFilter.filters.length
        && thisFilter.filters.every(t => otherFilter.filters.some(o => isDuplicateStaticFilter(t, o)))
        && otherFilter.filters.every(o => thisFilter.filters.some(t => isDuplicateStaticFilter(o, t)));
}
exports.isDuplicateStaticFilter = isDuplicateStaticFilter;
/**
 * Finds the {@link SelectableFieldValueFilter} from the list provided that matches
 * the given {@link FieldValueFilter}. If no matching {@link SelectableFieldValueFilter}
 * can be found, undefined is returned.
 *
 * @param filter - The filter to match against
 * @param selectableFilters - The list of {@link SelectableFieldValueFilter}s to search against
 */
function findSelectableFieldValueFilter(filter, selectableFilters) {
    return selectableFilters.find(selectableFilter => {
        const { displayName: _ } = selectableFilter, storedFilter = __rest(selectableFilter, ["displayName"]);
        return isDuplicateFieldValueFilter(storedFilter, filter);
    });
}
exports.findSelectableFieldValueFilter = findSelectableFieldValueFilter;
/**
 * Creates a number range value based on a min and max from user input.
 */
function parseNumberRangeInput(minRangeInput, maxRangeInput) {
    const minRange = parseNumber(minRangeInput);
    const maxRange = parseNumber(maxRangeInput);
    return Object.assign(Object.assign({}, (minRange !== undefined && {
        start: {
            matcher: search_headless_react_1.Matcher.GreaterThanOrEqualTo,
            value: minRange
        }
    })), (maxRange !== undefined && {
        end: {
            matcher: search_headless_react_1.Matcher.LessThanOrEqualTo,
            value: maxRange
        }
    }));
}
exports.parseNumberRangeInput = parseNumberRangeInput;
/**
 * Given a string, returns the corresponding number, or undefined if it is NaN.
 */
function parseNumber(num) {
    const parsedNum = parseFloat(num);
    if (isNaN(parsedNum)) {
        return undefined;
    }
    return parsedNum;
}
/**
 * Deselects the selected static number range filters in state. If fieldIds are
 * provided, only filters corresponding to one of those fieldIds are deselected.
 * Otherwise, all selected filters are deselected.
 */
function clearStaticRangeFilters(searchActions, fieldIds) {
    var _a, _b, _c;
    const selectedStaticRangeFilters = (_c = (_b = (_a = searchActions.state) === null || _a === void 0 ? void 0 : _a.filters) === null || _b === void 0 ? void 0 : _b.static) === null || _c === void 0 ? void 0 : _c.filter(filter => (0, NumberRangeFilter_1.isNumberRangeFilter)(filter)
        && filter.selected === true
        && (!fieldIds || fieldIds.has(filter.fieldId)));
    selectedStaticRangeFilters === null || selectedStaticRangeFilters === void 0 ? void 0 : selectedStaticRangeFilters.forEach(filter => {
        searchActions.setFilterOption(Object.assign(Object.assign({}, filter), { selected: false }));
    });
}
exports.clearStaticRangeFilters = clearStaticRangeFilters;
/**
 * Returns a set of fieldIds of the numerical facets in state that have at
 * least one option selected.
 */
function getSelectedNumericalFacetFields(searchActions) {
    var _a, _b;
    const selectedNumericalFacets = (_b = (_a = searchActions.state.filters.facets) === null || _a === void 0 ? void 0 : _a.filter(f => isNumericalFacet(f) && f.options.some(o => o.selected))) !== null && _b !== void 0 ? _b : [];
    return new Set(selectedNumericalFacets.map(f => f.fieldId));
}
exports.getSelectedNumericalFacetFields = getSelectedNumericalFacetFields;
/**
 * Goes through the provided static filters and returns all that are field value
 * filters.
 *
 * @param staticFilters - The list of {@link SelectableStaticFilter}s to search through
 * @returns All filters that are {@link SelectableFieldValueFilter}s
 */
function getSelectableFieldValueFilters(staticFilters) {
    return staticFilters.map(s => {
        const _a = s.filter, { kind } = _a, filterFields = __rest(_a, ["kind"]), displayFields = __rest(s, ["filter"]);
        if (kind === 'fieldValue') {
            return Object.assign(Object.assign({}, displayFields), filterFields);
        }
        return undefined;
    }).filter((s) => !!s);
}
exports.getSelectableFieldValueFilters = getSelectableFieldValueFilters;
//# sourceMappingURL=filterutils.js.map