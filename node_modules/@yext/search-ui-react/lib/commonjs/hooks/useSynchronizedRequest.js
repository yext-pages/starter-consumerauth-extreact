"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.useSynchronizedRequest = void 0;
const react_1 = require("react");
const useComponentMountStatus_1 = require("./useComponentMountStatus");
/**
 * Handles the network request race condition by synchronizing requests with their responses. If multiple
 * requests are sent before getting a response, only the response corresponding to the latest request will
 * be returned.
 *
 * @param executeRequest - Function that executes the network request
 * @param handleRejectedPromise - Function that executes when a rejected promise is received from the request
 *
 * @returns Reponse to the latest request and a function to execute the request in a synchronized manner
 */
function useSynchronizedRequest(executeRequest, handleRejectedPromise) {
    const executeRequestRef = (0, react_1.useRef)(executeRequest);
    const handleRejectedPromiseRef = (0, react_1.useRef)(handleRejectedPromise);
    const isMountedRef = (0, useComponentMountStatus_1.useComponentMountStatus)();
    const networkIds = (0, react_1.useRef)({ latestRequest: 0, responseInState: 0 });
    const [synchronizedResponse, setSynchronizedResponse] = (0, react_1.useState)();
    const executeSynchronizedRequest = (0, react_1.useCallback)(async (data) => {
        const requestId = ++networkIds.current.latestRequest;
        return new Promise(async (resolve) => {
            let response = undefined;
            try {
                response = await executeRequestRef.current(data);
            }
            catch (e) {
                handleRejectedPromiseRef.current ? handleRejectedPromiseRef.current(e) : console.error(e);
            }
            if (requestId >= networkIds.current.responseInState) {
                /**
                 * Avoid performing a React state update on an unmounted component
                 * (e.g unmounted during async await)
                 */
                if (!isMountedRef.current) {
                    return;
                }
                setSynchronizedResponse(response);
                networkIds.current.responseInState = requestId;
            }
            resolve(response);
        });
    }, [isMountedRef]);
    const clearResponseData = (0, react_1.useCallback)(() => {
        setSynchronizedResponse(undefined);
    }, [setSynchronizedResponse]);
    (0, react_1.useEffect)(() => {
        executeRequestRef.current = executeRequest;
        handleRejectedPromiseRef.current = handleRejectedPromise;
    });
    return [synchronizedResponse, executeSynchronizedRequest, clearResponseData];
}
exports.useSynchronizedRequest = useSynchronizedRequest;
//# sourceMappingURL=useSynchronizedRequest.js.map