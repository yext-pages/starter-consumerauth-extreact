"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.useEntityPreviews = void 0;
const react_1 = require("react");
const useComponentMountStatus_1 = require("./useComponentMountStatus");
const useDebouncedFunction_1 = require("./useDebouncedFunction");
/**
 * useEntityPreviews provides state surrounding the visual entities portion of visual autocomplete,
 * which performs debounced universal searches.
 *
 * @param entityPreviewSearcher - the headless instance use as searcher for entity preview related queries
 * @param debounceTime - the time in milliseconds to debounce the universal search request
 */
function useEntityPreviews(entityPreviewSearcher, debounceTime) {
    const isMountedRef = (0, useComponentMountStatus_1.useComponentMountStatus)();
    const [verticalKeyToResults, setVerticalKeyToResults] = (0, react_1.useState)({});
    const debouncedUniversalSearch = (0, useDebouncedFunction_1.useDebouncedFunction)(async () => {
        if (!entityPreviewSearcher) {
            return;
        }
        await entityPreviewSearcher.executeUniversalQuery();
        /**
         * Avoid performing a React state update on an unmounted component
         * (e.g unmounted during async await)
         */
        if (!isMountedRef.current) {
            return;
        }
        const results = entityPreviewSearcher.state.universal.verticals || [];
        setVerticalKeyToResults(getVerticalKeyToResults(results));
        setLoadingState(false);
    }, debounceTime);
    const [isLoading, setLoadingState] = (0, react_1.useState)(false);
    function executeEntityPreviewsQuery(query, universalLimit, restrictVerticals) {
        if (!entityPreviewSearcher) {
            return;
        }
        if (query === entityPreviewSearcher.state.query.input) {
            return;
        }
        setLoadingState(true);
        entityPreviewSearcher.setQuery(query);
        entityPreviewSearcher.setRestrictVerticals(restrictVerticals);
        entityPreviewSearcher.setUniversalLimit(universalLimit);
        debouncedUniversalSearch === null || debouncedUniversalSearch === void 0 ? void 0 : debouncedUniversalSearch();
    }
    return [{ verticalKeyToResults, isLoading }, executeEntityPreviewsQuery];
}
exports.useEntityPreviews = useEntityPreviews;
/**
 * @returns a mapping of vertical key to VerticalResults
 */
function getVerticalKeyToResults(verticalResultsArray) {
    return verticalResultsArray.reduce((prev, current) => {
        prev[current.verticalKey] = current;
        return prev;
    }, {});
}
//# sourceMappingURL=useEntityPreviews.js.map