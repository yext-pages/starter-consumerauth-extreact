"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.useRemovableFilters = void 0;
const search_headless_react_1 = require("@yext/search-headless-react");
const lodash_1 = require("lodash");
const react_1 = require("react");
const filterutils_1 = require("../utils/filterutils");
const isDescendantHierarchicalFacet_1 = require("../utils/isDescendantHierarchicalFacet");
const useStateUpdatedOnSearch_1 = require("./useStateUpdatedOnSearch");
const useRemovableStaticFilters_1 = require("./useRemovableStaticFilters");
/**
 * Returns a memoized RemovableFilter[], with handling for static filters,
 * hierarchical facets, and non-hierarchical facets.
 *
 * Duplicates are kept.
 *
 * @internal
 */
function useRemovableFilters(hierarchicalFieldIds, hierarchicalDelimiter, hiddenFields) {
    const facets = (0, useStateUpdatedOnSearch_1.useStateUpdatedOnSearch)(state => state.filters.facets);
    const hasResults = !!(0, search_headless_react_1.useSearchState)(state => state.vertical.results);
    const searchActions = (0, search_headless_react_1.useSearchActions)();
    const removableStaticFilters = (0, useRemovableStaticFilters_1.useRemovableStaticFilters)(hiddenFields);
    return (0, react_1.useMemo)(() => {
        var _a;
        if (!hasResults) {
            return [];
        }
        const removableFacets = (_a = facets === null || facets === void 0 ? void 0 : facets.filter(f => !hiddenFields.includes(f.fieldId)).flatMap((f) => {
            if (hierarchicalFieldIds === null || hierarchicalFieldIds === void 0 ? void 0 : hierarchicalFieldIds.includes(f.fieldId)) {
                return processHierarchicalFacet(f, hierarchicalDelimiter, searchActions, facets);
            }
            return processRegularFacet(f, searchActions);
        })) !== null && _a !== void 0 ? _a : [];
        return [...removableStaticFilters, ...removableFacets];
    }, [
        facets,
        hasResults,
        hiddenFields,
        hierarchicalDelimiter,
        hierarchicalFieldIds,
        searchActions,
        removableStaticFilters
    ]);
}
exports.useRemovableFilters = useRemovableFilters;
function processRegularFacet(f, searchActions) {
    return f.options.filter(o => o.selected).map(option => {
        const filter = {
            value: option.value,
            matcher: option.matcher,
            fieldId: f.fieldId
        };
        return {
            displayName: option.displayName,
            handleRemove: () => handleRemoveFacetOption(filter, searchActions),
            filter
        };
    });
}
function processHierarchicalFacet(f, delimiter, searchActions, facets) {
    function createAppliedFilter(o, tokens) {
        const filter = {
            matcher: o.matcher,
            value: o.value,
            fieldId: f.fieldId
        };
        const handleRemove = () => handleRemoveHierarchicalFacetOption(filter, tokens, delimiter, searchActions, facets);
        return {
            displayName: tokens[tokens.length - 1],
            handleRemove,
            filter,
            tokens
        };
    }
    return f.options.filter(o => o.selected).flatMap(selectedOption => {
        const displayNameTokens = splitDisplayName(selectedOption.displayName, delimiter);
        const appliedFacets = [createAppliedFilter(selectedOption, displayNameTokens)];
        // Create an object for each facet that is a parent of the currently selected option,
        // despite them not being explicitly selected
        f.options.forEach(option => {
            const tokens = splitDisplayName(option.displayName, delimiter);
            const isDescendant = (0, isDescendantHierarchicalFacet_1.isDescendantHierarchicalFacet)(displayNameTokens, tokens);
            if (!isDescendant) {
                return;
            }
            appliedFacets.push(createAppliedFilter(option, tokens));
        });
        appliedFacets.sort((a, b) => a.tokens.length - b.tokens.length);
        return appliedFacets;
    });
}
function handleRemoveHierarchicalFacetOption(filter, displayNameTokens, delimiter, searchActions, facets) {
    searchActions.setFacetOption(filter.fieldId, {
        matcher: filter.matcher,
        value: filter.value
    }, false);
    // Uncheck all descendant options in the hierarchy
    facets === null || facets === void 0 ? void 0 : facets.filter(f => f.fieldId === filter.fieldId).flatMap(f => f.options).forEach(o => {
        if (!o.selected) {
            return;
        }
        const tokensToCheck = splitDisplayName(o.displayName, delimiter);
        if ((0, isDescendantHierarchicalFacet_1.isDescendantHierarchicalFacet)(tokensToCheck, displayNameTokens)) {
            searchActions.setFacetOption(filter.fieldId, {
                matcher: o.matcher,
                value: o.value
            }, false);
        }
    });
    const parentTokens = displayNameTokens.slice(0, -1);
    const parentOption = facets === null || facets === void 0 ? void 0 : facets.filter(f => f.fieldId === filter.fieldId).flatMap(f => f.options).find(o => {
        const tokens = splitDisplayName(o.displayName, delimiter);
        return (0, lodash_1.isEqual)(tokens, parentTokens);
    });
    parentOption && searchActions.setFacetOption(filter.fieldId, {
        matcher: parentOption.matcher,
        value: parentOption.value
    }, true);
}
function handleRemoveFacetOption({ fieldId, matcher, value }, searchActions) {
    if ((0, filterutils_1.isNearFilterValue)(value)) {
        console.error('A FieldValueFilter with a NearFilterValue is not a supported RemovableFilter.');
        return;
    }
    searchActions.setFacetOption(fieldId, { matcher, value }, false);
}
function splitDisplayName(displayName, delimiter) {
    return displayName.split(delimiter).map(s => s.trim());
}
//# sourceMappingURL=useRemovableFilters.js.map