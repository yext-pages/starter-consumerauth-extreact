"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.useGeolocationHandler = void 0;
const search_headless_react_1 = require("@yext/search-headless-react");
const search_operations_1 = require("../utils/search-operations");
const location_operations_1 = require("../utils/location-operations");
const react_1 = require("react");
const GEOLOCATION_FIELD_ID = 'builtin.location';
const LOCATION_FIELD_IDS = [GEOLOCATION_FIELD_ID, 'builtin.region', 'address.countryCode'];
const METERS_PER_MILE = 1609.344;
/**
 * Creates a function to collect user's geolocation and, by default, will set
 * a built-in location filter and execute a search.
 *
 * @internal
 *
 * @param props - {@link GeolocationHandlerArgs}
 * @returns - A function to collect and process user's geolocation
 *          - A boolean to indicate if user's geolocation is being fetch
 */
function useGeolocationHandler({ geolocationOptions, radius = 50, handleUserPosition }) {
    const [isFetchingUserLocation, setIsFetchingUserLocation] = (0, react_1.useState)(false);
    const searchActions = (0, search_headless_react_1.useSearchActions)();
    const staticFilters = (0, search_headless_react_1.useSearchState)(s => s.filters.static || []);
    const defaultHandleUserPosition = (0, react_1.useCallback)((position) => {
        const { latitude, longitude, accuracy } = position.coords;
        const locationFilter = {
            displayName: 'Current Location',
            selected: true,
            filter: {
                kind: 'fieldValue',
                fieldId: GEOLOCATION_FIELD_ID,
                matcher: search_headless_react_1.Matcher.Near,
                value: {
                    lat: latitude,
                    lng: longitude,
                    radius: Math.max(accuracy, radius * METERS_PER_MILE)
                },
            }
        };
        const nonLocationFilters = staticFilters.filter(filter => {
            return !(filter.filter.kind === 'fieldValue'
                && LOCATION_FIELD_IDS.includes(filter.filter.fieldId));
        });
        searchActions.setStaticFilters([...nonLocationFilters, locationFilter]);
        (0, search_operations_1.executeSearch)(searchActions);
    }, [radius, searchActions, staticFilters]);
    const geolocationHandler = (0, react_1.useCallback)(async () => {
        setIsFetchingUserLocation(true);
        try {
            const position = await (0, location_operations_1.getUserLocation)(geolocationOptions);
            (handleUserPosition !== null && handleUserPosition !== void 0 ? handleUserPosition : defaultHandleUserPosition)(position);
        }
        catch (e) {
            console.warn(e);
        }
        finally {
            setIsFetchingUserLocation(false);
        }
    }, [setIsFetchingUserLocation, geolocationOptions, handleUserPosition, defaultHandleUserPosition]);
    return [geolocationHandler, isFetchingUserLocation];
}
exports.useGeolocationHandler = useGeolocationHandler;
//# sourceMappingURL=useGeolocationHandler.js.map