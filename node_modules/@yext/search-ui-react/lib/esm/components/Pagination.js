import { jsx as _jsx, jsxs as _jsxs } from "react/jsx-runtime";
import { useSearchState, useSearchActions } from '@yext/search-headless-react';
import { useComposedCssClasses } from '../hooks/useComposedCssClasses';
import { ChevronIcon as PageNavigationIcon } from '../icons/ChevronIcon';
import { usePaginationAnalytics } from '../hooks/usePaginationAnalytics';
import { executeSearch } from '../utils';
import { useCallback } from 'react';
import classNames from 'classnames';
const builtInPaginationCssClasses = {
    paginationContainer: 'flex justify-center mb-4',
    paginationLoading: 'opacity-50',
    label: 'z-0 inline-flex items-center px-4 py-2 text-sm font-semibold border border-gray-300 text-neutral',
    selectedLabel: 'z-10 inline-flex items-center px-4 py-2 text-sm font-semibold border border-primary text-primary bg-primary-light',
    leftIconContainer: 'inline-flex items-center px-3.5 py-2 border border-gray-300 rounded-l-md',
    rightIconContainer: 'inline-flex items-center px-3.5 py-2 border border-gray-300 rounded-r-md',
    icon: 'w-3 text-gray-600'
};
/**
 * Renders a component that divide a series of vertical results into chunks
 * across multiple pages and enable user to navigate between those pages.
 *
 * @public
 */
export function Pagination(props) {
    var _a;
    const { customCssClasses = {}, paginateAllOnNoResults = false } = props;
    const cssClasses = useComposedCssClasses(builtInPaginationCssClasses, customCssClasses);
    const searchActions = useSearchActions();
    const verticalResultsCount = useSearchState(state => state.vertical.resultsCount) || 0;
    const allResultsCountForVertical = useSearchState(state => { var _a, _b; return (_b = (_a = state.vertical) === null || _a === void 0 ? void 0 : _a.noResults) === null || _b === void 0 ? void 0 : _b.allResultsForVertical.resultsCount; }) || 0;
    const isLoading = useSearchState(state => state.searchStatus.isLoading);
    let resultsCount = verticalResultsCount;
    if (verticalResultsCount === 0 && paginateAllOnNoResults) {
        resultsCount = allResultsCountForVertical;
    }
    const offset = useSearchState(state => state.vertical.offset) || 0;
    const limit = useSearchState(state => state.vertical.limit) || 20;
    const currentPageNumber = (offset / limit) + 1;
    const maxPageCount = Math.ceil(resultsCount / limit);
    const reportAnalyticsEvent = usePaginationAnalytics();
    const navigateToPage = useCallback((newPageNumber) => {
        const newOffset = limit * (newPageNumber - 1);
        searchActions.setOffset(newOffset);
        executeSearch(searchActions);
        reportAnalyticsEvent(newPageNumber, currentPageNumber, maxPageCount);
    }, [searchActions, limit, maxPageCount, currentPageNumber, reportAnalyticsEvent]);
    if (maxPageCount <= 1) {
        return null;
    }
    const paginationLabels = generatePaginationLabels(currentPageNumber, maxPageCount);
    const paginationContainerClassNames = classNames(cssClasses.paginationContainer, {
        [(_a = cssClasses.paginationLoading) !== null && _a !== void 0 ? _a : '']: isLoading
    });
    return (_jsx("div", Object.assign({ className: paginationContainerClassNames }, { children: _jsxs("nav", Object.assign({ className: 'inline-flex shadow-sm -space-x-px', "aria-label": "Pagination" }, { children: [_jsx(PaginationButton, Object.assign({ ariaLabel: 'Navigate to the previous results page', className: cssClasses.leftIconContainer, navigateToPage: navigateToPage, newPageNumber: currentPageNumber - 1, disabled: currentPageNumber === 1 }, { children: _jsx(PageNavigationIcon, { className: cssClasses.icon + ' transform -rotate-90' }, void 0) }), void 0), paginationLabels.map((label, index) => {
                    switch (label) {
                        case '...':
                            return (_jsx("div", Object.assign({ className: cssClasses.label }, { children: label }), index));
                        case `${currentPageNumber}`:
                            return (_jsx(PaginationButton, Object.assign({ className: cssClasses.selectedLabel, navigateToPage: navigateToPage, newPageNumber: currentPageNumber }, { children: label }), index));
                        default:
                            return (_jsx(PaginationButton, Object.assign({ className: cssClasses.label, navigateToPage: navigateToPage, newPageNumber: Number(label) }, { children: label }), index));
                    }
                }), _jsx(PaginationButton, Object.assign({ ariaLabel: 'Navigate to the next results page', className: cssClasses.rightIconContainer, navigateToPage: navigateToPage, newPageNumber: currentPageNumber + 1, disabled: currentPageNumber === maxPageCount }, { children: _jsx(PageNavigationIcon, { className: cssClasses.icon + ' transform rotate-90' }, void 0) }), void 0)] }), void 0) }), void 0));
}
function PaginationButton(props) {
    const { navigateToPage, newPageNumber } = props;
    const handleClick = useCallback(() => {
        navigateToPage(newPageNumber);
    }, [navigateToPage, newPageNumber]);
    return (_jsx("button", Object.assign({ "aria-label": props.ariaLabel, className: props.className, onClick: handleClick, disabled: props.disabled }, { children: props.children }), void 0));
}
function generatePaginationLabels(currentPageNumber, maxPageCount) {
    const paginationLabels = [];
    const previousPageNumber = currentPageNumber - 1;
    const nextPageNumber = currentPageNumber + 1;
    if (previousPageNumber > 3) {
        paginationLabels.push('1', '...', `${previousPageNumber}`);
    }
    else if (previousPageNumber !== 0) {
        [...Array(previousPageNumber)].forEach((_, index) => paginationLabels.push(`${index + 1}`));
    }
    paginationLabels.push(`${currentPageNumber}`);
    if (maxPageCount - nextPageNumber > 2) {
        paginationLabels.push(`${nextPageNumber}`, '...', `${maxPageCount}`);
    }
    else if (nextPageNumber <= maxPageCount) {
        [...Array(maxPageCount - nextPageNumber + 1)]
            .forEach((_, index) => paginationLabels.push(`${nextPageNumber + index}`));
    }
    return paginationLabels;
}
//# sourceMappingURL=Pagination.js.map