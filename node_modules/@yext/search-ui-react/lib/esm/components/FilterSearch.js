import { jsx as _jsx, jsxs as _jsxs } from "react/jsx-runtime";
import { useSearchActions, useSearchState } from '@yext/search-headless-react';
import { useCallback, useEffect, useMemo, useState } from 'react';
import { useComposedCssClasses } from '../hooks/useComposedCssClasses';
import { useSynchronizedRequest } from '../hooks/useSynchronizedRequest';
import { executeSearch } from '../utils';
import { isDuplicateStaticFilter } from '../utils/filterutils';
import { Dropdown } from './Dropdown/Dropdown';
import { DropdownInput } from './Dropdown/DropdownInput';
import { DropdownItem } from './Dropdown/DropdownItem';
import { DropdownMenu } from './Dropdown/DropdownMenu';
import { processTranslation } from './utils/processTranslation';
import { renderAutocompleteResult } from './utils/renderAutocompleteResult';
const builtInCssClasses = {
    filterSearchContainer: 'relative mb-2',
    label: 'mb-4 text-sm font-medium text-neutral-dark',
    inputElement: 'text-sm bg-white outline-none h-9 w-full p-2 rounded-md border border-gray-300 focus:border-primary text-neutral-dark placeholder:text-neutral',
    sectionLabel: 'text-sm text-neutral-dark font-semibold py-2 px-4',
    focusedOption: 'bg-gray-100',
    option: 'text-sm text-neutral-dark py-1 cursor-pointer hover:bg-gray-100 px-4'
};
/**
 * A component which allows a user to search for filters associated with specific entities and fields.
 *
 * @public
 *
 * @param props - {@link FilterSearchProps}
 * @returns A react component for Filter Search
 */
export function FilterSearch({ searchFields, label, placeholder = 'Search here...', searchOnSelect, onSelect, sectioned = false, customCssClasses }) {
    const searchActions = useSearchActions();
    const searchParamFields = searchFields.map((searchField) => {
        return Object.assign(Object.assign({}, searchField), { fetchEntities: false });
    });
    const matchingFieldIds = useMemo(() => {
        const fieldIds = new Set(searchFields.map(s => s.fieldApiName));
        if (fieldIds.has('builtin.location')) {
            ['builtin.region', 'address.countryCode'].forEach(s => fieldIds.add(s));
        }
        return fieldIds;
    }, [searchFields]);
    const cssClasses = useComposedCssClasses(builtInCssClasses, customCssClasses);
    const [currentFilter, setCurrentFilter] = useState();
    const [filterQuery, setFilterQuery] = useState();
    const staticFilters = useSearchState(state => state.filters.static);
    const matchingFilters = useMemo(() => {
        var _a;
        return (_a = staticFilters === null || staticFilters === void 0 ? void 0 : staticFilters.filter(({ filter, selected }) => selected
            && filter.kind === 'fieldValue'
            && matchingFieldIds.has(filter.fieldId))) !== null && _a !== void 0 ? _a : [];
    }, [staticFilters, matchingFieldIds]);
    const [filterSearchResponse, executeFilterSearch, clearFilterSearchResponse] = useSynchronizedRequest(inputValue => {
        setFilterQuery(inputValue);
        return searchActions.executeFilterSearch(inputValue !== null && inputValue !== void 0 ? inputValue : '', sectioned, searchParamFields);
    }, (e) => console.error('Error occured executing a filter search request.\n', e));
    useEffect(() => {
        if (matchingFilters.length > 1 && !onSelect) {
            console.warn('More than one selected static filter found that matches the filter search fields: ['
                + [...matchingFieldIds].join(', ')
                + ']. Please update the state to remove the extra filters.'
                + ' Picking one filter to display in the input.');
        }
        if (currentFilter && (staticFilters === null || staticFilters === void 0 ? void 0 : staticFilters.find(f => isDuplicateStaticFilter(f.filter, currentFilter) && f.selected))) {
            return;
        }
        if (matchingFilters.length === 0) {
            clearFilterSearchResponse();
            setCurrentFilter(undefined);
            setFilterQuery('');
        }
        else {
            setCurrentFilter(matchingFilters[0].filter);
            executeFilterSearch(matchingFilters[0].displayName);
        }
    }, [
        clearFilterSearchResponse,
        currentFilter,
        staticFilters,
        executeFilterSearch,
        onSelect,
        matchingFilters,
        matchingFieldIds
    ]);
    const sections = useMemo(() => {
        var _a;
        return (_a = filterSearchResponse === null || filterSearchResponse === void 0 ? void 0 : filterSearchResponse.sections.filter(section => section.results.length > 0)) !== null && _a !== void 0 ? _a : [];
    }, [filterSearchResponse === null || filterSearchResponse === void 0 ? void 0 : filterSearchResponse.sections]);
    const hasResults = sections.flatMap(s => s.results).length > 0;
    const handleSelectDropdown = useCallback((_value, _index, itemData) => {
        const newFilter = itemData === null || itemData === void 0 ? void 0 : itemData.filter;
        const newDisplayName = itemData === null || itemData === void 0 ? void 0 : itemData.displayName;
        if (!newFilter || !newDisplayName) {
            return;
        }
        if (onSelect) {
            if (searchOnSelect) {
                console.warn('Both searchOnSelect and onSelect props were passed to the component.'
                    + ' Using onSelect instead of searchOnSelect as the latter is deprecated.');
            }
            return onSelect({
                newFilter,
                newDisplayName,
                currentFilter,
                setCurrentFilter,
                executeFilterSearch
            });
        }
        if (matchingFilters.length > 1) {
            console.warn('More than one selected static filter found that matches the filter search fields: ['
                + [...matchingFieldIds].join(', ')
                + ']. Unselecting all existing matching filters and selecting the new filter.');
        }
        matchingFilters.forEach(f => searchActions.setFilterOption({ filter: f.filter, selected: false }));
        if (currentFilter) {
            searchActions.setFilterOption({ filter: currentFilter, selected: false });
        }
        searchActions.setFilterOption({ filter: newFilter, displayName: newDisplayName, selected: true });
        setCurrentFilter(newFilter);
        executeFilterSearch(newDisplayName);
        if (searchOnSelect) {
            searchActions.setOffset(0);
            searchActions.resetFacets();
            executeSearch(searchActions);
        }
    }, [
        currentFilter,
        searchActions,
        executeFilterSearch,
        onSelect,
        searchOnSelect,
        matchingFilters,
        matchingFieldIds
    ]);
    const meetsSubmitCritera = useCallback(index => index >= 0, []);
    const itemDataMatrix = useMemo(() => {
        return sections.map(section => {
            return section.results.map(result => ({
                filter: Object.assign(Object.assign({}, result.filter), { kind: 'fieldValue' }),
                displayName: result.value
            }));
        });
    }, [sections]);
    function renderDropdownItems() {
        return sections.map((section, sectionIndex) => {
            return (_jsxs("div", Object.assign({ className: 'pb-2' }, { children: [section.label &&
                        _jsx("div", Object.assign({ className: cssClasses.sectionLabel }, { children: section.label }), void 0), _jsx("div", Object.assign({ className: cssClasses.optionsContainer }, { children: section.results.map((result, index) => (_jsx(DropdownItem, Object.assign({ focusedClassName: cssClasses.focusedOption, value: result.value, itemData: itemDataMatrix[sectionIndex][index] }, { children: renderAutocompleteResult(result, cssClasses) }), index))) }), void 0)] }), sectionIndex));
        });
    }
    const handleInputFocus = useCallback((value = '') => {
        if (value) {
            executeFilterSearch(value);
        }
    }, [executeFilterSearch]);
    return (_jsxs("div", Object.assign({ className: cssClasses.filterSearchContainer }, { children: [label && _jsx("h1", Object.assign({ className: cssClasses.label }, { children: label }), void 0), _jsxs(Dropdown, Object.assign({ screenReaderText: getScreenReaderText(sections), onSelect: handleSelectDropdown, alwaysSelectOption: true, parentQuery: filterQuery }, { children: [_jsx(DropdownInput, { className: cssClasses.inputElement, placeholder: placeholder, onChange: executeFilterSearch, onFocus: handleInputFocus, submitCriteria: meetsSubmitCritera }, void 0), _jsx(DropdownMenu, { children: hasResults &&
                            _jsx("div", Object.assign({ className: 'absolute z-10 w-full shadow-lg rounded-md border border-gray-300 bg-white pt-3 pb-1 mt-1' }, { children: renderDropdownItems() }), void 0) }, void 0)] }), void 0)] }), void 0));
}
function getScreenReaderText(sections) {
    let screenReaderText = processTranslation({
        phrase: '0 autocomplete option found.',
        pluralForm: '0 autocomplete options found.',
        count: 0
    });
    if (sections.length === 0) {
        return screenReaderText;
    }
    const screenReaderPhrases = sections.map(section => {
        const optionInfo = section.label
            ? `${section.results.length} ${section.label}`
            : `${section.results.length}`;
        return processTranslation({
            phrase: `${optionInfo} autocomplete option found.`,
            pluralForm: `${optionInfo} autocomplete options found.`,
            count: section.results.length
        });
    });
    screenReaderText = screenReaderPhrases.join(' ');
    return screenReaderText;
}
//# sourceMappingURL=FilterSearch.js.map