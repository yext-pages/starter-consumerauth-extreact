"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.combineStaticFilters = exports.createNearMeStaticFilter = exports.createDateRangeStaticFilter = exports.createNumberRangeStaticFilter = exports.createEqualsStaticFilter = void 0;
const search_core_1 = require("@yext/search-core");
/**
 * Creates a {@link FieldValueStaticFilter} that ensures all results will match
 * a specific field value.
 *
 * @param fieldId - The comparison field's identifier
 * @param value - The value to match
 * @returns The newly created {@link FieldValueStaticFilter} for the field value
 *
 * @public
 */
function createEqualsStaticFilter(fieldId, value) {
    return {
        kind: 'fieldValue',
        fieldId,
        matcher: search_core_1.Matcher.Equals,
        value
    };
}
exports.createEqualsStaticFilter = createEqualsStaticFilter;
/**
 * Creates a {@link StaticFilter} that matches all results where the
 * given field value falls in a specific number {@link BoundedRange}.
 *
 * @param fieldId - The comparison field's identifier
 * @param range - The acceptable number range
 * @returns The newly created static filter for the field value range
 *
 * @public
 */
function createNumberRangeStaticFilter(fieldId, range) {
    return createRangeStaticFilter(fieldId, range);
}
exports.createNumberRangeStaticFilter = createNumberRangeStaticFilter;
/**
 * Creates a {@link StaticFilter} that matches all results where the
 * given field value falls in a specific Date {@link BoundedRange}.
 *
 * @param fieldId - The comparison field's identifier
 * @param range - The acceptable date range
 * @returns The newly created static filter for the field value range
 *
 * @public
 */
function createDateRangeStaticFilter(fieldId, range) {
    return createRangeStaticFilter(fieldId, range);
}
exports.createDateRangeStaticFilter = createDateRangeStaticFilter;
function createRangeStaticFilter(fieldId, range) {
    const { min, max } = range;
    let minFilter;
    if (min) {
        minFilter = {
            kind: 'fieldValue',
            fieldId,
            value: min.value,
            matcher: min.inclusive ? search_core_1.Matcher.GreaterThanOrEqualTo : search_core_1.Matcher.GreaterThan
        };
    }
    let maxFilter;
    if (max) {
        maxFilter = {
            kind: 'fieldValue',
            fieldId,
            value: max.value,
            matcher: max.inclusive ? search_core_1.Matcher.LessThanOrEqualTo : search_core_1.Matcher.LessThan
        };
    }
    if (minFilter && maxFilter) {
        return combineStaticFilters(minFilter, maxFilter, search_core_1.FilterCombinator.AND);
    }
    else if (minFilter) {
        return minFilter;
    }
    else {
        return maxFilter;
    }
}
/**
 * Creates a {@link FieldValueStaticFilter} that matches all results within a certain radius
 * of the given position.
 *
 * @param position - The position and radius
 * @returns The newly created {@link FieldValueStaticFilter} for the radius of the position
 *
 * @public
 */
function createNearMeStaticFilter(position) {
    return {
        kind: 'fieldValue',
        fieldId: 'builtin.location',
        matcher: search_core_1.Matcher.Near,
        value: position
    };
}
exports.createNearMeStaticFilter = createNearMeStaticFilter;
/**
 * Creates a {@link StaticFilter} by applying the specified {@link FilterCombinator}
 * to the two static filters. Throws an error if an attempt is made to combine a
 * conjunction static filter using {@link FilterCombinator.OR}.
 *
 * @param filterA - The first static filter to be combined
 * @param filterB - The second static filter to be combined
 * @param combinator - Specifies how the two static filters should be joined
 * @returns The newly created {@link StaticFilter}
 *
 * @public
 */
function combineStaticFilters(filterA, filterB, combinator) {
    if (combinator === search_core_1.FilterCombinator.OR) {
        if (filterA.kind === 'conjunction' || filterB.kind == 'conjunction') {
            throw new Error('Cannot combine conjunction filters in a disjunction');
        }
        return {
            kind: 'disjunction',
            combinator,
            filters: [filterA, filterB]
        };
    }
    return {
        kind: 'conjunction',
        combinator,
        filters: [filterA, filterB]
    };
}
exports.combineStaticFilters = combineStaticFilters;
//# sourceMappingURL=filter-creators.js.map