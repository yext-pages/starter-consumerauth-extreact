import {
  require_react_dom
} from "./chunk-HBQAJRNJ.js";
import {
  BuiltInFieldType,
  DirectAnswerType,
  LocationBiasMethod,
  Matcher,
  QuerySource,
  SearchIntent,
  SearchTypeEnum,
  useSearchActions,
  useSearchState,
  useSearchUtilities
} from "./chunk-SGLK4FHA.js";
import {
  require_browser_ponyfill
} from "./chunk-GAJARCMZ.js";
import {
  require_jsx_runtime
} from "./chunk-Q73NGT2Y.js";
import {
  require_object_assign,
  require_react
} from "./chunk-C7AOB6VP.js";
import {
  require_classnames
} from "./chunk-XXYCH4YO.js";
import {
  __commonJS,
  __toESM
} from "./chunk-IN47U6CF.js";

// node_modules/recent-searches/dist/index.js
var require_dist = __commonJS({
  "node_modules/recent-searches/dist/index.js"(exports, module) {
    (function webpackUniversalModuleDefinition(root, factory) {
      if (typeof exports === "object" && typeof module === "object")
        module.exports = factory();
      else if (typeof define === "function" && define.amd)
        define("RecentSearches", [], factory);
      else if (typeof exports === "object")
        exports["RecentSearches"] = factory();
      else
        root["RecentSearches"] = factory();
    })(typeof self !== "undefined" ? self : exports, function() {
      return function(modules) {
        var installedModules = {};
        function __webpack_require__(moduleId) {
          if (installedModules[moduleId]) {
            return installedModules[moduleId].exports;
          }
          var module2 = installedModules[moduleId] = {
            i: moduleId,
            l: false,
            exports: {}
          };
          modules[moduleId].call(module2.exports, module2, module2.exports, __webpack_require__);
          module2.l = true;
          return module2.exports;
        }
        __webpack_require__.m = modules;
        __webpack_require__.c = installedModules;
        __webpack_require__.d = function(exports2, name, getter) {
          if (!__webpack_require__.o(exports2, name)) {
            Object.defineProperty(exports2, name, { enumerable: true, get: getter });
          }
        };
        __webpack_require__.r = function(exports2) {
          if (typeof Symbol !== "undefined" && Symbol.toStringTag) {
            Object.defineProperty(exports2, Symbol.toStringTag, { value: "Module" });
          }
          Object.defineProperty(exports2, "__esModule", { value: true });
        };
        __webpack_require__.t = function(value, mode) {
          if (mode & 1)
            value = __webpack_require__(value);
          if (mode & 8)
            return value;
          if (mode & 4 && typeof value === "object" && value && value.__esModule)
            return value;
          var ns = /* @__PURE__ */ Object.create(null);
          __webpack_require__.r(ns);
          Object.defineProperty(ns, "default", { enumerable: true, value });
          if (mode & 2 && typeof value != "string")
            for (var key in value)
              __webpack_require__.d(ns, key, function(key2) {
                return value[key2];
              }.bind(null, key));
          return ns;
        };
        __webpack_require__.n = function(module2) {
          var getter = module2 && module2.__esModule ? function getDefault() {
            return module2["default"];
          } : function getModuleExports() {
            return module2;
          };
          __webpack_require__.d(getter, "a", getter);
          return getter;
        };
        __webpack_require__.o = function(object, property) {
          return Object.prototype.hasOwnProperty.call(object, property);
        };
        __webpack_require__.p = "";
        return __webpack_require__(__webpack_require__.s = 0);
      }([
        function(module2, __webpack_exports__, __webpack_require__) {
          "use strict";
          __webpack_require__.r(__webpack_exports__);
          function _classCallCheck(instance, Constructor) {
            if (!(instance instanceof Constructor)) {
              throw new TypeError("Cannot call a class as a function");
            }
          }
          function _defineProperty(obj, key, value) {
            if (key in obj) {
              Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
            } else {
              obj[key] = value;
            }
            return obj;
          }
          var MemoryStorage_MemoryStorage = function MemoryStorage(config) {
            var _this = this;
            _classCallCheck(this, MemoryStorage);
            _defineProperty(this, "DATA", {});
            _defineProperty(this, "KEY", void 0);
            _defineProperty(this, "DEFAULT_VALUE", void 0);
            _defineProperty(this, "getItem", function() {
              return _this.DATA[_this.KEY] || _this.DEFAULT_VALUE;
            });
            _defineProperty(this, "setItem", function(data) {
              _this.DATA[_this.KEY] = data;
              return true;
            });
            var key = config.key, defaultValue = config.defaultValue;
            this.DATA = {};
            this.KEY = key || DEFAULT_STORAGE_KEY;
            this.DEFAULT_VALUE = defaultValue;
          };
          var lib_MemoryStorage = MemoryStorage_MemoryStorage;
          function SafeLocalStorage_classCallCheck(instance, Constructor) {
            if (!(instance instanceof Constructor)) {
              throw new TypeError("Cannot call a class as a function");
            }
          }
          function SafeLocalStorage_defineProperty(obj, key, value) {
            if (key in obj) {
              Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
            } else {
              obj[key] = value;
            }
            return obj;
          }
          var DEFAULT_STORAGE_KEY = "__RECENT_SEARCHES__";
          var isLocalStorageSupported = function isLocalStorageSupported2() {
            var key = "__TEST__KEY__";
            try {
              localStorage.setItem(key, "");
              localStorage.removeItem(key);
              return true;
            } catch (error) {
              return false;
            }
          };
          var safeDataParse = function safeDataParse2(data, defaultValue) {
            if (!data) {
              return defaultValue;
            }
            try {
              return JSON.parse(data);
            } catch (e2) {
              return defaultValue;
            }
          };
          var SafeLocalStorage = function SafeLocalStorage2(config) {
            var _this = this;
            SafeLocalStorage_classCallCheck(this, SafeLocalStorage2);
            SafeLocalStorage_defineProperty(this, "KEY", void 0);
            SafeLocalStorage_defineProperty(this, "DEFAULT_VALUE", void 0);
            SafeLocalStorage_defineProperty(this, "getItem", function() {
              var data = localStorage.getItem(_this.KEY);
              return safeDataParse(data, _this.DEFAULT_VALUE);
            });
            SafeLocalStorage_defineProperty(this, "setItem", function(items) {
              try {
                localStorage.setItem(_this.KEY, JSON.stringify(items));
                return true;
              } catch (e2) {
                return false;
              }
            });
            var key = config.key, defaultValue = config.defaultValue;
            this.KEY = key || DEFAULT_STORAGE_KEY;
            this.DEFAULT_VALUE = defaultValue;
          };
          var SafeLocalStorage_NewSafeLocalStorage = function NewSafeLocalStorage(config) {
            if (!isLocalStorageSupported()) {
              return new lib_MemoryStorage(config);
            }
            return new SafeLocalStorage(config);
          };
          var lib_SafeLocalStorage = SafeLocalStorage_NewSafeLocalStorage;
          var computeMatchScore = function computeMatchScore2(search, query, rankBy, ttl) {
            var normalizedQuery = String(query);
            switch (rankBy) {
              case "PROXIMITY":
                return search.query.indexOf(normalizedQuery);
              case "TIME":
                return Math.log10(new Date().getTime() - search.timestamp);
              default:
                var matchDistance = search.query.indexOf(normalizedQuery);
                var timeDelta = Math.log2((new Date().getTime() - search.timestamp) / ttl + 1);
                var proximity = Math.log2(matchDistance + 1) || 1;
                if (matchDistance === -1) {
                  return matchDistance;
                }
                return (0.01 + 0.49 * proximity + 0.49 * timeDelta) / 1;
            }
          };
          var utils_score = computeMatchScore;
          var isBlank = function isBlank2() {
            var str = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "";
            return /^\s*$/.test(str);
          };
          var isValidQuery = function isValidQuery2(query) {
            return typeof query === "string" && !isBlank(query) || typeof query === "number";
          };
          var string = isValidQuery;
          __webpack_require__.d(__webpack_exports__, "RecentSearches", function() {
            return lib_RecentSearches;
          });
          function lib_classCallCheck(instance, Constructor) {
            if (!(instance instanceof Constructor)) {
              throw new TypeError("Cannot call a class as a function");
            }
          }
          function lib_defineProperty(obj, key, value) {
            if (key in obj) {
              Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
            } else {
              obj[key] = value;
            }
            return obj;
          }
          var lib_RecentSearches = function RecentSearches2() {
            var _this = this;
            var config = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
            lib_classCallCheck(this, RecentSearches2);
            lib_defineProperty(this, "TTL", void 0);
            lib_defineProperty(this, "LIMIT", void 0);
            lib_defineProperty(this, "STORAGE", void 0);
            lib_defineProperty(this, "RANKING", void 0);
            lib_defineProperty(this, "RECENT_SEARCHES", []);
            lib_defineProperty(this, "getRecentSearches", function(query) {
              if (!string(query)) {
                return _this.RECENT_SEARCHES;
              }
              var matchedSearches = _this.RECENT_SEARCHES.map(function(search) {
                var score = utils_score(search, query, _this.RANKING, _this.TTL);
                return {
                  data: search.data,
                  query: search.query,
                  score,
                  timestamp: search.timestamp
                };
              }).filter(_this.filterScoredResults).sort(_this.sortScoredResults).map(function(search) {
                return {
                  data: search.data,
                  query: search.query,
                  timestamp: search.timestamp
                };
              });
              return matchedSearches;
            });
            lib_defineProperty(this, "setRecentSearch", function(query, data) {
              if (!string(query)) {
                return _this.RECENT_SEARCHES;
              }
              var search = {
                data,
                query: String(query),
                timestamp: new Date().getTime()
              };
              var existingQueryIndex = _this.RECENT_SEARCHES.findIndex(function(searchEntry) {
                return searchEntry.query === query;
              });
              if (existingQueryIndex > -1) {
                _this.RECENT_SEARCHES.splice(existingQueryIndex, 1);
              }
              _this.RECENT_SEARCHES.unshift(search);
              _this.RECENT_SEARCHES = _this.RECENT_SEARCHES.slice(0, _this.LIMIT);
              _this.STORAGE.setItem(_this.RECENT_SEARCHES);
              return _this.RECENT_SEARCHES;
            });
            lib_defineProperty(this, "filterScoredResults", function(search) {
              if (_this.RANKING === "TIME") {
                return true;
              }
              return search.score > -1;
            });
            lib_defineProperty(this, "sortScoredResults", function(a2, b) {
              return a2.score - b.score;
            });
            lib_defineProperty(this, "initializeStorageData", function() {
              var currentTimestamp = new Date().getTime();
              var items = _this.STORAGE.getItem().filter(function(search) {
                return search.timestamp + _this.TTL >= currentTimestamp;
              }).slice(0, _this.LIMIT);
              _this.STORAGE.setItem(items);
              _this.RECENT_SEARCHES = items;
              return items;
            });
            this.TTL = config.ttl || 1e3 * 60 * 60 * 24;
            this.LIMIT = config.limit || 50;
            this.STORAGE = lib_SafeLocalStorage({
              defaultValue: [],
              key: config.namespace
            });
            this.RECENT_SEARCHES = this.initializeStorageData();
            this.RANKING = config.ranking || "PROXIMITY_AND_TIME";
          };
          var lib = __webpack_exports__["default"] = lib_RecentSearches;
        }
      ]);
    });
  }
});

// node_modules/warning/warning.js
var require_warning = __commonJS({
  "node_modules/warning/warning.js"(exports, module) {
    "use strict";
    var __DEV__ = true;
    var warning3 = function() {
    };
    if (__DEV__) {
      printWarning = function printWarning2(format, args) {
        var len = arguments.length;
        args = new Array(len > 1 ? len - 1 : 0);
        for (var key = 1; key < len; key++) {
          args[key - 1] = arguments[key];
        }
        var argIndex = 0;
        var message = "Warning: " + format.replace(/%s/g, function() {
          return args[argIndex++];
        });
        if (typeof console !== "undefined") {
          console.error(message);
        }
        try {
          throw new Error(message);
        } catch (x2) {
        }
      };
      warning3 = function(condition, format, args) {
        var len = arguments.length;
        args = new Array(len > 2 ? len - 2 : 0);
        for (var key = 2; key < len; key++) {
          args[key - 2] = arguments[key];
        }
        if (format === void 0) {
          throw new Error(
            "`warning(condition, format, ...args)` requires a warning message argument"
          );
        }
        if (!condition) {
          printWarning.apply(null, [format].concat(args));
        }
      };
    }
    var printWarning;
    module.exports = warning3;
  }
});

// node_modules/lodash/lodash.js
var require_lodash = __commonJS({
  "node_modules/lodash/lodash.js"(exports, module) {
    (function() {
      var undefined2;
      var VERSION = "4.17.21";
      var LARGE_ARRAY_SIZE = 200;
      var CORE_ERROR_TEXT = "Unsupported core-js use. Try https://npms.io/search?q=ponyfill.", FUNC_ERROR_TEXT = "Expected a function", INVALID_TEMPL_VAR_ERROR_TEXT = "Invalid `variable` option passed into `_.template`";
      var HASH_UNDEFINED = "__lodash_hash_undefined__";
      var MAX_MEMOIZE_SIZE = 500;
      var PLACEHOLDER = "__lodash_placeholder__";
      var CLONE_DEEP_FLAG = 1, CLONE_FLAT_FLAG = 2, CLONE_SYMBOLS_FLAG = 4;
      var COMPARE_PARTIAL_FLAG = 1, COMPARE_UNORDERED_FLAG = 2;
      var WRAP_BIND_FLAG = 1, WRAP_BIND_KEY_FLAG = 2, WRAP_CURRY_BOUND_FLAG = 4, WRAP_CURRY_FLAG = 8, WRAP_CURRY_RIGHT_FLAG = 16, WRAP_PARTIAL_FLAG = 32, WRAP_PARTIAL_RIGHT_FLAG = 64, WRAP_ARY_FLAG = 128, WRAP_REARG_FLAG = 256, WRAP_FLIP_FLAG = 512;
      var DEFAULT_TRUNC_LENGTH = 30, DEFAULT_TRUNC_OMISSION = "...";
      var HOT_COUNT = 800, HOT_SPAN = 16;
      var LAZY_FILTER_FLAG = 1, LAZY_MAP_FLAG = 2, LAZY_WHILE_FLAG = 3;
      var INFINITY = 1 / 0, MAX_SAFE_INTEGER = 9007199254740991, MAX_INTEGER = 17976931348623157e292, NAN = 0 / 0;
      var MAX_ARRAY_LENGTH = 4294967295, MAX_ARRAY_INDEX = MAX_ARRAY_LENGTH - 1, HALF_MAX_ARRAY_LENGTH = MAX_ARRAY_LENGTH >>> 1;
      var wrapFlags = [
        ["ary", WRAP_ARY_FLAG],
        ["bind", WRAP_BIND_FLAG],
        ["bindKey", WRAP_BIND_KEY_FLAG],
        ["curry", WRAP_CURRY_FLAG],
        ["curryRight", WRAP_CURRY_RIGHT_FLAG],
        ["flip", WRAP_FLIP_FLAG],
        ["partial", WRAP_PARTIAL_FLAG],
        ["partialRight", WRAP_PARTIAL_RIGHT_FLAG],
        ["rearg", WRAP_REARG_FLAG]
      ];
      var argsTag = "[object Arguments]", arrayTag = "[object Array]", asyncTag = "[object AsyncFunction]", boolTag = "[object Boolean]", dateTag = "[object Date]", domExcTag = "[object DOMException]", errorTag = "[object Error]", funcTag = "[object Function]", genTag = "[object GeneratorFunction]", mapTag = "[object Map]", numberTag = "[object Number]", nullTag = "[object Null]", objectTag = "[object Object]", promiseTag = "[object Promise]", proxyTag = "[object Proxy]", regexpTag = "[object RegExp]", setTag = "[object Set]", stringTag = "[object String]", symbolTag = "[object Symbol]", undefinedTag = "[object Undefined]", weakMapTag = "[object WeakMap]", weakSetTag = "[object WeakSet]";
      var arrayBufferTag = "[object ArrayBuffer]", dataViewTag = "[object DataView]", float32Tag = "[object Float32Array]", float64Tag = "[object Float64Array]", int8Tag = "[object Int8Array]", int16Tag = "[object Int16Array]", int32Tag = "[object Int32Array]", uint8Tag = "[object Uint8Array]", uint8ClampedTag = "[object Uint8ClampedArray]", uint16Tag = "[object Uint16Array]", uint32Tag = "[object Uint32Array]";
      var reEmptyStringLeading = /\b__p \+= '';/g, reEmptyStringMiddle = /\b(__p \+=) '' \+/g, reEmptyStringTrailing = /(__e\(.*?\)|\b__t\)) \+\n'';/g;
      var reEscapedHtml = /&(?:amp|lt|gt|quot|#39);/g, reUnescapedHtml = /[&<>"']/g, reHasEscapedHtml = RegExp(reEscapedHtml.source), reHasUnescapedHtml = RegExp(reUnescapedHtml.source);
      var reEscape = /<%-([\s\S]+?)%>/g, reEvaluate = /<%([\s\S]+?)%>/g, reInterpolate = /<%=([\s\S]+?)%>/g;
      var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, reIsPlainProp = /^\w*$/, rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
      var reRegExpChar = /[\\^$.*+?()[\]{}|]/g, reHasRegExpChar = RegExp(reRegExpChar.source);
      var reTrimStart = /^\s+/;
      var reWhitespace = /\s/;
      var reWrapComment = /\{(?:\n\/\* \[wrapped with .+\] \*\/)?\n?/, reWrapDetails = /\{\n\/\* \[wrapped with (.+)\] \*/, reSplitDetails = /,? & /;
      var reAsciiWord = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g;
      var reForbiddenIdentifierChars = /[()=,{}\[\]\/\s]/;
      var reEscapeChar = /\\(\\)?/g;
      var reEsTemplate = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g;
      var reFlags = /\w*$/;
      var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
      var reIsBinary = /^0b[01]+$/i;
      var reIsHostCtor = /^\[object .+?Constructor\]$/;
      var reIsOctal = /^0o[0-7]+$/i;
      var reIsUint = /^(?:0|[1-9]\d*)$/;
      var reLatin = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g;
      var reNoMatch = /($^)/;
      var reUnescapedString = /['\n\r\u2028\u2029\\]/g;
      var rsAstralRange = "\\ud800-\\udfff", rsComboMarksRange = "\\u0300-\\u036f", reComboHalfMarksRange = "\\ufe20-\\ufe2f", rsComboSymbolsRange = "\\u20d0-\\u20ff", rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange, rsDingbatRange = "\\u2700-\\u27bf", rsLowerRange = "a-z\\xdf-\\xf6\\xf8-\\xff", rsMathOpRange = "\\xac\\xb1\\xd7\\xf7", rsNonCharRange = "\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf", rsPunctuationRange = "\\u2000-\\u206f", rsSpaceRange = " \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000", rsUpperRange = "A-Z\\xc0-\\xd6\\xd8-\\xde", rsVarRange = "\\ufe0e\\ufe0f", rsBreakRange = rsMathOpRange + rsNonCharRange + rsPunctuationRange + rsSpaceRange;
      var rsApos = "['\u2019]", rsAstral = "[" + rsAstralRange + "]", rsBreak = "[" + rsBreakRange + "]", rsCombo = "[" + rsComboRange + "]", rsDigits = "\\d+", rsDingbat = "[" + rsDingbatRange + "]", rsLower = "[" + rsLowerRange + "]", rsMisc = "[^" + rsAstralRange + rsBreakRange + rsDigits + rsDingbatRange + rsLowerRange + rsUpperRange + "]", rsFitz = "\\ud83c[\\udffb-\\udfff]", rsModifier = "(?:" + rsCombo + "|" + rsFitz + ")", rsNonAstral = "[^" + rsAstralRange + "]", rsRegional = "(?:\\ud83c[\\udde6-\\uddff]){2}", rsSurrPair = "[\\ud800-\\udbff][\\udc00-\\udfff]", rsUpper = "[" + rsUpperRange + "]", rsZWJ = "\\u200d";
      var rsMiscLower = "(?:" + rsLower + "|" + rsMisc + ")", rsMiscUpper = "(?:" + rsUpper + "|" + rsMisc + ")", rsOptContrLower = "(?:" + rsApos + "(?:d|ll|m|re|s|t|ve))?", rsOptContrUpper = "(?:" + rsApos + "(?:D|LL|M|RE|S|T|VE))?", reOptMod = rsModifier + "?", rsOptVar = "[" + rsVarRange + "]?", rsOptJoin = "(?:" + rsZWJ + "(?:" + [rsNonAstral, rsRegional, rsSurrPair].join("|") + ")" + rsOptVar + reOptMod + ")*", rsOrdLower = "\\d*(?:1st|2nd|3rd|(?![123])\\dth)(?=\\b|[A-Z_])", rsOrdUpper = "\\d*(?:1ST|2ND|3RD|(?![123])\\dTH)(?=\\b|[a-z_])", rsSeq = rsOptVar + reOptMod + rsOptJoin, rsEmoji = "(?:" + [rsDingbat, rsRegional, rsSurrPair].join("|") + ")" + rsSeq, rsSymbol = "(?:" + [rsNonAstral + rsCombo + "?", rsCombo, rsRegional, rsSurrPair, rsAstral].join("|") + ")";
      var reApos = RegExp(rsApos, "g");
      var reComboMark = RegExp(rsCombo, "g");
      var reUnicode = RegExp(rsFitz + "(?=" + rsFitz + ")|" + rsSymbol + rsSeq, "g");
      var reUnicodeWord = RegExp([
        rsUpper + "?" + rsLower + "+" + rsOptContrLower + "(?=" + [rsBreak, rsUpper, "$"].join("|") + ")",
        rsMiscUpper + "+" + rsOptContrUpper + "(?=" + [rsBreak, rsUpper + rsMiscLower, "$"].join("|") + ")",
        rsUpper + "?" + rsMiscLower + "+" + rsOptContrLower,
        rsUpper + "+" + rsOptContrUpper,
        rsOrdUpper,
        rsOrdLower,
        rsDigits,
        rsEmoji
      ].join("|"), "g");
      var reHasUnicode = RegExp("[" + rsZWJ + rsAstralRange + rsComboRange + rsVarRange + "]");
      var reHasUnicodeWord = /[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/;
      var contextProps = [
        "Array",
        "Buffer",
        "DataView",
        "Date",
        "Error",
        "Float32Array",
        "Float64Array",
        "Function",
        "Int8Array",
        "Int16Array",
        "Int32Array",
        "Map",
        "Math",
        "Object",
        "Promise",
        "RegExp",
        "Set",
        "String",
        "Symbol",
        "TypeError",
        "Uint8Array",
        "Uint8ClampedArray",
        "Uint16Array",
        "Uint32Array",
        "WeakMap",
        "_",
        "clearTimeout",
        "isFinite",
        "parseInt",
        "setTimeout"
      ];
      var templateCounter = -1;
      var typedArrayTags = {};
      typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
      typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
      var cloneableTags = {};
      cloneableTags[argsTag] = cloneableTags[arrayTag] = cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] = cloneableTags[boolTag] = cloneableTags[dateTag] = cloneableTags[float32Tag] = cloneableTags[float64Tag] = cloneableTags[int8Tag] = cloneableTags[int16Tag] = cloneableTags[int32Tag] = cloneableTags[mapTag] = cloneableTags[numberTag] = cloneableTags[objectTag] = cloneableTags[regexpTag] = cloneableTags[setTag] = cloneableTags[stringTag] = cloneableTags[symbolTag] = cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] = cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
      cloneableTags[errorTag] = cloneableTags[funcTag] = cloneableTags[weakMapTag] = false;
      var deburredLetters = {
        "\xC0": "A",
        "\xC1": "A",
        "\xC2": "A",
        "\xC3": "A",
        "\xC4": "A",
        "\xC5": "A",
        "\xE0": "a",
        "\xE1": "a",
        "\xE2": "a",
        "\xE3": "a",
        "\xE4": "a",
        "\xE5": "a",
        "\xC7": "C",
        "\xE7": "c",
        "\xD0": "D",
        "\xF0": "d",
        "\xC8": "E",
        "\xC9": "E",
        "\xCA": "E",
        "\xCB": "E",
        "\xE8": "e",
        "\xE9": "e",
        "\xEA": "e",
        "\xEB": "e",
        "\xCC": "I",
        "\xCD": "I",
        "\xCE": "I",
        "\xCF": "I",
        "\xEC": "i",
        "\xED": "i",
        "\xEE": "i",
        "\xEF": "i",
        "\xD1": "N",
        "\xF1": "n",
        "\xD2": "O",
        "\xD3": "O",
        "\xD4": "O",
        "\xD5": "O",
        "\xD6": "O",
        "\xD8": "O",
        "\xF2": "o",
        "\xF3": "o",
        "\xF4": "o",
        "\xF5": "o",
        "\xF6": "o",
        "\xF8": "o",
        "\xD9": "U",
        "\xDA": "U",
        "\xDB": "U",
        "\xDC": "U",
        "\xF9": "u",
        "\xFA": "u",
        "\xFB": "u",
        "\xFC": "u",
        "\xDD": "Y",
        "\xFD": "y",
        "\xFF": "y",
        "\xC6": "Ae",
        "\xE6": "ae",
        "\xDE": "Th",
        "\xFE": "th",
        "\xDF": "ss",
        "\u0100": "A",
        "\u0102": "A",
        "\u0104": "A",
        "\u0101": "a",
        "\u0103": "a",
        "\u0105": "a",
        "\u0106": "C",
        "\u0108": "C",
        "\u010A": "C",
        "\u010C": "C",
        "\u0107": "c",
        "\u0109": "c",
        "\u010B": "c",
        "\u010D": "c",
        "\u010E": "D",
        "\u0110": "D",
        "\u010F": "d",
        "\u0111": "d",
        "\u0112": "E",
        "\u0114": "E",
        "\u0116": "E",
        "\u0118": "E",
        "\u011A": "E",
        "\u0113": "e",
        "\u0115": "e",
        "\u0117": "e",
        "\u0119": "e",
        "\u011B": "e",
        "\u011C": "G",
        "\u011E": "G",
        "\u0120": "G",
        "\u0122": "G",
        "\u011D": "g",
        "\u011F": "g",
        "\u0121": "g",
        "\u0123": "g",
        "\u0124": "H",
        "\u0126": "H",
        "\u0125": "h",
        "\u0127": "h",
        "\u0128": "I",
        "\u012A": "I",
        "\u012C": "I",
        "\u012E": "I",
        "\u0130": "I",
        "\u0129": "i",
        "\u012B": "i",
        "\u012D": "i",
        "\u012F": "i",
        "\u0131": "i",
        "\u0134": "J",
        "\u0135": "j",
        "\u0136": "K",
        "\u0137": "k",
        "\u0138": "k",
        "\u0139": "L",
        "\u013B": "L",
        "\u013D": "L",
        "\u013F": "L",
        "\u0141": "L",
        "\u013A": "l",
        "\u013C": "l",
        "\u013E": "l",
        "\u0140": "l",
        "\u0142": "l",
        "\u0143": "N",
        "\u0145": "N",
        "\u0147": "N",
        "\u014A": "N",
        "\u0144": "n",
        "\u0146": "n",
        "\u0148": "n",
        "\u014B": "n",
        "\u014C": "O",
        "\u014E": "O",
        "\u0150": "O",
        "\u014D": "o",
        "\u014F": "o",
        "\u0151": "o",
        "\u0154": "R",
        "\u0156": "R",
        "\u0158": "R",
        "\u0155": "r",
        "\u0157": "r",
        "\u0159": "r",
        "\u015A": "S",
        "\u015C": "S",
        "\u015E": "S",
        "\u0160": "S",
        "\u015B": "s",
        "\u015D": "s",
        "\u015F": "s",
        "\u0161": "s",
        "\u0162": "T",
        "\u0164": "T",
        "\u0166": "T",
        "\u0163": "t",
        "\u0165": "t",
        "\u0167": "t",
        "\u0168": "U",
        "\u016A": "U",
        "\u016C": "U",
        "\u016E": "U",
        "\u0170": "U",
        "\u0172": "U",
        "\u0169": "u",
        "\u016B": "u",
        "\u016D": "u",
        "\u016F": "u",
        "\u0171": "u",
        "\u0173": "u",
        "\u0174": "W",
        "\u0175": "w",
        "\u0176": "Y",
        "\u0177": "y",
        "\u0178": "Y",
        "\u0179": "Z",
        "\u017B": "Z",
        "\u017D": "Z",
        "\u017A": "z",
        "\u017C": "z",
        "\u017E": "z",
        "\u0132": "IJ",
        "\u0133": "ij",
        "\u0152": "Oe",
        "\u0153": "oe",
        "\u0149": "'n",
        "\u017F": "s"
      };
      var htmlEscapes = {
        "&": "&amp;",
        "<": "&lt;",
        ">": "&gt;",
        '"': "&quot;",
        "'": "&#39;"
      };
      var htmlUnescapes = {
        "&amp;": "&",
        "&lt;": "<",
        "&gt;": ">",
        "&quot;": '"',
        "&#39;": "'"
      };
      var stringEscapes = {
        "\\": "\\",
        "'": "'",
        "\n": "n",
        "\r": "r",
        "\u2028": "u2028",
        "\u2029": "u2029"
      };
      var freeParseFloat = parseFloat, freeParseInt = parseInt;
      var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
      var freeSelf = typeof self == "object" && self && self.Object === Object && self;
      var root = freeGlobal || freeSelf || Function("return this")();
      var freeExports = typeof exports == "object" && exports && !exports.nodeType && exports;
      var freeModule = freeExports && typeof module == "object" && module && !module.nodeType && module;
      var moduleExports = freeModule && freeModule.exports === freeExports;
      var freeProcess = moduleExports && freeGlobal.process;
      var nodeUtil = function() {
        try {
          var types = freeModule && freeModule.require && freeModule.require("util").types;
          if (types) {
            return types;
          }
          return freeProcess && freeProcess.binding && freeProcess.binding("util");
        } catch (e2) {
        }
      }();
      var nodeIsArrayBuffer = nodeUtil && nodeUtil.isArrayBuffer, nodeIsDate = nodeUtil && nodeUtil.isDate, nodeIsMap = nodeUtil && nodeUtil.isMap, nodeIsRegExp = nodeUtil && nodeUtil.isRegExp, nodeIsSet = nodeUtil && nodeUtil.isSet, nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
      function apply(func, thisArg, args) {
        switch (args.length) {
          case 0:
            return func.call(thisArg);
          case 1:
            return func.call(thisArg, args[0]);
          case 2:
            return func.call(thisArg, args[0], args[1]);
          case 3:
            return func.call(thisArg, args[0], args[1], args[2]);
        }
        return func.apply(thisArg, args);
      }
      function arrayAggregator(array, setter, iteratee, accumulator) {
        var index2 = -1, length = array == null ? 0 : array.length;
        while (++index2 < length) {
          var value = array[index2];
          setter(accumulator, value, iteratee(value), array);
        }
        return accumulator;
      }
      function arrayEach(array, iteratee) {
        var index2 = -1, length = array == null ? 0 : array.length;
        while (++index2 < length) {
          if (iteratee(array[index2], index2, array) === false) {
            break;
          }
        }
        return array;
      }
      function arrayEachRight(array, iteratee) {
        var length = array == null ? 0 : array.length;
        while (length--) {
          if (iteratee(array[length], length, array) === false) {
            break;
          }
        }
        return array;
      }
      function arrayEvery(array, predicate) {
        var index2 = -1, length = array == null ? 0 : array.length;
        while (++index2 < length) {
          if (!predicate(array[index2], index2, array)) {
            return false;
          }
        }
        return true;
      }
      function arrayFilter(array, predicate) {
        var index2 = -1, length = array == null ? 0 : array.length, resIndex = 0, result = [];
        while (++index2 < length) {
          var value = array[index2];
          if (predicate(value, index2, array)) {
            result[resIndex++] = value;
          }
        }
        return result;
      }
      function arrayIncludes(array, value) {
        var length = array == null ? 0 : array.length;
        return !!length && baseIndexOf(array, value, 0) > -1;
      }
      function arrayIncludesWith(array, value, comparator) {
        var index2 = -1, length = array == null ? 0 : array.length;
        while (++index2 < length) {
          if (comparator(value, array[index2])) {
            return true;
          }
        }
        return false;
      }
      function arrayMap(array, iteratee) {
        var index2 = -1, length = array == null ? 0 : array.length, result = Array(length);
        while (++index2 < length) {
          result[index2] = iteratee(array[index2], index2, array);
        }
        return result;
      }
      function arrayPush(array, values) {
        var index2 = -1, length = values.length, offset = array.length;
        while (++index2 < length) {
          array[offset + index2] = values[index2];
        }
        return array;
      }
      function arrayReduce(array, iteratee, accumulator, initAccum) {
        var index2 = -1, length = array == null ? 0 : array.length;
        if (initAccum && length) {
          accumulator = array[++index2];
        }
        while (++index2 < length) {
          accumulator = iteratee(accumulator, array[index2], index2, array);
        }
        return accumulator;
      }
      function arrayReduceRight(array, iteratee, accumulator, initAccum) {
        var length = array == null ? 0 : array.length;
        if (initAccum && length) {
          accumulator = array[--length];
        }
        while (length--) {
          accumulator = iteratee(accumulator, array[length], length, array);
        }
        return accumulator;
      }
      function arraySome(array, predicate) {
        var index2 = -1, length = array == null ? 0 : array.length;
        while (++index2 < length) {
          if (predicate(array[index2], index2, array)) {
            return true;
          }
        }
        return false;
      }
      var asciiSize = baseProperty("length");
      function asciiToArray(string) {
        return string.split("");
      }
      function asciiWords(string) {
        return string.match(reAsciiWord) || [];
      }
      function baseFindKey(collection, predicate, eachFunc) {
        var result;
        eachFunc(collection, function(value, key, collection2) {
          if (predicate(value, key, collection2)) {
            result = key;
            return false;
          }
        });
        return result;
      }
      function baseFindIndex(array, predicate, fromIndex, fromRight) {
        var length = array.length, index2 = fromIndex + (fromRight ? 1 : -1);
        while (fromRight ? index2-- : ++index2 < length) {
          if (predicate(array[index2], index2, array)) {
            return index2;
          }
        }
        return -1;
      }
      function baseIndexOf(array, value, fromIndex) {
        return value === value ? strictIndexOf(array, value, fromIndex) : baseFindIndex(array, baseIsNaN, fromIndex);
      }
      function baseIndexOfWith(array, value, fromIndex, comparator) {
        var index2 = fromIndex - 1, length = array.length;
        while (++index2 < length) {
          if (comparator(array[index2], value)) {
            return index2;
          }
        }
        return -1;
      }
      function baseIsNaN(value) {
        return value !== value;
      }
      function baseMean(array, iteratee) {
        var length = array == null ? 0 : array.length;
        return length ? baseSum(array, iteratee) / length : NAN;
      }
      function baseProperty(key) {
        return function(object) {
          return object == null ? undefined2 : object[key];
        };
      }
      function basePropertyOf(object) {
        return function(key) {
          return object == null ? undefined2 : object[key];
        };
      }
      function baseReduce(collection, iteratee, accumulator, initAccum, eachFunc) {
        eachFunc(collection, function(value, index2, collection2) {
          accumulator = initAccum ? (initAccum = false, value) : iteratee(accumulator, value, index2, collection2);
        });
        return accumulator;
      }
      function baseSortBy(array, comparer) {
        var length = array.length;
        array.sort(comparer);
        while (length--) {
          array[length] = array[length].value;
        }
        return array;
      }
      function baseSum(array, iteratee) {
        var result, index2 = -1, length = array.length;
        while (++index2 < length) {
          var current = iteratee(array[index2]);
          if (current !== undefined2) {
            result = result === undefined2 ? current : result + current;
          }
        }
        return result;
      }
      function baseTimes(n2, iteratee) {
        var index2 = -1, result = Array(n2);
        while (++index2 < n2) {
          result[index2] = iteratee(index2);
        }
        return result;
      }
      function baseToPairs(object, props) {
        return arrayMap(props, function(key) {
          return [key, object[key]];
        });
      }
      function baseTrim(string) {
        return string ? string.slice(0, trimmedEndIndex(string) + 1).replace(reTrimStart, "") : string;
      }
      function baseUnary(func) {
        return function(value) {
          return func(value);
        };
      }
      function baseValues(object, props) {
        return arrayMap(props, function(key) {
          return object[key];
        });
      }
      function cacheHas(cache, key) {
        return cache.has(key);
      }
      function charsStartIndex(strSymbols, chrSymbols) {
        var index2 = -1, length = strSymbols.length;
        while (++index2 < length && baseIndexOf(chrSymbols, strSymbols[index2], 0) > -1) {
        }
        return index2;
      }
      function charsEndIndex(strSymbols, chrSymbols) {
        var index2 = strSymbols.length;
        while (index2-- && baseIndexOf(chrSymbols, strSymbols[index2], 0) > -1) {
        }
        return index2;
      }
      function countHolders(array, placeholder) {
        var length = array.length, result = 0;
        while (length--) {
          if (array[length] === placeholder) {
            ++result;
          }
        }
        return result;
      }
      var deburrLetter = basePropertyOf(deburredLetters);
      var escapeHtmlChar = basePropertyOf(htmlEscapes);
      function escapeStringChar(chr) {
        return "\\" + stringEscapes[chr];
      }
      function getValue(object, key) {
        return object == null ? undefined2 : object[key];
      }
      function hasUnicode(string) {
        return reHasUnicode.test(string);
      }
      function hasUnicodeWord(string) {
        return reHasUnicodeWord.test(string);
      }
      function iteratorToArray(iterator) {
        var data, result = [];
        while (!(data = iterator.next()).done) {
          result.push(data.value);
        }
        return result;
      }
      function mapToArray(map) {
        var index2 = -1, result = Array(map.size);
        map.forEach(function(value, key) {
          result[++index2] = [key, value];
        });
        return result;
      }
      function overArg(func, transform) {
        return function(arg) {
          return func(transform(arg));
        };
      }
      function replaceHolders(array, placeholder) {
        var index2 = -1, length = array.length, resIndex = 0, result = [];
        while (++index2 < length) {
          var value = array[index2];
          if (value === placeholder || value === PLACEHOLDER) {
            array[index2] = PLACEHOLDER;
            result[resIndex++] = index2;
          }
        }
        return result;
      }
      function setToArray(set) {
        var index2 = -1, result = Array(set.size);
        set.forEach(function(value) {
          result[++index2] = value;
        });
        return result;
      }
      function setToPairs(set) {
        var index2 = -1, result = Array(set.size);
        set.forEach(function(value) {
          result[++index2] = [value, value];
        });
        return result;
      }
      function strictIndexOf(array, value, fromIndex) {
        var index2 = fromIndex - 1, length = array.length;
        while (++index2 < length) {
          if (array[index2] === value) {
            return index2;
          }
        }
        return -1;
      }
      function strictLastIndexOf(array, value, fromIndex) {
        var index2 = fromIndex + 1;
        while (index2--) {
          if (array[index2] === value) {
            return index2;
          }
        }
        return index2;
      }
      function stringSize(string) {
        return hasUnicode(string) ? unicodeSize(string) : asciiSize(string);
      }
      function stringToArray(string) {
        return hasUnicode(string) ? unicodeToArray(string) : asciiToArray(string);
      }
      function trimmedEndIndex(string) {
        var index2 = string.length;
        while (index2-- && reWhitespace.test(string.charAt(index2))) {
        }
        return index2;
      }
      var unescapeHtmlChar = basePropertyOf(htmlUnescapes);
      function unicodeSize(string) {
        var result = reUnicode.lastIndex = 0;
        while (reUnicode.test(string)) {
          ++result;
        }
        return result;
      }
      function unicodeToArray(string) {
        return string.match(reUnicode) || [];
      }
      function unicodeWords(string) {
        return string.match(reUnicodeWord) || [];
      }
      var runInContext = function runInContext2(context) {
        context = context == null ? root : _.defaults(root.Object(), context, _.pick(root, contextProps));
        var Array2 = context.Array, Date2 = context.Date, Error2 = context.Error, Function2 = context.Function, Math2 = context.Math, Object2 = context.Object, RegExp2 = context.RegExp, String2 = context.String, TypeError2 = context.TypeError;
        var arrayProto = Array2.prototype, funcProto = Function2.prototype, objectProto = Object2.prototype;
        var coreJsData = context["__core-js_shared__"];
        var funcToString = funcProto.toString;
        var hasOwnProperty2 = objectProto.hasOwnProperty;
        var idCounter = 0;
        var maskSrcKey = function() {
          var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
          return uid ? "Symbol(src)_1." + uid : "";
        }();
        var nativeObjectToString = objectProto.toString;
        var objectCtorString = funcToString.call(Object2);
        var oldDash = root._;
        var reIsNative = RegExp2(
          "^" + funcToString.call(hasOwnProperty2).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
        );
        var Buffer = moduleExports ? context.Buffer : undefined2, Symbol2 = context.Symbol, Uint8Array2 = context.Uint8Array, allocUnsafe = Buffer ? Buffer.allocUnsafe : undefined2, getPrototype = overArg(Object2.getPrototypeOf, Object2), objectCreate = Object2.create, propertyIsEnumerable = objectProto.propertyIsEnumerable, splice = arrayProto.splice, spreadableSymbol = Symbol2 ? Symbol2.isConcatSpreadable : undefined2, symIterator = Symbol2 ? Symbol2.iterator : undefined2, symToStringTag = Symbol2 ? Symbol2.toStringTag : undefined2;
        var defineProperty = function() {
          try {
            var func = getNative(Object2, "defineProperty");
            func({}, "", {});
            return func;
          } catch (e2) {
          }
        }();
        var ctxClearTimeout = context.clearTimeout !== root.clearTimeout && context.clearTimeout, ctxNow = Date2 && Date2.now !== root.Date.now && Date2.now, ctxSetTimeout = context.setTimeout !== root.setTimeout && context.setTimeout;
        var nativeCeil = Math2.ceil, nativeFloor = Math2.floor, nativeGetSymbols = Object2.getOwnPropertySymbols, nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined2, nativeIsFinite = context.isFinite, nativeJoin = arrayProto.join, nativeKeys = overArg(Object2.keys, Object2), nativeMax = Math2.max, nativeMin = Math2.min, nativeNow = Date2.now, nativeParseInt = context.parseInt, nativeRandom = Math2.random, nativeReverse = arrayProto.reverse;
        var DataView = getNative(context, "DataView"), Map3 = getNative(context, "Map"), Promise2 = getNative(context, "Promise"), Set2 = getNative(context, "Set"), WeakMap = getNative(context, "WeakMap"), nativeCreate = getNative(Object2, "create");
        var metaMap = WeakMap && new WeakMap();
        var realNames = {};
        var dataViewCtorString = toSource(DataView), mapCtorString = toSource(Map3), promiseCtorString = toSource(Promise2), setCtorString = toSource(Set2), weakMapCtorString = toSource(WeakMap);
        var symbolProto = Symbol2 ? Symbol2.prototype : undefined2, symbolValueOf = symbolProto ? symbolProto.valueOf : undefined2, symbolToString = symbolProto ? symbolProto.toString : undefined2;
        function lodash(value) {
          if (isObjectLike(value) && !isArray(value) && !(value instanceof LazyWrapper)) {
            if (value instanceof LodashWrapper) {
              return value;
            }
            if (hasOwnProperty2.call(value, "__wrapped__")) {
              return wrapperClone(value);
            }
          }
          return new LodashWrapper(value);
        }
        var baseCreate = function() {
          function object() {
          }
          return function(proto) {
            if (!isObject(proto)) {
              return {};
            }
            if (objectCreate) {
              return objectCreate(proto);
            }
            object.prototype = proto;
            var result2 = new object();
            object.prototype = undefined2;
            return result2;
          };
        }();
        function baseLodash() {
        }
        function LodashWrapper(value, chainAll) {
          this.__wrapped__ = value;
          this.__actions__ = [];
          this.__chain__ = !!chainAll;
          this.__index__ = 0;
          this.__values__ = undefined2;
        }
        lodash.templateSettings = {
          "escape": reEscape,
          "evaluate": reEvaluate,
          "interpolate": reInterpolate,
          "variable": "",
          "imports": {
            "_": lodash
          }
        };
        lodash.prototype = baseLodash.prototype;
        lodash.prototype.constructor = lodash;
        LodashWrapper.prototype = baseCreate(baseLodash.prototype);
        LodashWrapper.prototype.constructor = LodashWrapper;
        function LazyWrapper(value) {
          this.__wrapped__ = value;
          this.__actions__ = [];
          this.__dir__ = 1;
          this.__filtered__ = false;
          this.__iteratees__ = [];
          this.__takeCount__ = MAX_ARRAY_LENGTH;
          this.__views__ = [];
        }
        function lazyClone() {
          var result2 = new LazyWrapper(this.__wrapped__);
          result2.__actions__ = copyArray(this.__actions__);
          result2.__dir__ = this.__dir__;
          result2.__filtered__ = this.__filtered__;
          result2.__iteratees__ = copyArray(this.__iteratees__);
          result2.__takeCount__ = this.__takeCount__;
          result2.__views__ = copyArray(this.__views__);
          return result2;
        }
        function lazyReverse() {
          if (this.__filtered__) {
            var result2 = new LazyWrapper(this);
            result2.__dir__ = -1;
            result2.__filtered__ = true;
          } else {
            result2 = this.clone();
            result2.__dir__ *= -1;
          }
          return result2;
        }
        function lazyValue() {
          var array = this.__wrapped__.value(), dir = this.__dir__, isArr = isArray(array), isRight = dir < 0, arrLength = isArr ? array.length : 0, view = getView(0, arrLength, this.__views__), start = view.start, end = view.end, length = end - start, index2 = isRight ? end : start - 1, iteratees = this.__iteratees__, iterLength = iteratees.length, resIndex = 0, takeCount = nativeMin(length, this.__takeCount__);
          if (!isArr || !isRight && arrLength == length && takeCount == length) {
            return baseWrapperValue(array, this.__actions__);
          }
          var result2 = [];
          outer:
            while (length-- && resIndex < takeCount) {
              index2 += dir;
              var iterIndex = -1, value = array[index2];
              while (++iterIndex < iterLength) {
                var data = iteratees[iterIndex], iteratee2 = data.iteratee, type = data.type, computed = iteratee2(value);
                if (type == LAZY_MAP_FLAG) {
                  value = computed;
                } else if (!computed) {
                  if (type == LAZY_FILTER_FLAG) {
                    continue outer;
                  } else {
                    break outer;
                  }
                }
              }
              result2[resIndex++] = value;
            }
          return result2;
        }
        LazyWrapper.prototype = baseCreate(baseLodash.prototype);
        LazyWrapper.prototype.constructor = LazyWrapper;
        function Hash(entries) {
          var index2 = -1, length = entries == null ? 0 : entries.length;
          this.clear();
          while (++index2 < length) {
            var entry = entries[index2];
            this.set(entry[0], entry[1]);
          }
        }
        function hashClear() {
          this.__data__ = nativeCreate ? nativeCreate(null) : {};
          this.size = 0;
        }
        function hashDelete(key) {
          var result2 = this.has(key) && delete this.__data__[key];
          this.size -= result2 ? 1 : 0;
          return result2;
        }
        function hashGet(key) {
          var data = this.__data__;
          if (nativeCreate) {
            var result2 = data[key];
            return result2 === HASH_UNDEFINED ? undefined2 : result2;
          }
          return hasOwnProperty2.call(data, key) ? data[key] : undefined2;
        }
        function hashHas(key) {
          var data = this.__data__;
          return nativeCreate ? data[key] !== undefined2 : hasOwnProperty2.call(data, key);
        }
        function hashSet(key, value) {
          var data = this.__data__;
          this.size += this.has(key) ? 0 : 1;
          data[key] = nativeCreate && value === undefined2 ? HASH_UNDEFINED : value;
          return this;
        }
        Hash.prototype.clear = hashClear;
        Hash.prototype["delete"] = hashDelete;
        Hash.prototype.get = hashGet;
        Hash.prototype.has = hashHas;
        Hash.prototype.set = hashSet;
        function ListCache(entries) {
          var index2 = -1, length = entries == null ? 0 : entries.length;
          this.clear();
          while (++index2 < length) {
            var entry = entries[index2];
            this.set(entry[0], entry[1]);
          }
        }
        function listCacheClear() {
          this.__data__ = [];
          this.size = 0;
        }
        function listCacheDelete(key) {
          var data = this.__data__, index2 = assocIndexOf(data, key);
          if (index2 < 0) {
            return false;
          }
          var lastIndex = data.length - 1;
          if (index2 == lastIndex) {
            data.pop();
          } else {
            splice.call(data, index2, 1);
          }
          --this.size;
          return true;
        }
        function listCacheGet(key) {
          var data = this.__data__, index2 = assocIndexOf(data, key);
          return index2 < 0 ? undefined2 : data[index2][1];
        }
        function listCacheHas(key) {
          return assocIndexOf(this.__data__, key) > -1;
        }
        function listCacheSet(key, value) {
          var data = this.__data__, index2 = assocIndexOf(data, key);
          if (index2 < 0) {
            ++this.size;
            data.push([key, value]);
          } else {
            data[index2][1] = value;
          }
          return this;
        }
        ListCache.prototype.clear = listCacheClear;
        ListCache.prototype["delete"] = listCacheDelete;
        ListCache.prototype.get = listCacheGet;
        ListCache.prototype.has = listCacheHas;
        ListCache.prototype.set = listCacheSet;
        function MapCache(entries) {
          var index2 = -1, length = entries == null ? 0 : entries.length;
          this.clear();
          while (++index2 < length) {
            var entry = entries[index2];
            this.set(entry[0], entry[1]);
          }
        }
        function mapCacheClear() {
          this.size = 0;
          this.__data__ = {
            "hash": new Hash(),
            "map": new (Map3 || ListCache)(),
            "string": new Hash()
          };
        }
        function mapCacheDelete(key) {
          var result2 = getMapData(this, key)["delete"](key);
          this.size -= result2 ? 1 : 0;
          return result2;
        }
        function mapCacheGet(key) {
          return getMapData(this, key).get(key);
        }
        function mapCacheHas(key) {
          return getMapData(this, key).has(key);
        }
        function mapCacheSet(key, value) {
          var data = getMapData(this, key), size2 = data.size;
          data.set(key, value);
          this.size += data.size == size2 ? 0 : 1;
          return this;
        }
        MapCache.prototype.clear = mapCacheClear;
        MapCache.prototype["delete"] = mapCacheDelete;
        MapCache.prototype.get = mapCacheGet;
        MapCache.prototype.has = mapCacheHas;
        MapCache.prototype.set = mapCacheSet;
        function SetCache(values2) {
          var index2 = -1, length = values2 == null ? 0 : values2.length;
          this.__data__ = new MapCache();
          while (++index2 < length) {
            this.add(values2[index2]);
          }
        }
        function setCacheAdd(value) {
          this.__data__.set(value, HASH_UNDEFINED);
          return this;
        }
        function setCacheHas(value) {
          return this.__data__.has(value);
        }
        SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
        SetCache.prototype.has = setCacheHas;
        function Stack(entries) {
          var data = this.__data__ = new ListCache(entries);
          this.size = data.size;
        }
        function stackClear() {
          this.__data__ = new ListCache();
          this.size = 0;
        }
        function stackDelete(key) {
          var data = this.__data__, result2 = data["delete"](key);
          this.size = data.size;
          return result2;
        }
        function stackGet(key) {
          return this.__data__.get(key);
        }
        function stackHas(key) {
          return this.__data__.has(key);
        }
        function stackSet(key, value) {
          var data = this.__data__;
          if (data instanceof ListCache) {
            var pairs = data.__data__;
            if (!Map3 || pairs.length < LARGE_ARRAY_SIZE - 1) {
              pairs.push([key, value]);
              this.size = ++data.size;
              return this;
            }
            data = this.__data__ = new MapCache(pairs);
          }
          data.set(key, value);
          this.size = data.size;
          return this;
        }
        Stack.prototype.clear = stackClear;
        Stack.prototype["delete"] = stackDelete;
        Stack.prototype.get = stackGet;
        Stack.prototype.has = stackHas;
        Stack.prototype.set = stackSet;
        function arrayLikeKeys(value, inherited) {
          var isArr = isArray(value), isArg = !isArr && isArguments(value), isBuff = !isArr && !isArg && isBuffer(value), isType = !isArr && !isArg && !isBuff && isTypedArray(value), skipIndexes = isArr || isArg || isBuff || isType, result2 = skipIndexes ? baseTimes(value.length, String2) : [], length = result2.length;
          for (var key in value) {
            if ((inherited || hasOwnProperty2.call(value, key)) && !(skipIndexes && (key == "length" || isBuff && (key == "offset" || key == "parent") || isType && (key == "buffer" || key == "byteLength" || key == "byteOffset") || isIndex(key, length)))) {
              result2.push(key);
            }
          }
          return result2;
        }
        function arraySample(array) {
          var length = array.length;
          return length ? array[baseRandom(0, length - 1)] : undefined2;
        }
        function arraySampleSize(array, n2) {
          return shuffleSelf(copyArray(array), baseClamp(n2, 0, array.length));
        }
        function arrayShuffle(array) {
          return shuffleSelf(copyArray(array));
        }
        function assignMergeValue(object, key, value) {
          if (value !== undefined2 && !eq(object[key], value) || value === undefined2 && !(key in object)) {
            baseAssignValue(object, key, value);
          }
        }
        function assignValue(object, key, value) {
          var objValue = object[key];
          if (!(hasOwnProperty2.call(object, key) && eq(objValue, value)) || value === undefined2 && !(key in object)) {
            baseAssignValue(object, key, value);
          }
        }
        function assocIndexOf(array, key) {
          var length = array.length;
          while (length--) {
            if (eq(array[length][0], key)) {
              return length;
            }
          }
          return -1;
        }
        function baseAggregator(collection, setter, iteratee2, accumulator) {
          baseEach(collection, function(value, key, collection2) {
            setter(accumulator, value, iteratee2(value), collection2);
          });
          return accumulator;
        }
        function baseAssign(object, source) {
          return object && copyObject(source, keys(source), object);
        }
        function baseAssignIn(object, source) {
          return object && copyObject(source, keysIn(source), object);
        }
        function baseAssignValue(object, key, value) {
          if (key == "__proto__" && defineProperty) {
            defineProperty(object, key, {
              "configurable": true,
              "enumerable": true,
              "value": value,
              "writable": true
            });
          } else {
            object[key] = value;
          }
        }
        function baseAt(object, paths) {
          var index2 = -1, length = paths.length, result2 = Array2(length), skip = object == null;
          while (++index2 < length) {
            result2[index2] = skip ? undefined2 : get(object, paths[index2]);
          }
          return result2;
        }
        function baseClamp(number, lower, upper) {
          if (number === number) {
            if (upper !== undefined2) {
              number = number <= upper ? number : upper;
            }
            if (lower !== undefined2) {
              number = number >= lower ? number : lower;
            }
          }
          return number;
        }
        function baseClone(value, bitmask, customizer, key, object, stack) {
          var result2, isDeep = bitmask & CLONE_DEEP_FLAG, isFlat = bitmask & CLONE_FLAT_FLAG, isFull = bitmask & CLONE_SYMBOLS_FLAG;
          if (customizer) {
            result2 = object ? customizer(value, key, object, stack) : customizer(value);
          }
          if (result2 !== undefined2) {
            return result2;
          }
          if (!isObject(value)) {
            return value;
          }
          var isArr = isArray(value);
          if (isArr) {
            result2 = initCloneArray(value);
            if (!isDeep) {
              return copyArray(value, result2);
            }
          } else {
            var tag = getTag(value), isFunc = tag == funcTag || tag == genTag;
            if (isBuffer(value)) {
              return cloneBuffer(value, isDeep);
            }
            if (tag == objectTag || tag == argsTag || isFunc && !object) {
              result2 = isFlat || isFunc ? {} : initCloneObject(value);
              if (!isDeep) {
                return isFlat ? copySymbolsIn(value, baseAssignIn(result2, value)) : copySymbols(value, baseAssign(result2, value));
              }
            } else {
              if (!cloneableTags[tag]) {
                return object ? value : {};
              }
              result2 = initCloneByTag(value, tag, isDeep);
            }
          }
          stack || (stack = new Stack());
          var stacked = stack.get(value);
          if (stacked) {
            return stacked;
          }
          stack.set(value, result2);
          if (isSet(value)) {
            value.forEach(function(subValue) {
              result2.add(baseClone(subValue, bitmask, customizer, subValue, value, stack));
            });
          } else if (isMap(value)) {
            value.forEach(function(subValue, key2) {
              result2.set(key2, baseClone(subValue, bitmask, customizer, key2, value, stack));
            });
          }
          var keysFunc = isFull ? isFlat ? getAllKeysIn : getAllKeys : isFlat ? keysIn : keys;
          var props = isArr ? undefined2 : keysFunc(value);
          arrayEach(props || value, function(subValue, key2) {
            if (props) {
              key2 = subValue;
              subValue = value[key2];
            }
            assignValue(result2, key2, baseClone(subValue, bitmask, customizer, key2, value, stack));
          });
          return result2;
        }
        function baseConforms(source) {
          var props = keys(source);
          return function(object) {
            return baseConformsTo(object, source, props);
          };
        }
        function baseConformsTo(object, source, props) {
          var length = props.length;
          if (object == null) {
            return !length;
          }
          object = Object2(object);
          while (length--) {
            var key = props[length], predicate = source[key], value = object[key];
            if (value === undefined2 && !(key in object) || !predicate(value)) {
              return false;
            }
          }
          return true;
        }
        function baseDelay(func, wait, args) {
          if (typeof func != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          return setTimeout2(function() {
            func.apply(undefined2, args);
          }, wait);
        }
        function baseDifference(array, values2, iteratee2, comparator) {
          var index2 = -1, includes2 = arrayIncludes, isCommon = true, length = array.length, result2 = [], valuesLength = values2.length;
          if (!length) {
            return result2;
          }
          if (iteratee2) {
            values2 = arrayMap(values2, baseUnary(iteratee2));
          }
          if (comparator) {
            includes2 = arrayIncludesWith;
            isCommon = false;
          } else if (values2.length >= LARGE_ARRAY_SIZE) {
            includes2 = cacheHas;
            isCommon = false;
            values2 = new SetCache(values2);
          }
          outer:
            while (++index2 < length) {
              var value = array[index2], computed = iteratee2 == null ? value : iteratee2(value);
              value = comparator || value !== 0 ? value : 0;
              if (isCommon && computed === computed) {
                var valuesIndex = valuesLength;
                while (valuesIndex--) {
                  if (values2[valuesIndex] === computed) {
                    continue outer;
                  }
                }
                result2.push(value);
              } else if (!includes2(values2, computed, comparator)) {
                result2.push(value);
              }
            }
          return result2;
        }
        var baseEach = createBaseEach(baseForOwn);
        var baseEachRight = createBaseEach(baseForOwnRight, true);
        function baseEvery(collection, predicate) {
          var result2 = true;
          baseEach(collection, function(value, index2, collection2) {
            result2 = !!predicate(value, index2, collection2);
            return result2;
          });
          return result2;
        }
        function baseExtremum(array, iteratee2, comparator) {
          var index2 = -1, length = array.length;
          while (++index2 < length) {
            var value = array[index2], current = iteratee2(value);
            if (current != null && (computed === undefined2 ? current === current && !isSymbol(current) : comparator(current, computed))) {
              var computed = current, result2 = value;
            }
          }
          return result2;
        }
        function baseFill(array, value, start, end) {
          var length = array.length;
          start = toInteger(start);
          if (start < 0) {
            start = -start > length ? 0 : length + start;
          }
          end = end === undefined2 || end > length ? length : toInteger(end);
          if (end < 0) {
            end += length;
          }
          end = start > end ? 0 : toLength(end);
          while (start < end) {
            array[start++] = value;
          }
          return array;
        }
        function baseFilter(collection, predicate) {
          var result2 = [];
          baseEach(collection, function(value, index2, collection2) {
            if (predicate(value, index2, collection2)) {
              result2.push(value);
            }
          });
          return result2;
        }
        function baseFlatten(array, depth, predicate, isStrict, result2) {
          var index2 = -1, length = array.length;
          predicate || (predicate = isFlattenable);
          result2 || (result2 = []);
          while (++index2 < length) {
            var value = array[index2];
            if (depth > 0 && predicate(value)) {
              if (depth > 1) {
                baseFlatten(value, depth - 1, predicate, isStrict, result2);
              } else {
                arrayPush(result2, value);
              }
            } else if (!isStrict) {
              result2[result2.length] = value;
            }
          }
          return result2;
        }
        var baseFor = createBaseFor();
        var baseForRight = createBaseFor(true);
        function baseForOwn(object, iteratee2) {
          return object && baseFor(object, iteratee2, keys);
        }
        function baseForOwnRight(object, iteratee2) {
          return object && baseForRight(object, iteratee2, keys);
        }
        function baseFunctions(object, props) {
          return arrayFilter(props, function(key) {
            return isFunction(object[key]);
          });
        }
        function baseGet(object, path) {
          path = castPath(path, object);
          var index2 = 0, length = path.length;
          while (object != null && index2 < length) {
            object = object[toKey(path[index2++])];
          }
          return index2 && index2 == length ? object : undefined2;
        }
        function baseGetAllKeys(object, keysFunc, symbolsFunc) {
          var result2 = keysFunc(object);
          return isArray(object) ? result2 : arrayPush(result2, symbolsFunc(object));
        }
        function baseGetTag(value) {
          if (value == null) {
            return value === undefined2 ? undefinedTag : nullTag;
          }
          return symToStringTag && symToStringTag in Object2(value) ? getRawTag(value) : objectToString(value);
        }
        function baseGt(value, other) {
          return value > other;
        }
        function baseHas(object, key) {
          return object != null && hasOwnProperty2.call(object, key);
        }
        function baseHasIn(object, key) {
          return object != null && key in Object2(object);
        }
        function baseInRange(number, start, end) {
          return number >= nativeMin(start, end) && number < nativeMax(start, end);
        }
        function baseIntersection(arrays, iteratee2, comparator) {
          var includes2 = comparator ? arrayIncludesWith : arrayIncludes, length = arrays[0].length, othLength = arrays.length, othIndex = othLength, caches = Array2(othLength), maxLength = Infinity, result2 = [];
          while (othIndex--) {
            var array = arrays[othIndex];
            if (othIndex && iteratee2) {
              array = arrayMap(array, baseUnary(iteratee2));
            }
            maxLength = nativeMin(array.length, maxLength);
            caches[othIndex] = !comparator && (iteratee2 || length >= 120 && array.length >= 120) ? new SetCache(othIndex && array) : undefined2;
          }
          array = arrays[0];
          var index2 = -1, seen = caches[0];
          outer:
            while (++index2 < length && result2.length < maxLength) {
              var value = array[index2], computed = iteratee2 ? iteratee2(value) : value;
              value = comparator || value !== 0 ? value : 0;
              if (!(seen ? cacheHas(seen, computed) : includes2(result2, computed, comparator))) {
                othIndex = othLength;
                while (--othIndex) {
                  var cache = caches[othIndex];
                  if (!(cache ? cacheHas(cache, computed) : includes2(arrays[othIndex], computed, comparator))) {
                    continue outer;
                  }
                }
                if (seen) {
                  seen.push(computed);
                }
                result2.push(value);
              }
            }
          return result2;
        }
        function baseInverter(object, setter, iteratee2, accumulator) {
          baseForOwn(object, function(value, key, object2) {
            setter(accumulator, iteratee2(value), key, object2);
          });
          return accumulator;
        }
        function baseInvoke(object, path, args) {
          path = castPath(path, object);
          object = parent(object, path);
          var func = object == null ? object : object[toKey(last(path))];
          return func == null ? undefined2 : apply(func, object, args);
        }
        function baseIsArguments(value) {
          return isObjectLike(value) && baseGetTag(value) == argsTag;
        }
        function baseIsArrayBuffer(value) {
          return isObjectLike(value) && baseGetTag(value) == arrayBufferTag;
        }
        function baseIsDate(value) {
          return isObjectLike(value) && baseGetTag(value) == dateTag;
        }
        function baseIsEqual(value, other, bitmask, customizer, stack) {
          if (value === other) {
            return true;
          }
          if (value == null || other == null || !isObjectLike(value) && !isObjectLike(other)) {
            return value !== value && other !== other;
          }
          return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);
        }
        function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {
          var objIsArr = isArray(object), othIsArr = isArray(other), objTag = objIsArr ? arrayTag : getTag(object), othTag = othIsArr ? arrayTag : getTag(other);
          objTag = objTag == argsTag ? objectTag : objTag;
          othTag = othTag == argsTag ? objectTag : othTag;
          var objIsObj = objTag == objectTag, othIsObj = othTag == objectTag, isSameTag = objTag == othTag;
          if (isSameTag && isBuffer(object)) {
            if (!isBuffer(other)) {
              return false;
            }
            objIsArr = true;
            objIsObj = false;
          }
          if (isSameTag && !objIsObj) {
            stack || (stack = new Stack());
            return objIsArr || isTypedArray(object) ? equalArrays(object, other, bitmask, customizer, equalFunc, stack) : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);
          }
          if (!(bitmask & COMPARE_PARTIAL_FLAG)) {
            var objIsWrapped = objIsObj && hasOwnProperty2.call(object, "__wrapped__"), othIsWrapped = othIsObj && hasOwnProperty2.call(other, "__wrapped__");
            if (objIsWrapped || othIsWrapped) {
              var objUnwrapped = objIsWrapped ? object.value() : object, othUnwrapped = othIsWrapped ? other.value() : other;
              stack || (stack = new Stack());
              return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
            }
          }
          if (!isSameTag) {
            return false;
          }
          stack || (stack = new Stack());
          return equalObjects(object, other, bitmask, customizer, equalFunc, stack);
        }
        function baseIsMap(value) {
          return isObjectLike(value) && getTag(value) == mapTag;
        }
        function baseIsMatch(object, source, matchData, customizer) {
          var index2 = matchData.length, length = index2, noCustomizer = !customizer;
          if (object == null) {
            return !length;
          }
          object = Object2(object);
          while (index2--) {
            var data = matchData[index2];
            if (noCustomizer && data[2] ? data[1] !== object[data[0]] : !(data[0] in object)) {
              return false;
            }
          }
          while (++index2 < length) {
            data = matchData[index2];
            var key = data[0], objValue = object[key], srcValue = data[1];
            if (noCustomizer && data[2]) {
              if (objValue === undefined2 && !(key in object)) {
                return false;
              }
            } else {
              var stack = new Stack();
              if (customizer) {
                var result2 = customizer(objValue, srcValue, key, object, source, stack);
              }
              if (!(result2 === undefined2 ? baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG, customizer, stack) : result2)) {
                return false;
              }
            }
          }
          return true;
        }
        function baseIsNative(value) {
          if (!isObject(value) || isMasked(value)) {
            return false;
          }
          var pattern = isFunction(value) ? reIsNative : reIsHostCtor;
          return pattern.test(toSource(value));
        }
        function baseIsRegExp(value) {
          return isObjectLike(value) && baseGetTag(value) == regexpTag;
        }
        function baseIsSet(value) {
          return isObjectLike(value) && getTag(value) == setTag;
        }
        function baseIsTypedArray(value) {
          return isObjectLike(value) && isLength2(value.length) && !!typedArrayTags[baseGetTag(value)];
        }
        function baseIteratee(value) {
          if (typeof value == "function") {
            return value;
          }
          if (value == null) {
            return identity;
          }
          if (typeof value == "object") {
            return isArray(value) ? baseMatchesProperty(value[0], value[1]) : baseMatches(value);
          }
          return property(value);
        }
        function baseKeys(object) {
          if (!isPrototype(object)) {
            return nativeKeys(object);
          }
          var result2 = [];
          for (var key in Object2(object)) {
            if (hasOwnProperty2.call(object, key) && key != "constructor") {
              result2.push(key);
            }
          }
          return result2;
        }
        function baseKeysIn(object) {
          if (!isObject(object)) {
            return nativeKeysIn(object);
          }
          var isProto = isPrototype(object), result2 = [];
          for (var key in object) {
            if (!(key == "constructor" && (isProto || !hasOwnProperty2.call(object, key)))) {
              result2.push(key);
            }
          }
          return result2;
        }
        function baseLt(value, other) {
          return value < other;
        }
        function baseMap(collection, iteratee2) {
          var index2 = -1, result2 = isArrayLike(collection) ? Array2(collection.length) : [];
          baseEach(collection, function(value, key, collection2) {
            result2[++index2] = iteratee2(value, key, collection2);
          });
          return result2;
        }
        function baseMatches(source) {
          var matchData = getMatchData(source);
          if (matchData.length == 1 && matchData[0][2]) {
            return matchesStrictComparable(matchData[0][0], matchData[0][1]);
          }
          return function(object) {
            return object === source || baseIsMatch(object, source, matchData);
          };
        }
        function baseMatchesProperty(path, srcValue) {
          if (isKey(path) && isStrictComparable(srcValue)) {
            return matchesStrictComparable(toKey(path), srcValue);
          }
          return function(object) {
            var objValue = get(object, path);
            return objValue === undefined2 && objValue === srcValue ? hasIn(object, path) : baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG);
          };
        }
        function baseMerge(object, source, srcIndex, customizer, stack) {
          if (object === source) {
            return;
          }
          baseFor(source, function(srcValue, key) {
            stack || (stack = new Stack());
            if (isObject(srcValue)) {
              baseMergeDeep(object, source, key, srcIndex, baseMerge, customizer, stack);
            } else {
              var newValue = customizer ? customizer(safeGet(object, key), srcValue, key + "", object, source, stack) : undefined2;
              if (newValue === undefined2) {
                newValue = srcValue;
              }
              assignMergeValue(object, key, newValue);
            }
          }, keysIn);
        }
        function baseMergeDeep(object, source, key, srcIndex, mergeFunc, customizer, stack) {
          var objValue = safeGet(object, key), srcValue = safeGet(source, key), stacked = stack.get(srcValue);
          if (stacked) {
            assignMergeValue(object, key, stacked);
            return;
          }
          var newValue = customizer ? customizer(objValue, srcValue, key + "", object, source, stack) : undefined2;
          var isCommon = newValue === undefined2;
          if (isCommon) {
            var isArr = isArray(srcValue), isBuff = !isArr && isBuffer(srcValue), isTyped = !isArr && !isBuff && isTypedArray(srcValue);
            newValue = srcValue;
            if (isArr || isBuff || isTyped) {
              if (isArray(objValue)) {
                newValue = objValue;
              } else if (isArrayLikeObject(objValue)) {
                newValue = copyArray(objValue);
              } else if (isBuff) {
                isCommon = false;
                newValue = cloneBuffer(srcValue, true);
              } else if (isTyped) {
                isCommon = false;
                newValue = cloneTypedArray(srcValue, true);
              } else {
                newValue = [];
              }
            } else if (isPlainObject(srcValue) || isArguments(srcValue)) {
              newValue = objValue;
              if (isArguments(objValue)) {
                newValue = toPlainObject(objValue);
              } else if (!isObject(objValue) || isFunction(objValue)) {
                newValue = initCloneObject(srcValue);
              }
            } else {
              isCommon = false;
            }
          }
          if (isCommon) {
            stack.set(srcValue, newValue);
            mergeFunc(newValue, srcValue, srcIndex, customizer, stack);
            stack["delete"](srcValue);
          }
          assignMergeValue(object, key, newValue);
        }
        function baseNth(array, n2) {
          var length = array.length;
          if (!length) {
            return;
          }
          n2 += n2 < 0 ? length : 0;
          return isIndex(n2, length) ? array[n2] : undefined2;
        }
        function baseOrderBy(collection, iteratees, orders) {
          if (iteratees.length) {
            iteratees = arrayMap(iteratees, function(iteratee2) {
              if (isArray(iteratee2)) {
                return function(value) {
                  return baseGet(value, iteratee2.length === 1 ? iteratee2[0] : iteratee2);
                };
              }
              return iteratee2;
            });
          } else {
            iteratees = [identity];
          }
          var index2 = -1;
          iteratees = arrayMap(iteratees, baseUnary(getIteratee()));
          var result2 = baseMap(collection, function(value, key, collection2) {
            var criteria = arrayMap(iteratees, function(iteratee2) {
              return iteratee2(value);
            });
            return { "criteria": criteria, "index": ++index2, "value": value };
          });
          return baseSortBy(result2, function(object, other) {
            return compareMultiple(object, other, orders);
          });
        }
        function basePick(object, paths) {
          return basePickBy(object, paths, function(value, path) {
            return hasIn(object, path);
          });
        }
        function basePickBy(object, paths, predicate) {
          var index2 = -1, length = paths.length, result2 = {};
          while (++index2 < length) {
            var path = paths[index2], value = baseGet(object, path);
            if (predicate(value, path)) {
              baseSet(result2, castPath(path, object), value);
            }
          }
          return result2;
        }
        function basePropertyDeep(path) {
          return function(object) {
            return baseGet(object, path);
          };
        }
        function basePullAll(array, values2, iteratee2, comparator) {
          var indexOf2 = comparator ? baseIndexOfWith : baseIndexOf, index2 = -1, length = values2.length, seen = array;
          if (array === values2) {
            values2 = copyArray(values2);
          }
          if (iteratee2) {
            seen = arrayMap(array, baseUnary(iteratee2));
          }
          while (++index2 < length) {
            var fromIndex = 0, value = values2[index2], computed = iteratee2 ? iteratee2(value) : value;
            while ((fromIndex = indexOf2(seen, computed, fromIndex, comparator)) > -1) {
              if (seen !== array) {
                splice.call(seen, fromIndex, 1);
              }
              splice.call(array, fromIndex, 1);
            }
          }
          return array;
        }
        function basePullAt(array, indexes) {
          var length = array ? indexes.length : 0, lastIndex = length - 1;
          while (length--) {
            var index2 = indexes[length];
            if (length == lastIndex || index2 !== previous) {
              var previous = index2;
              if (isIndex(index2)) {
                splice.call(array, index2, 1);
              } else {
                baseUnset(array, index2);
              }
            }
          }
          return array;
        }
        function baseRandom(lower, upper) {
          return lower + nativeFloor(nativeRandom() * (upper - lower + 1));
        }
        function baseRange(start, end, step, fromRight) {
          var index2 = -1, length = nativeMax(nativeCeil((end - start) / (step || 1)), 0), result2 = Array2(length);
          while (length--) {
            result2[fromRight ? length : ++index2] = start;
            start += step;
          }
          return result2;
        }
        function baseRepeat(string, n2) {
          var result2 = "";
          if (!string || n2 < 1 || n2 > MAX_SAFE_INTEGER) {
            return result2;
          }
          do {
            if (n2 % 2) {
              result2 += string;
            }
            n2 = nativeFloor(n2 / 2);
            if (n2) {
              string += string;
            }
          } while (n2);
          return result2;
        }
        function baseRest(func, start) {
          return setToString(overRest(func, start, identity), func + "");
        }
        function baseSample(collection) {
          return arraySample(values(collection));
        }
        function baseSampleSize(collection, n2) {
          var array = values(collection);
          return shuffleSelf(array, baseClamp(n2, 0, array.length));
        }
        function baseSet(object, path, value, customizer) {
          if (!isObject(object)) {
            return object;
          }
          path = castPath(path, object);
          var index2 = -1, length = path.length, lastIndex = length - 1, nested = object;
          while (nested != null && ++index2 < length) {
            var key = toKey(path[index2]), newValue = value;
            if (key === "__proto__" || key === "constructor" || key === "prototype") {
              return object;
            }
            if (index2 != lastIndex) {
              var objValue = nested[key];
              newValue = customizer ? customizer(objValue, key, nested) : undefined2;
              if (newValue === undefined2) {
                newValue = isObject(objValue) ? objValue : isIndex(path[index2 + 1]) ? [] : {};
              }
            }
            assignValue(nested, key, newValue);
            nested = nested[key];
          }
          return object;
        }
        var baseSetData = !metaMap ? identity : function(func, data) {
          metaMap.set(func, data);
          return func;
        };
        var baseSetToString = !defineProperty ? identity : function(func, string) {
          return defineProperty(func, "toString", {
            "configurable": true,
            "enumerable": false,
            "value": constant(string),
            "writable": true
          });
        };
        function baseShuffle(collection) {
          return shuffleSelf(values(collection));
        }
        function baseSlice(array, start, end) {
          var index2 = -1, length = array.length;
          if (start < 0) {
            start = -start > length ? 0 : length + start;
          }
          end = end > length ? length : end;
          if (end < 0) {
            end += length;
          }
          length = start > end ? 0 : end - start >>> 0;
          start >>>= 0;
          var result2 = Array2(length);
          while (++index2 < length) {
            result2[index2] = array[index2 + start];
          }
          return result2;
        }
        function baseSome(collection, predicate) {
          var result2;
          baseEach(collection, function(value, index2, collection2) {
            result2 = predicate(value, index2, collection2);
            return !result2;
          });
          return !!result2;
        }
        function baseSortedIndex(array, value, retHighest) {
          var low = 0, high = array == null ? low : array.length;
          if (typeof value == "number" && value === value && high <= HALF_MAX_ARRAY_LENGTH) {
            while (low < high) {
              var mid = low + high >>> 1, computed = array[mid];
              if (computed !== null && !isSymbol(computed) && (retHighest ? computed <= value : computed < value)) {
                low = mid + 1;
              } else {
                high = mid;
              }
            }
            return high;
          }
          return baseSortedIndexBy(array, value, identity, retHighest);
        }
        function baseSortedIndexBy(array, value, iteratee2, retHighest) {
          var low = 0, high = array == null ? 0 : array.length;
          if (high === 0) {
            return 0;
          }
          value = iteratee2(value);
          var valIsNaN = value !== value, valIsNull = value === null, valIsSymbol = isSymbol(value), valIsUndefined = value === undefined2;
          while (low < high) {
            var mid = nativeFloor((low + high) / 2), computed = iteratee2(array[mid]), othIsDefined = computed !== undefined2, othIsNull = computed === null, othIsReflexive = computed === computed, othIsSymbol = isSymbol(computed);
            if (valIsNaN) {
              var setLow = retHighest || othIsReflexive;
            } else if (valIsUndefined) {
              setLow = othIsReflexive && (retHighest || othIsDefined);
            } else if (valIsNull) {
              setLow = othIsReflexive && othIsDefined && (retHighest || !othIsNull);
            } else if (valIsSymbol) {
              setLow = othIsReflexive && othIsDefined && !othIsNull && (retHighest || !othIsSymbol);
            } else if (othIsNull || othIsSymbol) {
              setLow = false;
            } else {
              setLow = retHighest ? computed <= value : computed < value;
            }
            if (setLow) {
              low = mid + 1;
            } else {
              high = mid;
            }
          }
          return nativeMin(high, MAX_ARRAY_INDEX);
        }
        function baseSortedUniq(array, iteratee2) {
          var index2 = -1, length = array.length, resIndex = 0, result2 = [];
          while (++index2 < length) {
            var value = array[index2], computed = iteratee2 ? iteratee2(value) : value;
            if (!index2 || !eq(computed, seen)) {
              var seen = computed;
              result2[resIndex++] = value === 0 ? 0 : value;
            }
          }
          return result2;
        }
        function baseToNumber(value) {
          if (typeof value == "number") {
            return value;
          }
          if (isSymbol(value)) {
            return NAN;
          }
          return +value;
        }
        function baseToString(value) {
          if (typeof value == "string") {
            return value;
          }
          if (isArray(value)) {
            return arrayMap(value, baseToString) + "";
          }
          if (isSymbol(value)) {
            return symbolToString ? symbolToString.call(value) : "";
          }
          var result2 = value + "";
          return result2 == "0" && 1 / value == -INFINITY ? "-0" : result2;
        }
        function baseUniq(array, iteratee2, comparator) {
          var index2 = -1, includes2 = arrayIncludes, length = array.length, isCommon = true, result2 = [], seen = result2;
          if (comparator) {
            isCommon = false;
            includes2 = arrayIncludesWith;
          } else if (length >= LARGE_ARRAY_SIZE) {
            var set2 = iteratee2 ? null : createSet(array);
            if (set2) {
              return setToArray(set2);
            }
            isCommon = false;
            includes2 = cacheHas;
            seen = new SetCache();
          } else {
            seen = iteratee2 ? [] : result2;
          }
          outer:
            while (++index2 < length) {
              var value = array[index2], computed = iteratee2 ? iteratee2(value) : value;
              value = comparator || value !== 0 ? value : 0;
              if (isCommon && computed === computed) {
                var seenIndex = seen.length;
                while (seenIndex--) {
                  if (seen[seenIndex] === computed) {
                    continue outer;
                  }
                }
                if (iteratee2) {
                  seen.push(computed);
                }
                result2.push(value);
              } else if (!includes2(seen, computed, comparator)) {
                if (seen !== result2) {
                  seen.push(computed);
                }
                result2.push(value);
              }
            }
          return result2;
        }
        function baseUnset(object, path) {
          path = castPath(path, object);
          object = parent(object, path);
          return object == null || delete object[toKey(last(path))];
        }
        function baseUpdate(object, path, updater, customizer) {
          return baseSet(object, path, updater(baseGet(object, path)), customizer);
        }
        function baseWhile(array, predicate, isDrop, fromRight) {
          var length = array.length, index2 = fromRight ? length : -1;
          while ((fromRight ? index2-- : ++index2 < length) && predicate(array[index2], index2, array)) {
          }
          return isDrop ? baseSlice(array, fromRight ? 0 : index2, fromRight ? index2 + 1 : length) : baseSlice(array, fromRight ? index2 + 1 : 0, fromRight ? length : index2);
        }
        function baseWrapperValue(value, actions) {
          var result2 = value;
          if (result2 instanceof LazyWrapper) {
            result2 = result2.value();
          }
          return arrayReduce(actions, function(result3, action) {
            return action.func.apply(action.thisArg, arrayPush([result3], action.args));
          }, result2);
        }
        function baseXor(arrays, iteratee2, comparator) {
          var length = arrays.length;
          if (length < 2) {
            return length ? baseUniq(arrays[0]) : [];
          }
          var index2 = -1, result2 = Array2(length);
          while (++index2 < length) {
            var array = arrays[index2], othIndex = -1;
            while (++othIndex < length) {
              if (othIndex != index2) {
                result2[index2] = baseDifference(result2[index2] || array, arrays[othIndex], iteratee2, comparator);
              }
            }
          }
          return baseUniq(baseFlatten(result2, 1), iteratee2, comparator);
        }
        function baseZipObject(props, values2, assignFunc) {
          var index2 = -1, length = props.length, valsLength = values2.length, result2 = {};
          while (++index2 < length) {
            var value = index2 < valsLength ? values2[index2] : undefined2;
            assignFunc(result2, props[index2], value);
          }
          return result2;
        }
        function castArrayLikeObject(value) {
          return isArrayLikeObject(value) ? value : [];
        }
        function castFunction(value) {
          return typeof value == "function" ? value : identity;
        }
        function castPath(value, object) {
          if (isArray(value)) {
            return value;
          }
          return isKey(value, object) ? [value] : stringToPath(toString(value));
        }
        var castRest = baseRest;
        function castSlice(array, start, end) {
          var length = array.length;
          end = end === undefined2 ? length : end;
          return !start && end >= length ? array : baseSlice(array, start, end);
        }
        var clearTimeout2 = ctxClearTimeout || function(id2) {
          return root.clearTimeout(id2);
        };
        function cloneBuffer(buffer, isDeep) {
          if (isDeep) {
            return buffer.slice();
          }
          var length = buffer.length, result2 = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);
          buffer.copy(result2);
          return result2;
        }
        function cloneArrayBuffer(arrayBuffer) {
          var result2 = new arrayBuffer.constructor(arrayBuffer.byteLength);
          new Uint8Array2(result2).set(new Uint8Array2(arrayBuffer));
          return result2;
        }
        function cloneDataView(dataView, isDeep) {
          var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;
          return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
        }
        function cloneRegExp(regexp) {
          var result2 = new regexp.constructor(regexp.source, reFlags.exec(regexp));
          result2.lastIndex = regexp.lastIndex;
          return result2;
        }
        function cloneSymbol(symbol) {
          return symbolValueOf ? Object2(symbolValueOf.call(symbol)) : {};
        }
        function cloneTypedArray(typedArray, isDeep) {
          var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
          return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
        }
        function compareAscending(value, other) {
          if (value !== other) {
            var valIsDefined = value !== undefined2, valIsNull = value === null, valIsReflexive = value === value, valIsSymbol = isSymbol(value);
            var othIsDefined = other !== undefined2, othIsNull = other === null, othIsReflexive = other === other, othIsSymbol = isSymbol(other);
            if (!othIsNull && !othIsSymbol && !valIsSymbol && value > other || valIsSymbol && othIsDefined && othIsReflexive && !othIsNull && !othIsSymbol || valIsNull && othIsDefined && othIsReflexive || !valIsDefined && othIsReflexive || !valIsReflexive) {
              return 1;
            }
            if (!valIsNull && !valIsSymbol && !othIsSymbol && value < other || othIsSymbol && valIsDefined && valIsReflexive && !valIsNull && !valIsSymbol || othIsNull && valIsDefined && valIsReflexive || !othIsDefined && valIsReflexive || !othIsReflexive) {
              return -1;
            }
          }
          return 0;
        }
        function compareMultiple(object, other, orders) {
          var index2 = -1, objCriteria = object.criteria, othCriteria = other.criteria, length = objCriteria.length, ordersLength = orders.length;
          while (++index2 < length) {
            var result2 = compareAscending(objCriteria[index2], othCriteria[index2]);
            if (result2) {
              if (index2 >= ordersLength) {
                return result2;
              }
              var order = orders[index2];
              return result2 * (order == "desc" ? -1 : 1);
            }
          }
          return object.index - other.index;
        }
        function composeArgs(args, partials, holders, isCurried) {
          var argsIndex = -1, argsLength = args.length, holdersLength = holders.length, leftIndex = -1, leftLength = partials.length, rangeLength = nativeMax(argsLength - holdersLength, 0), result2 = Array2(leftLength + rangeLength), isUncurried = !isCurried;
          while (++leftIndex < leftLength) {
            result2[leftIndex] = partials[leftIndex];
          }
          while (++argsIndex < holdersLength) {
            if (isUncurried || argsIndex < argsLength) {
              result2[holders[argsIndex]] = args[argsIndex];
            }
          }
          while (rangeLength--) {
            result2[leftIndex++] = args[argsIndex++];
          }
          return result2;
        }
        function composeArgsRight(args, partials, holders, isCurried) {
          var argsIndex = -1, argsLength = args.length, holdersIndex = -1, holdersLength = holders.length, rightIndex = -1, rightLength = partials.length, rangeLength = nativeMax(argsLength - holdersLength, 0), result2 = Array2(rangeLength + rightLength), isUncurried = !isCurried;
          while (++argsIndex < rangeLength) {
            result2[argsIndex] = args[argsIndex];
          }
          var offset = argsIndex;
          while (++rightIndex < rightLength) {
            result2[offset + rightIndex] = partials[rightIndex];
          }
          while (++holdersIndex < holdersLength) {
            if (isUncurried || argsIndex < argsLength) {
              result2[offset + holders[holdersIndex]] = args[argsIndex++];
            }
          }
          return result2;
        }
        function copyArray(source, array) {
          var index2 = -1, length = source.length;
          array || (array = Array2(length));
          while (++index2 < length) {
            array[index2] = source[index2];
          }
          return array;
        }
        function copyObject(source, props, object, customizer) {
          var isNew = !object;
          object || (object = {});
          var index2 = -1, length = props.length;
          while (++index2 < length) {
            var key = props[index2];
            var newValue = customizer ? customizer(object[key], source[key], key, object, source) : undefined2;
            if (newValue === undefined2) {
              newValue = source[key];
            }
            if (isNew) {
              baseAssignValue(object, key, newValue);
            } else {
              assignValue(object, key, newValue);
            }
          }
          return object;
        }
        function copySymbols(source, object) {
          return copyObject(source, getSymbols(source), object);
        }
        function copySymbolsIn(source, object) {
          return copyObject(source, getSymbolsIn(source), object);
        }
        function createAggregator(setter, initializer) {
          return function(collection, iteratee2) {
            var func = isArray(collection) ? arrayAggregator : baseAggregator, accumulator = initializer ? initializer() : {};
            return func(collection, setter, getIteratee(iteratee2, 2), accumulator);
          };
        }
        function createAssigner(assigner) {
          return baseRest(function(object, sources) {
            var index2 = -1, length = sources.length, customizer = length > 1 ? sources[length - 1] : undefined2, guard = length > 2 ? sources[2] : undefined2;
            customizer = assigner.length > 3 && typeof customizer == "function" ? (length--, customizer) : undefined2;
            if (guard && isIterateeCall(sources[0], sources[1], guard)) {
              customizer = length < 3 ? undefined2 : customizer;
              length = 1;
            }
            object = Object2(object);
            while (++index2 < length) {
              var source = sources[index2];
              if (source) {
                assigner(object, source, index2, customizer);
              }
            }
            return object;
          });
        }
        function createBaseEach(eachFunc, fromRight) {
          return function(collection, iteratee2) {
            if (collection == null) {
              return collection;
            }
            if (!isArrayLike(collection)) {
              return eachFunc(collection, iteratee2);
            }
            var length = collection.length, index2 = fromRight ? length : -1, iterable = Object2(collection);
            while (fromRight ? index2-- : ++index2 < length) {
              if (iteratee2(iterable[index2], index2, iterable) === false) {
                break;
              }
            }
            return collection;
          };
        }
        function createBaseFor(fromRight) {
          return function(object, iteratee2, keysFunc) {
            var index2 = -1, iterable = Object2(object), props = keysFunc(object), length = props.length;
            while (length--) {
              var key = props[fromRight ? length : ++index2];
              if (iteratee2(iterable[key], key, iterable) === false) {
                break;
              }
            }
            return object;
          };
        }
        function createBind(func, bitmask, thisArg) {
          var isBind = bitmask & WRAP_BIND_FLAG, Ctor = createCtor(func);
          function wrapper() {
            var fn = this && this !== root && this instanceof wrapper ? Ctor : func;
            return fn.apply(isBind ? thisArg : this, arguments);
          }
          return wrapper;
        }
        function createCaseFirst(methodName) {
          return function(string) {
            string = toString(string);
            var strSymbols = hasUnicode(string) ? stringToArray(string) : undefined2;
            var chr = strSymbols ? strSymbols[0] : string.charAt(0);
            var trailing = strSymbols ? castSlice(strSymbols, 1).join("") : string.slice(1);
            return chr[methodName]() + trailing;
          };
        }
        function createCompounder(callback) {
          return function(string) {
            return arrayReduce(words(deburr(string).replace(reApos, "")), callback, "");
          };
        }
        function createCtor(Ctor) {
          return function() {
            var args = arguments;
            switch (args.length) {
              case 0:
                return new Ctor();
              case 1:
                return new Ctor(args[0]);
              case 2:
                return new Ctor(args[0], args[1]);
              case 3:
                return new Ctor(args[0], args[1], args[2]);
              case 4:
                return new Ctor(args[0], args[1], args[2], args[3]);
              case 5:
                return new Ctor(args[0], args[1], args[2], args[3], args[4]);
              case 6:
                return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5]);
              case 7:
                return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5], args[6]);
            }
            var thisBinding = baseCreate(Ctor.prototype), result2 = Ctor.apply(thisBinding, args);
            return isObject(result2) ? result2 : thisBinding;
          };
        }
        function createCurry(func, bitmask, arity) {
          var Ctor = createCtor(func);
          function wrapper() {
            var length = arguments.length, args = Array2(length), index2 = length, placeholder = getHolder(wrapper);
            while (index2--) {
              args[index2] = arguments[index2];
            }
            var holders = length < 3 && args[0] !== placeholder && args[length - 1] !== placeholder ? [] : replaceHolders(args, placeholder);
            length -= holders.length;
            if (length < arity) {
              return createRecurry(
                func,
                bitmask,
                createHybrid,
                wrapper.placeholder,
                undefined2,
                args,
                holders,
                undefined2,
                undefined2,
                arity - length
              );
            }
            var fn = this && this !== root && this instanceof wrapper ? Ctor : func;
            return apply(fn, this, args);
          }
          return wrapper;
        }
        function createFind(findIndexFunc) {
          return function(collection, predicate, fromIndex) {
            var iterable = Object2(collection);
            if (!isArrayLike(collection)) {
              var iteratee2 = getIteratee(predicate, 3);
              collection = keys(collection);
              predicate = function(key) {
                return iteratee2(iterable[key], key, iterable);
              };
            }
            var index2 = findIndexFunc(collection, predicate, fromIndex);
            return index2 > -1 ? iterable[iteratee2 ? collection[index2] : index2] : undefined2;
          };
        }
        function createFlow(fromRight) {
          return flatRest(function(funcs) {
            var length = funcs.length, index2 = length, prereq = LodashWrapper.prototype.thru;
            if (fromRight) {
              funcs.reverse();
            }
            while (index2--) {
              var func = funcs[index2];
              if (typeof func != "function") {
                throw new TypeError2(FUNC_ERROR_TEXT);
              }
              if (prereq && !wrapper && getFuncName(func) == "wrapper") {
                var wrapper = new LodashWrapper([], true);
              }
            }
            index2 = wrapper ? index2 : length;
            while (++index2 < length) {
              func = funcs[index2];
              var funcName = getFuncName(func), data = funcName == "wrapper" ? getData(func) : undefined2;
              if (data && isLaziable(data[0]) && data[1] == (WRAP_ARY_FLAG | WRAP_CURRY_FLAG | WRAP_PARTIAL_FLAG | WRAP_REARG_FLAG) && !data[4].length && data[9] == 1) {
                wrapper = wrapper[getFuncName(data[0])].apply(wrapper, data[3]);
              } else {
                wrapper = func.length == 1 && isLaziable(func) ? wrapper[funcName]() : wrapper.thru(func);
              }
            }
            return function() {
              var args = arguments, value = args[0];
              if (wrapper && args.length == 1 && isArray(value)) {
                return wrapper.plant(value).value();
              }
              var index3 = 0, result2 = length ? funcs[index3].apply(this, args) : value;
              while (++index3 < length) {
                result2 = funcs[index3].call(this, result2);
              }
              return result2;
            };
          });
        }
        function createHybrid(func, bitmask, thisArg, partials, holders, partialsRight, holdersRight, argPos, ary2, arity) {
          var isAry = bitmask & WRAP_ARY_FLAG, isBind = bitmask & WRAP_BIND_FLAG, isBindKey = bitmask & WRAP_BIND_KEY_FLAG, isCurried = bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG), isFlip = bitmask & WRAP_FLIP_FLAG, Ctor = isBindKey ? undefined2 : createCtor(func);
          function wrapper() {
            var length = arguments.length, args = Array2(length), index2 = length;
            while (index2--) {
              args[index2] = arguments[index2];
            }
            if (isCurried) {
              var placeholder = getHolder(wrapper), holdersCount = countHolders(args, placeholder);
            }
            if (partials) {
              args = composeArgs(args, partials, holders, isCurried);
            }
            if (partialsRight) {
              args = composeArgsRight(args, partialsRight, holdersRight, isCurried);
            }
            length -= holdersCount;
            if (isCurried && length < arity) {
              var newHolders = replaceHolders(args, placeholder);
              return createRecurry(
                func,
                bitmask,
                createHybrid,
                wrapper.placeholder,
                thisArg,
                args,
                newHolders,
                argPos,
                ary2,
                arity - length
              );
            }
            var thisBinding = isBind ? thisArg : this, fn = isBindKey ? thisBinding[func] : func;
            length = args.length;
            if (argPos) {
              args = reorder(args, argPos);
            } else if (isFlip && length > 1) {
              args.reverse();
            }
            if (isAry && ary2 < length) {
              args.length = ary2;
            }
            if (this && this !== root && this instanceof wrapper) {
              fn = Ctor || createCtor(fn);
            }
            return fn.apply(thisBinding, args);
          }
          return wrapper;
        }
        function createInverter(setter, toIteratee) {
          return function(object, iteratee2) {
            return baseInverter(object, setter, toIteratee(iteratee2), {});
          };
        }
        function createMathOperation(operator, defaultValue) {
          return function(value, other) {
            var result2;
            if (value === undefined2 && other === undefined2) {
              return defaultValue;
            }
            if (value !== undefined2) {
              result2 = value;
            }
            if (other !== undefined2) {
              if (result2 === undefined2) {
                return other;
              }
              if (typeof value == "string" || typeof other == "string") {
                value = baseToString(value);
                other = baseToString(other);
              } else {
                value = baseToNumber(value);
                other = baseToNumber(other);
              }
              result2 = operator(value, other);
            }
            return result2;
          };
        }
        function createOver(arrayFunc) {
          return flatRest(function(iteratees) {
            iteratees = arrayMap(iteratees, baseUnary(getIteratee()));
            return baseRest(function(args) {
              var thisArg = this;
              return arrayFunc(iteratees, function(iteratee2) {
                return apply(iteratee2, thisArg, args);
              });
            });
          });
        }
        function createPadding(length, chars) {
          chars = chars === undefined2 ? " " : baseToString(chars);
          var charsLength = chars.length;
          if (charsLength < 2) {
            return charsLength ? baseRepeat(chars, length) : chars;
          }
          var result2 = baseRepeat(chars, nativeCeil(length / stringSize(chars)));
          return hasUnicode(chars) ? castSlice(stringToArray(result2), 0, length).join("") : result2.slice(0, length);
        }
        function createPartial(func, bitmask, thisArg, partials) {
          var isBind = bitmask & WRAP_BIND_FLAG, Ctor = createCtor(func);
          function wrapper() {
            var argsIndex = -1, argsLength = arguments.length, leftIndex = -1, leftLength = partials.length, args = Array2(leftLength + argsLength), fn = this && this !== root && this instanceof wrapper ? Ctor : func;
            while (++leftIndex < leftLength) {
              args[leftIndex] = partials[leftIndex];
            }
            while (argsLength--) {
              args[leftIndex++] = arguments[++argsIndex];
            }
            return apply(fn, isBind ? thisArg : this, args);
          }
          return wrapper;
        }
        function createRange(fromRight) {
          return function(start, end, step) {
            if (step && typeof step != "number" && isIterateeCall(start, end, step)) {
              end = step = undefined2;
            }
            start = toFinite(start);
            if (end === undefined2) {
              end = start;
              start = 0;
            } else {
              end = toFinite(end);
            }
            step = step === undefined2 ? start < end ? 1 : -1 : toFinite(step);
            return baseRange(start, end, step, fromRight);
          };
        }
        function createRelationalOperation(operator) {
          return function(value, other) {
            if (!(typeof value == "string" && typeof other == "string")) {
              value = toNumber(value);
              other = toNumber(other);
            }
            return operator(value, other);
          };
        }
        function createRecurry(func, bitmask, wrapFunc, placeholder, thisArg, partials, holders, argPos, ary2, arity) {
          var isCurry = bitmask & WRAP_CURRY_FLAG, newHolders = isCurry ? holders : undefined2, newHoldersRight = isCurry ? undefined2 : holders, newPartials = isCurry ? partials : undefined2, newPartialsRight = isCurry ? undefined2 : partials;
          bitmask |= isCurry ? WRAP_PARTIAL_FLAG : WRAP_PARTIAL_RIGHT_FLAG;
          bitmask &= ~(isCurry ? WRAP_PARTIAL_RIGHT_FLAG : WRAP_PARTIAL_FLAG);
          if (!(bitmask & WRAP_CURRY_BOUND_FLAG)) {
            bitmask &= ~(WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG);
          }
          var newData = [
            func,
            bitmask,
            thisArg,
            newPartials,
            newHolders,
            newPartialsRight,
            newHoldersRight,
            argPos,
            ary2,
            arity
          ];
          var result2 = wrapFunc.apply(undefined2, newData);
          if (isLaziable(func)) {
            setData(result2, newData);
          }
          result2.placeholder = placeholder;
          return setWrapToString(result2, func, bitmask);
        }
        function createRound(methodName) {
          var func = Math2[methodName];
          return function(number, precision) {
            number = toNumber(number);
            precision = precision == null ? 0 : nativeMin(toInteger(precision), 292);
            if (precision && nativeIsFinite(number)) {
              var pair = (toString(number) + "e").split("e"), value = func(pair[0] + "e" + (+pair[1] + precision));
              pair = (toString(value) + "e").split("e");
              return +(pair[0] + "e" + (+pair[1] - precision));
            }
            return func(number);
          };
        }
        var createSet = !(Set2 && 1 / setToArray(new Set2([, -0]))[1] == INFINITY) ? noop3 : function(values2) {
          return new Set2(values2);
        };
        function createToPairs(keysFunc) {
          return function(object) {
            var tag = getTag(object);
            if (tag == mapTag) {
              return mapToArray(object);
            }
            if (tag == setTag) {
              return setToPairs(object);
            }
            return baseToPairs(object, keysFunc(object));
          };
        }
        function createWrap(func, bitmask, thisArg, partials, holders, argPos, ary2, arity) {
          var isBindKey = bitmask & WRAP_BIND_KEY_FLAG;
          if (!isBindKey && typeof func != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          var length = partials ? partials.length : 0;
          if (!length) {
            bitmask &= ~(WRAP_PARTIAL_FLAG | WRAP_PARTIAL_RIGHT_FLAG);
            partials = holders = undefined2;
          }
          ary2 = ary2 === undefined2 ? ary2 : nativeMax(toInteger(ary2), 0);
          arity = arity === undefined2 ? arity : toInteger(arity);
          length -= holders ? holders.length : 0;
          if (bitmask & WRAP_PARTIAL_RIGHT_FLAG) {
            var partialsRight = partials, holdersRight = holders;
            partials = holders = undefined2;
          }
          var data = isBindKey ? undefined2 : getData(func);
          var newData = [
            func,
            bitmask,
            thisArg,
            partials,
            holders,
            partialsRight,
            holdersRight,
            argPos,
            ary2,
            arity
          ];
          if (data) {
            mergeData(newData, data);
          }
          func = newData[0];
          bitmask = newData[1];
          thisArg = newData[2];
          partials = newData[3];
          holders = newData[4];
          arity = newData[9] = newData[9] === undefined2 ? isBindKey ? 0 : func.length : nativeMax(newData[9] - length, 0);
          if (!arity && bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG)) {
            bitmask &= ~(WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG);
          }
          if (!bitmask || bitmask == WRAP_BIND_FLAG) {
            var result2 = createBind(func, bitmask, thisArg);
          } else if (bitmask == WRAP_CURRY_FLAG || bitmask == WRAP_CURRY_RIGHT_FLAG) {
            result2 = createCurry(func, bitmask, arity);
          } else if ((bitmask == WRAP_PARTIAL_FLAG || bitmask == (WRAP_BIND_FLAG | WRAP_PARTIAL_FLAG)) && !holders.length) {
            result2 = createPartial(func, bitmask, thisArg, partials);
          } else {
            result2 = createHybrid.apply(undefined2, newData);
          }
          var setter = data ? baseSetData : setData;
          return setWrapToString(setter(result2, newData), func, bitmask);
        }
        function customDefaultsAssignIn(objValue, srcValue, key, object) {
          if (objValue === undefined2 || eq(objValue, objectProto[key]) && !hasOwnProperty2.call(object, key)) {
            return srcValue;
          }
          return objValue;
        }
        function customDefaultsMerge(objValue, srcValue, key, object, source, stack) {
          if (isObject(objValue) && isObject(srcValue)) {
            stack.set(srcValue, objValue);
            baseMerge(objValue, srcValue, undefined2, customDefaultsMerge, stack);
            stack["delete"](srcValue);
          }
          return objValue;
        }
        function customOmitClone(value) {
          return isPlainObject(value) ? undefined2 : value;
        }
        function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {
          var isPartial = bitmask & COMPARE_PARTIAL_FLAG, arrLength = array.length, othLength = other.length;
          if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
            return false;
          }
          var arrStacked = stack.get(array);
          var othStacked = stack.get(other);
          if (arrStacked && othStacked) {
            return arrStacked == other && othStacked == array;
          }
          var index2 = -1, result2 = true, seen = bitmask & COMPARE_UNORDERED_FLAG ? new SetCache() : undefined2;
          stack.set(array, other);
          stack.set(other, array);
          while (++index2 < arrLength) {
            var arrValue = array[index2], othValue = other[index2];
            if (customizer) {
              var compared = isPartial ? customizer(othValue, arrValue, index2, other, array, stack) : customizer(arrValue, othValue, index2, array, other, stack);
            }
            if (compared !== undefined2) {
              if (compared) {
                continue;
              }
              result2 = false;
              break;
            }
            if (seen) {
              if (!arraySome(other, function(othValue2, othIndex) {
                if (!cacheHas(seen, othIndex) && (arrValue === othValue2 || equalFunc(arrValue, othValue2, bitmask, customizer, stack))) {
                  return seen.push(othIndex);
                }
              })) {
                result2 = false;
                break;
              }
            } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
              result2 = false;
              break;
            }
          }
          stack["delete"](array);
          stack["delete"](other);
          return result2;
        }
        function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {
          switch (tag) {
            case dataViewTag:
              if (object.byteLength != other.byteLength || object.byteOffset != other.byteOffset) {
                return false;
              }
              object = object.buffer;
              other = other.buffer;
            case arrayBufferTag:
              if (object.byteLength != other.byteLength || !equalFunc(new Uint8Array2(object), new Uint8Array2(other))) {
                return false;
              }
              return true;
            case boolTag:
            case dateTag:
            case numberTag:
              return eq(+object, +other);
            case errorTag:
              return object.name == other.name && object.message == other.message;
            case regexpTag:
            case stringTag:
              return object == other + "";
            case mapTag:
              var convert = mapToArray;
            case setTag:
              var isPartial = bitmask & COMPARE_PARTIAL_FLAG;
              convert || (convert = setToArray);
              if (object.size != other.size && !isPartial) {
                return false;
              }
              var stacked = stack.get(object);
              if (stacked) {
                return stacked == other;
              }
              bitmask |= COMPARE_UNORDERED_FLAG;
              stack.set(object, other);
              var result2 = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);
              stack["delete"](object);
              return result2;
            case symbolTag:
              if (symbolValueOf) {
                return symbolValueOf.call(object) == symbolValueOf.call(other);
              }
          }
          return false;
        }
        function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {
          var isPartial = bitmask & COMPARE_PARTIAL_FLAG, objProps = getAllKeys(object), objLength = objProps.length, othProps = getAllKeys(other), othLength = othProps.length;
          if (objLength != othLength && !isPartial) {
            return false;
          }
          var index2 = objLength;
          while (index2--) {
            var key = objProps[index2];
            if (!(isPartial ? key in other : hasOwnProperty2.call(other, key))) {
              return false;
            }
          }
          var objStacked = stack.get(object);
          var othStacked = stack.get(other);
          if (objStacked && othStacked) {
            return objStacked == other && othStacked == object;
          }
          var result2 = true;
          stack.set(object, other);
          stack.set(other, object);
          var skipCtor = isPartial;
          while (++index2 < objLength) {
            key = objProps[index2];
            var objValue = object[key], othValue = other[key];
            if (customizer) {
              var compared = isPartial ? customizer(othValue, objValue, key, other, object, stack) : customizer(objValue, othValue, key, object, other, stack);
            }
            if (!(compared === undefined2 ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack) : compared)) {
              result2 = false;
              break;
            }
            skipCtor || (skipCtor = key == "constructor");
          }
          if (result2 && !skipCtor) {
            var objCtor = object.constructor, othCtor = other.constructor;
            if (objCtor != othCtor && ("constructor" in object && "constructor" in other) && !(typeof objCtor == "function" && objCtor instanceof objCtor && typeof othCtor == "function" && othCtor instanceof othCtor)) {
              result2 = false;
            }
          }
          stack["delete"](object);
          stack["delete"](other);
          return result2;
        }
        function flatRest(func) {
          return setToString(overRest(func, undefined2, flatten), func + "");
        }
        function getAllKeys(object) {
          return baseGetAllKeys(object, keys, getSymbols);
        }
        function getAllKeysIn(object) {
          return baseGetAllKeys(object, keysIn, getSymbolsIn);
        }
        var getData = !metaMap ? noop3 : function(func) {
          return metaMap.get(func);
        };
        function getFuncName(func) {
          var result2 = func.name + "", array = realNames[result2], length = hasOwnProperty2.call(realNames, result2) ? array.length : 0;
          while (length--) {
            var data = array[length], otherFunc = data.func;
            if (otherFunc == null || otherFunc == func) {
              return data.name;
            }
          }
          return result2;
        }
        function getHolder(func) {
          var object = hasOwnProperty2.call(lodash, "placeholder") ? lodash : func;
          return object.placeholder;
        }
        function getIteratee() {
          var result2 = lodash.iteratee || iteratee;
          result2 = result2 === iteratee ? baseIteratee : result2;
          return arguments.length ? result2(arguments[0], arguments[1]) : result2;
        }
        function getMapData(map2, key) {
          var data = map2.__data__;
          return isKeyable(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
        }
        function getMatchData(object) {
          var result2 = keys(object), length = result2.length;
          while (length--) {
            var key = result2[length], value = object[key];
            result2[length] = [key, value, isStrictComparable(value)];
          }
          return result2;
        }
        function getNative(object, key) {
          var value = getValue(object, key);
          return baseIsNative(value) ? value : undefined2;
        }
        function getRawTag(value) {
          var isOwn = hasOwnProperty2.call(value, symToStringTag), tag = value[symToStringTag];
          try {
            value[symToStringTag] = undefined2;
            var unmasked = true;
          } catch (e2) {
          }
          var result2 = nativeObjectToString.call(value);
          if (unmasked) {
            if (isOwn) {
              value[symToStringTag] = tag;
            } else {
              delete value[symToStringTag];
            }
          }
          return result2;
        }
        var getSymbols = !nativeGetSymbols ? stubArray : function(object) {
          if (object == null) {
            return [];
          }
          object = Object2(object);
          return arrayFilter(nativeGetSymbols(object), function(symbol) {
            return propertyIsEnumerable.call(object, symbol);
          });
        };
        var getSymbolsIn = !nativeGetSymbols ? stubArray : function(object) {
          var result2 = [];
          while (object) {
            arrayPush(result2, getSymbols(object));
            object = getPrototype(object);
          }
          return result2;
        };
        var getTag = baseGetTag;
        if (DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag || Map3 && getTag(new Map3()) != mapTag || Promise2 && getTag(Promise2.resolve()) != promiseTag || Set2 && getTag(new Set2()) != setTag || WeakMap && getTag(new WeakMap()) != weakMapTag) {
          getTag = function(value) {
            var result2 = baseGetTag(value), Ctor = result2 == objectTag ? value.constructor : undefined2, ctorString = Ctor ? toSource(Ctor) : "";
            if (ctorString) {
              switch (ctorString) {
                case dataViewCtorString:
                  return dataViewTag;
                case mapCtorString:
                  return mapTag;
                case promiseCtorString:
                  return promiseTag;
                case setCtorString:
                  return setTag;
                case weakMapCtorString:
                  return weakMapTag;
              }
            }
            return result2;
          };
        }
        function getView(start, end, transforms) {
          var index2 = -1, length = transforms.length;
          while (++index2 < length) {
            var data = transforms[index2], size2 = data.size;
            switch (data.type) {
              case "drop":
                start += size2;
                break;
              case "dropRight":
                end -= size2;
                break;
              case "take":
                end = nativeMin(end, start + size2);
                break;
              case "takeRight":
                start = nativeMax(start, end - size2);
                break;
            }
          }
          return { "start": start, "end": end };
        }
        function getWrapDetails(source) {
          var match = source.match(reWrapDetails);
          return match ? match[1].split(reSplitDetails) : [];
        }
        function hasPath(object, path, hasFunc) {
          path = castPath(path, object);
          var index2 = -1, length = path.length, result2 = false;
          while (++index2 < length) {
            var key = toKey(path[index2]);
            if (!(result2 = object != null && hasFunc(object, key))) {
              break;
            }
            object = object[key];
          }
          if (result2 || ++index2 != length) {
            return result2;
          }
          length = object == null ? 0 : object.length;
          return !!length && isLength2(length) && isIndex(key, length) && (isArray(object) || isArguments(object));
        }
        function initCloneArray(array) {
          var length = array.length, result2 = new array.constructor(length);
          if (length && typeof array[0] == "string" && hasOwnProperty2.call(array, "index")) {
            result2.index = array.index;
            result2.input = array.input;
          }
          return result2;
        }
        function initCloneObject(object) {
          return typeof object.constructor == "function" && !isPrototype(object) ? baseCreate(getPrototype(object)) : {};
        }
        function initCloneByTag(object, tag, isDeep) {
          var Ctor = object.constructor;
          switch (tag) {
            case arrayBufferTag:
              return cloneArrayBuffer(object);
            case boolTag:
            case dateTag:
              return new Ctor(+object);
            case dataViewTag:
              return cloneDataView(object, isDeep);
            case float32Tag:
            case float64Tag:
            case int8Tag:
            case int16Tag:
            case int32Tag:
            case uint8Tag:
            case uint8ClampedTag:
            case uint16Tag:
            case uint32Tag:
              return cloneTypedArray(object, isDeep);
            case mapTag:
              return new Ctor();
            case numberTag:
            case stringTag:
              return new Ctor(object);
            case regexpTag:
              return cloneRegExp(object);
            case setTag:
              return new Ctor();
            case symbolTag:
              return cloneSymbol(object);
          }
        }
        function insertWrapDetails(source, details) {
          var length = details.length;
          if (!length) {
            return source;
          }
          var lastIndex = length - 1;
          details[lastIndex] = (length > 1 ? "& " : "") + details[lastIndex];
          details = details.join(length > 2 ? ", " : " ");
          return source.replace(reWrapComment, "{\n/* [wrapped with " + details + "] */\n");
        }
        function isFlattenable(value) {
          return isArray(value) || isArguments(value) || !!(spreadableSymbol && value && value[spreadableSymbol]);
        }
        function isIndex(value, length) {
          var type = typeof value;
          length = length == null ? MAX_SAFE_INTEGER : length;
          return !!length && (type == "number" || type != "symbol" && reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length);
        }
        function isIterateeCall(value, index2, object) {
          if (!isObject(object)) {
            return false;
          }
          var type = typeof index2;
          if (type == "number" ? isArrayLike(object) && isIndex(index2, object.length) : type == "string" && index2 in object) {
            return eq(object[index2], value);
          }
          return false;
        }
        function isKey(value, object) {
          if (isArray(value)) {
            return false;
          }
          var type = typeof value;
          if (type == "number" || type == "symbol" || type == "boolean" || value == null || isSymbol(value)) {
            return true;
          }
          return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object != null && value in Object2(object);
        }
        function isKeyable(value) {
          var type = typeof value;
          return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
        }
        function isLaziable(func) {
          var funcName = getFuncName(func), other = lodash[funcName];
          if (typeof other != "function" || !(funcName in LazyWrapper.prototype)) {
            return false;
          }
          if (func === other) {
            return true;
          }
          var data = getData(other);
          return !!data && func === data[0];
        }
        function isMasked(func) {
          return !!maskSrcKey && maskSrcKey in func;
        }
        var isMaskable = coreJsData ? isFunction : stubFalse;
        function isPrototype(value) {
          var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto;
          return value === proto;
        }
        function isStrictComparable(value) {
          return value === value && !isObject(value);
        }
        function matchesStrictComparable(key, srcValue) {
          return function(object) {
            if (object == null) {
              return false;
            }
            return object[key] === srcValue && (srcValue !== undefined2 || key in Object2(object));
          };
        }
        function memoizeCapped(func) {
          var result2 = memoize(func, function(key) {
            if (cache.size === MAX_MEMOIZE_SIZE) {
              cache.clear();
            }
            return key;
          });
          var cache = result2.cache;
          return result2;
        }
        function mergeData(data, source) {
          var bitmask = data[1], srcBitmask = source[1], newBitmask = bitmask | srcBitmask, isCommon = newBitmask < (WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG | WRAP_ARY_FLAG);
          var isCombo = srcBitmask == WRAP_ARY_FLAG && bitmask == WRAP_CURRY_FLAG || srcBitmask == WRAP_ARY_FLAG && bitmask == WRAP_REARG_FLAG && data[7].length <= source[8] || srcBitmask == (WRAP_ARY_FLAG | WRAP_REARG_FLAG) && source[7].length <= source[8] && bitmask == WRAP_CURRY_FLAG;
          if (!(isCommon || isCombo)) {
            return data;
          }
          if (srcBitmask & WRAP_BIND_FLAG) {
            data[2] = source[2];
            newBitmask |= bitmask & WRAP_BIND_FLAG ? 0 : WRAP_CURRY_BOUND_FLAG;
          }
          var value = source[3];
          if (value) {
            var partials = data[3];
            data[3] = partials ? composeArgs(partials, value, source[4]) : value;
            data[4] = partials ? replaceHolders(data[3], PLACEHOLDER) : source[4];
          }
          value = source[5];
          if (value) {
            partials = data[5];
            data[5] = partials ? composeArgsRight(partials, value, source[6]) : value;
            data[6] = partials ? replaceHolders(data[5], PLACEHOLDER) : source[6];
          }
          value = source[7];
          if (value) {
            data[7] = value;
          }
          if (srcBitmask & WRAP_ARY_FLAG) {
            data[8] = data[8] == null ? source[8] : nativeMin(data[8], source[8]);
          }
          if (data[9] == null) {
            data[9] = source[9];
          }
          data[0] = source[0];
          data[1] = newBitmask;
          return data;
        }
        function nativeKeysIn(object) {
          var result2 = [];
          if (object != null) {
            for (var key in Object2(object)) {
              result2.push(key);
            }
          }
          return result2;
        }
        function objectToString(value) {
          return nativeObjectToString.call(value);
        }
        function overRest(func, start, transform2) {
          start = nativeMax(start === undefined2 ? func.length - 1 : start, 0);
          return function() {
            var args = arguments, index2 = -1, length = nativeMax(args.length - start, 0), array = Array2(length);
            while (++index2 < length) {
              array[index2] = args[start + index2];
            }
            index2 = -1;
            var otherArgs = Array2(start + 1);
            while (++index2 < start) {
              otherArgs[index2] = args[index2];
            }
            otherArgs[start] = transform2(array);
            return apply(func, this, otherArgs);
          };
        }
        function parent(object, path) {
          return path.length < 2 ? object : baseGet(object, baseSlice(path, 0, -1));
        }
        function reorder(array, indexes) {
          var arrLength = array.length, length = nativeMin(indexes.length, arrLength), oldArray = copyArray(array);
          while (length--) {
            var index2 = indexes[length];
            array[length] = isIndex(index2, arrLength) ? oldArray[index2] : undefined2;
          }
          return array;
        }
        function safeGet(object, key) {
          if (key === "constructor" && typeof object[key] === "function") {
            return;
          }
          if (key == "__proto__") {
            return;
          }
          return object[key];
        }
        var setData = shortOut(baseSetData);
        var setTimeout2 = ctxSetTimeout || function(func, wait) {
          return root.setTimeout(func, wait);
        };
        var setToString = shortOut(baseSetToString);
        function setWrapToString(wrapper, reference, bitmask) {
          var source = reference + "";
          return setToString(wrapper, insertWrapDetails(source, updateWrapDetails(getWrapDetails(source), bitmask)));
        }
        function shortOut(func) {
          var count = 0, lastCalled = 0;
          return function() {
            var stamp = nativeNow(), remaining = HOT_SPAN - (stamp - lastCalled);
            lastCalled = stamp;
            if (remaining > 0) {
              if (++count >= HOT_COUNT) {
                return arguments[0];
              }
            } else {
              count = 0;
            }
            return func.apply(undefined2, arguments);
          };
        }
        function shuffleSelf(array, size2) {
          var index2 = -1, length = array.length, lastIndex = length - 1;
          size2 = size2 === undefined2 ? length : size2;
          while (++index2 < size2) {
            var rand = baseRandom(index2, lastIndex), value = array[rand];
            array[rand] = array[index2];
            array[index2] = value;
          }
          array.length = size2;
          return array;
        }
        var stringToPath = memoizeCapped(function(string) {
          var result2 = [];
          if (string.charCodeAt(0) === 46) {
            result2.push("");
          }
          string.replace(rePropName, function(match, number, quote, subString) {
            result2.push(quote ? subString.replace(reEscapeChar, "$1") : number || match);
          });
          return result2;
        });
        function toKey(value) {
          if (typeof value == "string" || isSymbol(value)) {
            return value;
          }
          var result2 = value + "";
          return result2 == "0" && 1 / value == -INFINITY ? "-0" : result2;
        }
        function toSource(func) {
          if (func != null) {
            try {
              return funcToString.call(func);
            } catch (e2) {
            }
            try {
              return func + "";
            } catch (e2) {
            }
          }
          return "";
        }
        function updateWrapDetails(details, bitmask) {
          arrayEach(wrapFlags, function(pair) {
            var value = "_." + pair[0];
            if (bitmask & pair[1] && !arrayIncludes(details, value)) {
              details.push(value);
            }
          });
          return details.sort();
        }
        function wrapperClone(wrapper) {
          if (wrapper instanceof LazyWrapper) {
            return wrapper.clone();
          }
          var result2 = new LodashWrapper(wrapper.__wrapped__, wrapper.__chain__);
          result2.__actions__ = copyArray(wrapper.__actions__);
          result2.__index__ = wrapper.__index__;
          result2.__values__ = wrapper.__values__;
          return result2;
        }
        function chunk(array, size2, guard) {
          if (guard ? isIterateeCall(array, size2, guard) : size2 === undefined2) {
            size2 = 1;
          } else {
            size2 = nativeMax(toInteger(size2), 0);
          }
          var length = array == null ? 0 : array.length;
          if (!length || size2 < 1) {
            return [];
          }
          var index2 = 0, resIndex = 0, result2 = Array2(nativeCeil(length / size2));
          while (index2 < length) {
            result2[resIndex++] = baseSlice(array, index2, index2 += size2);
          }
          return result2;
        }
        function compact(array) {
          var index2 = -1, length = array == null ? 0 : array.length, resIndex = 0, result2 = [];
          while (++index2 < length) {
            var value = array[index2];
            if (value) {
              result2[resIndex++] = value;
            }
          }
          return result2;
        }
        function concat() {
          var length = arguments.length;
          if (!length) {
            return [];
          }
          var args = Array2(length - 1), array = arguments[0], index2 = length;
          while (index2--) {
            args[index2 - 1] = arguments[index2];
          }
          return arrayPush(isArray(array) ? copyArray(array) : [array], baseFlatten(args, 1));
        }
        var difference = baseRest(function(array, values2) {
          return isArrayLikeObject(array) ? baseDifference(array, baseFlatten(values2, 1, isArrayLikeObject, true)) : [];
        });
        var differenceBy = baseRest(function(array, values2) {
          var iteratee2 = last(values2);
          if (isArrayLikeObject(iteratee2)) {
            iteratee2 = undefined2;
          }
          return isArrayLikeObject(array) ? baseDifference(array, baseFlatten(values2, 1, isArrayLikeObject, true), getIteratee(iteratee2, 2)) : [];
        });
        var differenceWith = baseRest(function(array, values2) {
          var comparator = last(values2);
          if (isArrayLikeObject(comparator)) {
            comparator = undefined2;
          }
          return isArrayLikeObject(array) ? baseDifference(array, baseFlatten(values2, 1, isArrayLikeObject, true), undefined2, comparator) : [];
        });
        function drop(array, n2, guard) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return [];
          }
          n2 = guard || n2 === undefined2 ? 1 : toInteger(n2);
          return baseSlice(array, n2 < 0 ? 0 : n2, length);
        }
        function dropRight(array, n2, guard) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return [];
          }
          n2 = guard || n2 === undefined2 ? 1 : toInteger(n2);
          n2 = length - n2;
          return baseSlice(array, 0, n2 < 0 ? 0 : n2);
        }
        function dropRightWhile(array, predicate) {
          return array && array.length ? baseWhile(array, getIteratee(predicate, 3), true, true) : [];
        }
        function dropWhile(array, predicate) {
          return array && array.length ? baseWhile(array, getIteratee(predicate, 3), true) : [];
        }
        function fill(array, value, start, end) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return [];
          }
          if (start && typeof start != "number" && isIterateeCall(array, value, start)) {
            start = 0;
            end = length;
          }
          return baseFill(array, value, start, end);
        }
        function findIndex(array, predicate, fromIndex) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return -1;
          }
          var index2 = fromIndex == null ? 0 : toInteger(fromIndex);
          if (index2 < 0) {
            index2 = nativeMax(length + index2, 0);
          }
          return baseFindIndex(array, getIteratee(predicate, 3), index2);
        }
        function findLastIndex(array, predicate, fromIndex) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return -1;
          }
          var index2 = length - 1;
          if (fromIndex !== undefined2) {
            index2 = toInteger(fromIndex);
            index2 = fromIndex < 0 ? nativeMax(length + index2, 0) : nativeMin(index2, length - 1);
          }
          return baseFindIndex(array, getIteratee(predicate, 3), index2, true);
        }
        function flatten(array) {
          var length = array == null ? 0 : array.length;
          return length ? baseFlatten(array, 1) : [];
        }
        function flattenDeep(array) {
          var length = array == null ? 0 : array.length;
          return length ? baseFlatten(array, INFINITY) : [];
        }
        function flattenDepth(array, depth) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return [];
          }
          depth = depth === undefined2 ? 1 : toInteger(depth);
          return baseFlatten(array, depth);
        }
        function fromPairs(pairs) {
          var index2 = -1, length = pairs == null ? 0 : pairs.length, result2 = {};
          while (++index2 < length) {
            var pair = pairs[index2];
            result2[pair[0]] = pair[1];
          }
          return result2;
        }
        function head(array) {
          return array && array.length ? array[0] : undefined2;
        }
        function indexOf(array, value, fromIndex) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return -1;
          }
          var index2 = fromIndex == null ? 0 : toInteger(fromIndex);
          if (index2 < 0) {
            index2 = nativeMax(length + index2, 0);
          }
          return baseIndexOf(array, value, index2);
        }
        function initial(array) {
          var length = array == null ? 0 : array.length;
          return length ? baseSlice(array, 0, -1) : [];
        }
        var intersection = baseRest(function(arrays) {
          var mapped = arrayMap(arrays, castArrayLikeObject);
          return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped) : [];
        });
        var intersectionBy = baseRest(function(arrays) {
          var iteratee2 = last(arrays), mapped = arrayMap(arrays, castArrayLikeObject);
          if (iteratee2 === last(mapped)) {
            iteratee2 = undefined2;
          } else {
            mapped.pop();
          }
          return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped, getIteratee(iteratee2, 2)) : [];
        });
        var intersectionWith = baseRest(function(arrays) {
          var comparator = last(arrays), mapped = arrayMap(arrays, castArrayLikeObject);
          comparator = typeof comparator == "function" ? comparator : undefined2;
          if (comparator) {
            mapped.pop();
          }
          return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped, undefined2, comparator) : [];
        });
        function join(array, separator) {
          return array == null ? "" : nativeJoin.call(array, separator);
        }
        function last(array) {
          var length = array == null ? 0 : array.length;
          return length ? array[length - 1] : undefined2;
        }
        function lastIndexOf(array, value, fromIndex) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return -1;
          }
          var index2 = length;
          if (fromIndex !== undefined2) {
            index2 = toInteger(fromIndex);
            index2 = index2 < 0 ? nativeMax(length + index2, 0) : nativeMin(index2, length - 1);
          }
          return value === value ? strictLastIndexOf(array, value, index2) : baseFindIndex(array, baseIsNaN, index2, true);
        }
        function nth(array, n2) {
          return array && array.length ? baseNth(array, toInteger(n2)) : undefined2;
        }
        var pull = baseRest(pullAll);
        function pullAll(array, values2) {
          return array && array.length && values2 && values2.length ? basePullAll(array, values2) : array;
        }
        function pullAllBy(array, values2, iteratee2) {
          return array && array.length && values2 && values2.length ? basePullAll(array, values2, getIteratee(iteratee2, 2)) : array;
        }
        function pullAllWith(array, values2, comparator) {
          return array && array.length && values2 && values2.length ? basePullAll(array, values2, undefined2, comparator) : array;
        }
        var pullAt = flatRest(function(array, indexes) {
          var length = array == null ? 0 : array.length, result2 = baseAt(array, indexes);
          basePullAt(array, arrayMap(indexes, function(index2) {
            return isIndex(index2, length) ? +index2 : index2;
          }).sort(compareAscending));
          return result2;
        });
        function remove(array, predicate) {
          var result2 = [];
          if (!(array && array.length)) {
            return result2;
          }
          var index2 = -1, indexes = [], length = array.length;
          predicate = getIteratee(predicate, 3);
          while (++index2 < length) {
            var value = array[index2];
            if (predicate(value, index2, array)) {
              result2.push(value);
              indexes.push(index2);
            }
          }
          basePullAt(array, indexes);
          return result2;
        }
        function reverse(array) {
          return array == null ? array : nativeReverse.call(array);
        }
        function slice(array, start, end) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return [];
          }
          if (end && typeof end != "number" && isIterateeCall(array, start, end)) {
            start = 0;
            end = length;
          } else {
            start = start == null ? 0 : toInteger(start);
            end = end === undefined2 ? length : toInteger(end);
          }
          return baseSlice(array, start, end);
        }
        function sortedIndex(array, value) {
          return baseSortedIndex(array, value);
        }
        function sortedIndexBy(array, value, iteratee2) {
          return baseSortedIndexBy(array, value, getIteratee(iteratee2, 2));
        }
        function sortedIndexOf(array, value) {
          var length = array == null ? 0 : array.length;
          if (length) {
            var index2 = baseSortedIndex(array, value);
            if (index2 < length && eq(array[index2], value)) {
              return index2;
            }
          }
          return -1;
        }
        function sortedLastIndex(array, value) {
          return baseSortedIndex(array, value, true);
        }
        function sortedLastIndexBy(array, value, iteratee2) {
          return baseSortedIndexBy(array, value, getIteratee(iteratee2, 2), true);
        }
        function sortedLastIndexOf(array, value) {
          var length = array == null ? 0 : array.length;
          if (length) {
            var index2 = baseSortedIndex(array, value, true) - 1;
            if (eq(array[index2], value)) {
              return index2;
            }
          }
          return -1;
        }
        function sortedUniq(array) {
          return array && array.length ? baseSortedUniq(array) : [];
        }
        function sortedUniqBy(array, iteratee2) {
          return array && array.length ? baseSortedUniq(array, getIteratee(iteratee2, 2)) : [];
        }
        function tail(array) {
          var length = array == null ? 0 : array.length;
          return length ? baseSlice(array, 1, length) : [];
        }
        function take(array, n2, guard) {
          if (!(array && array.length)) {
            return [];
          }
          n2 = guard || n2 === undefined2 ? 1 : toInteger(n2);
          return baseSlice(array, 0, n2 < 0 ? 0 : n2);
        }
        function takeRight(array, n2, guard) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return [];
          }
          n2 = guard || n2 === undefined2 ? 1 : toInteger(n2);
          n2 = length - n2;
          return baseSlice(array, n2 < 0 ? 0 : n2, length);
        }
        function takeRightWhile(array, predicate) {
          return array && array.length ? baseWhile(array, getIteratee(predicate, 3), false, true) : [];
        }
        function takeWhile(array, predicate) {
          return array && array.length ? baseWhile(array, getIteratee(predicate, 3)) : [];
        }
        var union = baseRest(function(arrays) {
          return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true));
        });
        var unionBy = baseRest(function(arrays) {
          var iteratee2 = last(arrays);
          if (isArrayLikeObject(iteratee2)) {
            iteratee2 = undefined2;
          }
          return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true), getIteratee(iteratee2, 2));
        });
        var unionWith = baseRest(function(arrays) {
          var comparator = last(arrays);
          comparator = typeof comparator == "function" ? comparator : undefined2;
          return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true), undefined2, comparator);
        });
        function uniq(array) {
          return array && array.length ? baseUniq(array) : [];
        }
        function uniqBy(array, iteratee2) {
          return array && array.length ? baseUniq(array, getIteratee(iteratee2, 2)) : [];
        }
        function uniqWith(array, comparator) {
          comparator = typeof comparator == "function" ? comparator : undefined2;
          return array && array.length ? baseUniq(array, undefined2, comparator) : [];
        }
        function unzip(array) {
          if (!(array && array.length)) {
            return [];
          }
          var length = 0;
          array = arrayFilter(array, function(group) {
            if (isArrayLikeObject(group)) {
              length = nativeMax(group.length, length);
              return true;
            }
          });
          return baseTimes(length, function(index2) {
            return arrayMap(array, baseProperty(index2));
          });
        }
        function unzipWith(array, iteratee2) {
          if (!(array && array.length)) {
            return [];
          }
          var result2 = unzip(array);
          if (iteratee2 == null) {
            return result2;
          }
          return arrayMap(result2, function(group) {
            return apply(iteratee2, undefined2, group);
          });
        }
        var without = baseRest(function(array, values2) {
          return isArrayLikeObject(array) ? baseDifference(array, values2) : [];
        });
        var xor = baseRest(function(arrays) {
          return baseXor(arrayFilter(arrays, isArrayLikeObject));
        });
        var xorBy = baseRest(function(arrays) {
          var iteratee2 = last(arrays);
          if (isArrayLikeObject(iteratee2)) {
            iteratee2 = undefined2;
          }
          return baseXor(arrayFilter(arrays, isArrayLikeObject), getIteratee(iteratee2, 2));
        });
        var xorWith = baseRest(function(arrays) {
          var comparator = last(arrays);
          comparator = typeof comparator == "function" ? comparator : undefined2;
          return baseXor(arrayFilter(arrays, isArrayLikeObject), undefined2, comparator);
        });
        var zip = baseRest(unzip);
        function zipObject(props, values2) {
          return baseZipObject(props || [], values2 || [], assignValue);
        }
        function zipObjectDeep(props, values2) {
          return baseZipObject(props || [], values2 || [], baseSet);
        }
        var zipWith = baseRest(function(arrays) {
          var length = arrays.length, iteratee2 = length > 1 ? arrays[length - 1] : undefined2;
          iteratee2 = typeof iteratee2 == "function" ? (arrays.pop(), iteratee2) : undefined2;
          return unzipWith(arrays, iteratee2);
        });
        function chain(value) {
          var result2 = lodash(value);
          result2.__chain__ = true;
          return result2;
        }
        function tap(value, interceptor) {
          interceptor(value);
          return value;
        }
        function thru(value, interceptor) {
          return interceptor(value);
        }
        var wrapperAt = flatRest(function(paths) {
          var length = paths.length, start = length ? paths[0] : 0, value = this.__wrapped__, interceptor = function(object) {
            return baseAt(object, paths);
          };
          if (length > 1 || this.__actions__.length || !(value instanceof LazyWrapper) || !isIndex(start)) {
            return this.thru(interceptor);
          }
          value = value.slice(start, +start + (length ? 1 : 0));
          value.__actions__.push({
            "func": thru,
            "args": [interceptor],
            "thisArg": undefined2
          });
          return new LodashWrapper(value, this.__chain__).thru(function(array) {
            if (length && !array.length) {
              array.push(undefined2);
            }
            return array;
          });
        });
        function wrapperChain() {
          return chain(this);
        }
        function wrapperCommit() {
          return new LodashWrapper(this.value(), this.__chain__);
        }
        function wrapperNext() {
          if (this.__values__ === undefined2) {
            this.__values__ = toArray(this.value());
          }
          var done = this.__index__ >= this.__values__.length, value = done ? undefined2 : this.__values__[this.__index__++];
          return { "done": done, "value": value };
        }
        function wrapperToIterator() {
          return this;
        }
        function wrapperPlant(value) {
          var result2, parent2 = this;
          while (parent2 instanceof baseLodash) {
            var clone2 = wrapperClone(parent2);
            clone2.__index__ = 0;
            clone2.__values__ = undefined2;
            if (result2) {
              previous.__wrapped__ = clone2;
            } else {
              result2 = clone2;
            }
            var previous = clone2;
            parent2 = parent2.__wrapped__;
          }
          previous.__wrapped__ = value;
          return result2;
        }
        function wrapperReverse() {
          var value = this.__wrapped__;
          if (value instanceof LazyWrapper) {
            var wrapped = value;
            if (this.__actions__.length) {
              wrapped = new LazyWrapper(this);
            }
            wrapped = wrapped.reverse();
            wrapped.__actions__.push({
              "func": thru,
              "args": [reverse],
              "thisArg": undefined2
            });
            return new LodashWrapper(wrapped, this.__chain__);
          }
          return this.thru(reverse);
        }
        function wrapperValue() {
          return baseWrapperValue(this.__wrapped__, this.__actions__);
        }
        var countBy = createAggregator(function(result2, value, key) {
          if (hasOwnProperty2.call(result2, key)) {
            ++result2[key];
          } else {
            baseAssignValue(result2, key, 1);
          }
        });
        function every(collection, predicate, guard) {
          var func = isArray(collection) ? arrayEvery : baseEvery;
          if (guard && isIterateeCall(collection, predicate, guard)) {
            predicate = undefined2;
          }
          return func(collection, getIteratee(predicate, 3));
        }
        function filter(collection, predicate) {
          var func = isArray(collection) ? arrayFilter : baseFilter;
          return func(collection, getIteratee(predicate, 3));
        }
        var find = createFind(findIndex);
        var findLast = createFind(findLastIndex);
        function flatMap(collection, iteratee2) {
          return baseFlatten(map(collection, iteratee2), 1);
        }
        function flatMapDeep(collection, iteratee2) {
          return baseFlatten(map(collection, iteratee2), INFINITY);
        }
        function flatMapDepth(collection, iteratee2, depth) {
          depth = depth === undefined2 ? 1 : toInteger(depth);
          return baseFlatten(map(collection, iteratee2), depth);
        }
        function forEach(collection, iteratee2) {
          var func = isArray(collection) ? arrayEach : baseEach;
          return func(collection, getIteratee(iteratee2, 3));
        }
        function forEachRight(collection, iteratee2) {
          var func = isArray(collection) ? arrayEachRight : baseEachRight;
          return func(collection, getIteratee(iteratee2, 3));
        }
        var groupBy = createAggregator(function(result2, value, key) {
          if (hasOwnProperty2.call(result2, key)) {
            result2[key].push(value);
          } else {
            baseAssignValue(result2, key, [value]);
          }
        });
        function includes(collection, value, fromIndex, guard) {
          collection = isArrayLike(collection) ? collection : values(collection);
          fromIndex = fromIndex && !guard ? toInteger(fromIndex) : 0;
          var length = collection.length;
          if (fromIndex < 0) {
            fromIndex = nativeMax(length + fromIndex, 0);
          }
          return isString(collection) ? fromIndex <= length && collection.indexOf(value, fromIndex) > -1 : !!length && baseIndexOf(collection, value, fromIndex) > -1;
        }
        var invokeMap = baseRest(function(collection, path, args) {
          var index2 = -1, isFunc = typeof path == "function", result2 = isArrayLike(collection) ? Array2(collection.length) : [];
          baseEach(collection, function(value) {
            result2[++index2] = isFunc ? apply(path, value, args) : baseInvoke(value, path, args);
          });
          return result2;
        });
        var keyBy = createAggregator(function(result2, value, key) {
          baseAssignValue(result2, key, value);
        });
        function map(collection, iteratee2) {
          var func = isArray(collection) ? arrayMap : baseMap;
          return func(collection, getIteratee(iteratee2, 3));
        }
        function orderBy(collection, iteratees, orders, guard) {
          if (collection == null) {
            return [];
          }
          if (!isArray(iteratees)) {
            iteratees = iteratees == null ? [] : [iteratees];
          }
          orders = guard ? undefined2 : orders;
          if (!isArray(orders)) {
            orders = orders == null ? [] : [orders];
          }
          return baseOrderBy(collection, iteratees, orders);
        }
        var partition = createAggregator(function(result2, value, key) {
          result2[key ? 0 : 1].push(value);
        }, function() {
          return [[], []];
        });
        function reduce(collection, iteratee2, accumulator) {
          var func = isArray(collection) ? arrayReduce : baseReduce, initAccum = arguments.length < 3;
          return func(collection, getIteratee(iteratee2, 4), accumulator, initAccum, baseEach);
        }
        function reduceRight(collection, iteratee2, accumulator) {
          var func = isArray(collection) ? arrayReduceRight : baseReduce, initAccum = arguments.length < 3;
          return func(collection, getIteratee(iteratee2, 4), accumulator, initAccum, baseEachRight);
        }
        function reject(collection, predicate) {
          var func = isArray(collection) ? arrayFilter : baseFilter;
          return func(collection, negate(getIteratee(predicate, 3)));
        }
        function sample(collection) {
          var func = isArray(collection) ? arraySample : baseSample;
          return func(collection);
        }
        function sampleSize(collection, n2, guard) {
          if (guard ? isIterateeCall(collection, n2, guard) : n2 === undefined2) {
            n2 = 1;
          } else {
            n2 = toInteger(n2);
          }
          var func = isArray(collection) ? arraySampleSize : baseSampleSize;
          return func(collection, n2);
        }
        function shuffle(collection) {
          var func = isArray(collection) ? arrayShuffle : baseShuffle;
          return func(collection);
        }
        function size(collection) {
          if (collection == null) {
            return 0;
          }
          if (isArrayLike(collection)) {
            return isString(collection) ? stringSize(collection) : collection.length;
          }
          var tag = getTag(collection);
          if (tag == mapTag || tag == setTag) {
            return collection.size;
          }
          return baseKeys(collection).length;
        }
        function some(collection, predicate, guard) {
          var func = isArray(collection) ? arraySome : baseSome;
          if (guard && isIterateeCall(collection, predicate, guard)) {
            predicate = undefined2;
          }
          return func(collection, getIteratee(predicate, 3));
        }
        var sortBy = baseRest(function(collection, iteratees) {
          if (collection == null) {
            return [];
          }
          var length = iteratees.length;
          if (length > 1 && isIterateeCall(collection, iteratees[0], iteratees[1])) {
            iteratees = [];
          } else if (length > 2 && isIterateeCall(iteratees[0], iteratees[1], iteratees[2])) {
            iteratees = [iteratees[0]];
          }
          return baseOrderBy(collection, baseFlatten(iteratees, 1), []);
        });
        var now = ctxNow || function() {
          return root.Date.now();
        };
        function after(n2, func) {
          if (typeof func != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          n2 = toInteger(n2);
          return function() {
            if (--n2 < 1) {
              return func.apply(this, arguments);
            }
          };
        }
        function ary(func, n2, guard) {
          n2 = guard ? undefined2 : n2;
          n2 = func && n2 == null ? func.length : n2;
          return createWrap(func, WRAP_ARY_FLAG, undefined2, undefined2, undefined2, undefined2, n2);
        }
        function before(n2, func) {
          var result2;
          if (typeof func != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          n2 = toInteger(n2);
          return function() {
            if (--n2 > 0) {
              result2 = func.apply(this, arguments);
            }
            if (n2 <= 1) {
              func = undefined2;
            }
            return result2;
          };
        }
        var bind = baseRest(function(func, thisArg, partials) {
          var bitmask = WRAP_BIND_FLAG;
          if (partials.length) {
            var holders = replaceHolders(partials, getHolder(bind));
            bitmask |= WRAP_PARTIAL_FLAG;
          }
          return createWrap(func, bitmask, thisArg, partials, holders);
        });
        var bindKey = baseRest(function(object, key, partials) {
          var bitmask = WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG;
          if (partials.length) {
            var holders = replaceHolders(partials, getHolder(bindKey));
            bitmask |= WRAP_PARTIAL_FLAG;
          }
          return createWrap(key, bitmask, object, partials, holders);
        });
        function curry(func, arity, guard) {
          arity = guard ? undefined2 : arity;
          var result2 = createWrap(func, WRAP_CURRY_FLAG, undefined2, undefined2, undefined2, undefined2, undefined2, arity);
          result2.placeholder = curry.placeholder;
          return result2;
        }
        function curryRight(func, arity, guard) {
          arity = guard ? undefined2 : arity;
          var result2 = createWrap(func, WRAP_CURRY_RIGHT_FLAG, undefined2, undefined2, undefined2, undefined2, undefined2, arity);
          result2.placeholder = curryRight.placeholder;
          return result2;
        }
        function debounce(func, wait, options) {
          var lastArgs, lastThis, maxWait, result2, timerId, lastCallTime, lastInvokeTime = 0, leading = false, maxing = false, trailing = true;
          if (typeof func != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          wait = toNumber(wait) || 0;
          if (isObject(options)) {
            leading = !!options.leading;
            maxing = "maxWait" in options;
            maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;
            trailing = "trailing" in options ? !!options.trailing : trailing;
          }
          function invokeFunc(time) {
            var args = lastArgs, thisArg = lastThis;
            lastArgs = lastThis = undefined2;
            lastInvokeTime = time;
            result2 = func.apply(thisArg, args);
            return result2;
          }
          function leadingEdge(time) {
            lastInvokeTime = time;
            timerId = setTimeout2(timerExpired, wait);
            return leading ? invokeFunc(time) : result2;
          }
          function remainingWait(time) {
            var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime, timeWaiting = wait - timeSinceLastCall;
            return maxing ? nativeMin(timeWaiting, maxWait - timeSinceLastInvoke) : timeWaiting;
          }
          function shouldInvoke(time) {
            var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime;
            return lastCallTime === undefined2 || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxing && timeSinceLastInvoke >= maxWait;
          }
          function timerExpired() {
            var time = now();
            if (shouldInvoke(time)) {
              return trailingEdge(time);
            }
            timerId = setTimeout2(timerExpired, remainingWait(time));
          }
          function trailingEdge(time) {
            timerId = undefined2;
            if (trailing && lastArgs) {
              return invokeFunc(time);
            }
            lastArgs = lastThis = undefined2;
            return result2;
          }
          function cancel() {
            if (timerId !== undefined2) {
              clearTimeout2(timerId);
            }
            lastInvokeTime = 0;
            lastArgs = lastCallTime = lastThis = timerId = undefined2;
          }
          function flush() {
            return timerId === undefined2 ? result2 : trailingEdge(now());
          }
          function debounced() {
            var time = now(), isInvoking = shouldInvoke(time);
            lastArgs = arguments;
            lastThis = this;
            lastCallTime = time;
            if (isInvoking) {
              if (timerId === undefined2) {
                return leadingEdge(lastCallTime);
              }
              if (maxing) {
                clearTimeout2(timerId);
                timerId = setTimeout2(timerExpired, wait);
                return invokeFunc(lastCallTime);
              }
            }
            if (timerId === undefined2) {
              timerId = setTimeout2(timerExpired, wait);
            }
            return result2;
          }
          debounced.cancel = cancel;
          debounced.flush = flush;
          return debounced;
        }
        var defer = baseRest(function(func, args) {
          return baseDelay(func, 1, args);
        });
        var delay = baseRest(function(func, wait, args) {
          return baseDelay(func, toNumber(wait) || 0, args);
        });
        function flip(func) {
          return createWrap(func, WRAP_FLIP_FLAG);
        }
        function memoize(func, resolver) {
          if (typeof func != "function" || resolver != null && typeof resolver != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          var memoized = function() {
            var args = arguments, key = resolver ? resolver.apply(this, args) : args[0], cache = memoized.cache;
            if (cache.has(key)) {
              return cache.get(key);
            }
            var result2 = func.apply(this, args);
            memoized.cache = cache.set(key, result2) || cache;
            return result2;
          };
          memoized.cache = new (memoize.Cache || MapCache)();
          return memoized;
        }
        memoize.Cache = MapCache;
        function negate(predicate) {
          if (typeof predicate != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          return function() {
            var args = arguments;
            switch (args.length) {
              case 0:
                return !predicate.call(this);
              case 1:
                return !predicate.call(this, args[0]);
              case 2:
                return !predicate.call(this, args[0], args[1]);
              case 3:
                return !predicate.call(this, args[0], args[1], args[2]);
            }
            return !predicate.apply(this, args);
          };
        }
        function once(func) {
          return before(2, func);
        }
        var overArgs = castRest(function(func, transforms) {
          transforms = transforms.length == 1 && isArray(transforms[0]) ? arrayMap(transforms[0], baseUnary(getIteratee())) : arrayMap(baseFlatten(transforms, 1), baseUnary(getIteratee()));
          var funcsLength = transforms.length;
          return baseRest(function(args) {
            var index2 = -1, length = nativeMin(args.length, funcsLength);
            while (++index2 < length) {
              args[index2] = transforms[index2].call(this, args[index2]);
            }
            return apply(func, this, args);
          });
        });
        var partial = baseRest(function(func, partials) {
          var holders = replaceHolders(partials, getHolder(partial));
          return createWrap(func, WRAP_PARTIAL_FLAG, undefined2, partials, holders);
        });
        var partialRight = baseRest(function(func, partials) {
          var holders = replaceHolders(partials, getHolder(partialRight));
          return createWrap(func, WRAP_PARTIAL_RIGHT_FLAG, undefined2, partials, holders);
        });
        var rearg = flatRest(function(func, indexes) {
          return createWrap(func, WRAP_REARG_FLAG, undefined2, undefined2, undefined2, indexes);
        });
        function rest(func, start) {
          if (typeof func != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          start = start === undefined2 ? start : toInteger(start);
          return baseRest(func, start);
        }
        function spread(func, start) {
          if (typeof func != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          start = start == null ? 0 : nativeMax(toInteger(start), 0);
          return baseRest(function(args) {
            var array = args[start], otherArgs = castSlice(args, 0, start);
            if (array) {
              arrayPush(otherArgs, array);
            }
            return apply(func, this, otherArgs);
          });
        }
        function throttle(func, wait, options) {
          var leading = true, trailing = true;
          if (typeof func != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          if (isObject(options)) {
            leading = "leading" in options ? !!options.leading : leading;
            trailing = "trailing" in options ? !!options.trailing : trailing;
          }
          return debounce(func, wait, {
            "leading": leading,
            "maxWait": wait,
            "trailing": trailing
          });
        }
        function unary(func) {
          return ary(func, 1);
        }
        function wrap(value, wrapper) {
          return partial(castFunction(wrapper), value);
        }
        function castArray() {
          if (!arguments.length) {
            return [];
          }
          var value = arguments[0];
          return isArray(value) ? value : [value];
        }
        function clone(value) {
          return baseClone(value, CLONE_SYMBOLS_FLAG);
        }
        function cloneWith(value, customizer) {
          customizer = typeof customizer == "function" ? customizer : undefined2;
          return baseClone(value, CLONE_SYMBOLS_FLAG, customizer);
        }
        function cloneDeep(value) {
          return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG);
        }
        function cloneDeepWith(value, customizer) {
          customizer = typeof customizer == "function" ? customizer : undefined2;
          return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG, customizer);
        }
        function conformsTo(object, source) {
          return source == null || baseConformsTo(object, source, keys(source));
        }
        function eq(value, other) {
          return value === other || value !== value && other !== other;
        }
        var gt = createRelationalOperation(baseGt);
        var gte = createRelationalOperation(function(value, other) {
          return value >= other;
        });
        var isArguments = baseIsArguments(function() {
          return arguments;
        }()) ? baseIsArguments : function(value) {
          return isObjectLike(value) && hasOwnProperty2.call(value, "callee") && !propertyIsEnumerable.call(value, "callee");
        };
        var isArray = Array2.isArray;
        var isArrayBuffer = nodeIsArrayBuffer ? baseUnary(nodeIsArrayBuffer) : baseIsArrayBuffer;
        function isArrayLike(value) {
          return value != null && isLength2(value.length) && !isFunction(value);
        }
        function isArrayLikeObject(value) {
          return isObjectLike(value) && isArrayLike(value);
        }
        function isBoolean(value) {
          return value === true || value === false || isObjectLike(value) && baseGetTag(value) == boolTag;
        }
        var isBuffer = nativeIsBuffer || stubFalse;
        var isDate = nodeIsDate ? baseUnary(nodeIsDate) : baseIsDate;
        function isElement(value) {
          return isObjectLike(value) && value.nodeType === 1 && !isPlainObject(value);
        }
        function isEmpty(value) {
          if (value == null) {
            return true;
          }
          if (isArrayLike(value) && (isArray(value) || typeof value == "string" || typeof value.splice == "function" || isBuffer(value) || isTypedArray(value) || isArguments(value))) {
            return !value.length;
          }
          var tag = getTag(value);
          if (tag == mapTag || tag == setTag) {
            return !value.size;
          }
          if (isPrototype(value)) {
            return !baseKeys(value).length;
          }
          for (var key in value) {
            if (hasOwnProperty2.call(value, key)) {
              return false;
            }
          }
          return true;
        }
        function isEqual3(value, other) {
          return baseIsEqual(value, other);
        }
        function isEqualWith(value, other, customizer) {
          customizer = typeof customizer == "function" ? customizer : undefined2;
          var result2 = customizer ? customizer(value, other) : undefined2;
          return result2 === undefined2 ? baseIsEqual(value, other, undefined2, customizer) : !!result2;
        }
        function isError(value) {
          if (!isObjectLike(value)) {
            return false;
          }
          var tag = baseGetTag(value);
          return tag == errorTag || tag == domExcTag || typeof value.message == "string" && typeof value.name == "string" && !isPlainObject(value);
        }
        function isFinite2(value) {
          return typeof value == "number" && nativeIsFinite(value);
        }
        function isFunction(value) {
          if (!isObject(value)) {
            return false;
          }
          var tag = baseGetTag(value);
          return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
        }
        function isInteger2(value) {
          return typeof value == "number" && value == toInteger(value);
        }
        function isLength2(value) {
          return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
        }
        function isObject(value) {
          var type = typeof value;
          return value != null && (type == "object" || type == "function");
        }
        function isObjectLike(value) {
          return value != null && typeof value == "object";
        }
        var isMap = nodeIsMap ? baseUnary(nodeIsMap) : baseIsMap;
        function isMatch(object, source) {
          return object === source || baseIsMatch(object, source, getMatchData(source));
        }
        function isMatchWith(object, source, customizer) {
          customizer = typeof customizer == "function" ? customizer : undefined2;
          return baseIsMatch(object, source, getMatchData(source), customizer);
        }
        function isNaN2(value) {
          return isNumber2(value) && value != +value;
        }
        function isNative(value) {
          if (isMaskable(value)) {
            throw new Error2(CORE_ERROR_TEXT);
          }
          return baseIsNative(value);
        }
        function isNull(value) {
          return value === null;
        }
        function isNil(value) {
          return value == null;
        }
        function isNumber2(value) {
          return typeof value == "number" || isObjectLike(value) && baseGetTag(value) == numberTag;
        }
        function isPlainObject(value) {
          if (!isObjectLike(value) || baseGetTag(value) != objectTag) {
            return false;
          }
          var proto = getPrototype(value);
          if (proto === null) {
            return true;
          }
          var Ctor = hasOwnProperty2.call(proto, "constructor") && proto.constructor;
          return typeof Ctor == "function" && Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString;
        }
        var isRegExp = nodeIsRegExp ? baseUnary(nodeIsRegExp) : baseIsRegExp;
        function isSafeInteger(value) {
          return isInteger2(value) && value >= -MAX_SAFE_INTEGER && value <= MAX_SAFE_INTEGER;
        }
        var isSet = nodeIsSet ? baseUnary(nodeIsSet) : baseIsSet;
        function isString(value) {
          return typeof value == "string" || !isArray(value) && isObjectLike(value) && baseGetTag(value) == stringTag;
        }
        function isSymbol(value) {
          return typeof value == "symbol" || isObjectLike(value) && baseGetTag(value) == symbolTag;
        }
        var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
        function isUndefined(value) {
          return value === undefined2;
        }
        function isWeakMap(value) {
          return isObjectLike(value) && getTag(value) == weakMapTag;
        }
        function isWeakSet(value) {
          return isObjectLike(value) && baseGetTag(value) == weakSetTag;
        }
        var lt = createRelationalOperation(baseLt);
        var lte = createRelationalOperation(function(value, other) {
          return value <= other;
        });
        function toArray(value) {
          if (!value) {
            return [];
          }
          if (isArrayLike(value)) {
            return isString(value) ? stringToArray(value) : copyArray(value);
          }
          if (symIterator && value[symIterator]) {
            return iteratorToArray(value[symIterator]());
          }
          var tag = getTag(value), func = tag == mapTag ? mapToArray : tag == setTag ? setToArray : values;
          return func(value);
        }
        function toFinite(value) {
          if (!value) {
            return value === 0 ? value : 0;
          }
          value = toNumber(value);
          if (value === INFINITY || value === -INFINITY) {
            var sign = value < 0 ? -1 : 1;
            return sign * MAX_INTEGER;
          }
          return value === value ? value : 0;
        }
        function toInteger(value) {
          var result2 = toFinite(value), remainder = result2 % 1;
          return result2 === result2 ? remainder ? result2 - remainder : result2 : 0;
        }
        function toLength(value) {
          return value ? baseClamp(toInteger(value), 0, MAX_ARRAY_LENGTH) : 0;
        }
        function toNumber(value) {
          if (typeof value == "number") {
            return value;
          }
          if (isSymbol(value)) {
            return NAN;
          }
          if (isObject(value)) {
            var other = typeof value.valueOf == "function" ? value.valueOf() : value;
            value = isObject(other) ? other + "" : other;
          }
          if (typeof value != "string") {
            return value === 0 ? value : +value;
          }
          value = baseTrim(value);
          var isBinary = reIsBinary.test(value);
          return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
        }
        function toPlainObject(value) {
          return copyObject(value, keysIn(value));
        }
        function toSafeInteger(value) {
          return value ? baseClamp(toInteger(value), -MAX_SAFE_INTEGER, MAX_SAFE_INTEGER) : value === 0 ? value : 0;
        }
        function toString(value) {
          return value == null ? "" : baseToString(value);
        }
        var assign = createAssigner(function(object, source) {
          if (isPrototype(source) || isArrayLike(source)) {
            copyObject(source, keys(source), object);
            return;
          }
          for (var key in source) {
            if (hasOwnProperty2.call(source, key)) {
              assignValue(object, key, source[key]);
            }
          }
        });
        var assignIn = createAssigner(function(object, source) {
          copyObject(source, keysIn(source), object);
        });
        var assignInWith = createAssigner(function(object, source, srcIndex, customizer) {
          copyObject(source, keysIn(source), object, customizer);
        });
        var assignWith = createAssigner(function(object, source, srcIndex, customizer) {
          copyObject(source, keys(source), object, customizer);
        });
        var at = flatRest(baseAt);
        function create(prototype, properties) {
          var result2 = baseCreate(prototype);
          return properties == null ? result2 : baseAssign(result2, properties);
        }
        var defaults = baseRest(function(object, sources) {
          object = Object2(object);
          var index2 = -1;
          var length = sources.length;
          var guard = length > 2 ? sources[2] : undefined2;
          if (guard && isIterateeCall(sources[0], sources[1], guard)) {
            length = 1;
          }
          while (++index2 < length) {
            var source = sources[index2];
            var props = keysIn(source);
            var propsIndex = -1;
            var propsLength = props.length;
            while (++propsIndex < propsLength) {
              var key = props[propsIndex];
              var value = object[key];
              if (value === undefined2 || eq(value, objectProto[key]) && !hasOwnProperty2.call(object, key)) {
                object[key] = source[key];
              }
            }
          }
          return object;
        });
        var defaultsDeep = baseRest(function(args) {
          args.push(undefined2, customDefaultsMerge);
          return apply(mergeWith, undefined2, args);
        });
        function findKey(object, predicate) {
          return baseFindKey(object, getIteratee(predicate, 3), baseForOwn);
        }
        function findLastKey(object, predicate) {
          return baseFindKey(object, getIteratee(predicate, 3), baseForOwnRight);
        }
        function forIn(object, iteratee2) {
          return object == null ? object : baseFor(object, getIteratee(iteratee2, 3), keysIn);
        }
        function forInRight(object, iteratee2) {
          return object == null ? object : baseForRight(object, getIteratee(iteratee2, 3), keysIn);
        }
        function forOwn(object, iteratee2) {
          return object && baseForOwn(object, getIteratee(iteratee2, 3));
        }
        function forOwnRight(object, iteratee2) {
          return object && baseForOwnRight(object, getIteratee(iteratee2, 3));
        }
        function functions(object) {
          return object == null ? [] : baseFunctions(object, keys(object));
        }
        function functionsIn(object) {
          return object == null ? [] : baseFunctions(object, keysIn(object));
        }
        function get(object, path, defaultValue) {
          var result2 = object == null ? undefined2 : baseGet(object, path);
          return result2 === undefined2 ? defaultValue : result2;
        }
        function has(object, path) {
          return object != null && hasPath(object, path, baseHas);
        }
        function hasIn(object, path) {
          return object != null && hasPath(object, path, baseHasIn);
        }
        var invert = createInverter(function(result2, value, key) {
          if (value != null && typeof value.toString != "function") {
            value = nativeObjectToString.call(value);
          }
          result2[value] = key;
        }, constant(identity));
        var invertBy = createInverter(function(result2, value, key) {
          if (value != null && typeof value.toString != "function") {
            value = nativeObjectToString.call(value);
          }
          if (hasOwnProperty2.call(result2, value)) {
            result2[value].push(key);
          } else {
            result2[value] = [key];
          }
        }, getIteratee);
        var invoke = baseRest(baseInvoke);
        function keys(object) {
          return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
        }
        function keysIn(object) {
          return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
        }
        function mapKeys(object, iteratee2) {
          var result2 = {};
          iteratee2 = getIteratee(iteratee2, 3);
          baseForOwn(object, function(value, key, object2) {
            baseAssignValue(result2, iteratee2(value, key, object2), value);
          });
          return result2;
        }
        function mapValues(object, iteratee2) {
          var result2 = {};
          iteratee2 = getIteratee(iteratee2, 3);
          baseForOwn(object, function(value, key, object2) {
            baseAssignValue(result2, key, iteratee2(value, key, object2));
          });
          return result2;
        }
        var merge = createAssigner(function(object, source, srcIndex) {
          baseMerge(object, source, srcIndex);
        });
        var mergeWith = createAssigner(function(object, source, srcIndex, customizer) {
          baseMerge(object, source, srcIndex, customizer);
        });
        var omit = flatRest(function(object, paths) {
          var result2 = {};
          if (object == null) {
            return result2;
          }
          var isDeep = false;
          paths = arrayMap(paths, function(path) {
            path = castPath(path, object);
            isDeep || (isDeep = path.length > 1);
            return path;
          });
          copyObject(object, getAllKeysIn(object), result2);
          if (isDeep) {
            result2 = baseClone(result2, CLONE_DEEP_FLAG | CLONE_FLAT_FLAG | CLONE_SYMBOLS_FLAG, customOmitClone);
          }
          var length = paths.length;
          while (length--) {
            baseUnset(result2, paths[length]);
          }
          return result2;
        });
        function omitBy(object, predicate) {
          return pickBy(object, negate(getIteratee(predicate)));
        }
        var pick = flatRest(function(object, paths) {
          return object == null ? {} : basePick(object, paths);
        });
        function pickBy(object, predicate) {
          if (object == null) {
            return {};
          }
          var props = arrayMap(getAllKeysIn(object), function(prop) {
            return [prop];
          });
          predicate = getIteratee(predicate);
          return basePickBy(object, props, function(value, path) {
            return predicate(value, path[0]);
          });
        }
        function result(object, path, defaultValue) {
          path = castPath(path, object);
          var index2 = -1, length = path.length;
          if (!length) {
            length = 1;
            object = undefined2;
          }
          while (++index2 < length) {
            var value = object == null ? undefined2 : object[toKey(path[index2])];
            if (value === undefined2) {
              index2 = length;
              value = defaultValue;
            }
            object = isFunction(value) ? value.call(object) : value;
          }
          return object;
        }
        function set(object, path, value) {
          return object == null ? object : baseSet(object, path, value);
        }
        function setWith(object, path, value, customizer) {
          customizer = typeof customizer == "function" ? customizer : undefined2;
          return object == null ? object : baseSet(object, path, value, customizer);
        }
        var toPairs = createToPairs(keys);
        var toPairsIn = createToPairs(keysIn);
        function transform(object, iteratee2, accumulator) {
          var isArr = isArray(object), isArrLike = isArr || isBuffer(object) || isTypedArray(object);
          iteratee2 = getIteratee(iteratee2, 4);
          if (accumulator == null) {
            var Ctor = object && object.constructor;
            if (isArrLike) {
              accumulator = isArr ? new Ctor() : [];
            } else if (isObject(object)) {
              accumulator = isFunction(Ctor) ? baseCreate(getPrototype(object)) : {};
            } else {
              accumulator = {};
            }
          }
          (isArrLike ? arrayEach : baseForOwn)(object, function(value, index2, object2) {
            return iteratee2(accumulator, value, index2, object2);
          });
          return accumulator;
        }
        function unset(object, path) {
          return object == null ? true : baseUnset(object, path);
        }
        function update(object, path, updater) {
          return object == null ? object : baseUpdate(object, path, castFunction(updater));
        }
        function updateWith(object, path, updater, customizer) {
          customizer = typeof customizer == "function" ? customizer : undefined2;
          return object == null ? object : baseUpdate(object, path, castFunction(updater), customizer);
        }
        function values(object) {
          return object == null ? [] : baseValues(object, keys(object));
        }
        function valuesIn(object) {
          return object == null ? [] : baseValues(object, keysIn(object));
        }
        function clamp(number, lower, upper) {
          if (upper === undefined2) {
            upper = lower;
            lower = undefined2;
          }
          if (upper !== undefined2) {
            upper = toNumber(upper);
            upper = upper === upper ? upper : 0;
          }
          if (lower !== undefined2) {
            lower = toNumber(lower);
            lower = lower === lower ? lower : 0;
          }
          return baseClamp(toNumber(number), lower, upper);
        }
        function inRange(number, start, end) {
          start = toFinite(start);
          if (end === undefined2) {
            end = start;
            start = 0;
          } else {
            end = toFinite(end);
          }
          number = toNumber(number);
          return baseInRange(number, start, end);
        }
        function random(lower, upper, floating) {
          if (floating && typeof floating != "boolean" && isIterateeCall(lower, upper, floating)) {
            upper = floating = undefined2;
          }
          if (floating === undefined2) {
            if (typeof upper == "boolean") {
              floating = upper;
              upper = undefined2;
            } else if (typeof lower == "boolean") {
              floating = lower;
              lower = undefined2;
            }
          }
          if (lower === undefined2 && upper === undefined2) {
            lower = 0;
            upper = 1;
          } else {
            lower = toFinite(lower);
            if (upper === undefined2) {
              upper = lower;
              lower = 0;
            } else {
              upper = toFinite(upper);
            }
          }
          if (lower > upper) {
            var temp = lower;
            lower = upper;
            upper = temp;
          }
          if (floating || lower % 1 || upper % 1) {
            var rand = nativeRandom();
            return nativeMin(lower + rand * (upper - lower + freeParseFloat("1e-" + ((rand + "").length - 1))), upper);
          }
          return baseRandom(lower, upper);
        }
        var camelCase = createCompounder(function(result2, word, index2) {
          word = word.toLowerCase();
          return result2 + (index2 ? capitalize(word) : word);
        });
        function capitalize(string) {
          return upperFirst(toString(string).toLowerCase());
        }
        function deburr(string) {
          string = toString(string);
          return string && string.replace(reLatin, deburrLetter).replace(reComboMark, "");
        }
        function endsWith(string, target, position) {
          string = toString(string);
          target = baseToString(target);
          var length = string.length;
          position = position === undefined2 ? length : baseClamp(toInteger(position), 0, length);
          var end = position;
          position -= target.length;
          return position >= 0 && string.slice(position, end) == target;
        }
        function escape(string) {
          string = toString(string);
          return string && reHasUnescapedHtml.test(string) ? string.replace(reUnescapedHtml, escapeHtmlChar) : string;
        }
        function escapeRegExp(string) {
          string = toString(string);
          return string && reHasRegExpChar.test(string) ? string.replace(reRegExpChar, "\\$&") : string;
        }
        var kebabCase = createCompounder(function(result2, word, index2) {
          return result2 + (index2 ? "-" : "") + word.toLowerCase();
        });
        var lowerCase = createCompounder(function(result2, word, index2) {
          return result2 + (index2 ? " " : "") + word.toLowerCase();
        });
        var lowerFirst = createCaseFirst("toLowerCase");
        function pad(string, length, chars) {
          string = toString(string);
          length = toInteger(length);
          var strLength = length ? stringSize(string) : 0;
          if (!length || strLength >= length) {
            return string;
          }
          var mid = (length - strLength) / 2;
          return createPadding(nativeFloor(mid), chars) + string + createPadding(nativeCeil(mid), chars);
        }
        function padEnd(string, length, chars) {
          string = toString(string);
          length = toInteger(length);
          var strLength = length ? stringSize(string) : 0;
          return length && strLength < length ? string + createPadding(length - strLength, chars) : string;
        }
        function padStart(string, length, chars) {
          string = toString(string);
          length = toInteger(length);
          var strLength = length ? stringSize(string) : 0;
          return length && strLength < length ? createPadding(length - strLength, chars) + string : string;
        }
        function parseInt2(string, radix, guard) {
          if (guard || radix == null) {
            radix = 0;
          } else if (radix) {
            radix = +radix;
          }
          return nativeParseInt(toString(string).replace(reTrimStart, ""), radix || 0);
        }
        function repeat(string, n2, guard) {
          if (guard ? isIterateeCall(string, n2, guard) : n2 === undefined2) {
            n2 = 1;
          } else {
            n2 = toInteger(n2);
          }
          return baseRepeat(toString(string), n2);
        }
        function replace() {
          var args = arguments, string = toString(args[0]);
          return args.length < 3 ? string : string.replace(args[1], args[2]);
        }
        var snakeCase = createCompounder(function(result2, word, index2) {
          return result2 + (index2 ? "_" : "") + word.toLowerCase();
        });
        function split(string, separator, limit) {
          if (limit && typeof limit != "number" && isIterateeCall(string, separator, limit)) {
            separator = limit = undefined2;
          }
          limit = limit === undefined2 ? MAX_ARRAY_LENGTH : limit >>> 0;
          if (!limit) {
            return [];
          }
          string = toString(string);
          if (string && (typeof separator == "string" || separator != null && !isRegExp(separator))) {
            separator = baseToString(separator);
            if (!separator && hasUnicode(string)) {
              return castSlice(stringToArray(string), 0, limit);
            }
          }
          return string.split(separator, limit);
        }
        var startCase = createCompounder(function(result2, word, index2) {
          return result2 + (index2 ? " " : "") + upperFirst(word);
        });
        function startsWith(string, target, position) {
          string = toString(string);
          position = position == null ? 0 : baseClamp(toInteger(position), 0, string.length);
          target = baseToString(target);
          return string.slice(position, position + target.length) == target;
        }
        function template(string, options, guard) {
          var settings = lodash.templateSettings;
          if (guard && isIterateeCall(string, options, guard)) {
            options = undefined2;
          }
          string = toString(string);
          options = assignInWith({}, options, settings, customDefaultsAssignIn);
          var imports = assignInWith({}, options.imports, settings.imports, customDefaultsAssignIn), importsKeys = keys(imports), importsValues = baseValues(imports, importsKeys);
          var isEscaping, isEvaluating, index2 = 0, interpolate = options.interpolate || reNoMatch, source = "__p += '";
          var reDelimiters = RegExp2(
            (options.escape || reNoMatch).source + "|" + interpolate.source + "|" + (interpolate === reInterpolate ? reEsTemplate : reNoMatch).source + "|" + (options.evaluate || reNoMatch).source + "|$",
            "g"
          );
          var sourceURL = "//# sourceURL=" + (hasOwnProperty2.call(options, "sourceURL") ? (options.sourceURL + "").replace(/\s/g, " ") : "lodash.templateSources[" + ++templateCounter + "]") + "\n";
          string.replace(reDelimiters, function(match, escapeValue, interpolateValue, esTemplateValue, evaluateValue, offset) {
            interpolateValue || (interpolateValue = esTemplateValue);
            source += string.slice(index2, offset).replace(reUnescapedString, escapeStringChar);
            if (escapeValue) {
              isEscaping = true;
              source += "' +\n__e(" + escapeValue + ") +\n'";
            }
            if (evaluateValue) {
              isEvaluating = true;
              source += "';\n" + evaluateValue + ";\n__p += '";
            }
            if (interpolateValue) {
              source += "' +\n((__t = (" + interpolateValue + ")) == null ? '' : __t) +\n'";
            }
            index2 = offset + match.length;
            return match;
          });
          source += "';\n";
          var variable = hasOwnProperty2.call(options, "variable") && options.variable;
          if (!variable) {
            source = "with (obj) {\n" + source + "\n}\n";
          } else if (reForbiddenIdentifierChars.test(variable)) {
            throw new Error2(INVALID_TEMPL_VAR_ERROR_TEXT);
          }
          source = (isEvaluating ? source.replace(reEmptyStringLeading, "") : source).replace(reEmptyStringMiddle, "$1").replace(reEmptyStringTrailing, "$1;");
          source = "function(" + (variable || "obj") + ") {\n" + (variable ? "" : "obj || (obj = {});\n") + "var __t, __p = ''" + (isEscaping ? ", __e = _.escape" : "") + (isEvaluating ? ", __j = Array.prototype.join;\nfunction print() { __p += __j.call(arguments, '') }\n" : ";\n") + source + "return __p\n}";
          var result2 = attempt(function() {
            return Function2(importsKeys, sourceURL + "return " + source).apply(undefined2, importsValues);
          });
          result2.source = source;
          if (isError(result2)) {
            throw result2;
          }
          return result2;
        }
        function toLower(value) {
          return toString(value).toLowerCase();
        }
        function toUpper(value) {
          return toString(value).toUpperCase();
        }
        function trim(string, chars, guard) {
          string = toString(string);
          if (string && (guard || chars === undefined2)) {
            return baseTrim(string);
          }
          if (!string || !(chars = baseToString(chars))) {
            return string;
          }
          var strSymbols = stringToArray(string), chrSymbols = stringToArray(chars), start = charsStartIndex(strSymbols, chrSymbols), end = charsEndIndex(strSymbols, chrSymbols) + 1;
          return castSlice(strSymbols, start, end).join("");
        }
        function trimEnd(string, chars, guard) {
          string = toString(string);
          if (string && (guard || chars === undefined2)) {
            return string.slice(0, trimmedEndIndex(string) + 1);
          }
          if (!string || !(chars = baseToString(chars))) {
            return string;
          }
          var strSymbols = stringToArray(string), end = charsEndIndex(strSymbols, stringToArray(chars)) + 1;
          return castSlice(strSymbols, 0, end).join("");
        }
        function trimStart(string, chars, guard) {
          string = toString(string);
          if (string && (guard || chars === undefined2)) {
            return string.replace(reTrimStart, "");
          }
          if (!string || !(chars = baseToString(chars))) {
            return string;
          }
          var strSymbols = stringToArray(string), start = charsStartIndex(strSymbols, stringToArray(chars));
          return castSlice(strSymbols, start).join("");
        }
        function truncate(string, options) {
          var length = DEFAULT_TRUNC_LENGTH, omission = DEFAULT_TRUNC_OMISSION;
          if (isObject(options)) {
            var separator = "separator" in options ? options.separator : separator;
            length = "length" in options ? toInteger(options.length) : length;
            omission = "omission" in options ? baseToString(options.omission) : omission;
          }
          string = toString(string);
          var strLength = string.length;
          if (hasUnicode(string)) {
            var strSymbols = stringToArray(string);
            strLength = strSymbols.length;
          }
          if (length >= strLength) {
            return string;
          }
          var end = length - stringSize(omission);
          if (end < 1) {
            return omission;
          }
          var result2 = strSymbols ? castSlice(strSymbols, 0, end).join("") : string.slice(0, end);
          if (separator === undefined2) {
            return result2 + omission;
          }
          if (strSymbols) {
            end += result2.length - end;
          }
          if (isRegExp(separator)) {
            if (string.slice(end).search(separator)) {
              var match, substring = result2;
              if (!separator.global) {
                separator = RegExp2(separator.source, toString(reFlags.exec(separator)) + "g");
              }
              separator.lastIndex = 0;
              while (match = separator.exec(substring)) {
                var newEnd = match.index;
              }
              result2 = result2.slice(0, newEnd === undefined2 ? end : newEnd);
            }
          } else if (string.indexOf(baseToString(separator), end) != end) {
            var index2 = result2.lastIndexOf(separator);
            if (index2 > -1) {
              result2 = result2.slice(0, index2);
            }
          }
          return result2 + omission;
        }
        function unescape(string) {
          string = toString(string);
          return string && reHasEscapedHtml.test(string) ? string.replace(reEscapedHtml, unescapeHtmlChar) : string;
        }
        var upperCase = createCompounder(function(result2, word, index2) {
          return result2 + (index2 ? " " : "") + word.toUpperCase();
        });
        var upperFirst = createCaseFirst("toUpperCase");
        function words(string, pattern, guard) {
          string = toString(string);
          pattern = guard ? undefined2 : pattern;
          if (pattern === undefined2) {
            return hasUnicodeWord(string) ? unicodeWords(string) : asciiWords(string);
          }
          return string.match(pattern) || [];
        }
        var attempt = baseRest(function(func, args) {
          try {
            return apply(func, undefined2, args);
          } catch (e2) {
            return isError(e2) ? e2 : new Error2(e2);
          }
        });
        var bindAll = flatRest(function(object, methodNames) {
          arrayEach(methodNames, function(key) {
            key = toKey(key);
            baseAssignValue(object, key, bind(object[key], object));
          });
          return object;
        });
        function cond(pairs) {
          var length = pairs == null ? 0 : pairs.length, toIteratee = getIteratee();
          pairs = !length ? [] : arrayMap(pairs, function(pair) {
            if (typeof pair[1] != "function") {
              throw new TypeError2(FUNC_ERROR_TEXT);
            }
            return [toIteratee(pair[0]), pair[1]];
          });
          return baseRest(function(args) {
            var index2 = -1;
            while (++index2 < length) {
              var pair = pairs[index2];
              if (apply(pair[0], this, args)) {
                return apply(pair[1], this, args);
              }
            }
          });
        }
        function conforms(source) {
          return baseConforms(baseClone(source, CLONE_DEEP_FLAG));
        }
        function constant(value) {
          return function() {
            return value;
          };
        }
        function defaultTo(value, defaultValue) {
          return value == null || value !== value ? defaultValue : value;
        }
        var flow = createFlow();
        var flowRight = createFlow(true);
        function identity(value) {
          return value;
        }
        function iteratee(func) {
          return baseIteratee(typeof func == "function" ? func : baseClone(func, CLONE_DEEP_FLAG));
        }
        function matches(source) {
          return baseMatches(baseClone(source, CLONE_DEEP_FLAG));
        }
        function matchesProperty(path, srcValue) {
          return baseMatchesProperty(path, baseClone(srcValue, CLONE_DEEP_FLAG));
        }
        var method = baseRest(function(path, args) {
          return function(object) {
            return baseInvoke(object, path, args);
          };
        });
        var methodOf = baseRest(function(object, args) {
          return function(path) {
            return baseInvoke(object, path, args);
          };
        });
        function mixin(object, source, options) {
          var props = keys(source), methodNames = baseFunctions(source, props);
          if (options == null && !(isObject(source) && (methodNames.length || !props.length))) {
            options = source;
            source = object;
            object = this;
            methodNames = baseFunctions(source, keys(source));
          }
          var chain2 = !(isObject(options) && "chain" in options) || !!options.chain, isFunc = isFunction(object);
          arrayEach(methodNames, function(methodName) {
            var func = source[methodName];
            object[methodName] = func;
            if (isFunc) {
              object.prototype[methodName] = function() {
                var chainAll = this.__chain__;
                if (chain2 || chainAll) {
                  var result2 = object(this.__wrapped__), actions = result2.__actions__ = copyArray(this.__actions__);
                  actions.push({ "func": func, "args": arguments, "thisArg": object });
                  result2.__chain__ = chainAll;
                  return result2;
                }
                return func.apply(object, arrayPush([this.value()], arguments));
              };
            }
          });
          return object;
        }
        function noConflict() {
          if (root._ === this) {
            root._ = oldDash;
          }
          return this;
        }
        function noop3() {
        }
        function nthArg(n2) {
          n2 = toInteger(n2);
          return baseRest(function(args) {
            return baseNth(args, n2);
          });
        }
        var over = createOver(arrayMap);
        var overEvery = createOver(arrayEvery);
        var overSome = createOver(arraySome);
        function property(path) {
          return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);
        }
        function propertyOf(object) {
          return function(path) {
            return object == null ? undefined2 : baseGet(object, path);
          };
        }
        var range = createRange();
        var rangeRight = createRange(true);
        function stubArray() {
          return [];
        }
        function stubFalse() {
          return false;
        }
        function stubObject() {
          return {};
        }
        function stubString() {
          return "";
        }
        function stubTrue() {
          return true;
        }
        function times(n2, iteratee2) {
          n2 = toInteger(n2);
          if (n2 < 1 || n2 > MAX_SAFE_INTEGER) {
            return [];
          }
          var index2 = MAX_ARRAY_LENGTH, length = nativeMin(n2, MAX_ARRAY_LENGTH);
          iteratee2 = getIteratee(iteratee2);
          n2 -= MAX_ARRAY_LENGTH;
          var result2 = baseTimes(length, iteratee2);
          while (++index2 < n2) {
            iteratee2(index2);
          }
          return result2;
        }
        function toPath(value) {
          if (isArray(value)) {
            return arrayMap(value, toKey);
          }
          return isSymbol(value) ? [value] : copyArray(stringToPath(toString(value)));
        }
        function uniqueId(prefix) {
          var id2 = ++idCounter;
          return toString(prefix) + id2;
        }
        var add = createMathOperation(function(augend, addend) {
          return augend + addend;
        }, 0);
        var ceil = createRound("ceil");
        var divide = createMathOperation(function(dividend, divisor) {
          return dividend / divisor;
        }, 1);
        var floor = createRound("floor");
        function max(array) {
          return array && array.length ? baseExtremum(array, identity, baseGt) : undefined2;
        }
        function maxBy(array, iteratee2) {
          return array && array.length ? baseExtremum(array, getIteratee(iteratee2, 2), baseGt) : undefined2;
        }
        function mean(array) {
          return baseMean(array, identity);
        }
        function meanBy(array, iteratee2) {
          return baseMean(array, getIteratee(iteratee2, 2));
        }
        function min(array) {
          return array && array.length ? baseExtremum(array, identity, baseLt) : undefined2;
        }
        function minBy(array, iteratee2) {
          return array && array.length ? baseExtremum(array, getIteratee(iteratee2, 2), baseLt) : undefined2;
        }
        var multiply = createMathOperation(function(multiplier, multiplicand) {
          return multiplier * multiplicand;
        }, 1);
        var round = createRound("round");
        var subtract = createMathOperation(function(minuend, subtrahend) {
          return minuend - subtrahend;
        }, 0);
        function sum(array) {
          return array && array.length ? baseSum(array, identity) : 0;
        }
        function sumBy(array, iteratee2) {
          return array && array.length ? baseSum(array, getIteratee(iteratee2, 2)) : 0;
        }
        lodash.after = after;
        lodash.ary = ary;
        lodash.assign = assign;
        lodash.assignIn = assignIn;
        lodash.assignInWith = assignInWith;
        lodash.assignWith = assignWith;
        lodash.at = at;
        lodash.before = before;
        lodash.bind = bind;
        lodash.bindAll = bindAll;
        lodash.bindKey = bindKey;
        lodash.castArray = castArray;
        lodash.chain = chain;
        lodash.chunk = chunk;
        lodash.compact = compact;
        lodash.concat = concat;
        lodash.cond = cond;
        lodash.conforms = conforms;
        lodash.constant = constant;
        lodash.countBy = countBy;
        lodash.create = create;
        lodash.curry = curry;
        lodash.curryRight = curryRight;
        lodash.debounce = debounce;
        lodash.defaults = defaults;
        lodash.defaultsDeep = defaultsDeep;
        lodash.defer = defer;
        lodash.delay = delay;
        lodash.difference = difference;
        lodash.differenceBy = differenceBy;
        lodash.differenceWith = differenceWith;
        lodash.drop = drop;
        lodash.dropRight = dropRight;
        lodash.dropRightWhile = dropRightWhile;
        lodash.dropWhile = dropWhile;
        lodash.fill = fill;
        lodash.filter = filter;
        lodash.flatMap = flatMap;
        lodash.flatMapDeep = flatMapDeep;
        lodash.flatMapDepth = flatMapDepth;
        lodash.flatten = flatten;
        lodash.flattenDeep = flattenDeep;
        lodash.flattenDepth = flattenDepth;
        lodash.flip = flip;
        lodash.flow = flow;
        lodash.flowRight = flowRight;
        lodash.fromPairs = fromPairs;
        lodash.functions = functions;
        lodash.functionsIn = functionsIn;
        lodash.groupBy = groupBy;
        lodash.initial = initial;
        lodash.intersection = intersection;
        lodash.intersectionBy = intersectionBy;
        lodash.intersectionWith = intersectionWith;
        lodash.invert = invert;
        lodash.invertBy = invertBy;
        lodash.invokeMap = invokeMap;
        lodash.iteratee = iteratee;
        lodash.keyBy = keyBy;
        lodash.keys = keys;
        lodash.keysIn = keysIn;
        lodash.map = map;
        lodash.mapKeys = mapKeys;
        lodash.mapValues = mapValues;
        lodash.matches = matches;
        lodash.matchesProperty = matchesProperty;
        lodash.memoize = memoize;
        lodash.merge = merge;
        lodash.mergeWith = mergeWith;
        lodash.method = method;
        lodash.methodOf = methodOf;
        lodash.mixin = mixin;
        lodash.negate = negate;
        lodash.nthArg = nthArg;
        lodash.omit = omit;
        lodash.omitBy = omitBy;
        lodash.once = once;
        lodash.orderBy = orderBy;
        lodash.over = over;
        lodash.overArgs = overArgs;
        lodash.overEvery = overEvery;
        lodash.overSome = overSome;
        lodash.partial = partial;
        lodash.partialRight = partialRight;
        lodash.partition = partition;
        lodash.pick = pick;
        lodash.pickBy = pickBy;
        lodash.property = property;
        lodash.propertyOf = propertyOf;
        lodash.pull = pull;
        lodash.pullAll = pullAll;
        lodash.pullAllBy = pullAllBy;
        lodash.pullAllWith = pullAllWith;
        lodash.pullAt = pullAt;
        lodash.range = range;
        lodash.rangeRight = rangeRight;
        lodash.rearg = rearg;
        lodash.reject = reject;
        lodash.remove = remove;
        lodash.rest = rest;
        lodash.reverse = reverse;
        lodash.sampleSize = sampleSize;
        lodash.set = set;
        lodash.setWith = setWith;
        lodash.shuffle = shuffle;
        lodash.slice = slice;
        lodash.sortBy = sortBy;
        lodash.sortedUniq = sortedUniq;
        lodash.sortedUniqBy = sortedUniqBy;
        lodash.split = split;
        lodash.spread = spread;
        lodash.tail = tail;
        lodash.take = take;
        lodash.takeRight = takeRight;
        lodash.takeRightWhile = takeRightWhile;
        lodash.takeWhile = takeWhile;
        lodash.tap = tap;
        lodash.throttle = throttle;
        lodash.thru = thru;
        lodash.toArray = toArray;
        lodash.toPairs = toPairs;
        lodash.toPairsIn = toPairsIn;
        lodash.toPath = toPath;
        lodash.toPlainObject = toPlainObject;
        lodash.transform = transform;
        lodash.unary = unary;
        lodash.union = union;
        lodash.unionBy = unionBy;
        lodash.unionWith = unionWith;
        lodash.uniq = uniq;
        lodash.uniqBy = uniqBy;
        lodash.uniqWith = uniqWith;
        lodash.unset = unset;
        lodash.unzip = unzip;
        lodash.unzipWith = unzipWith;
        lodash.update = update;
        lodash.updateWith = updateWith;
        lodash.values = values;
        lodash.valuesIn = valuesIn;
        lodash.without = without;
        lodash.words = words;
        lodash.wrap = wrap;
        lodash.xor = xor;
        lodash.xorBy = xorBy;
        lodash.xorWith = xorWith;
        lodash.zip = zip;
        lodash.zipObject = zipObject;
        lodash.zipObjectDeep = zipObjectDeep;
        lodash.zipWith = zipWith;
        lodash.entries = toPairs;
        lodash.entriesIn = toPairsIn;
        lodash.extend = assignIn;
        lodash.extendWith = assignInWith;
        mixin(lodash, lodash);
        lodash.add = add;
        lodash.attempt = attempt;
        lodash.camelCase = camelCase;
        lodash.capitalize = capitalize;
        lodash.ceil = ceil;
        lodash.clamp = clamp;
        lodash.clone = clone;
        lodash.cloneDeep = cloneDeep;
        lodash.cloneDeepWith = cloneDeepWith;
        lodash.cloneWith = cloneWith;
        lodash.conformsTo = conformsTo;
        lodash.deburr = deburr;
        lodash.defaultTo = defaultTo;
        lodash.divide = divide;
        lodash.endsWith = endsWith;
        lodash.eq = eq;
        lodash.escape = escape;
        lodash.escapeRegExp = escapeRegExp;
        lodash.every = every;
        lodash.find = find;
        lodash.findIndex = findIndex;
        lodash.findKey = findKey;
        lodash.findLast = findLast;
        lodash.findLastIndex = findLastIndex;
        lodash.findLastKey = findLastKey;
        lodash.floor = floor;
        lodash.forEach = forEach;
        lodash.forEachRight = forEachRight;
        lodash.forIn = forIn;
        lodash.forInRight = forInRight;
        lodash.forOwn = forOwn;
        lodash.forOwnRight = forOwnRight;
        lodash.get = get;
        lodash.gt = gt;
        lodash.gte = gte;
        lodash.has = has;
        lodash.hasIn = hasIn;
        lodash.head = head;
        lodash.identity = identity;
        lodash.includes = includes;
        lodash.indexOf = indexOf;
        lodash.inRange = inRange;
        lodash.invoke = invoke;
        lodash.isArguments = isArguments;
        lodash.isArray = isArray;
        lodash.isArrayBuffer = isArrayBuffer;
        lodash.isArrayLike = isArrayLike;
        lodash.isArrayLikeObject = isArrayLikeObject;
        lodash.isBoolean = isBoolean;
        lodash.isBuffer = isBuffer;
        lodash.isDate = isDate;
        lodash.isElement = isElement;
        lodash.isEmpty = isEmpty;
        lodash.isEqual = isEqual3;
        lodash.isEqualWith = isEqualWith;
        lodash.isError = isError;
        lodash.isFinite = isFinite2;
        lodash.isFunction = isFunction;
        lodash.isInteger = isInteger2;
        lodash.isLength = isLength2;
        lodash.isMap = isMap;
        lodash.isMatch = isMatch;
        lodash.isMatchWith = isMatchWith;
        lodash.isNaN = isNaN2;
        lodash.isNative = isNative;
        lodash.isNil = isNil;
        lodash.isNull = isNull;
        lodash.isNumber = isNumber2;
        lodash.isObject = isObject;
        lodash.isObjectLike = isObjectLike;
        lodash.isPlainObject = isPlainObject;
        lodash.isRegExp = isRegExp;
        lodash.isSafeInteger = isSafeInteger;
        lodash.isSet = isSet;
        lodash.isString = isString;
        lodash.isSymbol = isSymbol;
        lodash.isTypedArray = isTypedArray;
        lodash.isUndefined = isUndefined;
        lodash.isWeakMap = isWeakMap;
        lodash.isWeakSet = isWeakSet;
        lodash.join = join;
        lodash.kebabCase = kebabCase;
        lodash.last = last;
        lodash.lastIndexOf = lastIndexOf;
        lodash.lowerCase = lowerCase;
        lodash.lowerFirst = lowerFirst;
        lodash.lt = lt;
        lodash.lte = lte;
        lodash.max = max;
        lodash.maxBy = maxBy;
        lodash.mean = mean;
        lodash.meanBy = meanBy;
        lodash.min = min;
        lodash.minBy = minBy;
        lodash.stubArray = stubArray;
        lodash.stubFalse = stubFalse;
        lodash.stubObject = stubObject;
        lodash.stubString = stubString;
        lodash.stubTrue = stubTrue;
        lodash.multiply = multiply;
        lodash.nth = nth;
        lodash.noConflict = noConflict;
        lodash.noop = noop3;
        lodash.now = now;
        lodash.pad = pad;
        lodash.padEnd = padEnd;
        lodash.padStart = padStart;
        lodash.parseInt = parseInt2;
        lodash.random = random;
        lodash.reduce = reduce;
        lodash.reduceRight = reduceRight;
        lodash.repeat = repeat;
        lodash.replace = replace;
        lodash.result = result;
        lodash.round = round;
        lodash.runInContext = runInContext2;
        lodash.sample = sample;
        lodash.size = size;
        lodash.snakeCase = snakeCase;
        lodash.some = some;
        lodash.sortedIndex = sortedIndex;
        lodash.sortedIndexBy = sortedIndexBy;
        lodash.sortedIndexOf = sortedIndexOf;
        lodash.sortedLastIndex = sortedLastIndex;
        lodash.sortedLastIndexBy = sortedLastIndexBy;
        lodash.sortedLastIndexOf = sortedLastIndexOf;
        lodash.startCase = startCase;
        lodash.startsWith = startsWith;
        lodash.subtract = subtract;
        lodash.sum = sum;
        lodash.sumBy = sumBy;
        lodash.template = template;
        lodash.times = times;
        lodash.toFinite = toFinite;
        lodash.toInteger = toInteger;
        lodash.toLength = toLength;
        lodash.toLower = toLower;
        lodash.toNumber = toNumber;
        lodash.toSafeInteger = toSafeInteger;
        lodash.toString = toString;
        lodash.toUpper = toUpper;
        lodash.trim = trim;
        lodash.trimEnd = trimEnd;
        lodash.trimStart = trimStart;
        lodash.truncate = truncate;
        lodash.unescape = unescape;
        lodash.uniqueId = uniqueId;
        lodash.upperCase = upperCase;
        lodash.upperFirst = upperFirst;
        lodash.each = forEach;
        lodash.eachRight = forEachRight;
        lodash.first = head;
        mixin(lodash, function() {
          var source = {};
          baseForOwn(lodash, function(func, methodName) {
            if (!hasOwnProperty2.call(lodash.prototype, methodName)) {
              source[methodName] = func;
            }
          });
          return source;
        }(), { "chain": false });
        lodash.VERSION = VERSION;
        arrayEach(["bind", "bindKey", "curry", "curryRight", "partial", "partialRight"], function(methodName) {
          lodash[methodName].placeholder = lodash;
        });
        arrayEach(["drop", "take"], function(methodName, index2) {
          LazyWrapper.prototype[methodName] = function(n2) {
            n2 = n2 === undefined2 ? 1 : nativeMax(toInteger(n2), 0);
            var result2 = this.__filtered__ && !index2 ? new LazyWrapper(this) : this.clone();
            if (result2.__filtered__) {
              result2.__takeCount__ = nativeMin(n2, result2.__takeCount__);
            } else {
              result2.__views__.push({
                "size": nativeMin(n2, MAX_ARRAY_LENGTH),
                "type": methodName + (result2.__dir__ < 0 ? "Right" : "")
              });
            }
            return result2;
          };
          LazyWrapper.prototype[methodName + "Right"] = function(n2) {
            return this.reverse()[methodName](n2).reverse();
          };
        });
        arrayEach(["filter", "map", "takeWhile"], function(methodName, index2) {
          var type = index2 + 1, isFilter = type == LAZY_FILTER_FLAG || type == LAZY_WHILE_FLAG;
          LazyWrapper.prototype[methodName] = function(iteratee2) {
            var result2 = this.clone();
            result2.__iteratees__.push({
              "iteratee": getIteratee(iteratee2, 3),
              "type": type
            });
            result2.__filtered__ = result2.__filtered__ || isFilter;
            return result2;
          };
        });
        arrayEach(["head", "last"], function(methodName, index2) {
          var takeName = "take" + (index2 ? "Right" : "");
          LazyWrapper.prototype[methodName] = function() {
            return this[takeName](1).value()[0];
          };
        });
        arrayEach(["initial", "tail"], function(methodName, index2) {
          var dropName = "drop" + (index2 ? "" : "Right");
          LazyWrapper.prototype[methodName] = function() {
            return this.__filtered__ ? new LazyWrapper(this) : this[dropName](1);
          };
        });
        LazyWrapper.prototype.compact = function() {
          return this.filter(identity);
        };
        LazyWrapper.prototype.find = function(predicate) {
          return this.filter(predicate).head();
        };
        LazyWrapper.prototype.findLast = function(predicate) {
          return this.reverse().find(predicate);
        };
        LazyWrapper.prototype.invokeMap = baseRest(function(path, args) {
          if (typeof path == "function") {
            return new LazyWrapper(this);
          }
          return this.map(function(value) {
            return baseInvoke(value, path, args);
          });
        });
        LazyWrapper.prototype.reject = function(predicate) {
          return this.filter(negate(getIteratee(predicate)));
        };
        LazyWrapper.prototype.slice = function(start, end) {
          start = toInteger(start);
          var result2 = this;
          if (result2.__filtered__ && (start > 0 || end < 0)) {
            return new LazyWrapper(result2);
          }
          if (start < 0) {
            result2 = result2.takeRight(-start);
          } else if (start) {
            result2 = result2.drop(start);
          }
          if (end !== undefined2) {
            end = toInteger(end);
            result2 = end < 0 ? result2.dropRight(-end) : result2.take(end - start);
          }
          return result2;
        };
        LazyWrapper.prototype.takeRightWhile = function(predicate) {
          return this.reverse().takeWhile(predicate).reverse();
        };
        LazyWrapper.prototype.toArray = function() {
          return this.take(MAX_ARRAY_LENGTH);
        };
        baseForOwn(LazyWrapper.prototype, function(func, methodName) {
          var checkIteratee = /^(?:filter|find|map|reject)|While$/.test(methodName), isTaker = /^(?:head|last)$/.test(methodName), lodashFunc = lodash[isTaker ? "take" + (methodName == "last" ? "Right" : "") : methodName], retUnwrapped = isTaker || /^find/.test(methodName);
          if (!lodashFunc) {
            return;
          }
          lodash.prototype[methodName] = function() {
            var value = this.__wrapped__, args = isTaker ? [1] : arguments, isLazy = value instanceof LazyWrapper, iteratee2 = args[0], useLazy = isLazy || isArray(value);
            var interceptor = function(value2) {
              var result3 = lodashFunc.apply(lodash, arrayPush([value2], args));
              return isTaker && chainAll ? result3[0] : result3;
            };
            if (useLazy && checkIteratee && typeof iteratee2 == "function" && iteratee2.length != 1) {
              isLazy = useLazy = false;
            }
            var chainAll = this.__chain__, isHybrid = !!this.__actions__.length, isUnwrapped = retUnwrapped && !chainAll, onlyLazy = isLazy && !isHybrid;
            if (!retUnwrapped && useLazy) {
              value = onlyLazy ? value : new LazyWrapper(this);
              var result2 = func.apply(value, args);
              result2.__actions__.push({ "func": thru, "args": [interceptor], "thisArg": undefined2 });
              return new LodashWrapper(result2, chainAll);
            }
            if (isUnwrapped && onlyLazy) {
              return func.apply(this, args);
            }
            result2 = this.thru(interceptor);
            return isUnwrapped ? isTaker ? result2.value()[0] : result2.value() : result2;
          };
        });
        arrayEach(["pop", "push", "shift", "sort", "splice", "unshift"], function(methodName) {
          var func = arrayProto[methodName], chainName = /^(?:push|sort|unshift)$/.test(methodName) ? "tap" : "thru", retUnwrapped = /^(?:pop|shift)$/.test(methodName);
          lodash.prototype[methodName] = function() {
            var args = arguments;
            if (retUnwrapped && !this.__chain__) {
              var value = this.value();
              return func.apply(isArray(value) ? value : [], args);
            }
            return this[chainName](function(value2) {
              return func.apply(isArray(value2) ? value2 : [], args);
            });
          };
        });
        baseForOwn(LazyWrapper.prototype, function(func, methodName) {
          var lodashFunc = lodash[methodName];
          if (lodashFunc) {
            var key = lodashFunc.name + "";
            if (!hasOwnProperty2.call(realNames, key)) {
              realNames[key] = [];
            }
            realNames[key].push({ "name": methodName, "func": lodashFunc });
          }
        });
        realNames[createHybrid(undefined2, WRAP_BIND_KEY_FLAG).name] = [{
          "name": "wrapper",
          "func": undefined2
        }];
        LazyWrapper.prototype.clone = lazyClone;
        LazyWrapper.prototype.reverse = lazyReverse;
        LazyWrapper.prototype.value = lazyValue;
        lodash.prototype.at = wrapperAt;
        lodash.prototype.chain = wrapperChain;
        lodash.prototype.commit = wrapperCommit;
        lodash.prototype.next = wrapperNext;
        lodash.prototype.plant = wrapperPlant;
        lodash.prototype.reverse = wrapperReverse;
        lodash.prototype.toJSON = lodash.prototype.valueOf = lodash.prototype.value = wrapperValue;
        lodash.prototype.first = lodash.prototype.head;
        if (symIterator) {
          lodash.prototype[symIterator] = wrapperToIterator;
        }
        return lodash;
      };
      var _ = runInContext();
      if (typeof define == "function" && typeof define.amd == "object" && define.amd) {
        root._ = _;
        define(function() {
          return _;
        });
      } else if (freeModule) {
        (freeModule.exports = _)._ = _;
        freeExports._ = _;
      } else {
        root._ = _;
      }
    }).call(exports);
  }
});

// node_modules/react-is/cjs/react-is.development.js
var require_react_is_development = __commonJS({
  "node_modules/react-is/cjs/react-is.development.js"(exports) {
    "use strict";
    if (true) {
      (function() {
        "use strict";
        var hasSymbol = typeof Symbol === "function" && Symbol.for;
        var REACT_ELEMENT_TYPE = hasSymbol ? Symbol.for("react.element") : 60103;
        var REACT_PORTAL_TYPE = hasSymbol ? Symbol.for("react.portal") : 60106;
        var REACT_FRAGMENT_TYPE = hasSymbol ? Symbol.for("react.fragment") : 60107;
        var REACT_STRICT_MODE_TYPE = hasSymbol ? Symbol.for("react.strict_mode") : 60108;
        var REACT_PROFILER_TYPE = hasSymbol ? Symbol.for("react.profiler") : 60114;
        var REACT_PROVIDER_TYPE = hasSymbol ? Symbol.for("react.provider") : 60109;
        var REACT_CONTEXT_TYPE = hasSymbol ? Symbol.for("react.context") : 60110;
        var REACT_ASYNC_MODE_TYPE = hasSymbol ? Symbol.for("react.async_mode") : 60111;
        var REACT_CONCURRENT_MODE_TYPE = hasSymbol ? Symbol.for("react.concurrent_mode") : 60111;
        var REACT_FORWARD_REF_TYPE = hasSymbol ? Symbol.for("react.forward_ref") : 60112;
        var REACT_SUSPENSE_TYPE = hasSymbol ? Symbol.for("react.suspense") : 60113;
        var REACT_SUSPENSE_LIST_TYPE = hasSymbol ? Symbol.for("react.suspense_list") : 60120;
        var REACT_MEMO_TYPE = hasSymbol ? Symbol.for("react.memo") : 60115;
        var REACT_LAZY_TYPE = hasSymbol ? Symbol.for("react.lazy") : 60116;
        var REACT_BLOCK_TYPE = hasSymbol ? Symbol.for("react.block") : 60121;
        var REACT_FUNDAMENTAL_TYPE = hasSymbol ? Symbol.for("react.fundamental") : 60117;
        var REACT_RESPONDER_TYPE = hasSymbol ? Symbol.for("react.responder") : 60118;
        var REACT_SCOPE_TYPE = hasSymbol ? Symbol.for("react.scope") : 60119;
        function isValidElementType(type) {
          return typeof type === "string" || typeof type === "function" || type === REACT_FRAGMENT_TYPE || type === REACT_CONCURRENT_MODE_TYPE || type === REACT_PROFILER_TYPE || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || typeof type === "object" && type !== null && (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || type.$$typeof === REACT_FUNDAMENTAL_TYPE || type.$$typeof === REACT_RESPONDER_TYPE || type.$$typeof === REACT_SCOPE_TYPE || type.$$typeof === REACT_BLOCK_TYPE);
        }
        function typeOf(object) {
          if (typeof object === "object" && object !== null) {
            var $$typeof = object.$$typeof;
            switch ($$typeof) {
              case REACT_ELEMENT_TYPE:
                var type = object.type;
                switch (type) {
                  case REACT_ASYNC_MODE_TYPE:
                  case REACT_CONCURRENT_MODE_TYPE:
                  case REACT_FRAGMENT_TYPE:
                  case REACT_PROFILER_TYPE:
                  case REACT_STRICT_MODE_TYPE:
                  case REACT_SUSPENSE_TYPE:
                    return type;
                  default:
                    var $$typeofType = type && type.$$typeof;
                    switch ($$typeofType) {
                      case REACT_CONTEXT_TYPE:
                      case REACT_FORWARD_REF_TYPE:
                      case REACT_LAZY_TYPE:
                      case REACT_MEMO_TYPE:
                      case REACT_PROVIDER_TYPE:
                        return $$typeofType;
                      default:
                        return $$typeof;
                    }
                }
              case REACT_PORTAL_TYPE:
                return $$typeof;
            }
          }
          return void 0;
        }
        var AsyncMode = REACT_ASYNC_MODE_TYPE;
        var ConcurrentMode = REACT_CONCURRENT_MODE_TYPE;
        var ContextConsumer = REACT_CONTEXT_TYPE;
        var ContextProvider = REACT_PROVIDER_TYPE;
        var Element = REACT_ELEMENT_TYPE;
        var ForwardRef = REACT_FORWARD_REF_TYPE;
        var Fragment7 = REACT_FRAGMENT_TYPE;
        var Lazy = REACT_LAZY_TYPE;
        var Memo = REACT_MEMO_TYPE;
        var Portal = REACT_PORTAL_TYPE;
        var Profiler = REACT_PROFILER_TYPE;
        var StrictMode = REACT_STRICT_MODE_TYPE;
        var Suspense = REACT_SUSPENSE_TYPE;
        var hasWarnedAboutDeprecatedIsAsyncMode = false;
        function isAsyncMode(object) {
          {
            if (!hasWarnedAboutDeprecatedIsAsyncMode) {
              hasWarnedAboutDeprecatedIsAsyncMode = true;
              console["warn"]("The ReactIs.isAsyncMode() alias has been deprecated, and will be removed in React 17+. Update your code to use ReactIs.isConcurrentMode() instead. It has the exact same API.");
            }
          }
          return isConcurrentMode(object) || typeOf(object) === REACT_ASYNC_MODE_TYPE;
        }
        function isConcurrentMode(object) {
          return typeOf(object) === REACT_CONCURRENT_MODE_TYPE;
        }
        function isContextConsumer(object) {
          return typeOf(object) === REACT_CONTEXT_TYPE;
        }
        function isContextProvider(object) {
          return typeOf(object) === REACT_PROVIDER_TYPE;
        }
        function isElement(object) {
          return typeof object === "object" && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
        }
        function isForwardRef(object) {
          return typeOf(object) === REACT_FORWARD_REF_TYPE;
        }
        function isFragment(object) {
          return typeOf(object) === REACT_FRAGMENT_TYPE;
        }
        function isLazy(object) {
          return typeOf(object) === REACT_LAZY_TYPE;
        }
        function isMemo(object) {
          return typeOf(object) === REACT_MEMO_TYPE;
        }
        function isPortal(object) {
          return typeOf(object) === REACT_PORTAL_TYPE;
        }
        function isProfiler(object) {
          return typeOf(object) === REACT_PROFILER_TYPE;
        }
        function isStrictMode(object) {
          return typeOf(object) === REACT_STRICT_MODE_TYPE;
        }
        function isSuspense(object) {
          return typeOf(object) === REACT_SUSPENSE_TYPE;
        }
        exports.AsyncMode = AsyncMode;
        exports.ConcurrentMode = ConcurrentMode;
        exports.ContextConsumer = ContextConsumer;
        exports.ContextProvider = ContextProvider;
        exports.Element = Element;
        exports.ForwardRef = ForwardRef;
        exports.Fragment = Fragment7;
        exports.Lazy = Lazy;
        exports.Memo = Memo;
        exports.Portal = Portal;
        exports.Profiler = Profiler;
        exports.StrictMode = StrictMode;
        exports.Suspense = Suspense;
        exports.isAsyncMode = isAsyncMode;
        exports.isConcurrentMode = isConcurrentMode;
        exports.isContextConsumer = isContextConsumer;
        exports.isContextProvider = isContextProvider;
        exports.isElement = isElement;
        exports.isForwardRef = isForwardRef;
        exports.isFragment = isFragment;
        exports.isLazy = isLazy;
        exports.isMemo = isMemo;
        exports.isPortal = isPortal;
        exports.isProfiler = isProfiler;
        exports.isStrictMode = isStrictMode;
        exports.isSuspense = isSuspense;
        exports.isValidElementType = isValidElementType;
        exports.typeOf = typeOf;
      })();
    }
  }
});

// node_modules/react-is/index.js
var require_react_is = __commonJS({
  "node_modules/react-is/index.js"(exports, module) {
    "use strict";
    if (false) {
      module.exports = null;
    } else {
      module.exports = require_react_is_development();
    }
  }
});

// node_modules/prop-types/lib/ReactPropTypesSecret.js
var require_ReactPropTypesSecret = __commonJS({
  "node_modules/prop-types/lib/ReactPropTypesSecret.js"(exports, module) {
    "use strict";
    var ReactPropTypesSecret = "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED";
    module.exports = ReactPropTypesSecret;
  }
});

// node_modules/prop-types/lib/has.js
var require_has = __commonJS({
  "node_modules/prop-types/lib/has.js"(exports, module) {
    module.exports = Function.call.bind(Object.prototype.hasOwnProperty);
  }
});

// node_modules/prop-types/checkPropTypes.js
var require_checkPropTypes = __commonJS({
  "node_modules/prop-types/checkPropTypes.js"(exports, module) {
    "use strict";
    var printWarning = function() {
    };
    if (true) {
      ReactPropTypesSecret = require_ReactPropTypesSecret();
      loggedTypeFailures = {};
      has = require_has();
      printWarning = function(text) {
        var message = "Warning: " + text;
        if (typeof console !== "undefined") {
          console.error(message);
        }
        try {
          throw new Error(message);
        } catch (x2) {
        }
      };
    }
    var ReactPropTypesSecret;
    var loggedTypeFailures;
    var has;
    function checkPropTypes(typeSpecs, values, location, componentName, getStack) {
      if (true) {
        for (var typeSpecName in typeSpecs) {
          if (has(typeSpecs, typeSpecName)) {
            var error;
            try {
              if (typeof typeSpecs[typeSpecName] !== "function") {
                var err = Error(
                  (componentName || "React class") + ": " + location + " type `" + typeSpecName + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof typeSpecs[typeSpecName] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`."
                );
                err.name = "Invariant Violation";
                throw err;
              }
              error = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, ReactPropTypesSecret);
            } catch (ex) {
              error = ex;
            }
            if (error && !(error instanceof Error)) {
              printWarning(
                (componentName || "React class") + ": type specification of " + location + " `" + typeSpecName + "` is invalid; the type checker function must return `null` or an `Error` but returned a " + typeof error + ". You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument)."
              );
            }
            if (error instanceof Error && !(error.message in loggedTypeFailures)) {
              loggedTypeFailures[error.message] = true;
              var stack = getStack ? getStack() : "";
              printWarning(
                "Failed " + location + " type: " + error.message + (stack != null ? stack : "")
              );
            }
          }
        }
      }
    }
    checkPropTypes.resetWarningCache = function() {
      if (true) {
        loggedTypeFailures = {};
      }
    };
    module.exports = checkPropTypes;
  }
});

// node_modules/prop-types/factoryWithTypeCheckers.js
var require_factoryWithTypeCheckers = __commonJS({
  "node_modules/prop-types/factoryWithTypeCheckers.js"(exports, module) {
    "use strict";
    var ReactIs = require_react_is();
    var assign = require_object_assign();
    var ReactPropTypesSecret = require_ReactPropTypesSecret();
    var has = require_has();
    var checkPropTypes = require_checkPropTypes();
    var printWarning = function() {
    };
    if (true) {
      printWarning = function(text) {
        var message = "Warning: " + text;
        if (typeof console !== "undefined") {
          console.error(message);
        }
        try {
          throw new Error(message);
        } catch (x2) {
        }
      };
    }
    function emptyFunctionThatReturnsNull() {
      return null;
    }
    module.exports = function(isValidElement5, throwOnDirectAccess) {
      var ITERATOR_SYMBOL = typeof Symbol === "function" && Symbol.iterator;
      var FAUX_ITERATOR_SYMBOL = "@@iterator";
      function getIteratorFn(maybeIterable) {
        var iteratorFn = maybeIterable && (ITERATOR_SYMBOL && maybeIterable[ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL]);
        if (typeof iteratorFn === "function") {
          return iteratorFn;
        }
      }
      var ANONYMOUS = "<<anonymous>>";
      var ReactPropTypes = {
        array: createPrimitiveTypeChecker("array"),
        bigint: createPrimitiveTypeChecker("bigint"),
        bool: createPrimitiveTypeChecker("boolean"),
        func: createPrimitiveTypeChecker("function"),
        number: createPrimitiveTypeChecker("number"),
        object: createPrimitiveTypeChecker("object"),
        string: createPrimitiveTypeChecker("string"),
        symbol: createPrimitiveTypeChecker("symbol"),
        any: createAnyTypeChecker(),
        arrayOf: createArrayOfTypeChecker,
        element: createElementTypeChecker(),
        elementType: createElementTypeTypeChecker(),
        instanceOf: createInstanceTypeChecker,
        node: createNodeChecker(),
        objectOf: createObjectOfTypeChecker,
        oneOf: createEnumTypeChecker,
        oneOfType: createUnionTypeChecker,
        shape: createShapeTypeChecker,
        exact: createStrictShapeTypeChecker
      };
      function is(x2, y2) {
        if (x2 === y2) {
          return x2 !== 0 || 1 / x2 === 1 / y2;
        } else {
          return x2 !== x2 && y2 !== y2;
        }
      }
      function PropTypeError(message, data) {
        this.message = message;
        this.data = data && typeof data === "object" ? data : {};
        this.stack = "";
      }
      PropTypeError.prototype = Error.prototype;
      function createChainableTypeChecker(validate) {
        if (true) {
          var manualPropTypeCallCache = {};
          var manualPropTypeWarningCount = 0;
        }
        function checkType(isRequired, props, propName, componentName, location, propFullName, secret) {
          componentName = componentName || ANONYMOUS;
          propFullName = propFullName || propName;
          if (secret !== ReactPropTypesSecret) {
            if (throwOnDirectAccess) {
              var err = new Error(
                "Calling PropTypes validators directly is not supported by the `prop-types` package. Use `PropTypes.checkPropTypes()` to call them. Read more at http://fb.me/use-check-prop-types"
              );
              err.name = "Invariant Violation";
              throw err;
            } else if (typeof console !== "undefined") {
              var cacheKey = componentName + ":" + propName;
              if (!manualPropTypeCallCache[cacheKey] && manualPropTypeWarningCount < 3) {
                printWarning(
                  "You are manually calling a React.PropTypes validation function for the `" + propFullName + "` prop on `" + componentName + "`. This is deprecated and will throw in the standalone `prop-types` package. You may be seeing this warning due to a third-party PropTypes library. See https://fb.me/react-warning-dont-call-proptypes for details."
                );
                manualPropTypeCallCache[cacheKey] = true;
                manualPropTypeWarningCount++;
              }
            }
          }
          if (props[propName] == null) {
            if (isRequired) {
              if (props[propName] === null) {
                return new PropTypeError("The " + location + " `" + propFullName + "` is marked as required " + ("in `" + componentName + "`, but its value is `null`."));
              }
              return new PropTypeError("The " + location + " `" + propFullName + "` is marked as required in " + ("`" + componentName + "`, but its value is `undefined`."));
            }
            return null;
          } else {
            return validate(props, propName, componentName, location, propFullName);
          }
        }
        var chainedCheckType = checkType.bind(null, false);
        chainedCheckType.isRequired = checkType.bind(null, true);
        return chainedCheckType;
      }
      function createPrimitiveTypeChecker(expectedType) {
        function validate(props, propName, componentName, location, propFullName, secret) {
          var propValue = props[propName];
          var propType = getPropType(propValue);
          if (propType !== expectedType) {
            var preciseType = getPreciseType(propValue);
            return new PropTypeError(
              "Invalid " + location + " `" + propFullName + "` of type " + ("`" + preciseType + "` supplied to `" + componentName + "`, expected ") + ("`" + expectedType + "`."),
              { expectedType }
            );
          }
          return null;
        }
        return createChainableTypeChecker(validate);
      }
      function createAnyTypeChecker() {
        return createChainableTypeChecker(emptyFunctionThatReturnsNull);
      }
      function createArrayOfTypeChecker(typeChecker) {
        function validate(props, propName, componentName, location, propFullName) {
          if (typeof typeChecker !== "function") {
            return new PropTypeError("Property `" + propFullName + "` of component `" + componentName + "` has invalid PropType notation inside arrayOf.");
          }
          var propValue = props[propName];
          if (!Array.isArray(propValue)) {
            var propType = getPropType(propValue);
            return new PropTypeError("Invalid " + location + " `" + propFullName + "` of type " + ("`" + propType + "` supplied to `" + componentName + "`, expected an array."));
          }
          for (var i2 = 0; i2 < propValue.length; i2++) {
            var error = typeChecker(propValue, i2, componentName, location, propFullName + "[" + i2 + "]", ReactPropTypesSecret);
            if (error instanceof Error) {
              return error;
            }
          }
          return null;
        }
        return createChainableTypeChecker(validate);
      }
      function createElementTypeChecker() {
        function validate(props, propName, componentName, location, propFullName) {
          var propValue = props[propName];
          if (!isValidElement5(propValue)) {
            var propType = getPropType(propValue);
            return new PropTypeError("Invalid " + location + " `" + propFullName + "` of type " + ("`" + propType + "` supplied to `" + componentName + "`, expected a single ReactElement."));
          }
          return null;
        }
        return createChainableTypeChecker(validate);
      }
      function createElementTypeTypeChecker() {
        function validate(props, propName, componentName, location, propFullName) {
          var propValue = props[propName];
          if (!ReactIs.isValidElementType(propValue)) {
            var propType = getPropType(propValue);
            return new PropTypeError("Invalid " + location + " `" + propFullName + "` of type " + ("`" + propType + "` supplied to `" + componentName + "`, expected a single ReactElement type."));
          }
          return null;
        }
        return createChainableTypeChecker(validate);
      }
      function createInstanceTypeChecker(expectedClass) {
        function validate(props, propName, componentName, location, propFullName) {
          if (!(props[propName] instanceof expectedClass)) {
            var expectedClassName = expectedClass.name || ANONYMOUS;
            var actualClassName = getClassName(props[propName]);
            return new PropTypeError("Invalid " + location + " `" + propFullName + "` of type " + ("`" + actualClassName + "` supplied to `" + componentName + "`, expected ") + ("instance of `" + expectedClassName + "`."));
          }
          return null;
        }
        return createChainableTypeChecker(validate);
      }
      function createEnumTypeChecker(expectedValues) {
        if (!Array.isArray(expectedValues)) {
          if (true) {
            if (arguments.length > 1) {
              printWarning(
                "Invalid arguments supplied to oneOf, expected an array, got " + arguments.length + " arguments. A common mistake is to write oneOf(x, y, z) instead of oneOf([x, y, z])."
              );
            } else {
              printWarning("Invalid argument supplied to oneOf, expected an array.");
            }
          }
          return emptyFunctionThatReturnsNull;
        }
        function validate(props, propName, componentName, location, propFullName) {
          var propValue = props[propName];
          for (var i2 = 0; i2 < expectedValues.length; i2++) {
            if (is(propValue, expectedValues[i2])) {
              return null;
            }
          }
          var valuesString = JSON.stringify(expectedValues, function replacer(key, value) {
            var type = getPreciseType(value);
            if (type === "symbol") {
              return String(value);
            }
            return value;
          });
          return new PropTypeError("Invalid " + location + " `" + propFullName + "` of value `" + String(propValue) + "` " + ("supplied to `" + componentName + "`, expected one of " + valuesString + "."));
        }
        return createChainableTypeChecker(validate);
      }
      function createObjectOfTypeChecker(typeChecker) {
        function validate(props, propName, componentName, location, propFullName) {
          if (typeof typeChecker !== "function") {
            return new PropTypeError("Property `" + propFullName + "` of component `" + componentName + "` has invalid PropType notation inside objectOf.");
          }
          var propValue = props[propName];
          var propType = getPropType(propValue);
          if (propType !== "object") {
            return new PropTypeError("Invalid " + location + " `" + propFullName + "` of type " + ("`" + propType + "` supplied to `" + componentName + "`, expected an object."));
          }
          for (var key in propValue) {
            if (has(propValue, key)) {
              var error = typeChecker(propValue, key, componentName, location, propFullName + "." + key, ReactPropTypesSecret);
              if (error instanceof Error) {
                return error;
              }
            }
          }
          return null;
        }
        return createChainableTypeChecker(validate);
      }
      function createUnionTypeChecker(arrayOfTypeCheckers) {
        if (!Array.isArray(arrayOfTypeCheckers)) {
          true ? printWarning("Invalid argument supplied to oneOfType, expected an instance of array.") : void 0;
          return emptyFunctionThatReturnsNull;
        }
        for (var i2 = 0; i2 < arrayOfTypeCheckers.length; i2++) {
          var checker = arrayOfTypeCheckers[i2];
          if (typeof checker !== "function") {
            printWarning(
              "Invalid argument supplied to oneOfType. Expected an array of check functions, but received " + getPostfixForTypeWarning(checker) + " at index " + i2 + "."
            );
            return emptyFunctionThatReturnsNull;
          }
        }
        function validate(props, propName, componentName, location, propFullName) {
          var expectedTypes = [];
          for (var i3 = 0; i3 < arrayOfTypeCheckers.length; i3++) {
            var checker2 = arrayOfTypeCheckers[i3];
            var checkerResult = checker2(props, propName, componentName, location, propFullName, ReactPropTypesSecret);
            if (checkerResult == null) {
              return null;
            }
            if (checkerResult.data && has(checkerResult.data, "expectedType")) {
              expectedTypes.push(checkerResult.data.expectedType);
            }
          }
          var expectedTypesMessage = expectedTypes.length > 0 ? ", expected one of type [" + expectedTypes.join(", ") + "]" : "";
          return new PropTypeError("Invalid " + location + " `" + propFullName + "` supplied to " + ("`" + componentName + "`" + expectedTypesMessage + "."));
        }
        return createChainableTypeChecker(validate);
      }
      function createNodeChecker() {
        function validate(props, propName, componentName, location, propFullName) {
          if (!isNode(props[propName])) {
            return new PropTypeError("Invalid " + location + " `" + propFullName + "` supplied to " + ("`" + componentName + "`, expected a ReactNode."));
          }
          return null;
        }
        return createChainableTypeChecker(validate);
      }
      function invalidValidatorError(componentName, location, propFullName, key, type) {
        return new PropTypeError(
          (componentName || "React class") + ": " + location + " type `" + propFullName + "." + key + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + type + "`."
        );
      }
      function createShapeTypeChecker(shapeTypes) {
        function validate(props, propName, componentName, location, propFullName) {
          var propValue = props[propName];
          var propType = getPropType(propValue);
          if (propType !== "object") {
            return new PropTypeError("Invalid " + location + " `" + propFullName + "` of type `" + propType + "` " + ("supplied to `" + componentName + "`, expected `object`."));
          }
          for (var key in shapeTypes) {
            var checker = shapeTypes[key];
            if (typeof checker !== "function") {
              return invalidValidatorError(componentName, location, propFullName, key, getPreciseType(checker));
            }
            var error = checker(propValue, key, componentName, location, propFullName + "." + key, ReactPropTypesSecret);
            if (error) {
              return error;
            }
          }
          return null;
        }
        return createChainableTypeChecker(validate);
      }
      function createStrictShapeTypeChecker(shapeTypes) {
        function validate(props, propName, componentName, location, propFullName) {
          var propValue = props[propName];
          var propType = getPropType(propValue);
          if (propType !== "object") {
            return new PropTypeError("Invalid " + location + " `" + propFullName + "` of type `" + propType + "` " + ("supplied to `" + componentName + "`, expected `object`."));
          }
          var allKeys = assign({}, props[propName], shapeTypes);
          for (var key in allKeys) {
            var checker = shapeTypes[key];
            if (has(shapeTypes, key) && typeof checker !== "function") {
              return invalidValidatorError(componentName, location, propFullName, key, getPreciseType(checker));
            }
            if (!checker) {
              return new PropTypeError(
                "Invalid " + location + " `" + propFullName + "` key `" + key + "` supplied to `" + componentName + "`.\nBad object: " + JSON.stringify(props[propName], null, "  ") + "\nValid keys: " + JSON.stringify(Object.keys(shapeTypes), null, "  ")
              );
            }
            var error = checker(propValue, key, componentName, location, propFullName + "." + key, ReactPropTypesSecret);
            if (error) {
              return error;
            }
          }
          return null;
        }
        return createChainableTypeChecker(validate);
      }
      function isNode(propValue) {
        switch (typeof propValue) {
          case "number":
          case "string":
          case "undefined":
            return true;
          case "boolean":
            return !propValue;
          case "object":
            if (Array.isArray(propValue)) {
              return propValue.every(isNode);
            }
            if (propValue === null || isValidElement5(propValue)) {
              return true;
            }
            var iteratorFn = getIteratorFn(propValue);
            if (iteratorFn) {
              var iterator = iteratorFn.call(propValue);
              var step;
              if (iteratorFn !== propValue.entries) {
                while (!(step = iterator.next()).done) {
                  if (!isNode(step.value)) {
                    return false;
                  }
                }
              } else {
                while (!(step = iterator.next()).done) {
                  var entry = step.value;
                  if (entry) {
                    if (!isNode(entry[1])) {
                      return false;
                    }
                  }
                }
              }
            } else {
              return false;
            }
            return true;
          default:
            return false;
        }
      }
      function isSymbol(propType, propValue) {
        if (propType === "symbol") {
          return true;
        }
        if (!propValue) {
          return false;
        }
        if (propValue["@@toStringTag"] === "Symbol") {
          return true;
        }
        if (typeof Symbol === "function" && propValue instanceof Symbol) {
          return true;
        }
        return false;
      }
      function getPropType(propValue) {
        var propType = typeof propValue;
        if (Array.isArray(propValue)) {
          return "array";
        }
        if (propValue instanceof RegExp) {
          return "object";
        }
        if (isSymbol(propType, propValue)) {
          return "symbol";
        }
        return propType;
      }
      function getPreciseType(propValue) {
        if (typeof propValue === "undefined" || propValue === null) {
          return "" + propValue;
        }
        var propType = getPropType(propValue);
        if (propType === "object") {
          if (propValue instanceof Date) {
            return "date";
          } else if (propValue instanceof RegExp) {
            return "regexp";
          }
        }
        return propType;
      }
      function getPostfixForTypeWarning(value) {
        var type = getPreciseType(value);
        switch (type) {
          case "array":
          case "object":
            return "an " + type;
          case "boolean":
          case "date":
          case "regexp":
            return "a " + type;
          default:
            return type;
        }
      }
      function getClassName(propValue) {
        if (!propValue.constructor || !propValue.constructor.name) {
          return ANONYMOUS;
        }
        return propValue.constructor.name;
      }
      ReactPropTypes.checkPropTypes = checkPropTypes;
      ReactPropTypes.resetWarningCache = checkPropTypes.resetWarningCache;
      ReactPropTypes.PropTypes = ReactPropTypes;
      return ReactPropTypes;
    };
  }
});

// node_modules/prop-types/index.js
var require_prop_types = __commonJS({
  "node_modules/prop-types/index.js"(exports, module) {
    if (true) {
      ReactIs = require_react_is();
      throwOnDirectAccess = true;
      module.exports = require_factoryWithTypeCheckers()(ReactIs.isElement, throwOnDirectAccess);
    } else {
      module.exports = null();
    }
    var ReactIs;
    var throwOnDirectAccess;
  }
});

// node_modules/mapbox-gl/dist/mapbox-gl.js
var require_mapbox_gl = __commonJS({
  "node_modules/mapbox-gl/dist/mapbox-gl.js"(exports, module) {
    (function(global2, factory) {
      typeof exports === "object" && typeof module !== "undefined" ? module.exports = factory() : typeof define === "function" && define.amd ? define(factory) : (global2 = typeof globalThis !== "undefined" ? globalThis : global2 || self, global2.mapboxgl = factory());
    })(exports, function() {
      "use strict";
      var shared, worker, mapboxgl2;
      function define2(_, chunk) {
        if (!shared) {
          shared = chunk;
        } else if (!worker) {
          worker = chunk;
        } else {
          var workerBundleString = "self.onerror = function() { console.error('An error occurred while parsing the WebWorker bundle. This is most likely due to improper transpilation by Babel; please see https://docs.mapbox.com/mapbox-gl-js/guides/install/#transpiling'); }; var sharedChunk = {}; (" + shared + ")(sharedChunk); (" + worker + ")(sharedChunk); self.onerror = null;";
          var sharedChunk = {};
          shared(sharedChunk);
          mapboxgl2 = chunk(sharedChunk);
          if (typeof window !== "undefined" && window && window.URL && window.URL.createObjectURL) {
            mapboxgl2.workerUrl = window.URL.createObjectURL(new Blob([workerBundleString], { type: "text/javascript" }));
          }
        }
      }
      define2(["exports"], function(t2) {
        "use strict";
        var e2 = "undefined" != typeof self ? self : {}, r2 = "2.15.0";
        let n2;
        const i2 = { API_URL: "https://api.mapbox.com", get API_URL_REGEX() {
          if (null == n2) {
            const t3 = /^((https?:)?\/\/)?([^\/]+\.)?mapbox\.c(n|om)(\/|\?|$)/i;
            try {
              n2 = null != process.env.API_URL_REGEX ? new RegExp(process.env.API_URL_REGEX) : t3;
            } catch (e3) {
              n2 = t3;
            }
          }
          return n2;
        }, get API_TILEJSON_REGEX() {
          return /^((https?:)?\/\/)?([^\/]+\.)?mapbox\.c(n|om)(\/v[0-9]*\/.*\.json.*$)/i;
        }, get API_SPRITE_REGEX() {
          return /^((https?:)?\/\/)?([^\/]+\.)?mapbox\.c(n|om)(\/styles\/v[0-9]*\/)(.*\/sprite.*\..*$)/i;
        }, get API_FONTS_REGEX() {
          return /^((https?:)?\/\/)?([^\/]+\.)?mapbox\.c(n|om)(\/fonts\/v[0-9]*\/)(.*\.pbf.*$)/i;
        }, get API_STYLE_REGEX() {
          return /^((https?:)?\/\/)?([^\/]+\.)?mapbox\.c(n|om)(\/styles\/v[0-9]*\/)(.*$)/i;
        }, get API_CDN_URL_REGEX() {
          return /^((https?:)?\/\/)?api\.mapbox\.c(n|om)(\/mapbox-gl-js\/)(.*$)/i;
        }, get EVENTS_URL() {
          if (!i2.API_URL)
            return null;
          try {
            const t3 = new URL(i2.API_URL);
            return "api.mapbox.cn" === t3.hostname ? "https://events.mapbox.cn/events/v2" : "api.mapbox.com" === t3.hostname ? "https://events.mapbox.com/events/v2" : null;
          } catch (t3) {
            return null;
          }
        }, SESSION_PATH: "/map-sessions/v1", FEEDBACK_URL: "https://apps.mapbox.com/feedback", TILE_URL_VERSION: "v4", RASTER_URL_PREFIX: "raster/v1", REQUIRE_ACCESS_TOKEN: true, ACCESS_TOKEN: null, MAX_PARALLEL_IMAGE_REQUESTS: 16 }, s2 = { supported: false, testSupport: function(t3) {
          !l && o2 && (u2 ? c2(t3) : a2 = t3);
        } };
        let a2, o2, l = false, u2 = false;
        function c2(t3) {
          const e3 = t3.createTexture();
          t3.bindTexture(t3.TEXTURE_2D, e3);
          try {
            if (t3.texImage2D(t3.TEXTURE_2D, 0, t3.RGBA, t3.RGBA, t3.UNSIGNED_BYTE, o2), t3.isContextLost())
              return;
            s2.supported = true;
          } catch (t4) {
          }
          t3.deleteTexture(e3), l = true;
        }
        e2.document && (o2 = e2.document.createElement("img"), o2.onload = function() {
          a2 && c2(a2), a2 = null, u2 = true;
        }, o2.onerror = function() {
          l = true, a2 = null;
        }, o2.src = "data:image/webp;base64,UklGRh4AAABXRUJQVlA4TBEAAAAvAQAAAAfQ//73v/+BiOh/AAA=");
        const h2 = "01";
        function p2(t3) {
          return t3 && t3.__esModule && Object.prototype.hasOwnProperty.call(t3, "default") ? t3.default : t3;
        }
        var d2 = f2;
        function f2(t3, e3, r3, n3) {
          this.cx = 3 * t3, this.bx = 3 * (r3 - t3) - this.cx, this.ax = 1 - this.cx - this.bx, this.cy = 3 * e3, this.by = 3 * (n3 - e3) - this.cy, this.ay = 1 - this.cy - this.by, this.p1x = t3, this.p1y = e3, this.p2x = r3, this.p2y = n3;
        }
        f2.prototype = { sampleCurveX: function(t3) {
          return ((this.ax * t3 + this.bx) * t3 + this.cx) * t3;
        }, sampleCurveY: function(t3) {
          return ((this.ay * t3 + this.by) * t3 + this.cy) * t3;
        }, sampleCurveDerivativeX: function(t3) {
          return (3 * this.ax * t3 + 2 * this.bx) * t3 + this.cx;
        }, solveCurveX: function(t3, e3) {
          if (void 0 === e3 && (e3 = 1e-6), t3 < 0)
            return 0;
          if (t3 > 1)
            return 1;
          for (var r3 = t3, n3 = 0; n3 < 8; n3++) {
            var i3 = this.sampleCurveX(r3) - t3;
            if (Math.abs(i3) < e3)
              return r3;
            var s3 = this.sampleCurveDerivativeX(r3);
            if (Math.abs(s3) < 1e-6)
              break;
            r3 -= i3 / s3;
          }
          var a3 = 0, o3 = 1;
          for (r3 = t3, n3 = 0; n3 < 20 && (i3 = this.sampleCurveX(r3), !(Math.abs(i3 - t3) < e3)); n3++)
            t3 > i3 ? a3 = r3 : o3 = r3, r3 = 0.5 * (o3 - a3) + a3;
          return r3;
        }, solve: function(t3, e3) {
          return this.sampleCurveY(this.solveCurveX(t3, e3));
        } };
        var y2 = p2(d2), m2 = g2;
        function g2(t3, e3) {
          this.x = t3, this.y = e3;
        }
        g2.prototype = { clone: function() {
          return new g2(this.x, this.y);
        }, add: function(t3) {
          return this.clone()._add(t3);
        }, sub: function(t3) {
          return this.clone()._sub(t3);
        }, multByPoint: function(t3) {
          return this.clone()._multByPoint(t3);
        }, divByPoint: function(t3) {
          return this.clone()._divByPoint(t3);
        }, mult: function(t3) {
          return this.clone()._mult(t3);
        }, div: function(t3) {
          return this.clone()._div(t3);
        }, rotate: function(t3) {
          return this.clone()._rotate(t3);
        }, rotateAround: function(t3, e3) {
          return this.clone()._rotateAround(t3, e3);
        }, matMult: function(t3) {
          return this.clone()._matMult(t3);
        }, unit: function() {
          return this.clone()._unit();
        }, perp: function() {
          return this.clone()._perp();
        }, round: function() {
          return this.clone()._round();
        }, mag: function() {
          return Math.sqrt(this.x * this.x + this.y * this.y);
        }, equals: function(t3) {
          return this.x === t3.x && this.y === t3.y;
        }, dist: function(t3) {
          return Math.sqrt(this.distSqr(t3));
        }, distSqr: function(t3) {
          var e3 = t3.x - this.x, r3 = t3.y - this.y;
          return e3 * e3 + r3 * r3;
        }, angle: function() {
          return Math.atan2(this.y, this.x);
        }, angleTo: function(t3) {
          return Math.atan2(this.y - t3.y, this.x - t3.x);
        }, angleWith: function(t3) {
          return this.angleWithSep(t3.x, t3.y);
        }, angleWithSep: function(t3, e3) {
          return Math.atan2(this.x * e3 - this.y * t3, this.x * t3 + this.y * e3);
        }, _matMult: function(t3) {
          var e3 = t3[2] * this.x + t3[3] * this.y;
          return this.x = t3[0] * this.x + t3[1] * this.y, this.y = e3, this;
        }, _add: function(t3) {
          return this.x += t3.x, this.y += t3.y, this;
        }, _sub: function(t3) {
          return this.x -= t3.x, this.y -= t3.y, this;
        }, _mult: function(t3) {
          return this.x *= t3, this.y *= t3, this;
        }, _div: function(t3) {
          return this.x /= t3, this.y /= t3, this;
        }, _multByPoint: function(t3) {
          return this.x *= t3.x, this.y *= t3.y, this;
        }, _divByPoint: function(t3) {
          return this.x /= t3.x, this.y /= t3.y, this;
        }, _unit: function() {
          return this._div(this.mag()), this;
        }, _perp: function() {
          var t3 = this.y;
          return this.y = this.x, this.x = -t3, this;
        }, _rotate: function(t3) {
          var e3 = Math.cos(t3), r3 = Math.sin(t3), n3 = r3 * this.x + e3 * this.y;
          return this.x = e3 * this.x - r3 * this.y, this.y = n3, this;
        }, _rotateAround: function(t3, e3) {
          var r3 = Math.cos(t3), n3 = Math.sin(t3), i3 = e3.y + n3 * (this.x - e3.x) + r3 * (this.y - e3.y);
          return this.x = e3.x + r3 * (this.x - e3.x) - n3 * (this.y - e3.y), this.y = i3, this;
        }, _round: function() {
          return this.x = Math.round(this.x), this.y = Math.round(this.y), this;
        } }, g2.convert = function(t3) {
          return t3 instanceof g2 ? t3 : Array.isArray(t3) ? new g2(t3[0], t3[1]) : t3;
        };
        var x2 = p2(m2);
        const v2 = Math.PI / 180, b = 180 / Math.PI;
        function w(t3) {
          return t3 * v2;
        }
        function _(t3) {
          return t3 * b;
        }
        const A = [[0, 0], [1, 0], [1, 1], [0, 1]];
        function S(t3) {
          if (t3 <= 0)
            return 0;
          if (t3 >= 1)
            return 1;
          const e3 = t3 * t3, r3 = e3 * t3;
          return 4 * (t3 < 0.5 ? r3 : 3 * (t3 - e3) + r3 - 0.75);
        }
        function k(t3, e3, r3, n3) {
          const i3 = new y2(t3, e3, r3, n3);
          return function(t4) {
            return i3.solve(t4);
          };
        }
        const I = k(0.25, 0.1, 0.25, 1);
        function M(t3, e3, r3) {
          return Math.min(r3, Math.max(e3, t3));
        }
        function T(t3, e3, r3) {
          return (r3 = M((r3 - t3) / (e3 - t3), 0, 1)) * r3 * (3 - 2 * r3);
        }
        function z(t3, e3, r3) {
          const n3 = r3 - e3, i3 = ((t3 - e3) % n3 + n3) % n3 + e3;
          return i3 === e3 ? r3 : i3;
        }
        function B(t3, e3, r3) {
          if (!t3.length)
            return r3(null, []);
          let n3 = t3.length;
          const i3 = new Array(t3.length);
          let s3 = null;
          t3.forEach((t4, a3) => {
            e3(t4, (t5, e4) => {
              t5 && (s3 = t5), i3[a3] = e4, 0 == --n3 && r3(s3, i3);
            });
          });
        }
        function E2(t3) {
          const e3 = [];
          for (const r3 in t3)
            e3.push(t3[r3]);
          return e3;
        }
        function C(t3, ...e3) {
          for (const r3 of e3)
            for (const e4 in r3)
              t3[e4] = r3[e4];
          return t3;
        }
        let P = 1;
        function D() {
          return P++;
        }
        function V() {
          return function t3(e3) {
            return e3 ? (e3 ^ Math.random() * (16 >> e3 / 4)).toString(16) : ([1e7] + -[1e3] + -4e3 + -8e3 + -1e11).replace(/[018]/g, t3);
          }();
        }
        function L(t3) {
          return t3 <= 1 ? 1 : Math.pow(2, Math.ceil(Math.log(t3) / Math.LN2));
        }
        function F(t3) {
          return !!t3 && /^[0-9a-f]{8}-[0-9a-f]{4}-[4][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i.test(t3);
        }
        function R(t3, e3) {
          t3.forEach((t4) => {
            e3[t4] && (e3[t4] = e3[t4].bind(e3));
          });
        }
        function U(t3, e3) {
          return -1 !== t3.indexOf(e3, t3.length - e3.length);
        }
        function $(t3, e3, r3) {
          const n3 = {};
          for (const i3 in t3)
            n3[i3] = e3.call(r3 || this, t3[i3], i3, t3);
          return n3;
        }
        function j(t3, e3, r3) {
          const n3 = {};
          for (const i3 in t3)
            e3.call(r3 || this, t3[i3], i3, t3) && (n3[i3] = t3[i3]);
          return n3;
        }
        function O(t3) {
          return Array.isArray(t3) ? t3.map(O) : "object" == typeof t3 && t3 ? $(t3, O) : t3;
        }
        const q = {};
        function N(t3) {
          q[t3] || ("undefined" != typeof console && console.warn(t3), q[t3] = true);
        }
        function G(t3, e3, r3) {
          return (r3.y - t3.y) * (e3.x - t3.x) > (e3.y - t3.y) * (r3.x - t3.x);
        }
        function Z(t3) {
          let e3 = 0;
          for (let r3, n3, i3 = 0, s3 = t3.length, a3 = s3 - 1; i3 < s3; a3 = i3++)
            r3 = t3[i3], n3 = t3[a3], e3 += (n3.x - r3.x) * (r3.y + n3.y);
          return e3;
        }
        function K() {
          return "undefined" != typeof WorkerGlobalScope && "undefined" != typeof self && self instanceof WorkerGlobalScope;
        }
        function X(t3) {
          const e3 = {};
          if (t3.replace(/(?:^|(?:\s*\,\s*))([^\x00-\x20\(\)<>@\,;\:\\"\/\[\]\?\=\{\}\x7F]+)(?:\=(?:([^\x00-\x20\(\)<>@\,;\:\\"\/\[\]\?\=\{\}\x7F]+)|(?:\"((?:[^"\\]|\\.)*)\")))?/g, (t4, r3, n3, i3) => {
            const s3 = n3 || i3;
            return e3[r3] = !s3 || s3.toLowerCase(), "";
          }), e3["max-age"]) {
            const t4 = parseInt(e3["max-age"], 10);
            isNaN(t4) ? delete e3["max-age"] : e3["max-age"] = t4;
          }
          return e3;
        }
        let J = null;
        function H(t3) {
          if (null == J) {
            const e3 = t3.navigator ? t3.navigator.userAgent : null;
            J = !!t3.safari || !(!e3 || !(/\b(iPad|iPhone|iPod)\b/.test(e3) || e3.match("Safari") && !e3.match("Chrome")));
          }
          return J;
        }
        function Y(t3) {
          try {
            const r3 = e2[t3];
            return r3.setItem("_mapbox_test_", 1), r3.removeItem("_mapbox_test_"), true;
          } catch (t4) {
            return false;
          }
        }
        function W(t3, e3) {
          return [t3[4 * e3], t3[4 * e3 + 1], t3[4 * e3 + 2], t3[4 * e3 + 3]];
        }
        const Q = "mapbox-tiles";
        let tt = 500, et = 50;
        let rt, nt;
        function it() {
          try {
            return e2.caches;
          } catch (t3) {
          }
        }
        function st() {
          it() && !rt && (rt = e2.caches.open(Q));
        }
        function at(t3) {
          const e3 = t3.indexOf("?");
          if (e3 < 0)
            return t3;
          const r3 = function(t4) {
            const e4 = t4.indexOf("?");
            return e4 > 0 ? t4.slice(e4 + 1).split("&") : [];
          }(t3), n3 = r3.filter((t4) => {
            const e4 = t4.split("=");
            return "language" === e4[0] || "worldview" === e4[0];
          });
          return n3.length ? `${t3.slice(0, e3)}?${n3.join("&")}` : t3.slice(0, e3);
        }
        let ot = 1 / 0;
        const lt = { Unknown: "Unknown", Style: "Style", Source: "Source", Tile: "Tile", Glyphs: "Glyphs", SpriteImage: "SpriteImage", SpriteJSON: "SpriteJSON", Image: "Image" };
        "function" == typeof Object.freeze && Object.freeze(lt);
        class ut extends Error {
          constructor(t3, e3, r3) {
            401 === e3 && bt(r3) && (t3 += ": you may have provided an invalid Mapbox access token. See https://docs.mapbox.com/api/overview/#access-tokens-and-token-scopes"), super(t3), this.status = e3, this.url = r3;
          }
          toString() {
            return `${this.name}: ${this.message} (${this.status}): ${this.url}`;
          }
        }
        const ct = K() ? () => self.worker && self.worker.referrer : () => ("blob:" === e2.location.protocol ? e2.parent : e2).location.href;
        const ht = function(t3, r3) {
          if (!(/^file:/.test(n3 = t3.url) || /^file:/.test(ct()) && !/^\w+:/.test(n3))) {
            if (e2.fetch && e2.Request && e2.AbortController && e2.Request.prototype.hasOwnProperty("signal"))
              return function(t4, r4) {
                const n4 = new e2.AbortController(), i3 = new e2.Request(t4.url, { method: t4.method || "GET", body: t4.body, credentials: t4.credentials, headers: t4.headers, referrer: ct(), referrerPolicy: t4.referrerPolicy, signal: n4.signal });
                let s3 = false, a3 = false;
                const o3 = (l2 = i3.url).indexOf("sku=") > 0 && bt(l2);
                var l2;
                "json" === t4.type && i3.headers.set("Accept", "application/json");
                const u3 = (n5, s4, l3) => {
                  if (a3)
                    return;
                  if (n5 && "SecurityError" !== n5.message && N(n5.toString()), s4 && l3)
                    return c3(s4);
                  const u4 = Date.now();
                  e2.fetch(i3).then((e3) => {
                    if (e3.ok) {
                      const t5 = o3 ? e3.clone() : null;
                      return c3(e3, t5, u4);
                    }
                    return r4(new ut(e3.statusText, e3.status, t4.url));
                  }).catch((e3) => {
                    "AbortError" !== e3.name && r4(new Error(`${e3.message} ${t4.url}`));
                  });
                }, c3 = (n5, o4, l3) => {
                  ("arrayBuffer" === t4.type ? n5.arrayBuffer() : "json" === t4.type ? n5.json() : n5.text()).then((t5) => {
                    a3 || (o4 && l3 && function(t6, r5, n6) {
                      if (st(), !rt)
                        return;
                      const i4 = { status: r5.status, statusText: r5.statusText, headers: new e2.Headers() };
                      r5.headers.forEach((t7, e3) => i4.headers.set(e3, t7));
                      const s4 = X(r5.headers.get("Cache-Control") || "");
                      if (s4["no-store"])
                        return;
                      s4["max-age"] && i4.headers.set("Expires", new Date(n6 + 1e3 * s4["max-age"]).toUTCString());
                      const a4 = i4.headers.get("Expires");
                      a4 && (new Date(a4).getTime() - n6 < 42e4 || function(t7, e3) {
                        if (void 0 === nt)
                          try {
                            new Response(new ReadableStream()), nt = true;
                          } catch (t8) {
                            nt = false;
                          }
                        nt ? e3(t7.body) : t7.blob().then(e3);
                      }(r5, (r6) => {
                        const n7 = new e2.Response(r6, i4);
                        st(), rt && rt.then((e3) => e3.put(at(t6.url), n7)).catch((t7) => N(t7.message));
                      }));
                    }(i3, o4, l3), s3 = true, r4(null, t5, n5.headers.get("Cache-Control"), n5.headers.get("Expires")));
                  }).catch((t5) => {
                    a3 || r4(new Error(t5.message));
                  });
                };
                return o3 ? function(t5, e3) {
                  if (st(), !rt)
                    return e3(null);
                  const r5 = at(t5.url);
                  rt.then((t6) => {
                    t6.match(r5).then((n5) => {
                      const i4 = function(t7) {
                        if (!t7)
                          return false;
                        const e4 = new Date(t7.headers.get("Expires") || 0), r6 = X(t7.headers.get("Cache-Control") || "");
                        return e4 > Date.now() && !r6["no-cache"];
                      }(n5);
                      t6.delete(r5), i4 && t6.put(r5, n5.clone()), e3(null, n5, i4);
                    }).catch(e3);
                  }).catch(e3);
                }(i3, u3) : u3(null, null), { cancel: () => {
                  a3 = true, s3 || n4.abort();
                } };
              }(t3, r3);
            if (K() && self.worker && self.worker.actor)
              return self.worker.actor.send("getResource", t3, r3, void 0, true);
          }
          var n3;
          return function(t4, r4) {
            const n4 = new e2.XMLHttpRequest();
            n4.open(t4.method || "GET", t4.url, true), "arrayBuffer" === t4.type && (n4.responseType = "arraybuffer");
            for (const e3 in t4.headers)
              n4.setRequestHeader(e3, t4.headers[e3]);
            return "json" === t4.type && (n4.responseType = "text", n4.setRequestHeader("Accept", "application/json")), n4.withCredentials = "include" === t4.credentials, n4.onerror = () => {
              r4(new Error(n4.statusText));
            }, n4.onload = () => {
              if ((n4.status >= 200 && n4.status < 300 || 0 === n4.status) && null !== n4.response) {
                let e3 = n4.response;
                if ("json" === t4.type)
                  try {
                    e3 = JSON.parse(n4.response);
                  } catch (t5) {
                    return r4(t5);
                  }
                r4(null, e3, n4.getResponseHeader("Cache-Control"), n4.getResponseHeader("Expires"));
              } else
                r4(new ut(n4.statusText, n4.status, t4.url));
            }, n4.send(t4.body), { cancel: () => n4.abort() };
          }(t3, r3);
        }, pt = function(t3, e3) {
          return ht(C(t3, { type: "arrayBuffer" }), e3);
        };
        function dt(t3) {
          const r3 = e2.document.createElement("a");
          return r3.href = t3, r3.protocol === e2.document.location.protocol && r3.host === e2.document.location.host;
        }
        const ft = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAC0lEQVQYV2NgAAIAAAUAAarVyFEAAAAASUVORK5CYII=";
        let yt, mt;
        yt = [], mt = 0;
        const gt = function(t3, r3) {
          if (s2.supported && (t3.headers || (t3.headers = {}), t3.headers.accept = "image/webp,*/*"), mt >= i2.MAX_PARALLEL_IMAGE_REQUESTS) {
            const e3 = { requestParameters: t3, callback: r3, cancelled: false, cancel() {
              this.cancelled = true;
            } };
            return yt.push(e3), e3;
          }
          mt++;
          let n3 = false;
          const a3 = () => {
            if (!n3)
              for (n3 = true, mt--; yt.length && mt < i2.MAX_PARALLEL_IMAGE_REQUESTS; ) {
                const t4 = yt.shift(), { requestParameters: e3, callback: r4, cancelled: n4 } = t4;
                n4 || (t4.cancel = gt(e3, r4).cancel);
              }
          }, o3 = pt(t3, (t4, n4, i3, s3) => {
            a3(), t4 ? r3(t4) : n4 && (e2.createImageBitmap ? function(t5, r4) {
              const n5 = new e2.Blob([new Uint8Array(t5)], { type: "image/png" });
              e2.createImageBitmap(n5).then((t6) => {
                r4(null, t6);
              }).catch((t6) => {
                r4(new Error(`Could not load image because of ${t6.message}. Please make sure to use a supported image type such as PNG or JPEG. Note that SVGs are not supported.`));
              });
            }(n4, (t5, e3) => r3(t5, e3, i3, s3)) : function(t5, r4) {
              const n5 = new e2.Image(), i4 = e2.URL;
              n5.onload = () => {
                r4(null, n5), i4.revokeObjectURL(n5.src), n5.onload = null, e2.requestAnimationFrame(() => {
                  n5.src = ft;
                });
              }, n5.onerror = () => r4(new Error("Could not load image. Please make sure to use a supported image type such as PNG or JPEG. Note that SVGs are not supported."));
              const s4 = new e2.Blob([new Uint8Array(t5)], { type: "image/png" });
              n5.src = t5.byteLength ? i4.createObjectURL(s4) : ft;
            }(n4, (t5, e3) => r3(t5, e3, i3, s3)));
          });
          return { cancel: () => {
            o3.cancel(), a3();
          } };
        }, xt = "NO_ACCESS_TOKEN";
        function vt(t3) {
          return 0 === t3.indexOf("mapbox:");
        }
        function bt(t3) {
          return i2.API_URL_REGEX.test(t3);
        }
        function wt(t3) {
          return i2.API_CDN_URL_REGEX.test(t3);
        }
        function _t(t3) {
          return i2.API_STYLE_REGEX.test(t3) && !At(t3);
        }
        function At(t3) {
          return i2.API_SPRITE_REGEX.test(t3);
        }
        const St = /^(\w+):\/\/([^/?]*)(\/[^?]+)?\??(.+)?/;
        function kt(t3) {
          const e3 = t3.match(St);
          if (!e3)
            throw new Error("Unable to parse URL object");
          return { protocol: e3[1], authority: e3[2], path: e3[3] || "/", params: e3[4] ? e3[4].split("&") : [] };
        }
        function It(t3) {
          const e3 = t3.params.length ? `?${t3.params.join("&")}` : "";
          return `${t3.protocol}://${t3.authority}${t3.path}${e3}`;
        }
        const Mt = "mapbox.eventData";
        function Tt(t3) {
          if (!t3)
            return null;
          const r3 = t3.split(".");
          if (!r3 || 3 !== r3.length)
            return null;
          try {
            return JSON.parse(decodeURIComponent(e2.atob(r3[1]).split("").map((t4) => "%" + ("00" + t4.charCodeAt(0).toString(16)).slice(-2)).join("")));
          } catch (t4) {
            return null;
          }
        }
        class zt {
          constructor(t3) {
            this.type = t3, this.anonId = null, this.eventData = {}, this.queue = [], this.pendingRequest = null;
          }
          getStorageKey(t3) {
            const r3 = Tt(i2.ACCESS_TOKEN);
            let n3 = "";
            return n3 = r3 && r3.u ? e2.btoa(encodeURIComponent(r3.u).replace(/%([0-9A-F]{2})/g, (t4, e3) => String.fromCharCode(Number("0x" + e3)))) : i2.ACCESS_TOKEN || "", t3 ? `${Mt}.${t3}:${n3}` : `${Mt}:${n3}`;
          }
          fetchEventData() {
            const t3 = Y("localStorage"), r3 = this.getStorageKey(), n3 = this.getStorageKey("uuid");
            if (t3)
              try {
                const t4 = e2.localStorage.getItem(r3);
                t4 && (this.eventData = JSON.parse(t4));
                const i3 = e2.localStorage.getItem(n3);
                i3 && (this.anonId = i3);
              } catch (t4) {
                N("Unable to read from LocalStorage");
              }
          }
          saveEventData() {
            const t3 = Y("localStorage"), r3 = this.getStorageKey(), n3 = this.getStorageKey("uuid");
            if (t3)
              try {
                e2.localStorage.setItem(n3, this.anonId), Object.keys(this.eventData).length >= 1 && e2.localStorage.setItem(r3, JSON.stringify(this.eventData));
              } catch (t4) {
                N("Unable to write to LocalStorage");
              }
          }
          processRequests(t3) {
          }
          postEvent(t3, e3, r3, n3) {
            if (!i2.EVENTS_URL)
              return;
            const s3 = kt(i2.EVENTS_URL);
            s3.params.push(`access_token=${n3 || i2.ACCESS_TOKEN || ""}`);
            const a3 = { event: this.type, created: new Date(t3).toISOString() }, o3 = e3 ? C(a3, e3) : a3, l2 = { url: It(s3), headers: { "Content-Type": "text/plain" }, body: JSON.stringify([o3]) };
            this.pendingRequest = function(t4, e4) {
              return ht(C(t4, { method: "POST" }), e4);
            }(l2, (t4) => {
              this.pendingRequest = null, r3(t4), this.saveEventData(), this.processRequests(n3);
            });
          }
          queueRequest(t3, e3) {
            this.queue.push(t3), this.processRequests(e3);
          }
        }
        const Bt = new class extends zt {
          constructor(t3) {
            super("appUserTurnstile"), this._customAccessToken = t3;
          }
          postTurnstileEvent(t3, e3) {
            i2.EVENTS_URL && i2.ACCESS_TOKEN && Array.isArray(t3) && t3.some((t4) => vt(t4) || bt(t4)) && this.queueRequest(Date.now(), e3);
          }
          processRequests(t3) {
            if (this.pendingRequest || 0 === this.queue.length)
              return;
            this.anonId && this.eventData.lastSuccess && this.eventData.tokenU || this.fetchEventData();
            const e3 = Tt(i2.ACCESS_TOKEN), n3 = e3 ? e3.u : i2.ACCESS_TOKEN;
            let s3 = n3 !== this.eventData.tokenU;
            F(this.anonId) || (this.anonId = V(), s3 = true);
            const a3 = this.queue.shift();
            if (this.eventData.lastSuccess) {
              const t4 = new Date(this.eventData.lastSuccess), e4 = new Date(a3), r3 = (a3 - this.eventData.lastSuccess) / 864e5;
              s3 = s3 || r3 >= 1 || r3 < -1 || t4.getDate() !== e4.getDate();
            } else
              s3 = true;
            s3 ? this.postEvent(a3, { sdkIdentifier: "mapbox-gl-js", sdkVersion: r2, skuId: h2, "enabled.telemetry": false, userId: this.anonId }, (t4) => {
              t4 || (this.eventData.lastSuccess = a3, this.eventData.tokenU = n3);
            }, t3) : this.processRequests();
          }
        }(), Et = Bt.postTurnstileEvent.bind(Bt), Ct = new class extends zt {
          constructor() {
            super("map.load"), this.success = {}, this.skuToken = "";
          }
          postMapLoadEvent(t3, e3, r3, n3) {
            this.skuToken = e3, this.errorCb = n3, i2.EVENTS_URL && (r3 || i2.ACCESS_TOKEN ? this.queueRequest({ id: t3, timestamp: Date.now() }, r3) : this.errorCb(new Error(xt)));
          }
          processRequests(t3) {
            if (this.pendingRequest || 0 === this.queue.length)
              return;
            const { id: e3, timestamp: n3 } = this.queue.shift();
            e3 && this.success[e3] || (this.anonId || this.fetchEventData(), F(this.anonId) || (this.anonId = V()), this.postEvent(n3, { sdkIdentifier: "mapbox-gl-js", sdkVersion: r2, skuId: h2, skuToken: this.skuToken, userId: this.anonId }, (t4) => {
              t4 ? this.errorCb(t4) : e3 && (this.success[e3] = true);
            }, t3));
          }
        }(), Pt = Ct.postMapLoadEvent.bind(Ct), Dt = new class extends zt {
          constructor() {
            super("gljs.performance");
          }
          postPerformanceEvent(t3, e3) {
            i2.EVENTS_URL && (t3 || i2.ACCESS_TOKEN) && this.queueRequest({ timestamp: Date.now(), performanceData: e3 }, t3);
          }
          processRequests(t3) {
            if (this.pendingRequest || 0 === this.queue.length)
              return;
            const { timestamp: n3, performanceData: i3 } = this.queue.shift(), s3 = function(t4) {
              const n4 = e2.performance.getEntriesByType("resource"), i4 = e2.performance.getEntriesByType("mark"), s4 = function(t5) {
                const e3 = {};
                if (t5) {
                  for (const r3 in t5)
                    if ("other" !== r3)
                      for (const n5 of t5[r3]) {
                        const t6 = `${r3}ResolveRangeMin`, i5 = `${r3}ResolveRangeMax`, s5 = `${r3}RequestCount`, a4 = `${r3}RequestCachedCount`;
                        e3[t6] = Math.min(e3[t6] || 1 / 0, n5.startTime), e3[i5] = Math.max(e3[i5] || -1 / 0, n5.responseEnd);
                        const o4 = (t7) => {
                          void 0 === e3[t7] && (e3[t7] = 0), ++e3[t7];
                        };
                        void 0 !== n5.transferSize && 0 === n5.transferSize && o4(a4), o4(s5);
                      }
                }
                return e3;
              }(function(t5, e3) {
                const r3 = {};
                if (t5)
                  for (const n5 of t5) {
                    const t6 = e3(n5);
                    void 0 === r3[t6] && (r3[t6] = []), r3[t6].push(n5);
                  }
                return r3;
              }(n4, jt)), a3 = e2.devicePixelRatio, o3 = e2.navigator.connection || e2.navigator.mozConnection || e2.navigator.webkitConnection, l2 = { counters: [], metadata: [], attributes: [] }, u3 = (t5, e3, r3) => {
                null != r3 && t5.push({ name: e3, value: r3.toString() });
              };
              for (const t5 in s4)
                u3(l2.counters, t5, s4[t5]);
              if (t4.interactionRange[0] !== 1 / 0 && t4.interactionRange[1] !== -1 / 0 && (u3(l2.counters, "interactionRangeMin", t4.interactionRange[0]), u3(l2.counters, "interactionRangeMax", t4.interactionRange[1])), i4)
                for (const t5 of Object.keys(Ut)) {
                  const e3 = Ut[t5], r3 = i4.find((t6) => t6.name === e3);
                  r3 && u3(l2.counters, e3, r3.startTime);
                }
              return u3(l2.counters, "visibilityHidden", t4.visibilityHidden), u3(l2.attributes, "style", function(t5) {
                if (t5)
                  for (const e3 of t5) {
                    const t6 = e3.name.split("?")[0];
                    if (_t(t6)) {
                      const e4 = t6.split("/").slice(-2);
                      if (2 === e4.length)
                        return `mapbox://styles/${e4[0]}/${e4[1]}`;
                    }
                  }
              }(n4)), u3(l2.attributes, "terrainEnabled", t4.terrainEnabled ? "true" : "false"), u3(l2.attributes, "fogEnabled", t4.fogEnabled ? "true" : "false"), u3(l2.attributes, "projection", t4.projection), u3(l2.attributes, "zoom", t4.zoom), u3(l2.metadata, "devicePixelRatio", a3), u3(l2.metadata, "connectionEffectiveType", o3 ? o3.effectiveType : void 0), u3(l2.metadata, "navigatorUserAgent", e2.navigator.userAgent), u3(l2.metadata, "screenWidth", e2.screen.width), u3(l2.metadata, "screenHeight", e2.screen.height), u3(l2.metadata, "windowWidth", e2.innerWidth), u3(l2.metadata, "windowHeight", e2.innerHeight), u3(l2.metadata, "mapWidth", t4.width / a3), u3(l2.metadata, "mapHeight", t4.height / a3), u3(l2.metadata, "webglRenderer", t4.renderer), u3(l2.metadata, "webglVendor", t4.vendor), u3(l2.metadata, "sdkVersion", r2), u3(l2.metadata, "sdkIdentifier", "mapbox-gl-js"), l2;
            }(i3);
            for (const t4 of s3.metadata)
              ;
            for (const t4 of s3.counters)
              ;
            for (const t4 of s3.attributes)
              ;
            this.postEvent(n3, s3, () => {
            }, t3);
          }
        }(), Vt = Dt.postPerformanceEvent.bind(Dt), Lt = new class extends zt {
          constructor() {
            super("map.auth"), this.success = {}, this.skuToken = "";
          }
          getSession(t3, e3, r3, n3) {
            if (!i2.API_URL || !i2.SESSION_PATH)
              return;
            const s3 = kt(i2.API_URL + i2.SESSION_PATH);
            s3.params.push(`sku=${e3 || ""}`), s3.params.push(`access_token=${n3 || i2.ACCESS_TOKEN || ""}`);
            const a3 = { url: It(s3), headers: { "Content-Type": "text/plain" } };
            this.pendingRequest = function(t4, e4) {
              return ht(C(t4, { method: "GET" }), e4);
            }(a3, (t4) => {
              this.pendingRequest = null, r3(t4), this.saveEventData(), this.processRequests(n3);
            });
          }
          getSessionAPI(t3, e3, r3, n3) {
            this.skuToken = e3, this.errorCb = n3, i2.SESSION_PATH && i2.API_URL && (r3 || i2.ACCESS_TOKEN ? this.queueRequest({ id: t3, timestamp: Date.now() }, r3) : this.errorCb(new Error(xt)));
          }
          processRequests(t3) {
            if (this.pendingRequest || 0 === this.queue.length)
              return;
            const { id: e3, timestamp: r3 } = this.queue.shift();
            e3 && this.success[e3] || this.getSession(r3, this.skuToken, (t4) => {
              t4 ? this.errorCb(t4) : e3 && (this.success[e3] = true);
            }, t3);
          }
        }(), Ft = Lt.getSessionAPI.bind(Lt), Rt = /* @__PURE__ */ new Set(), Ut = { create: "create", load: "load", fullLoad: "fullLoad" }, $t = { mark(t3) {
          e2.performance.mark(t3);
        }, measure(t3, r3, n3) {
          e2.performance.measure(t3, r3, n3);
        } };
        function jt(t3) {
          const e3 = t3.name.split("?")[0];
          return wt(e3) && e3.includes("mapbox-gl.js") ? "javascript" : wt(e3) && e3.includes("mapbox-gl.css") ? "css" : function(t4) {
            return i2.API_FONTS_REGEX.test(t4);
          }(e3) ? "fontRange" : At(e3) ? "sprite" : _t(e3) ? "style" : function(t4) {
            return i2.API_TILEJSON_REGEX.test(t4);
          }(e3) ? "tilejson" : "other";
        }
        const Ot = e2.performance;
        function qt(t3) {
          const e3 = t3 ? t3.url.toString() : void 0;
          return Ot.getEntriesByName(e3);
        }
        let Nt, Gt, Zt, Kt;
        const Xt = { now: () => void 0 !== Zt ? Zt : e2.performance.now(), setNow(t3) {
          Zt = t3;
        }, restoreNow() {
          Zt = void 0;
        }, frame(t3) {
          const r3 = e2.requestAnimationFrame(t3);
          return { cancel: () => e2.cancelAnimationFrame(r3) };
        }, getImageData(t3, r3 = 0) {
          const { width: n3, height: i3 } = t3;
          Kt || (Kt = e2.document.createElement("canvas"));
          const s3 = Kt.getContext("2d", { willReadFrequently: true });
          if (!s3)
            throw new Error("failed to create canvas 2d context");
          return (n3 > Kt.width || i3 > Kt.height) && (Kt.width = n3, Kt.height = i3), s3.clearRect(-r3, -r3, n3 + 2 * r3, i3 + 2 * r3), s3.drawImage(t3, 0, 0, n3, i3), s3.getImageData(-r3, -r3, n3 + 2 * r3, i3 + 2 * r3);
        }, resolveURL: (t3) => (Nt || (Nt = e2.document.createElement("a")), Nt.href = t3, Nt.href), get devicePixelRatio() {
          return e2.devicePixelRatio;
        }, get prefersReducedMotion() {
          return !!e2.matchMedia && (null == Gt && (Gt = e2.matchMedia("(prefers-reduced-motion: reduce)")), Gt.matches);
        } };
        function Jt(t3, e3, r3) {
          r3[t3] && -1 !== r3[t3].indexOf(e3) || (r3[t3] = r3[t3] || [], r3[t3].push(e3));
        }
        function Ht(t3, e3, r3) {
          if (r3 && r3[t3]) {
            const n3 = r3[t3].indexOf(e3);
            -1 !== n3 && r3[t3].splice(n3, 1);
          }
        }
        class Yt {
          constructor(t3, e3 = {}) {
            C(this, e3), this.type = t3;
          }
        }
        class Wt extends Yt {
          constructor(t3, e3 = {}) {
            super("error", C({ error: t3 }, e3));
          }
        }
        class Qt {
          on(t3, e3) {
            return this._listeners = this._listeners || {}, Jt(t3, e3, this._listeners), this;
          }
          off(t3, e3) {
            return Ht(t3, e3, this._listeners), Ht(t3, e3, this._oneTimeListeners), this;
          }
          once(t3, e3) {
            return e3 ? (this._oneTimeListeners = this._oneTimeListeners || {}, Jt(t3, e3, this._oneTimeListeners), this) : new Promise((e4) => this.once(t3, e4));
          }
          fire(t3, e3) {
            "string" == typeof t3 && (t3 = new Yt(t3, e3 || {}));
            const r3 = t3.type;
            if (this.listens(r3)) {
              t3.target = this;
              const e4 = this._listeners && this._listeners[r3] ? this._listeners[r3].slice() : [];
              for (const r4 of e4)
                r4.call(this, t3);
              const n3 = this._oneTimeListeners && this._oneTimeListeners[r3] ? this._oneTimeListeners[r3].slice() : [];
              for (const e5 of n3)
                Ht(r3, e5, this._oneTimeListeners), e5.call(this, t3);
              const i3 = this._eventedParent;
              i3 && (C(t3, "function" == typeof this._eventedParentData ? this._eventedParentData() : this._eventedParentData), i3.fire(t3));
            } else
              t3 instanceof Wt && console.error(t3.error);
            return this;
          }
          listens(t3) {
            return !!(this._listeners && this._listeners[t3] && this._listeners[t3].length > 0 || this._oneTimeListeners && this._oneTimeListeners[t3] && this._oneTimeListeners[t3].length > 0 || this._eventedParent && this._eventedParent.listens(t3));
          }
          setEventedParent(t3, e3) {
            return this._eventedParent = t3, this._eventedParentData = e3, this;
          }
        }
        var te = JSON.parse('{"$version":8,"$root":{"version":{"required":true,"type":"enum","values":[8]},"name":{"type":"string"},"metadata":{"type":"*"},"center":{"type":"array","value":"number"},"zoom":{"type":"number"},"bearing":{"type":"number","default":0,"period":360,"units":"degrees"},"pitch":{"type":"number","default":0,"units":"degrees"},"light":{"type":"light"},"terrain":{"type":"terrain"},"fog":{"type":"fog"},"sources":{"required":true,"type":"sources"},"sprite":{"type":"string"},"glyphs":{"type":"string"},"transition":{"type":"transition"},"projection":{"type":"projection"},"layers":{"required":true,"type":"array","value":"layer"}},"sources":{"*":{"type":"source"}},"source":["source_vector","source_raster","source_raster_dem","source_geojson","source_video","source_image"],"source_vector":{"type":{"required":true,"type":"enum","values":{"vector":{}}},"url":{"type":"string"},"tiles":{"type":"array","value":"string"},"bounds":{"type":"array","value":"number","length":4,"default":[-180,-85.051129,180,85.051129]},"scheme":{"type":"enum","values":{"xyz":{},"tms":{}},"default":"xyz"},"minzoom":{"type":"number","default":0},"maxzoom":{"type":"number","default":22},"attribution":{"type":"string"},"promoteId":{"type":"promoteId"},"volatile":{"type":"boolean","default":false},"*":{"type":"*"}},"source_raster":{"type":{"required":true,"type":"enum","values":{"raster":{}}},"url":{"type":"string"},"tiles":{"type":"array","value":"string"},"bounds":{"type":"array","value":"number","length":4,"default":[-180,-85.051129,180,85.051129]},"minzoom":{"type":"number","default":0},"maxzoom":{"type":"number","default":22},"tileSize":{"type":"number","default":512,"units":"pixels"},"scheme":{"type":"enum","values":{"xyz":{},"tms":{}},"default":"xyz"},"attribution":{"type":"string"},"volatile":{"type":"boolean","default":false},"*":{"type":"*"}},"source_raster_dem":{"type":{"required":true,"type":"enum","values":{"raster-dem":{}}},"url":{"type":"string"},"tiles":{"type":"array","value":"string"},"bounds":{"type":"array","value":"number","length":4,"default":[-180,-85.051129,180,85.051129]},"minzoom":{"type":"number","default":0},"maxzoom":{"type":"number","default":22},"tileSize":{"type":"number","default":512,"units":"pixels"},"attribution":{"type":"string"},"encoding":{"type":"enum","values":{"terrarium":{},"mapbox":{}},"default":"mapbox"},"volatile":{"type":"boolean","default":false},"*":{"type":"*"}},"source_geojson":{"type":{"required":true,"type":"enum","values":{"geojson":{}}},"data":{"type":"*"},"maxzoom":{"type":"number","default":18},"attribution":{"type":"string"},"buffer":{"type":"number","default":128,"maximum":512,"minimum":0},"filter":{"type":"*"},"tolerance":{"type":"number","default":0.375},"cluster":{"type":"boolean","default":false},"clusterRadius":{"type":"number","default":50,"minimum":0},"clusterMaxZoom":{"type":"number"},"clusterMinPoints":{"type":"number"},"clusterProperties":{"type":"*"},"lineMetrics":{"type":"boolean","default":false},"generateId":{"type":"boolean","default":false},"promoteId":{"type":"promoteId"}},"source_video":{"type":{"required":true,"type":"enum","values":{"video":{}}},"urls":{"required":true,"type":"array","value":"string"},"coordinates":{"required":true,"type":"array","length":4,"value":{"type":"array","length":2,"value":"number"}}},"source_image":{"type":{"required":true,"type":"enum","values":{"image":{}}},"url":{"required":true,"type":"string"},"coordinates":{"required":true,"type":"array","length":4,"value":{"type":"array","length":2,"value":"number"}}},"layer":{"id":{"type":"string","required":true},"type":{"type":"enum","values":{"fill":{},"line":{},"symbol":{},"circle":{},"heatmap":{},"fill-extrusion":{},"raster":{},"hillshade":{},"background":{},"sky":{}},"required":true},"metadata":{"type":"*"},"source":{"type":"string"},"source-layer":{"type":"string"},"minzoom":{"type":"number","minimum":0,"maximum":24},"maxzoom":{"type":"number","minimum":0,"maximum":24},"filter":{"type":"filter"},"layout":{"type":"layout"},"paint":{"type":"paint"}},"layout":["layout_fill","layout_line","layout_circle","layout_heatmap","layout_fill-extrusion","layout_symbol","layout_raster","layout_hillshade","layout_background","layout_sky"],"layout_background":{"visibility":{"type":"enum","values":{"visible":{},"none":{}},"default":"visible","property-type":"constant"}},"layout_sky":{"visibility":{"type":"enum","values":{"visible":{},"none":{}},"default":"visible","property-type":"constant"}},"layout_fill":{"fill-sort-key":{"type":"number","expression":{"interpolated":false,"parameters":["zoom","feature"]},"property-type":"data-driven"},"visibility":{"type":"enum","values":{"visible":{},"none":{}},"default":"visible","property-type":"constant"}},"layout_circle":{"circle-sort-key":{"type":"number","expression":{"interpolated":false,"parameters":["zoom","feature"]},"property-type":"data-driven"},"visibility":{"type":"enum","values":{"visible":{},"none":{}},"default":"visible","property-type":"constant"}},"layout_heatmap":{"visibility":{"type":"enum","values":{"visible":{},"none":{}},"default":"visible","property-type":"constant"}},"layout_fill-extrusion":{"visibility":{"type":"enum","values":{"visible":{},"none":{}},"default":"visible","property-type":"constant"},"fill-extrusion-edge-radius":{"type":"number","private":true,"default":0,"minimum":0,"maximum":1,"property-type":"constant"}},"layout_line":{"line-cap":{"type":"enum","values":{"butt":{},"round":{},"square":{}},"default":"butt","expression":{"interpolated":false,"parameters":["zoom","feature"]},"property-type":"data-driven"},"line-join":{"type":"enum","values":{"bevel":{},"round":{},"miter":{}},"default":"miter","expression":{"interpolated":false,"parameters":["zoom","feature"]},"property-type":"data-driven"},"line-miter-limit":{"type":"number","default":2,"requires":[{"line-join":"miter"}],"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"line-round-limit":{"type":"number","default":1.05,"requires":[{"line-join":"round"}],"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"line-sort-key":{"type":"number","expression":{"interpolated":false,"parameters":["zoom","feature"]},"property-type":"data-driven"},"visibility":{"type":"enum","values":{"visible":{},"none":{}},"default":"visible","property-type":"constant"}},"layout_symbol":{"symbol-placement":{"type":"enum","values":{"point":{},"line":{},"line-center":{}},"default":"point","expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"symbol-spacing":{"type":"number","default":250,"minimum":1,"units":"pixels","requires":[{"symbol-placement":"line"}],"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"symbol-avoid-edges":{"type":"boolean","default":false,"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"symbol-sort-key":{"type":"number","expression":{"interpolated":false,"parameters":["zoom","feature"]},"property-type":"data-driven"},"symbol-z-order":{"type":"enum","values":{"auto":{},"viewport-y":{},"source":{}},"default":"auto","expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"icon-allow-overlap":{"type":"boolean","default":false,"requires":["icon-image"],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"icon-ignore-placement":{"type":"boolean","default":false,"requires":["icon-image"],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"icon-optional":{"type":"boolean","default":false,"requires":["icon-image","text-field"],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"icon-rotation-alignment":{"type":"enum","values":{"map":{},"viewport":{},"auto":{}},"default":"auto","requires":["icon-image"],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"icon-size":{"type":"number","default":1,"minimum":0,"units":"factor of the original icon size","requires":["icon-image"],"expression":{"interpolated":true,"parameters":["zoom","feature"]},"property-type":"data-driven"},"icon-text-fit":{"type":"enum","values":{"none":{},"width":{},"height":{},"both":{}},"default":"none","requires":["icon-image","text-field"],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"icon-text-fit-padding":{"type":"array","value":"number","length":4,"default":[0,0,0,0],"units":"pixels","requires":["icon-image","text-field",{"icon-text-fit":["both","width","height"]}],"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"icon-image":{"type":"resolvedImage","tokens":true,"expression":{"interpolated":false,"parameters":["zoom","feature"]},"property-type":"data-driven"},"icon-rotate":{"type":"number","default":0,"period":360,"units":"degrees","requires":["icon-image"],"expression":{"interpolated":true,"parameters":["zoom","feature"]},"property-type":"data-driven"},"icon-padding":{"type":"number","default":2,"minimum":0,"units":"pixels","requires":["icon-image"],"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"icon-keep-upright":{"type":"boolean","default":false,"requires":["icon-image",{"icon-rotation-alignment":"map"},{"symbol-placement":["line","line-center"]}],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"icon-offset":{"type":"array","value":"number","length":2,"default":[0,0],"requires":["icon-image"],"expression":{"interpolated":true,"parameters":["zoom","feature"]},"property-type":"data-driven"},"icon-anchor":{"type":"enum","values":{"center":{},"left":{},"right":{},"top":{},"bottom":{},"top-left":{},"top-right":{},"bottom-left":{},"bottom-right":{}},"default":"center","requires":["icon-image"],"expression":{"interpolated":false,"parameters":["zoom","feature"]},"property-type":"data-driven"},"icon-pitch-alignment":{"type":"enum","values":{"map":{},"viewport":{},"auto":{}},"default":"auto","requires":["icon-image"],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"text-pitch-alignment":{"type":"enum","values":{"map":{},"viewport":{},"auto":{}},"default":"auto","requires":["text-field"],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"text-rotation-alignment":{"type":"enum","values":{"map":{},"viewport":{},"auto":{}},"default":"auto","requires":["text-field"],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"text-field":{"type":"formatted","default":"","tokens":true,"expression":{"interpolated":false,"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-font":{"type":"array","value":"string","default":["Open Sans Regular","Arial Unicode MS Regular"],"requires":["text-field"],"expression":{"interpolated":false,"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-size":{"type":"number","default":16,"minimum":0,"units":"pixels","requires":["text-field"],"expression":{"interpolated":true,"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-max-width":{"type":"number","default":10,"minimum":0,"units":"ems","requires":["text-field",{"symbol-placement":["point"]}],"expression":{"interpolated":true,"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-line-height":{"type":"number","default":1.2,"units":"ems","requires":["text-field"],"expression":{"interpolated":true,"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-letter-spacing":{"type":"number","default":0,"units":"ems","requires":["text-field"],"expression":{"interpolated":true,"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-justify":{"type":"enum","values":{"auto":{},"left":{},"center":{},"right":{}},"default":"center","requires":["text-field"],"expression":{"interpolated":false,"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-radial-offset":{"type":"number","units":"ems","default":0,"requires":["text-field"],"property-type":"data-driven","expression":{"interpolated":true,"parameters":["zoom","feature"]}},"text-variable-anchor":{"type":"array","value":"enum","values":{"center":{},"left":{},"right":{},"top":{},"bottom":{},"top-left":{},"top-right":{},"bottom-left":{},"bottom-right":{}},"requires":["text-field",{"symbol-placement":["point"]}],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"text-anchor":{"type":"enum","values":{"center":{},"left":{},"right":{},"top":{},"bottom":{},"top-left":{},"top-right":{},"bottom-left":{},"bottom-right":{}},"default":"center","requires":["text-field",{"!":"text-variable-anchor"}],"expression":{"interpolated":false,"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-max-angle":{"type":"number","default":45,"units":"degrees","requires":["text-field",{"symbol-placement":["line","line-center"]}],"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"text-writing-mode":{"type":"array","value":"enum","values":{"horizontal":{},"vertical":{}},"requires":["text-field"],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"text-rotate":{"type":"number","default":0,"period":360,"units":"degrees","requires":["text-field"],"expression":{"interpolated":true,"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-padding":{"type":"number","default":2,"minimum":0,"units":"pixels","requires":["text-field"],"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"text-keep-upright":{"type":"boolean","default":true,"requires":["text-field",{"text-rotation-alignment":"map"},{"symbol-placement":["line","line-center"]}],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"text-transform":{"type":"enum","values":{"none":{},"uppercase":{},"lowercase":{}},"default":"none","requires":["text-field"],"expression":{"interpolated":false,"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-offset":{"type":"array","value":"number","units":"ems","length":2,"default":[0,0],"requires":["text-field",{"!":"text-radial-offset"}],"expression":{"interpolated":true,"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-allow-overlap":{"type":"boolean","default":false,"requires":["text-field"],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"text-ignore-placement":{"type":"boolean","default":false,"requires":["text-field"],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"text-optional":{"type":"boolean","default":false,"requires":["text-field","icon-image"],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"visibility":{"type":"enum","values":{"visible":{},"none":{}},"default":"visible","property-type":"constant"}},"layout_raster":{"visibility":{"type":"enum","values":{"visible":{},"none":{}},"default":"visible","property-type":"constant"}},"layout_hillshade":{"visibility":{"type":"enum","values":{"visible":{},"none":{}},"default":"visible","property-type":"constant"}},"filter":{"type":"array","value":"*"},"filter_symbol":{"type":"boolean","default":false,"transition":false,"property-type":"data-driven","expression":{"interpolated":false,"parameters":["zoom","feature","pitch","distance-from-center"]}},"filter_fill":{"type":"boolean","default":false,"transition":false,"property-type":"data-driven","expression":{"interpolated":false,"parameters":["zoom","feature"]}},"filter_line":{"type":"boolean","default":false,"transition":false,"property-type":"data-driven","expression":{"interpolated":false,"parameters":["zoom","feature"]}},"filter_circle":{"type":"boolean","default":false,"transition":false,"property-type":"data-driven","expression":{"interpolated":false,"parameters":["zoom","feature"]}},"filter_fill-extrusion":{"type":"boolean","default":false,"transition":false,"property-type":"data-driven","expression":{"interpolated":false,"parameters":["zoom","feature"]}},"filter_heatmap":{"type":"boolean","default":false,"transition":false,"property-type":"data-driven","expression":{"interpolated":false,"parameters":["zoom","feature"]}},"filter_operator":{"type":"enum","values":{"==":{},"!=":{},">":{},">=":{},"<":{},"<=":{},"in":{},"!in":{},"all":{},"any":{},"none":{},"has":{},"!has":{},"within":{}}},"geometry_type":{"type":"enum","values":{"Point":{},"LineString":{},"Polygon":{}}},"function":{"expression":{"type":"expression"},"stops":{"type":"array","value":"function_stop"},"base":{"type":"number","default":1,"minimum":0},"property":{"type":"string","default":"$zoom"},"type":{"type":"enum","values":{"identity":{},"exponential":{},"interval":{},"categorical":{}},"default":"exponential"},"colorSpace":{"type":"enum","values":{"rgb":{},"lab":{},"hcl":{}},"default":"rgb"},"default":{"type":"*","required":false}},"function_stop":{"type":"array","minimum":0,"maximum":24,"value":["number","color"],"length":2},"expression":{"type":"array","value":"*","minimum":1},"fog":{"range":{"type":"array","default":[0.5,10],"minimum":-20,"maximum":20,"length":2,"value":"number","property-type":"data-constant","transition":true,"expression":{"interpolated":true,"parameters":["zoom"]}},"color":{"type":"color","property-type":"data-constant","default":"#ffffff","expression":{"interpolated":true,"parameters":["zoom"]},"transition":true},"high-color":{"type":"color","property-type":"data-constant","default":"#245cdf","expression":{"interpolated":true,"parameters":["zoom"]},"transition":true},"space-color":{"type":"color","property-type":"data-constant","default":["interpolate",["linear"],["zoom"],4,"#010b19",7,"#367ab9"],"expression":{"interpolated":true,"parameters":["zoom"]},"transition":true},"horizon-blend":{"type":"number","property-type":"data-constant","default":["interpolate",["linear"],["zoom"],4,0.2,7,0.1],"minimum":0,"maximum":1,"expression":{"interpolated":true,"parameters":["zoom"]},"transition":true},"star-intensity":{"type":"number","property-type":"data-constant","default":["interpolate",["linear"],["zoom"],5,0.35,6,0],"minimum":0,"maximum":1,"expression":{"interpolated":true,"parameters":["zoom"]},"transition":true}},"light":{"anchor":{"type":"enum","default":"viewport","values":{"map":{},"viewport":{}},"property-type":"data-constant","transition":false,"expression":{"interpolated":false,"parameters":["zoom"]}},"position":{"type":"array","default":[1.15,210,30],"length":3,"value":"number","property-type":"data-constant","transition":true,"expression":{"interpolated":true,"parameters":["zoom"]}},"color":{"type":"color","property-type":"data-constant","default":"#ffffff","expression":{"interpolated":true,"parameters":["zoom"]},"transition":true},"intensity":{"type":"number","property-type":"data-constant","default":0.5,"minimum":0,"maximum":1,"expression":{"interpolated":true,"parameters":["zoom"]},"transition":true}},"projection":{"name":{"type":"enum","values":{"albers":{},"equalEarth":{},"equirectangular":{},"lambertConformalConic":{},"mercator":{},"naturalEarth":{},"winkelTripel":{},"globe":{}},"default":"mercator","required":true},"center":{"type":"array","length":2,"value":"number","property-type":"data-constant","minimum":[-180,-90],"maximum":[180,90],"transition":false,"requires":[{"name":["albers","lambertConformalConic"]}]},"parallels":{"type":"array","length":2,"value":"number","property-type":"data-constant","minimum":[-90,-90],"maximum":[90,90],"transition":false,"requires":[{"name":["albers","lambertConformalConic"]}]}},"terrain":{"source":{"type":"string","required":true},"exaggeration":{"type":"number","property-type":"data-constant","default":1,"minimum":0,"maximum":1000,"expression":{"interpolated":true,"parameters":["zoom"]},"transition":true,"requires":["source"]}},"paint":["paint_fill","paint_line","paint_circle","paint_heatmap","paint_fill-extrusion","paint_symbol","paint_raster","paint_hillshade","paint_background","paint_sky"],"paint_fill":{"fill-antialias":{"type":"boolean","default":true,"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"fill-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"fill-color":{"type":"color","default":"#000000","transition":true,"requires":[{"!":"fill-pattern"}],"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"fill-outline-color":{"type":"color","transition":true,"requires":[{"!":"fill-pattern"},{"fill-antialias":true}],"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"fill-translate":{"type":"array","value":"number","length":2,"default":[0,0],"transition":true,"units":"pixels","expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"fill-translate-anchor":{"type":"enum","values":{"map":{},"viewport":{}},"default":"map","requires":["fill-translate"],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"fill-pattern":{"type":"resolvedImage","transition":false,"expression":{"interpolated":false,"parameters":["zoom","feature"]},"property-type":"data-driven"}},"paint_fill-extrusion":{"fill-extrusion-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"fill-extrusion-color":{"type":"color","default":"#000000","transition":true,"requires":[{"!":"fill-extrusion-pattern"}],"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"fill-extrusion-translate":{"type":"array","value":"number","length":2,"default":[0,0],"transition":true,"units":"pixels","expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"fill-extrusion-translate-anchor":{"type":"enum","values":{"map":{},"viewport":{}},"default":"map","requires":["fill-extrusion-translate"],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"fill-extrusion-pattern":{"type":"resolvedImage","transition":false,"expression":{"interpolated":false,"parameters":["zoom","feature"]},"property-type":"data-driven"},"fill-extrusion-height":{"type":"number","default":0,"minimum":0,"units":"meters","transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"fill-extrusion-base":{"type":"number","default":0,"minimum":0,"units":"meters","transition":true,"requires":["fill-extrusion-height"],"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"fill-extrusion-vertical-gradient":{"type":"boolean","default":true,"transition":false,"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"fill-extrusion-ambient-occlusion-intensity":{"property-type":"data-constant","type":"number","private":true,"default":0,"minimum":0,"maximum":1,"expression":{"interpolated":true,"parameters":["zoom"]},"transition":true},"fill-extrusion-ambient-occlusion-radius":{"property-type":"data-constant","type":"number","private":true,"default":3,"minimum":0,"expression":{"interpolated":true,"parameters":["zoom"]},"transition":true,"requires":["fill-extrusion-edge-radius"]},"fill-extrusion-rounded-roof":{"type":"boolean","default":true,"requires":["fill-extrusion-edge-radius"],"transition":false,"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"}},"paint_line":{"line-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"line-color":{"type":"color","default":"#000000","transition":true,"requires":[{"!":"line-pattern"}],"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"line-translate":{"type":"array","value":"number","length":2,"default":[0,0],"transition":true,"units":"pixels","expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"line-translate-anchor":{"type":"enum","values":{"map":{},"viewport":{}},"default":"map","requires":["line-translate"],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"line-width":{"type":"number","default":1,"minimum":0,"transition":true,"units":"pixels","expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"line-gap-width":{"type":"number","default":0,"minimum":0,"transition":true,"units":"pixels","expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"line-offset":{"type":"number","default":0,"transition":true,"units":"pixels","expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"line-blur":{"type":"number","default":0,"minimum":0,"transition":true,"units":"pixels","expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"line-dasharray":{"type":"array","value":"number","minimum":0,"transition":false,"units":"line widths","requires":[{"!":"line-pattern"}],"expression":{"interpolated":false,"parameters":["zoom","feature"]},"property-type":"data-driven"},"line-pattern":{"type":"resolvedImage","transition":false,"expression":{"interpolated":false,"parameters":["zoom","feature"]},"property-type":"data-driven"},"line-gradient":{"type":"color","transition":false,"requires":[{"!":"line-pattern"},{"source":"geojson","has":{"lineMetrics":true}}],"expression":{"interpolated":true,"parameters":["line-progress"]},"property-type":"color-ramp"},"line-trim-offset":{"type":"array","value":"number","length":2,"default":[0,0],"minimum":[0,0],"maximum":[1,1],"transition":false,"requires":[{"source":"geojson","has":{"lineMetrics":true}}],"property-type":"constant"}},"paint_circle":{"circle-radius":{"type":"number","default":5,"minimum":0,"transition":true,"units":"pixels","expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"circle-color":{"type":"color","default":"#000000","transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"circle-blur":{"type":"number","default":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"circle-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"circle-translate":{"type":"array","value":"number","length":2,"default":[0,0],"transition":true,"units":"pixels","expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"circle-translate-anchor":{"type":"enum","values":{"map":{},"viewport":{}},"default":"map","requires":["circle-translate"],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"circle-pitch-scale":{"type":"enum","values":{"map":{},"viewport":{}},"default":"map","expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"circle-pitch-alignment":{"type":"enum","values":{"map":{},"viewport":{}},"default":"viewport","expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"circle-stroke-width":{"type":"number","default":0,"minimum":0,"transition":true,"units":"pixels","expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"circle-stroke-color":{"type":"color","default":"#000000","transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"circle-stroke-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"}},"paint_heatmap":{"heatmap-radius":{"type":"number","default":30,"minimum":1,"transition":true,"units":"pixels","expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"heatmap-weight":{"type":"number","default":1,"minimum":0,"transition":false,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"heatmap-intensity":{"type":"number","default":1,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"heatmap-color":{"type":"color","default":["interpolate",["linear"],["heatmap-density"],0,"rgba(0, 0, 255, 0)",0.1,"royalblue",0.3,"cyan",0.5,"lime",0.7,"yellow",1,"red"],"transition":false,"expression":{"interpolated":true,"parameters":["heatmap-density"]},"property-type":"color-ramp"},"heatmap-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"}},"paint_symbol":{"icon-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"requires":["icon-image"],"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"icon-color":{"type":"color","default":"#000000","transition":true,"requires":["icon-image"],"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"icon-halo-color":{"type":"color","default":"rgba(0, 0, 0, 0)","transition":true,"requires":["icon-image"],"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"icon-halo-width":{"type":"number","default":0,"minimum":0,"transition":true,"units":"pixels","requires":["icon-image"],"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"icon-halo-blur":{"type":"number","default":0,"minimum":0,"transition":true,"units":"pixels","requires":["icon-image"],"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"icon-translate":{"type":"array","value":"number","length":2,"default":[0,0],"transition":true,"units":"pixels","requires":["icon-image"],"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"icon-translate-anchor":{"type":"enum","values":{"map":{},"viewport":{}},"default":"map","requires":["icon-image","icon-translate"],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"text-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"requires":["text-field"],"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"text-color":{"type":"color","default":"#000000","transition":true,"overridable":true,"requires":["text-field"],"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"text-halo-color":{"type":"color","default":"rgba(0, 0, 0, 0)","transition":true,"requires":["text-field"],"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"text-halo-width":{"type":"number","default":0,"minimum":0,"transition":true,"units":"pixels","requires":["text-field"],"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"text-halo-blur":{"type":"number","default":0,"minimum":0,"transition":true,"units":"pixels","requires":["text-field"],"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"text-translate":{"type":"array","value":"number","length":2,"default":[0,0],"transition":true,"units":"pixels","requires":["text-field"],"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"text-translate-anchor":{"type":"enum","values":{"map":{},"viewport":{}},"default":"map","requires":["text-field","text-translate"],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"}},"paint_raster":{"raster-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"raster-hue-rotate":{"type":"number","default":0,"period":360,"transition":true,"units":"degrees","expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"raster-brightness-min":{"type":"number","default":0,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"raster-brightness-max":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"raster-saturation":{"type":"number","default":0,"minimum":-1,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"raster-contrast":{"type":"number","default":0,"minimum":-1,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"raster-resampling":{"type":"enum","values":{"linear":{},"nearest":{}},"default":"linear","expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"raster-fade-duration":{"type":"number","default":300,"minimum":0,"transition":false,"units":"milliseconds","expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"}},"paint_hillshade":{"hillshade-illumination-direction":{"type":"number","default":335,"minimum":0,"maximum":359,"transition":false,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"hillshade-illumination-anchor":{"type":"enum","values":{"map":{},"viewport":{}},"default":"viewport","expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"hillshade-exaggeration":{"type":"number","default":0.5,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"hillshade-shadow-color":{"type":"color","default":"#000000","transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"hillshade-highlight-color":{"type":"color","default":"#FFFFFF","transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"hillshade-accent-color":{"type":"color","default":"#000000","transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"}},"paint_background":{"background-color":{"type":"color","default":"#000000","transition":true,"requires":[{"!":"background-pattern"}],"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"background-pattern":{"type":"resolvedImage","transition":false,"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"background-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"}},"paint_sky":{"sky-type":{"type":"enum","values":{"gradient":{},"atmosphere":{}},"default":"atmosphere","expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"sky-atmosphere-sun":{"type":"array","value":"number","length":2,"units":"degrees","minimum":[0,0],"maximum":[360,180],"transition":false,"requires":[{"sky-type":"atmosphere"}],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"sky-atmosphere-sun-intensity":{"type":"number","requires":[{"sky-type":"atmosphere"}],"default":10,"minimum":0,"maximum":100,"transition":false,"property-type":"data-constant"},"sky-gradient-center":{"type":"array","requires":[{"sky-type":"gradient"}],"value":"number","default":[0,0],"length":2,"units":"degrees","minimum":[0,0],"maximum":[360,180],"transition":false,"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"sky-gradient-radius":{"type":"number","requires":[{"sky-type":"gradient"}],"default":90,"minimum":0,"maximum":180,"transition":false,"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"sky-gradient":{"type":"color","default":["interpolate",["linear"],["sky-radial-progress"],0.8,"#87ceeb",1,"white"],"transition":false,"requires":[{"sky-type":"gradient"}],"expression":{"interpolated":true,"parameters":["sky-radial-progress"]},"property-type":"color-ramp"},"sky-atmosphere-halo-color":{"type":"color","default":"white","transition":false,"requires":[{"sky-type":"atmosphere"}],"property-type":"data-constant"},"sky-atmosphere-color":{"type":"color","default":"white","transition":false,"requires":[{"sky-type":"atmosphere"}],"property-type":"data-constant"},"sky-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"}},"transition":{"duration":{"type":"number","default":300,"minimum":0,"units":"milliseconds"},"delay":{"type":"number","default":0,"minimum":0,"units":"milliseconds"}},"property-type":{"data-driven":{"type":"property-type"},"color-ramp":{"type":"property-type"},"data-constant":{"type":"property-type"},"constant":{"type":"property-type"}},"promoteId":{"*":{"type":"string"}}}');
        function ee(t3, ...e3) {
          for (const r3 of e3)
            for (const e4 in r3)
              t3[e4] = r3[e4];
          return t3;
        }
        function re(t3) {
          return t3 instanceof Number || t3 instanceof String || t3 instanceof Boolean ? t3.valueOf() : t3;
        }
        function ne(t3) {
          if (Array.isArray(t3))
            return t3.map(ne);
          if (t3 instanceof Object && !(t3 instanceof Number || t3 instanceof String || t3 instanceof Boolean)) {
            const e3 = {};
            for (const r3 in t3)
              e3[r3] = ne(t3[r3]);
            return e3;
          }
          return re(t3);
        }
        class ie extends Error {
          constructor(t3, e3) {
            super(e3), this.message = e3, this.key = t3;
          }
        }
        var se = ie;
        class ae {
          constructor(t3, e3 = []) {
            this.parent = t3, this.bindings = {};
            for (const [t4, r3] of e3)
              this.bindings[t4] = r3;
          }
          concat(t3) {
            return new ae(this, t3);
          }
          get(t3) {
            if (this.bindings[t3])
              return this.bindings[t3];
            if (this.parent)
              return this.parent.get(t3);
            throw new Error(`${t3} not found in scope.`);
          }
          has(t3) {
            return !!this.bindings[t3] || !!this.parent && this.parent.has(t3);
          }
        }
        var oe = ae;
        const le = { kind: "null" }, ue = { kind: "number" }, ce = { kind: "string" }, he = { kind: "boolean" }, pe = { kind: "color" }, de = { kind: "object" }, fe = { kind: "value" }, ye = { kind: "collator" }, me = { kind: "formatted" }, ge = { kind: "resolvedImage" };
        function xe(t3, e3) {
          return { kind: "array", itemType: t3, N: e3 };
        }
        function ve(t3) {
          if ("array" === t3.kind) {
            const e3 = ve(t3.itemType);
            return "number" == typeof t3.N ? `array<${e3}, ${t3.N}>` : "value" === t3.itemType.kind ? "array" : `array<${e3}>`;
          }
          return t3.kind;
        }
        const be = [le, ue, ce, he, pe, me, de, xe(fe), ge];
        function we(t3, e3) {
          if ("error" === e3.kind)
            return null;
          if ("array" === t3.kind) {
            if ("array" === e3.kind && (0 === e3.N && "value" === e3.itemType.kind || !we(t3.itemType, e3.itemType)) && ("number" != typeof t3.N || t3.N === e3.N))
              return null;
          } else {
            if (t3.kind === e3.kind)
              return null;
            if ("value" === t3.kind) {
              for (const t4 of be)
                if (!we(t4, e3))
                  return null;
            }
          }
          return `Expected ${ve(t3)} but found ${ve(e3)} instead.`;
        }
        function _e(t3, e3) {
          return e3.some((e4) => e4.kind === t3.kind);
        }
        function Ae(t3, e3) {
          return e3.some((e4) => "null" === e4 ? null === t3 : "array" === e4 ? Array.isArray(t3) : "object" === e4 ? t3 && !Array.isArray(t3) && "object" == typeof t3 : e4 === typeof t3);
        }
        var Se, ke = { transparent: [0, 0, 0, 0], aliceblue: [240, 248, 255, 1], antiquewhite: [250, 235, 215, 1], aqua: [0, 255, 255, 1], aquamarine: [127, 255, 212, 1], azure: [240, 255, 255, 1], beige: [245, 245, 220, 1], bisque: [255, 228, 196, 1], black: [0, 0, 0, 1], blanchedalmond: [255, 235, 205, 1], blue: [0, 0, 255, 1], blueviolet: [138, 43, 226, 1], brown: [165, 42, 42, 1], burlywood: [222, 184, 135, 1], cadetblue: [95, 158, 160, 1], chartreuse: [127, 255, 0, 1], chocolate: [210, 105, 30, 1], coral: [255, 127, 80, 1], cornflowerblue: [100, 149, 237, 1], cornsilk: [255, 248, 220, 1], crimson: [220, 20, 60, 1], cyan: [0, 255, 255, 1], darkblue: [0, 0, 139, 1], darkcyan: [0, 139, 139, 1], darkgoldenrod: [184, 134, 11, 1], darkgray: [169, 169, 169, 1], darkgreen: [0, 100, 0, 1], darkgrey: [169, 169, 169, 1], darkkhaki: [189, 183, 107, 1], darkmagenta: [139, 0, 139, 1], darkolivegreen: [85, 107, 47, 1], darkorange: [255, 140, 0, 1], darkorchid: [153, 50, 204, 1], darkred: [139, 0, 0, 1], darksalmon: [233, 150, 122, 1], darkseagreen: [143, 188, 143, 1], darkslateblue: [72, 61, 139, 1], darkslategray: [47, 79, 79, 1], darkslategrey: [47, 79, 79, 1], darkturquoise: [0, 206, 209, 1], darkviolet: [148, 0, 211, 1], deeppink: [255, 20, 147, 1], deepskyblue: [0, 191, 255, 1], dimgray: [105, 105, 105, 1], dimgrey: [105, 105, 105, 1], dodgerblue: [30, 144, 255, 1], firebrick: [178, 34, 34, 1], floralwhite: [255, 250, 240, 1], forestgreen: [34, 139, 34, 1], fuchsia: [255, 0, 255, 1], gainsboro: [220, 220, 220, 1], ghostwhite: [248, 248, 255, 1], gold: [255, 215, 0, 1], goldenrod: [218, 165, 32, 1], gray: [128, 128, 128, 1], green: [0, 128, 0, 1], greenyellow: [173, 255, 47, 1], grey: [128, 128, 128, 1], honeydew: [240, 255, 240, 1], hotpink: [255, 105, 180, 1], indianred: [205, 92, 92, 1], indigo: [75, 0, 130, 1], ivory: [255, 255, 240, 1], khaki: [240, 230, 140, 1], lavender: [230, 230, 250, 1], lavenderblush: [255, 240, 245, 1], lawngreen: [124, 252, 0, 1], lemonchiffon: [255, 250, 205, 1], lightblue: [173, 216, 230, 1], lightcoral: [240, 128, 128, 1], lightcyan: [224, 255, 255, 1], lightgoldenrodyellow: [250, 250, 210, 1], lightgray: [211, 211, 211, 1], lightgreen: [144, 238, 144, 1], lightgrey: [211, 211, 211, 1], lightpink: [255, 182, 193, 1], lightsalmon: [255, 160, 122, 1], lightseagreen: [32, 178, 170, 1], lightskyblue: [135, 206, 250, 1], lightslategray: [119, 136, 153, 1], lightslategrey: [119, 136, 153, 1], lightsteelblue: [176, 196, 222, 1], lightyellow: [255, 255, 224, 1], lime: [0, 255, 0, 1], limegreen: [50, 205, 50, 1], linen: [250, 240, 230, 1], magenta: [255, 0, 255, 1], maroon: [128, 0, 0, 1], mediumaquamarine: [102, 205, 170, 1], mediumblue: [0, 0, 205, 1], mediumorchid: [186, 85, 211, 1], mediumpurple: [147, 112, 219, 1], mediumseagreen: [60, 179, 113, 1], mediumslateblue: [123, 104, 238, 1], mediumspringgreen: [0, 250, 154, 1], mediumturquoise: [72, 209, 204, 1], mediumvioletred: [199, 21, 133, 1], midnightblue: [25, 25, 112, 1], mintcream: [245, 255, 250, 1], mistyrose: [255, 228, 225, 1], moccasin: [255, 228, 181, 1], navajowhite: [255, 222, 173, 1], navy: [0, 0, 128, 1], oldlace: [253, 245, 230, 1], olive: [128, 128, 0, 1], olivedrab: [107, 142, 35, 1], orange: [255, 165, 0, 1], orangered: [255, 69, 0, 1], orchid: [218, 112, 214, 1], palegoldenrod: [238, 232, 170, 1], palegreen: [152, 251, 152, 1], paleturquoise: [175, 238, 238, 1], palevioletred: [219, 112, 147, 1], papayawhip: [255, 239, 213, 1], peachpuff: [255, 218, 185, 1], peru: [205, 133, 63, 1], pink: [255, 192, 203, 1], plum: [221, 160, 221, 1], powderblue: [176, 224, 230, 1], purple: [128, 0, 128, 1], rebeccapurple: [102, 51, 153, 1], red: [255, 0, 0, 1], rosybrown: [188, 143, 143, 1], royalblue: [65, 105, 225, 1], saddlebrown: [139, 69, 19, 1], salmon: [250, 128, 114, 1], sandybrown: [244, 164, 96, 1], seagreen: [46, 139, 87, 1], seashell: [255, 245, 238, 1], sienna: [160, 82, 45, 1], silver: [192, 192, 192, 1], skyblue: [135, 206, 235, 1], slateblue: [106, 90, 205, 1], slategray: [112, 128, 144, 1], slategrey: [112, 128, 144, 1], snow: [255, 250, 250, 1], springgreen: [0, 255, 127, 1], steelblue: [70, 130, 180, 1], tan: [210, 180, 140, 1], teal: [0, 128, 128, 1], thistle: [216, 191, 216, 1], tomato: [255, 99, 71, 1], turquoise: [64, 224, 208, 1], violet: [238, 130, 238, 1], wheat: [245, 222, 179, 1], white: [255, 255, 255, 1], whitesmoke: [245, 245, 245, 1], yellow: [255, 255, 0, 1], yellowgreen: [154, 205, 50, 1] };
        function Ie(t3) {
          return (t3 = Math.round(t3)) < 0 ? 0 : t3 > 255 ? 255 : t3;
        }
        function Me(t3) {
          return Ie("%" === t3[t3.length - 1] ? parseFloat(t3) / 100 * 255 : parseInt(t3));
        }
        function Te(t3) {
          return (e3 = "%" === t3[t3.length - 1] ? parseFloat(t3) / 100 : parseFloat(t3)) < 0 ? 0 : e3 > 1 ? 1 : e3;
          var e3;
        }
        function ze(t3, e3, r3) {
          return r3 < 0 ? r3 += 1 : r3 > 1 && (r3 -= 1), 6 * r3 < 1 ? t3 + (e3 - t3) * r3 * 6 : 2 * r3 < 1 ? e3 : 3 * r3 < 2 ? t3 + (e3 - t3) * (2 / 3 - r3) * 6 : t3;
        }
        try {
          Se = {}.parseCSSColor = function(t3) {
            var e3, r3 = t3.replace(/ /g, "").toLowerCase();
            if (r3 in ke)
              return ke[r3].slice();
            if ("#" === r3[0])
              return 4 === r3.length ? (e3 = parseInt(r3.substr(1), 16)) >= 0 && e3 <= 4095 ? [(3840 & e3) >> 4 | (3840 & e3) >> 8, 240 & e3 | (240 & e3) >> 4, 15 & e3 | (15 & e3) << 4, 1] : null : 7 === r3.length && (e3 = parseInt(r3.substr(1), 16)) >= 0 && e3 <= 16777215 ? [(16711680 & e3) >> 16, (65280 & e3) >> 8, 255 & e3, 1] : null;
            var n3 = r3.indexOf("("), i3 = r3.indexOf(")");
            if (-1 !== n3 && i3 + 1 === r3.length) {
              var s3 = r3.substr(0, n3), a3 = r3.substr(n3 + 1, i3 - (n3 + 1)).split(","), o3 = 1;
              switch (s3) {
                case "rgba":
                  if (4 !== a3.length)
                    return null;
                  o3 = Te(a3.pop());
                case "rgb":
                  return 3 !== a3.length ? null : [Me(a3[0]), Me(a3[1]), Me(a3[2]), o3];
                case "hsla":
                  if (4 !== a3.length)
                    return null;
                  o3 = Te(a3.pop());
                case "hsl":
                  if (3 !== a3.length)
                    return null;
                  var l2 = (parseFloat(a3[0]) % 360 + 360) % 360 / 360, u3 = Te(a3[1]), c3 = Te(a3[2]), h3 = c3 <= 0.5 ? c3 * (u3 + 1) : c3 + u3 - c3 * u3, p3 = 2 * c3 - h3;
                  return [Ie(255 * ze(p3, h3, l2 + 1 / 3)), Ie(255 * ze(p3, h3, l2)), Ie(255 * ze(p3, h3, l2 - 1 / 3)), o3];
                default:
                  return null;
              }
            }
            return null;
          };
        } catch (t3) {
        }
        class Be {
          constructor(t3, e3, r3, n3 = 1) {
            this.r = t3, this.g = e3, this.b = r3, this.a = n3;
          }
          static parse(t3) {
            if (!t3)
              return;
            if (t3 instanceof Be)
              return t3;
            if ("string" != typeof t3)
              return;
            const e3 = Se(t3);
            return e3 ? new Be(e3[0] / 255 * e3[3], e3[1] / 255 * e3[3], e3[2] / 255 * e3[3], e3[3]) : void 0;
          }
          toString() {
            const [t3, e3, r3, n3] = this.toArray();
            return `rgba(${Math.round(t3)},${Math.round(e3)},${Math.round(r3)},${n3})`;
          }
          toArray() {
            const { r: t3, g: e3, b: r3, a: n3 } = this;
            return 0 === n3 ? [0, 0, 0, 0] : [255 * t3 / n3, 255 * e3 / n3, 255 * r3 / n3, n3];
          }
          toArray01() {
            const { r: t3, g: e3, b: r3, a: n3 } = this;
            return 0 === n3 ? [0, 0, 0, 0] : [t3 / n3, e3 / n3, r3 / n3, n3];
          }
          toArray01PremultipliedAlpha() {
            const { r: t3, g: e3, b: r3, a: n3 } = this;
            return [t3, e3, r3, n3];
          }
        }
        Be.black = new Be(0, 0, 0, 1), Be.white = new Be(1, 1, 1, 1), Be.transparent = new Be(0, 0, 0, 0), Be.red = new Be(1, 0, 0, 1), Be.blue = new Be(0, 0, 1, 1);
        var Ee = Be;
        class Ce {
          constructor(t3, e3, r3) {
            this.sensitivity = t3 ? e3 ? "variant" : "case" : e3 ? "accent" : "base", this.locale = r3, this.collator = new Intl.Collator(this.locale ? this.locale : [], { sensitivity: this.sensitivity, usage: "search" });
          }
          compare(t3, e3) {
            return this.collator.compare(t3, e3);
          }
          resolvedLocale() {
            return new Intl.Collator(this.locale ? this.locale : []).resolvedOptions().locale;
          }
        }
        class Pe {
          constructor(t3, e3, r3, n3, i3) {
            this.text = t3.normalize ? t3.normalize() : t3, this.image = e3, this.scale = r3, this.fontStack = n3, this.textColor = i3;
          }
        }
        class De {
          constructor(t3) {
            this.sections = t3;
          }
          static fromString(t3) {
            return new De([new Pe(t3, null, null, null, null)]);
          }
          isEmpty() {
            return 0 === this.sections.length || !this.sections.some((t3) => 0 !== t3.text.length || t3.image && 0 !== t3.image.name.length);
          }
          static factory(t3) {
            return t3 instanceof De ? t3 : De.fromString(t3);
          }
          toString() {
            return 0 === this.sections.length ? "" : this.sections.map((t3) => t3.text).join("");
          }
          serialize() {
            const t3 = ["format"];
            for (const e3 of this.sections) {
              if (e3.image) {
                t3.push(["image", e3.image.name]);
                continue;
              }
              t3.push(e3.text);
              const r3 = {};
              e3.fontStack && (r3["text-font"] = ["literal", e3.fontStack.split(",")]), e3.scale && (r3["font-scale"] = e3.scale), e3.textColor && (r3["text-color"] = ["rgba"].concat(e3.textColor.toArray())), t3.push(r3);
            }
            return t3;
          }
        }
        class Ve {
          constructor(t3) {
            this.name = t3.name, this.available = t3.available;
          }
          toString() {
            return this.name;
          }
          static fromString(t3) {
            return t3 ? new Ve({ name: t3, available: false }) : null;
          }
          serialize() {
            return ["image", this.name];
          }
        }
        function Le(t3, e3, r3, n3) {
          return "number" == typeof t3 && t3 >= 0 && t3 <= 255 && "number" == typeof e3 && e3 >= 0 && e3 <= 255 && "number" == typeof r3 && r3 >= 0 && r3 <= 255 ? void 0 === n3 || "number" == typeof n3 && n3 >= 0 && n3 <= 1 ? null : `Invalid rgba value [${[t3, e3, r3, n3].join(", ")}]: 'a' must be between 0 and 1.` : `Invalid rgba value [${("number" == typeof n3 ? [t3, e3, r3, n3] : [t3, e3, r3]).join(", ")}]: 'r', 'g', and 'b' must be between 0 and 255.`;
        }
        function Fe(t3) {
          if (null === t3)
            return true;
          if ("string" == typeof t3)
            return true;
          if ("boolean" == typeof t3)
            return true;
          if ("number" == typeof t3)
            return true;
          if (t3 instanceof Ee)
            return true;
          if (t3 instanceof Ce)
            return true;
          if (t3 instanceof De)
            return true;
          if (t3 instanceof Ve)
            return true;
          if (Array.isArray(t3)) {
            for (const e3 of t3)
              if (!Fe(e3))
                return false;
            return true;
          }
          if ("object" == typeof t3) {
            for (const e3 in t3)
              if (!Fe(t3[e3]))
                return false;
            return true;
          }
          return false;
        }
        function Re(t3) {
          if (null === t3)
            return le;
          if ("string" == typeof t3)
            return ce;
          if ("boolean" == typeof t3)
            return he;
          if ("number" == typeof t3)
            return ue;
          if (t3 instanceof Ee)
            return pe;
          if (t3 instanceof Ce)
            return ye;
          if (t3 instanceof De)
            return me;
          if (t3 instanceof Ve)
            return ge;
          if (Array.isArray(t3)) {
            const e3 = t3.length;
            let r3;
            for (const e4 of t3) {
              const t4 = Re(e4);
              if (r3) {
                if (r3 === t4)
                  continue;
                r3 = fe;
                break;
              }
              r3 = t4;
            }
            return xe(r3 || fe, e3);
          }
          return de;
        }
        function Ue(t3) {
          const e3 = typeof t3;
          return null === t3 ? "" : "string" === e3 || "number" === e3 || "boolean" === e3 ? String(t3) : t3 instanceof Ee || t3 instanceof De || t3 instanceof Ve ? t3.toString() : JSON.stringify(t3);
        }
        class $e {
          constructor(t3, e3) {
            this.type = t3, this.value = e3;
          }
          static parse(t3, e3) {
            if (2 !== t3.length)
              return e3.error(`'literal' expression requires exactly one argument, but found ${t3.length - 1} instead.`);
            if (!Fe(t3[1]))
              return e3.error("invalid value");
            const r3 = t3[1];
            let n3 = Re(r3);
            const i3 = e3.expectedType;
            return "array" !== n3.kind || 0 !== n3.N || !i3 || "array" !== i3.kind || "number" == typeof i3.N && 0 !== i3.N || (n3 = i3), new $e(n3, r3);
          }
          evaluate() {
            return this.value;
          }
          eachChild() {
          }
          outputDefined() {
            return true;
          }
          serialize() {
            return "array" === this.type.kind || "object" === this.type.kind ? ["literal", this.value] : this.value instanceof Ee ? ["rgba"].concat(this.value.toArray()) : this.value instanceof De ? this.value.serialize() : this.value;
          }
        }
        var je = $e, Oe = class {
          constructor(t3) {
            this.name = "ExpressionEvaluationError", this.message = t3;
          }
          toJSON() {
            return this.message;
          }
        };
        const qe = { string: ce, number: ue, boolean: he, object: de };
        class Ne {
          constructor(t3, e3) {
            this.type = t3, this.args = e3;
          }
          static parse(t3, e3) {
            if (t3.length < 2)
              return e3.error("Expected at least one argument.");
            let r3, n3 = 1;
            const i3 = t3[0];
            if ("array" === i3) {
              let i4, s4;
              if (t3.length > 2) {
                const r4 = t3[1];
                if ("string" != typeof r4 || !(r4 in qe) || "object" === r4)
                  return e3.error('The item type argument of "array" must be one of string, number, boolean', 1);
                i4 = qe[r4], n3++;
              } else
                i4 = fe;
              if (t3.length > 3) {
                if (null !== t3[2] && ("number" != typeof t3[2] || t3[2] < 0 || t3[2] !== Math.floor(t3[2])))
                  return e3.error('The length argument to "array" must be a positive integer literal', 2);
                s4 = t3[2], n3++;
              }
              r3 = xe(i4, s4);
            } else
              r3 = qe[i3];
            const s3 = [];
            for (; n3 < t3.length; n3++) {
              const r4 = e3.parse(t3[n3], n3, fe);
              if (!r4)
                return null;
              s3.push(r4);
            }
            return new Ne(r3, s3);
          }
          evaluate(t3) {
            for (let e3 = 0; e3 < this.args.length; e3++) {
              const r3 = this.args[e3].evaluate(t3);
              if (!we(this.type, Re(r3)))
                return r3;
              if (e3 === this.args.length - 1)
                throw new Oe(`Expected value to be of type ${ve(this.type)}, but found ${ve(Re(r3))} instead.`);
            }
            return null;
          }
          eachChild(t3) {
            this.args.forEach(t3);
          }
          outputDefined() {
            return this.args.every((t3) => t3.outputDefined());
          }
          serialize() {
            const t3 = this.type, e3 = [t3.kind];
            if ("array" === t3.kind) {
              const r3 = t3.itemType;
              if ("string" === r3.kind || "number" === r3.kind || "boolean" === r3.kind) {
                e3.push(r3.kind);
                const n3 = t3.N;
                ("number" == typeof n3 || this.args.length > 1) && e3.push(n3);
              }
            }
            return e3.concat(this.args.map((t4) => t4.serialize()));
          }
        }
        var Ge = Ne;
        class Ze {
          constructor(t3) {
            this.type = me, this.sections = t3;
          }
          static parse(t3, e3) {
            if (t3.length < 2)
              return e3.error("Expected at least one argument.");
            const r3 = t3[1];
            if (!Array.isArray(r3) && "object" == typeof r3)
              return e3.error("First argument must be an image or text section.");
            const n3 = [];
            let i3 = false;
            for (let r4 = 1; r4 <= t3.length - 1; ++r4) {
              const s3 = t3[r4];
              if (i3 && "object" == typeof s3 && !Array.isArray(s3)) {
                i3 = false;
                let t4 = null;
                if (s3["font-scale"] && (t4 = e3.parse(s3["font-scale"], 1, ue), !t4))
                  return null;
                let r5 = null;
                if (s3["text-font"] && (r5 = e3.parse(s3["text-font"], 1, xe(ce)), !r5))
                  return null;
                let a3 = null;
                if (s3["text-color"] && (a3 = e3.parse(s3["text-color"], 1, pe), !a3))
                  return null;
                const o3 = n3[n3.length - 1];
                o3.scale = t4, o3.font = r5, o3.textColor = a3;
              } else {
                const s4 = e3.parse(t3[r4], 1, fe);
                if (!s4)
                  return null;
                const a3 = s4.type.kind;
                if ("string" !== a3 && "value" !== a3 && "null" !== a3 && "resolvedImage" !== a3)
                  return e3.error("Formatted text type must be 'string', 'value', 'image' or 'null'.");
                i3 = true, n3.push({ content: s4, scale: null, font: null, textColor: null });
              }
            }
            return new Ze(n3);
          }
          evaluate(t3) {
            return new De(this.sections.map((e3) => {
              const r3 = e3.content.evaluate(t3);
              return Re(r3) === ge ? new Pe("", r3, null, null, null) : new Pe(Ue(r3), null, e3.scale ? e3.scale.evaluate(t3) : null, e3.font ? e3.font.evaluate(t3).join(",") : null, e3.textColor ? e3.textColor.evaluate(t3) : null);
            }));
          }
          eachChild(t3) {
            for (const e3 of this.sections)
              t3(e3.content), e3.scale && t3(e3.scale), e3.font && t3(e3.font), e3.textColor && t3(e3.textColor);
          }
          outputDefined() {
            return false;
          }
          serialize() {
            const t3 = ["format"];
            for (const e3 of this.sections) {
              t3.push(e3.content.serialize());
              const r3 = {};
              e3.scale && (r3["font-scale"] = e3.scale.serialize()), e3.font && (r3["text-font"] = e3.font.serialize()), e3.textColor && (r3["text-color"] = e3.textColor.serialize()), t3.push(r3);
            }
            return t3;
          }
        }
        class Ke {
          constructor(t3) {
            this.type = ge, this.input = t3;
          }
          static parse(t3, e3) {
            if (2 !== t3.length)
              return e3.error("Expected two arguments.");
            const r3 = e3.parse(t3[1], 1, ce);
            return r3 ? new Ke(r3) : e3.error("No image name provided.");
          }
          evaluate(t3) {
            const e3 = this.input.evaluate(t3), r3 = Ve.fromString(e3);
            return r3 && t3.availableImages && (r3.available = t3.availableImages.indexOf(e3) > -1), r3;
          }
          eachChild(t3) {
            t3(this.input);
          }
          outputDefined() {
            return false;
          }
          serialize() {
            return ["image", this.input.serialize()];
          }
        }
        const Xe = { "to-boolean": he, "to-color": pe, "to-number": ue, "to-string": ce };
        class Je {
          constructor(t3, e3) {
            this.type = t3, this.args = e3;
          }
          static parse(t3, e3) {
            if (t3.length < 2)
              return e3.error("Expected at least one argument.");
            const r3 = t3[0];
            if (("to-boolean" === r3 || "to-string" === r3) && 2 !== t3.length)
              return e3.error("Expected one argument.");
            const n3 = Xe[r3], i3 = [];
            for (let r4 = 1; r4 < t3.length; r4++) {
              const n4 = e3.parse(t3[r4], r4, fe);
              if (!n4)
                return null;
              i3.push(n4);
            }
            return new Je(n3, i3);
          }
          evaluate(t3) {
            if ("boolean" === this.type.kind)
              return Boolean(this.args[0].evaluate(t3));
            if ("color" === this.type.kind) {
              let e3, r3;
              for (const n3 of this.args) {
                if (e3 = n3.evaluate(t3), r3 = null, e3 instanceof Ee)
                  return e3;
                if ("string" == typeof e3) {
                  const r4 = t3.parseColor(e3);
                  if (r4)
                    return r4;
                } else if (Array.isArray(e3) && (r3 = e3.length < 3 || e3.length > 4 ? `Invalid rbga value ${JSON.stringify(e3)}: expected an array containing either three or four numeric values.` : Le(e3[0], e3[1], e3[2], e3[3]), !r3))
                  return new Ee(e3[0] / 255, e3[1] / 255, e3[2] / 255, e3[3]);
              }
              throw new Oe(r3 || `Could not parse color from value '${"string" == typeof e3 ? e3 : String(JSON.stringify(e3))}'`);
            }
            if ("number" === this.type.kind) {
              let e3 = null;
              for (const r3 of this.args) {
                if (e3 = r3.evaluate(t3), null === e3)
                  return 0;
                const n3 = Number(e3);
                if (!isNaN(n3))
                  return n3;
              }
              throw new Oe(`Could not convert ${JSON.stringify(e3)} to number.`);
            }
            return "formatted" === this.type.kind ? De.fromString(Ue(this.args[0].evaluate(t3))) : "resolvedImage" === this.type.kind ? Ve.fromString(Ue(this.args[0].evaluate(t3))) : Ue(this.args[0].evaluate(t3));
          }
          eachChild(t3) {
            this.args.forEach(t3);
          }
          outputDefined() {
            return this.args.every((t3) => t3.outputDefined());
          }
          serialize() {
            if ("formatted" === this.type.kind)
              return new Ze([{ content: this.args[0], scale: null, font: null, textColor: null }]).serialize();
            if ("resolvedImage" === this.type.kind)
              return new Ke(this.args[0]).serialize();
            const t3 = [`to-${this.type.kind}`];
            return this.eachChild((e3) => {
              t3.push(e3.serialize());
            }), t3;
          }
        }
        var He = Je;
        const Ye = ["Unknown", "Point", "LineString", "Polygon"];
        var We = class {
          constructor() {
            this.globals = null, this.feature = null, this.featureState = null, this.formattedSection = null, this._parseColorCache = {}, this.availableImages = null, this.canonical = null, this.featureTileCoord = null, this.featureDistanceData = null;
          }
          id() {
            return this.feature && void 0 !== this.feature.id ? this.feature.id : null;
          }
          geometryType() {
            return this.feature ? "number" == typeof this.feature.type ? Ye[this.feature.type] : this.feature.type : null;
          }
          geometry() {
            return this.feature && "geometry" in this.feature ? this.feature.geometry : null;
          }
          canonicalID() {
            return this.canonical;
          }
          properties() {
            return this.feature && this.feature.properties || {};
          }
          distanceFromCenter() {
            if (this.featureTileCoord && this.featureDistanceData) {
              const t3 = this.featureDistanceData.center, e3 = this.featureDistanceData.scale, { x: r3, y: n3 } = this.featureTileCoord;
              return this.featureDistanceData.bearing[0] * (r3 * e3 - t3[0]) + this.featureDistanceData.bearing[1] * (n3 * e3 - t3[1]);
            }
            return 0;
          }
          parseColor(t3) {
            let e3 = this._parseColorCache[t3];
            return e3 || (e3 = this._parseColorCache[t3] = Ee.parse(t3)), e3;
          }
        };
        class Qe {
          constructor(t3, e3, r3, n3) {
            this.name = t3, this.type = e3, this._evaluate = r3, this.args = n3;
          }
          evaluate(t3) {
            return this._evaluate(t3, this.args);
          }
          eachChild(t3) {
            this.args.forEach(t3);
          }
          outputDefined() {
            return false;
          }
          serialize() {
            return [this.name].concat(this.args.map((t3) => t3.serialize()));
          }
          static parse(t3, e3) {
            const r3 = t3[0], n3 = Qe.definitions[r3];
            if (!n3)
              return e3.error(`Unknown expression "${r3}". If you wanted a literal array, use ["literal", [...]].`, 0);
            const i3 = Array.isArray(n3) ? n3[0] : n3.type, s3 = Array.isArray(n3) ? [[n3[1], n3[2]]] : n3.overloads, a3 = s3.filter(([e4]) => !Array.isArray(e4) || e4.length === t3.length - 1);
            let o3 = null;
            for (const [n4, s4] of a3) {
              o3 = new Ir(e3.registry, e3.path, null, e3.scope);
              const a4 = [];
              let l2 = false;
              for (let e4 = 1; e4 < t3.length; e4++) {
                const r4 = t3[e4], i4 = Array.isArray(n4) ? n4[e4 - 1] : n4.type, s5 = o3.parse(r4, 1 + a4.length, i4);
                if (!s5) {
                  l2 = true;
                  break;
                }
                a4.push(s5);
              }
              if (!l2)
                if (Array.isArray(n4) && n4.length !== a4.length)
                  o3.error(`Expected ${n4.length} arguments, but found ${a4.length} instead.`);
                else {
                  for (let t4 = 0; t4 < a4.length; t4++) {
                    const e4 = Array.isArray(n4) ? n4[t4] : n4.type, r4 = a4[t4];
                    o3.concat(t4 + 1).checkSubtype(e4, r4.type);
                  }
                  if (0 === o3.errors.length)
                    return new Qe(r3, i3, s4, a4);
                }
            }
            if (1 === a3.length)
              e3.errors.push(...o3.errors);
            else {
              const r4 = (a3.length ? a3 : s3).map(([t4]) => {
                return e4 = t4, Array.isArray(e4) ? `(${e4.map(ve).join(", ")})` : `(${ve(e4.type)}...)`;
                var e4;
              }).join(" | "), n4 = [];
              for (let r5 = 1; r5 < t3.length; r5++) {
                const i4 = e3.parse(t3[r5], 1 + n4.length);
                if (!i4)
                  return null;
                n4.push(ve(i4.type));
              }
              e3.error(`Expected arguments of type ${r4}, but found (${n4.join(", ")}) instead.`);
            }
            return null;
          }
          static register(t3, e3) {
            Qe.definitions = e3;
            for (const r3 in e3)
              t3[r3] = Qe;
          }
        }
        var tr = Qe;
        class er {
          constructor(t3, e3, r3) {
            this.type = ye, this.locale = r3, this.caseSensitive = t3, this.diacriticSensitive = e3;
          }
          static parse(t3, e3) {
            if (2 !== t3.length)
              return e3.error("Expected one argument.");
            const r3 = t3[1];
            if ("object" != typeof r3 || Array.isArray(r3))
              return e3.error("Collator options argument must be an object.");
            const n3 = e3.parse(void 0 !== r3["case-sensitive"] && r3["case-sensitive"], 1, he);
            if (!n3)
              return null;
            const i3 = e3.parse(void 0 !== r3["diacritic-sensitive"] && r3["diacritic-sensitive"], 1, he);
            if (!i3)
              return null;
            let s3 = null;
            return r3.locale && (s3 = e3.parse(r3.locale, 1, ce), !s3) ? null : new er(n3, i3, s3);
          }
          evaluate(t3) {
            return new Ce(this.caseSensitive.evaluate(t3), this.diacriticSensitive.evaluate(t3), this.locale ? this.locale.evaluate(t3) : null);
          }
          eachChild(t3) {
            t3(this.caseSensitive), t3(this.diacriticSensitive), this.locale && t3(this.locale);
          }
          outputDefined() {
            return false;
          }
          serialize() {
            const t3 = {};
            return t3["case-sensitive"] = this.caseSensitive.serialize(), t3["diacritic-sensitive"] = this.diacriticSensitive.serialize(), this.locale && (t3.locale = this.locale.serialize()), ["collator", t3];
          }
        }
        const rr = 8192;
        function nr(t3, e3) {
          t3[0] = Math.min(t3[0], e3[0]), t3[1] = Math.min(t3[1], e3[1]), t3[2] = Math.max(t3[2], e3[0]), t3[3] = Math.max(t3[3], e3[1]);
        }
        function ir(t3, e3) {
          return !(t3[0] <= e3[0] || t3[2] >= e3[2] || t3[1] <= e3[1] || t3[3] >= e3[3]);
        }
        function sr(t3, e3) {
          const r3 = (180 + t3[0]) / 360, n3 = (180 - 180 / Math.PI * Math.log(Math.tan(Math.PI / 4 + t3[1] * Math.PI / 360))) / 360, i3 = Math.pow(2, e3.z);
          return [Math.round(r3 * i3 * rr), Math.round(n3 * i3 * rr)];
        }
        function ar(t3, e3, r3) {
          const n3 = t3[0] - e3[0], i3 = t3[1] - e3[1], s3 = t3[0] - r3[0], a3 = t3[1] - r3[1];
          return n3 * a3 - s3 * i3 == 0 && n3 * s3 <= 0 && i3 * a3 <= 0;
        }
        function or(t3, e3) {
          let r3 = false;
          for (let a3 = 0, o3 = e3.length; a3 < o3; a3++) {
            const o4 = e3[a3];
            for (let e4 = 0, a4 = o4.length; e4 < a4 - 1; e4++) {
              if (ar(t3, o4[e4], o4[e4 + 1]))
                return false;
              (i3 = o4[e4])[1] > (n3 = t3)[1] != (s3 = o4[e4 + 1])[1] > n3[1] && n3[0] < (s3[0] - i3[0]) * (n3[1] - i3[1]) / (s3[1] - i3[1]) + i3[0] && (r3 = !r3);
            }
          }
          var n3, i3, s3;
          return r3;
        }
        function lr(t3, e3) {
          for (let r3 = 0; r3 < e3.length; r3++)
            if (or(t3, e3[r3]))
              return true;
          return false;
        }
        function ur(t3, e3, r3, n3) {
          const i3 = n3[0] - r3[0], s3 = n3[1] - r3[1], a3 = (t3[0] - r3[0]) * s3 - i3 * (t3[1] - r3[1]), o3 = (e3[0] - r3[0]) * s3 - i3 * (e3[1] - r3[1]);
          return a3 > 0 && o3 < 0 || a3 < 0 && o3 > 0;
        }
        function cr(t3, e3, r3) {
          for (const u3 of r3)
            for (let r4 = 0; r4 < u3.length - 1; ++r4)
              if (0 != (o3 = [(a3 = u3[r4 + 1])[0] - (s3 = u3[r4])[0], a3[1] - s3[1]])[0] * (l2 = [(i3 = e3)[0] - (n3 = t3)[0], i3[1] - n3[1]])[1] - o3[1] * l2[0] && ur(n3, i3, s3, a3) && ur(s3, a3, n3, i3))
                return true;
          var n3, i3, s3, a3, o3, l2;
          return false;
        }
        function hr(t3, e3) {
          for (let r3 = 0; r3 < t3.length; ++r3)
            if (!or(t3[r3], e3))
              return false;
          for (let r3 = 0; r3 < t3.length - 1; ++r3)
            if (cr(t3[r3], t3[r3 + 1], e3))
              return false;
          return true;
        }
        function pr(t3, e3) {
          for (let r3 = 0; r3 < e3.length; r3++)
            if (hr(t3, e3[r3]))
              return true;
          return false;
        }
        function dr(t3, e3, r3) {
          const n3 = [];
          for (let i3 = 0; i3 < t3.length; i3++) {
            const s3 = [];
            for (let n4 = 0; n4 < t3[i3].length; n4++) {
              const a3 = sr(t3[i3][n4], r3);
              nr(e3, a3), s3.push(a3);
            }
            n3.push(s3);
          }
          return n3;
        }
        function fr(t3, e3, r3) {
          const n3 = [];
          for (let i3 = 0; i3 < t3.length; i3++) {
            const s3 = dr(t3[i3], e3, r3);
            n3.push(s3);
          }
          return n3;
        }
        function yr(t3, e3, r3, n3) {
          if (t3[0] < r3[0] || t3[0] > r3[2]) {
            const e4 = 0.5 * n3;
            let i3 = t3[0] - r3[0] > e4 ? -n3 : r3[0] - t3[0] > e4 ? n3 : 0;
            0 === i3 && (i3 = t3[0] - r3[2] > e4 ? -n3 : r3[2] - t3[0] > e4 ? n3 : 0), t3[0] += i3;
          }
          nr(e3, t3);
        }
        function mr(t3, e3, r3, n3) {
          const i3 = Math.pow(2, n3.z) * rr, s3 = [n3.x * rr, n3.y * rr], a3 = [];
          if (!t3)
            return a3;
          for (const n4 of t3)
            for (const t4 of n4) {
              const n5 = [t4.x + s3[0], t4.y + s3[1]];
              yr(n5, e3, r3, i3), a3.push(n5);
            }
          return a3;
        }
        function gr(t3, e3, r3, n3) {
          const i3 = Math.pow(2, n3.z) * rr, s3 = [n3.x * rr, n3.y * rr], a3 = [];
          if (!t3)
            return a3;
          for (const r4 of t3) {
            const t4 = [];
            for (const n4 of r4) {
              const r5 = [n4.x + s3[0], n4.y + s3[1]];
              nr(e3, r5), t4.push(r5);
            }
            a3.push(t4);
          }
          if (e3[2] - e3[0] <= i3 / 2) {
            (o3 = e3)[0] = o3[1] = 1 / 0, o3[2] = o3[3] = -1 / 0;
            for (const t4 of a3)
              for (const n4 of t4)
                yr(n4, e3, r3, i3);
          }
          var o3;
          return a3;
        }
        class xr {
          constructor(t3, e3) {
            this.type = he, this.geojson = t3, this.geometries = e3;
          }
          static parse(t3, e3) {
            if (2 !== t3.length)
              return e3.error(`'within' expression requires exactly one argument, but found ${t3.length - 1} instead.`);
            if (Fe(t3[1])) {
              const e4 = t3[1];
              if ("FeatureCollection" === e4.type)
                for (let t4 = 0; t4 < e4.features.length; ++t4) {
                  const r3 = e4.features[t4].geometry.type;
                  if ("Polygon" === r3 || "MultiPolygon" === r3)
                    return new xr(e4, e4.features[t4].geometry);
                }
              else if ("Feature" === e4.type) {
                const t4 = e4.geometry.type;
                if ("Polygon" === t4 || "MultiPolygon" === t4)
                  return new xr(e4, e4.geometry);
              } else if ("Polygon" === e4.type || "MultiPolygon" === e4.type)
                return new xr(e4, e4);
            }
            return e3.error("'within' expression requires valid geojson object that contains polygon geometry type.");
          }
          evaluate(t3) {
            if (null != t3.geometry() && null != t3.canonicalID()) {
              if ("Point" === t3.geometryType())
                return function(t4, e3) {
                  const r3 = [1 / 0, 1 / 0, -1 / 0, -1 / 0], n3 = [1 / 0, 1 / 0, -1 / 0, -1 / 0], i3 = t4.canonicalID();
                  if (!i3)
                    return false;
                  if ("Polygon" === e3.type) {
                    const s3 = dr(e3.coordinates, n3, i3), a3 = mr(t4.geometry(), r3, n3, i3);
                    if (!ir(r3, n3))
                      return false;
                    for (const t5 of a3)
                      if (!or(t5, s3))
                        return false;
                  }
                  if ("MultiPolygon" === e3.type) {
                    const s3 = fr(e3.coordinates, n3, i3), a3 = mr(t4.geometry(), r3, n3, i3);
                    if (!ir(r3, n3))
                      return false;
                    for (const t5 of a3)
                      if (!lr(t5, s3))
                        return false;
                  }
                  return true;
                }(t3, this.geometries);
              if ("LineString" === t3.geometryType())
                return function(t4, e3) {
                  const r3 = [1 / 0, 1 / 0, -1 / 0, -1 / 0], n3 = [1 / 0, 1 / 0, -1 / 0, -1 / 0], i3 = t4.canonicalID();
                  if (!i3)
                    return false;
                  if ("Polygon" === e3.type) {
                    const s3 = dr(e3.coordinates, n3, i3), a3 = gr(t4.geometry(), r3, n3, i3);
                    if (!ir(r3, n3))
                      return false;
                    for (const t5 of a3)
                      if (!hr(t5, s3))
                        return false;
                  }
                  if ("MultiPolygon" === e3.type) {
                    const s3 = fr(e3.coordinates, n3, i3), a3 = gr(t4.geometry(), r3, n3, i3);
                    if (!ir(r3, n3))
                      return false;
                    for (const t5 of a3)
                      if (!pr(t5, s3))
                        return false;
                  }
                  return true;
                }(t3, this.geometries);
            }
            return false;
          }
          eachChild() {
          }
          outputDefined() {
            return true;
          }
          serialize() {
            return ["within", this.geojson];
          }
        }
        var vr = xr;
        function br(t3) {
          if (t3 instanceof tr) {
            if ("get" === t3.name && 1 === t3.args.length)
              return false;
            if ("feature-state" === t3.name)
              return false;
            if ("has" === t3.name && 1 === t3.args.length)
              return false;
            if ("properties" === t3.name || "geometry-type" === t3.name || "id" === t3.name)
              return false;
            if (/^filter-/.test(t3.name))
              return false;
          }
          if (t3 instanceof vr)
            return false;
          let e3 = true;
          return t3.eachChild((t4) => {
            e3 && !br(t4) && (e3 = false);
          }), e3;
        }
        function wr(t3) {
          if (t3 instanceof tr && "feature-state" === t3.name)
            return false;
          let e3 = true;
          return t3.eachChild((t4) => {
            e3 && !wr(t4) && (e3 = false);
          }), e3;
        }
        function _r(t3, e3) {
          if (t3 instanceof tr && e3.indexOf(t3.name) >= 0)
            return false;
          let r3 = true;
          return t3.eachChild((t4) => {
            r3 && !_r(t4, e3) && (r3 = false);
          }), r3;
        }
        class Ar {
          constructor(t3, e3) {
            this.type = e3.type, this.name = t3, this.boundExpression = e3;
          }
          static parse(t3, e3) {
            if (2 !== t3.length || "string" != typeof t3[1])
              return e3.error("'var' expression requires exactly one string literal argument.");
            const r3 = t3[1];
            return e3.scope.has(r3) ? new Ar(r3, e3.scope.get(r3)) : e3.error(`Unknown variable "${r3}". Make sure "${r3}" has been bound in an enclosing "let" expression before using it.`, 1);
          }
          evaluate(t3) {
            return this.boundExpression.evaluate(t3);
          }
          eachChild() {
          }
          outputDefined() {
            return false;
          }
          serialize() {
            return ["var", this.name];
          }
        }
        var Sr = Ar;
        class kr {
          constructor(t3, e3 = [], r3, n3 = new oe(), i3 = []) {
            this.registry = t3, this.path = e3, this.key = e3.map((t4) => `[${t4}]`).join(""), this.scope = n3, this.errors = i3, this.expectedType = r3;
          }
          parse(t3, e3, r3, n3, i3 = {}) {
            return e3 ? this.concat(e3, r3, n3)._parse(t3, i3) : this._parse(t3, i3);
          }
          _parse(t3, e3) {
            function r3(t4, e4, r4) {
              return "assert" === r4 ? new Ge(e4, [t4]) : "coerce" === r4 ? new He(e4, [t4]) : t4;
            }
            if (null !== t3 && "string" != typeof t3 && "boolean" != typeof t3 && "number" != typeof t3 || (t3 = ["literal", t3]), Array.isArray(t3)) {
              if (0 === t3.length)
                return this.error('Expected an array with at least one element. If you wanted a literal array, use ["literal", []].');
              const n3 = t3[0];
              if ("string" != typeof n3)
                return this.error(`Expression name must be a string, but found ${typeof n3} instead. If you wanted a literal array, use ["literal", [...]].`, 0), null;
              const i3 = this.registry[n3];
              if (i3) {
                let n4 = i3.parse(t3, this);
                if (!n4)
                  return null;
                if (this.expectedType) {
                  const t4 = this.expectedType, i4 = n4.type;
                  if ("string" !== t4.kind && "number" !== t4.kind && "boolean" !== t4.kind && "object" !== t4.kind && "array" !== t4.kind || "value" !== i4.kind)
                    if ("color" !== t4.kind && "formatted" !== t4.kind && "resolvedImage" !== t4.kind || "value" !== i4.kind && "string" !== i4.kind) {
                      if (this.checkSubtype(t4, i4))
                        return null;
                    } else
                      n4 = r3(n4, t4, e3.typeAnnotation || "coerce");
                  else
                    n4 = r3(n4, t4, e3.typeAnnotation || "assert");
                }
                if (!(n4 instanceof je) && "resolvedImage" !== n4.type.kind && Mr(n4)) {
                  const t4 = new We();
                  try {
                    n4 = new je(n4.type, n4.evaluate(t4));
                  } catch (t5) {
                    return this.error(t5.message), null;
                  }
                }
                return n4;
              }
              return this.error(`Unknown expression "${n3}". If you wanted a literal array, use ["literal", [...]].`, 0);
            }
            return this.error(void 0 === t3 ? "'undefined' value invalid. Use null instead." : "object" == typeof t3 ? 'Bare objects invalid. Use ["literal", {...}] instead.' : `Expected an array, but found ${typeof t3} instead.`);
          }
          concat(t3, e3, r3) {
            const n3 = "number" == typeof t3 ? this.path.concat(t3) : this.path, i3 = r3 ? this.scope.concat(r3) : this.scope;
            return new kr(this.registry, n3, e3 || null, i3, this.errors);
          }
          error(t3, ...e3) {
            const r3 = `${this.key}${e3.map((t4) => `[${t4}]`).join("")}`;
            this.errors.push(new se(r3, t3));
          }
          checkSubtype(t3, e3) {
            const r3 = we(t3, e3);
            return r3 && this.error(r3), r3;
          }
        }
        var Ir = kr;
        function Mr(t3) {
          if (t3 instanceof Sr)
            return Mr(t3.boundExpression);
          if (t3 instanceof tr && "error" === t3.name)
            return false;
          if (t3 instanceof er)
            return false;
          if (t3 instanceof vr)
            return false;
          const e3 = t3 instanceof He || t3 instanceof Ge;
          let r3 = true;
          return t3.eachChild((t4) => {
            r3 = e3 ? r3 && Mr(t4) : r3 && t4 instanceof je;
          }), !!r3 && br(t3) && _r(t3, ["zoom", "heatmap-density", "line-progress", "sky-radial-progress", "accumulated", "is-supported-script", "pitch", "distance-from-center"]);
        }
        function Tr(t3, e3) {
          const r3 = t3.length - 1;
          let n3, i3, s3 = 0, a3 = r3, o3 = 0;
          for (; s3 <= a3; )
            if (o3 = Math.floor((s3 + a3) / 2), n3 = t3[o3], i3 = t3[o3 + 1], n3 <= e3) {
              if (o3 === r3 || e3 < i3)
                return o3;
              s3 = o3 + 1;
            } else {
              if (!(n3 > e3))
                throw new Oe("Input is not a number.");
              a3 = o3 - 1;
            }
          return 0;
        }
        class zr {
          constructor(t3, e3, r3) {
            this.type = t3, this.input = e3, this.labels = [], this.outputs = [];
            for (const [t4, e4] of r3)
              this.labels.push(t4), this.outputs.push(e4);
          }
          static parse(t3, e3) {
            if (t3.length - 1 < 4)
              return e3.error(`Expected at least 4 arguments, but found only ${t3.length - 1}.`);
            if ((t3.length - 1) % 2 != 0)
              return e3.error("Expected an even number of arguments.");
            const r3 = e3.parse(t3[1], 1, ue);
            if (!r3)
              return null;
            const n3 = [];
            let i3 = null;
            e3.expectedType && "value" !== e3.expectedType.kind && (i3 = e3.expectedType);
            for (let r4 = 1; r4 < t3.length; r4 += 2) {
              const s3 = 1 === r4 ? -1 / 0 : t3[r4], a3 = t3[r4 + 1], o3 = r4, l2 = r4 + 1;
              if ("number" != typeof s3)
                return e3.error('Input/output pairs for "step" expressions must be defined using literal numeric values (not computed expressions) for the input values.', o3);
              if (n3.length && n3[n3.length - 1][0] >= s3)
                return e3.error('Input/output pairs for "step" expressions must be arranged with input values in strictly ascending order.', o3);
              const u3 = e3.parse(a3, l2, i3);
              if (!u3)
                return null;
              i3 = i3 || u3.type, n3.push([s3, u3]);
            }
            return new zr(i3, r3, n3);
          }
          evaluate(t3) {
            const e3 = this.labels, r3 = this.outputs;
            if (1 === e3.length)
              return r3[0].evaluate(t3);
            const n3 = this.input.evaluate(t3);
            if (n3 <= e3[0])
              return r3[0].evaluate(t3);
            const i3 = e3.length;
            return n3 >= e3[i3 - 1] ? r3[i3 - 1].evaluate(t3) : r3[Tr(e3, n3)].evaluate(t3);
          }
          eachChild(t3) {
            t3(this.input);
            for (const e3 of this.outputs)
              t3(e3);
          }
          outputDefined() {
            return this.outputs.every((t3) => t3.outputDefined());
          }
          serialize() {
            const t3 = ["step", this.input.serialize()];
            for (let e3 = 0; e3 < this.labels.length; e3++)
              e3 > 0 && t3.push(this.labels[e3]), t3.push(this.outputs[e3].serialize());
            return t3;
          }
        }
        var Br = zr;
        function Er(t3, e3, r3) {
          return t3 * (1 - r3) + e3 * r3;
        }
        var Cr = Object.freeze({ __proto__: null, array: function(t3, e3, r3) {
          return t3.map((t4, n3) => Er(t4, e3[n3], r3));
        }, color: function(t3, e3, r3) {
          return new Ee(Er(t3.r, e3.r, r3), Er(t3.g, e3.g, r3), Er(t3.b, e3.b, r3), Er(t3.a, e3.a, r3));
        }, number: Er });
        const Pr = 0.95047, Dr = 1.08883, Vr = 4 / 29, Lr = 6 / 29, Fr = 3 * Lr * Lr, Rr = Lr * Lr * Lr, Ur = Math.PI / 180, $r = 180 / Math.PI;
        function jr(t3) {
          return t3 > Rr ? Math.pow(t3, 1 / 3) : t3 / Fr + Vr;
        }
        function Or(t3) {
          return t3 > Lr ? t3 * t3 * t3 : Fr * (t3 - Vr);
        }
        function qr(t3) {
          return 255 * (t3 <= 31308e-7 ? 12.92 * t3 : 1.055 * Math.pow(t3, 1 / 2.4) - 0.055);
        }
        function Nr(t3) {
          return (t3 /= 255) <= 0.04045 ? t3 / 12.92 : Math.pow((t3 + 0.055) / 1.055, 2.4);
        }
        function Gr(t3) {
          const e3 = Nr(t3.r), r3 = Nr(t3.g), n3 = Nr(t3.b), i3 = jr((0.4124564 * e3 + 0.3575761 * r3 + 0.1804375 * n3) / Pr), s3 = jr((0.2126729 * e3 + 0.7151522 * r3 + 0.072175 * n3) / 1);
          return { l: 116 * s3 - 16, a: 500 * (i3 - s3), b: 200 * (s3 - jr((0.0193339 * e3 + 0.119192 * r3 + 0.9503041 * n3) / Dr)), alpha: t3.a };
        }
        function Zr(t3) {
          let e3 = (t3.l + 16) / 116, r3 = isNaN(t3.a) ? e3 : e3 + t3.a / 500, n3 = isNaN(t3.b) ? e3 : e3 - t3.b / 200;
          return e3 = 1 * Or(e3), r3 = Pr * Or(r3), n3 = Dr * Or(n3), new Ee(qr(3.2404542 * r3 - 1.5371385 * e3 - 0.4985314 * n3), qr(-0.969266 * r3 + 1.8760108 * e3 + 0.041556 * n3), qr(0.0556434 * r3 - 0.2040259 * e3 + 1.0572252 * n3), t3.alpha);
        }
        function Kr(t3, e3, r3) {
          const n3 = e3 - t3;
          return t3 + r3 * (n3 > 180 || n3 < -180 ? n3 - 360 * Math.round(n3 / 360) : n3);
        }
        const Xr = { forward: Gr, reverse: Zr, interpolate: function(t3, e3, r3) {
          return { l: Er(t3.l, e3.l, r3), a: Er(t3.a, e3.a, r3), b: Er(t3.b, e3.b, r3), alpha: Er(t3.alpha, e3.alpha, r3) };
        } }, Jr = { forward: function(t3) {
          const { l: e3, a: r3, b: n3 } = Gr(t3), i3 = Math.atan2(n3, r3) * $r;
          return { h: i3 < 0 ? i3 + 360 : i3, c: Math.sqrt(r3 * r3 + n3 * n3), l: e3, alpha: t3.a };
        }, reverse: function(t3) {
          const e3 = t3.h * Ur, r3 = t3.c;
          return Zr({ l: t3.l, a: Math.cos(e3) * r3, b: Math.sin(e3) * r3, alpha: t3.alpha });
        }, interpolate: function(t3, e3, r3) {
          return { h: Kr(t3.h, e3.h, r3), c: Er(t3.c, e3.c, r3), l: Er(t3.l, e3.l, r3), alpha: Er(t3.alpha, e3.alpha, r3) };
        } };
        var Hr = Object.freeze({ __proto__: null, hcl: Jr, lab: Xr });
        class Yr {
          constructor(t3, e3, r3, n3, i3) {
            this.type = t3, this.operator = e3, this.interpolation = r3, this.input = n3, this.labels = [], this.outputs = [];
            for (const [t4, e4] of i3)
              this.labels.push(t4), this.outputs.push(e4);
          }
          static interpolationFactor(t3, e3, r3, n3) {
            let i3 = 0;
            if ("exponential" === t3.name)
              i3 = Wr(e3, t3.base, r3, n3);
            else if ("linear" === t3.name)
              i3 = Wr(e3, 1, r3, n3);
            else if ("cubic-bezier" === t3.name) {
              const s3 = t3.controlPoints;
              i3 = new y2(s3[0], s3[1], s3[2], s3[3]).solve(Wr(e3, 1, r3, n3));
            }
            return i3;
          }
          static parse(t3, e3) {
            let [r3, n3, i3, ...s3] = t3;
            if (!Array.isArray(n3) || 0 === n3.length)
              return e3.error("Expected an interpolation type expression.", 1);
            if ("linear" === n3[0])
              n3 = { name: "linear" };
            else if ("exponential" === n3[0]) {
              const t4 = n3[1];
              if ("number" != typeof t4)
                return e3.error("Exponential interpolation requires a numeric base.", 1, 1);
              n3 = { name: "exponential", base: t4 };
            } else {
              if ("cubic-bezier" !== n3[0])
                return e3.error(`Unknown interpolation type ${String(n3[0])}`, 1, 0);
              {
                const t4 = n3.slice(1);
                if (4 !== t4.length || t4.some((t5) => "number" != typeof t5 || t5 < 0 || t5 > 1))
                  return e3.error("Cubic bezier interpolation requires four numeric arguments with values between 0 and 1.", 1);
                n3 = { name: "cubic-bezier", controlPoints: t4 };
              }
            }
            if (t3.length - 1 < 4)
              return e3.error(`Expected at least 4 arguments, but found only ${t3.length - 1}.`);
            if ((t3.length - 1) % 2 != 0)
              return e3.error("Expected an even number of arguments.");
            if (i3 = e3.parse(i3, 2, ue), !i3)
              return null;
            const a3 = [];
            let o3 = null;
            "interpolate-hcl" === r3 || "interpolate-lab" === r3 ? o3 = pe : e3.expectedType && "value" !== e3.expectedType.kind && (o3 = e3.expectedType);
            for (let t4 = 0; t4 < s3.length; t4 += 2) {
              const r4 = s3[t4], n4 = s3[t4 + 1], i4 = t4 + 3, l2 = t4 + 4;
              if ("number" != typeof r4)
                return e3.error('Input/output pairs for "interpolate" expressions must be defined using literal numeric values (not computed expressions) for the input values.', i4);
              if (a3.length && a3[a3.length - 1][0] >= r4)
                return e3.error('Input/output pairs for "interpolate" expressions must be arranged with input values in strictly ascending order.', i4);
              const u3 = e3.parse(n4, l2, o3);
              if (!u3)
                return null;
              o3 = o3 || u3.type, a3.push([r4, u3]);
            }
            return "number" === o3.kind || "color" === o3.kind || "array" === o3.kind && "number" === o3.itemType.kind && "number" == typeof o3.N ? new Yr(o3, r3, n3, i3, a3) : e3.error(`Type ${ve(o3)} is not interpolatable.`);
          }
          evaluate(t3) {
            const e3 = this.labels, r3 = this.outputs;
            if (1 === e3.length)
              return r3[0].evaluate(t3);
            const n3 = this.input.evaluate(t3);
            if (n3 <= e3[0])
              return r3[0].evaluate(t3);
            const i3 = e3.length;
            if (n3 >= e3[i3 - 1])
              return r3[i3 - 1].evaluate(t3);
            const s3 = Tr(e3, n3), a3 = Yr.interpolationFactor(this.interpolation, n3, e3[s3], e3[s3 + 1]), o3 = r3[s3].evaluate(t3), l2 = r3[s3 + 1].evaluate(t3);
            return "interpolate" === this.operator ? Cr[this.type.kind.toLowerCase()](o3, l2, a3) : "interpolate-hcl" === this.operator ? Jr.reverse(Jr.interpolate(Jr.forward(o3), Jr.forward(l2), a3)) : Xr.reverse(Xr.interpolate(Xr.forward(o3), Xr.forward(l2), a3));
          }
          eachChild(t3) {
            t3(this.input);
            for (const e3 of this.outputs)
              t3(e3);
          }
          outputDefined() {
            return this.outputs.every((t3) => t3.outputDefined());
          }
          serialize() {
            let t3;
            t3 = "linear" === this.interpolation.name ? ["linear"] : "exponential" === this.interpolation.name ? 1 === this.interpolation.base ? ["linear"] : ["exponential", this.interpolation.base] : ["cubic-bezier"].concat(this.interpolation.controlPoints);
            const e3 = [this.operator, t3, this.input.serialize()];
            for (let t4 = 0; t4 < this.labels.length; t4++)
              e3.push(this.labels[t4], this.outputs[t4].serialize());
            return e3;
          }
        }
        function Wr(t3, e3, r3, n3) {
          const i3 = n3 - r3, s3 = t3 - r3;
          return 0 === i3 ? 0 : 1 === e3 ? s3 / i3 : (Math.pow(e3, s3) - 1) / (Math.pow(e3, i3) - 1);
        }
        var Qr = Yr;
        class tn {
          constructor(t3, e3) {
            this.type = t3, this.args = e3;
          }
          static parse(t3, e3) {
            if (t3.length < 2)
              return e3.error("Expectected at least one argument.");
            let r3 = null;
            const n3 = e3.expectedType;
            n3 && "value" !== n3.kind && (r3 = n3);
            const i3 = [];
            for (const n4 of t3.slice(1)) {
              const t4 = e3.parse(n4, 1 + i3.length, r3, void 0, { typeAnnotation: "omit" });
              if (!t4)
                return null;
              r3 = r3 || t4.type, i3.push(t4);
            }
            const s3 = n3 && i3.some((t4) => we(n3, t4.type));
            return new tn(s3 ? fe : r3, i3);
          }
          evaluate(t3) {
            let e3, r3 = null, n3 = 0;
            for (const i3 of this.args) {
              if (n3++, r3 = i3.evaluate(t3), r3 && r3 instanceof Ve && !r3.available && (e3 || (e3 = r3), r3 = null, n3 === this.args.length))
                return e3;
              if (null !== r3)
                break;
            }
            return r3;
          }
          eachChild(t3) {
            this.args.forEach(t3);
          }
          outputDefined() {
            return this.args.every((t3) => t3.outputDefined());
          }
          serialize() {
            const t3 = ["coalesce"];
            return this.eachChild((e3) => {
              t3.push(e3.serialize());
            }), t3;
          }
        }
        var en = tn;
        class rn {
          constructor(t3, e3) {
            this.type = e3.type, this.bindings = [].concat(t3), this.result = e3;
          }
          evaluate(t3) {
            return this.result.evaluate(t3);
          }
          eachChild(t3) {
            for (const e3 of this.bindings)
              t3(e3[1]);
            t3(this.result);
          }
          static parse(t3, e3) {
            if (t3.length < 4)
              return e3.error(`Expected at least 3 arguments, but found ${t3.length - 1} instead.`);
            const r3 = [];
            for (let n4 = 1; n4 < t3.length - 1; n4 += 2) {
              const i3 = t3[n4];
              if ("string" != typeof i3)
                return e3.error(`Expected string, but found ${typeof i3} instead.`, n4);
              if (/[^a-zA-Z0-9_]/.test(i3))
                return e3.error("Variable names must contain only alphanumeric characters or '_'.", n4);
              const s3 = e3.parse(t3[n4 + 1], n4 + 1);
              if (!s3)
                return null;
              r3.push([i3, s3]);
            }
            const n3 = e3.parse(t3[t3.length - 1], t3.length - 1, e3.expectedType, r3);
            return n3 ? new rn(r3, n3) : null;
          }
          outputDefined() {
            return this.result.outputDefined();
          }
          serialize() {
            const t3 = ["let"];
            for (const [e3, r3] of this.bindings)
              t3.push(e3, r3.serialize());
            return t3.push(this.result.serialize()), t3;
          }
        }
        var nn = rn;
        class sn {
          constructor(t3, e3, r3) {
            this.type = t3, this.index = e3, this.input = r3;
          }
          static parse(t3, e3) {
            if (3 !== t3.length)
              return e3.error(`Expected 2 arguments, but found ${t3.length - 1} instead.`);
            const r3 = e3.parse(t3[1], 1, ue), n3 = e3.parse(t3[2], 2, xe(e3.expectedType || fe));
            return r3 && n3 ? new sn(n3.type.itemType, r3, n3) : null;
          }
          evaluate(t3) {
            const e3 = this.index.evaluate(t3), r3 = this.input.evaluate(t3);
            if (e3 < 0)
              throw new Oe(`Array index out of bounds: ${e3} < 0.`);
            if (e3 >= r3.length)
              throw new Oe(`Array index out of bounds: ${e3} > ${r3.length - 1}.`);
            if (e3 !== Math.floor(e3))
              throw new Oe(`Array index must be an integer, but found ${e3} instead.`);
            return r3[e3];
          }
          eachChild(t3) {
            t3(this.index), t3(this.input);
          }
          outputDefined() {
            return false;
          }
          serialize() {
            return ["at", this.index.serialize(), this.input.serialize()];
          }
        }
        var an = sn;
        class on {
          constructor(t3, e3) {
            this.type = he, this.needle = t3, this.haystack = e3;
          }
          static parse(t3, e3) {
            if (3 !== t3.length)
              return e3.error(`Expected 2 arguments, but found ${t3.length - 1} instead.`);
            const r3 = e3.parse(t3[1], 1, fe), n3 = e3.parse(t3[2], 2, fe);
            return r3 && n3 ? _e(r3.type, [he, ce, ue, le, fe]) ? new on(r3, n3) : e3.error(`Expected first argument to be of type boolean, string, number or null, but found ${ve(r3.type)} instead`) : null;
          }
          evaluate(t3) {
            const e3 = this.needle.evaluate(t3), r3 = this.haystack.evaluate(t3);
            if (null == r3)
              return false;
            if (!Ae(e3, ["boolean", "string", "number", "null"]))
              throw new Oe(`Expected first argument to be of type boolean, string, number or null, but found ${ve(Re(e3))} instead.`);
            if (!Ae(r3, ["string", "array"]))
              throw new Oe(`Expected second argument to be of type array or string, but found ${ve(Re(r3))} instead.`);
            return r3.indexOf(e3) >= 0;
          }
          eachChild(t3) {
            t3(this.needle), t3(this.haystack);
          }
          outputDefined() {
            return true;
          }
          serialize() {
            return ["in", this.needle.serialize(), this.haystack.serialize()];
          }
        }
        var ln = on;
        class un {
          constructor(t3, e3, r3) {
            this.type = ue, this.needle = t3, this.haystack = e3, this.fromIndex = r3;
          }
          static parse(t3, e3) {
            if (t3.length <= 2 || t3.length >= 5)
              return e3.error(`Expected 3 or 4 arguments, but found ${t3.length - 1} instead.`);
            const r3 = e3.parse(t3[1], 1, fe), n3 = e3.parse(t3[2], 2, fe);
            if (!r3 || !n3)
              return null;
            if (!_e(r3.type, [he, ce, ue, le, fe]))
              return e3.error(`Expected first argument to be of type boolean, string, number or null, but found ${ve(r3.type)} instead`);
            if (4 === t3.length) {
              const i3 = e3.parse(t3[3], 3, ue);
              return i3 ? new un(r3, n3, i3) : null;
            }
            return new un(r3, n3);
          }
          evaluate(t3) {
            const e3 = this.needle.evaluate(t3), r3 = this.haystack.evaluate(t3);
            if (!Ae(e3, ["boolean", "string", "number", "null"]))
              throw new Oe(`Expected first argument to be of type boolean, string, number or null, but found ${ve(Re(e3))} instead.`);
            if (!Ae(r3, ["string", "array"]))
              throw new Oe(`Expected second argument to be of type array or string, but found ${ve(Re(r3))} instead.`);
            if (this.fromIndex) {
              const n3 = this.fromIndex.evaluate(t3);
              return r3.indexOf(e3, n3);
            }
            return r3.indexOf(e3);
          }
          eachChild(t3) {
            t3(this.needle), t3(this.haystack), this.fromIndex && t3(this.fromIndex);
          }
          outputDefined() {
            return false;
          }
          serialize() {
            if (null != this.fromIndex && void 0 !== this.fromIndex) {
              const t3 = this.fromIndex.serialize();
              return ["index-of", this.needle.serialize(), this.haystack.serialize(), t3];
            }
            return ["index-of", this.needle.serialize(), this.haystack.serialize()];
          }
        }
        var cn = un;
        class hn {
          constructor(t3, e3, r3, n3, i3, s3) {
            this.inputType = t3, this.type = e3, this.input = r3, this.cases = n3, this.outputs = i3, this.otherwise = s3;
          }
          static parse(t3, e3) {
            if (t3.length < 5)
              return e3.error(`Expected at least 4 arguments, but found only ${t3.length - 1}.`);
            if (t3.length % 2 != 1)
              return e3.error("Expected an even number of arguments.");
            let r3, n3;
            e3.expectedType && "value" !== e3.expectedType.kind && (n3 = e3.expectedType);
            const i3 = {}, s3 = [];
            for (let a4 = 2; a4 < t3.length - 1; a4 += 2) {
              let o4 = t3[a4];
              const l2 = t3[a4 + 1];
              Array.isArray(o4) || (o4 = [o4]);
              const u3 = e3.concat(a4);
              if (0 === o4.length)
                return u3.error("Expected at least one branch label.");
              for (const t4 of o4) {
                if ("number" != typeof t4 && "string" != typeof t4)
                  return u3.error("Branch labels must be numbers or strings.");
                if ("number" == typeof t4 && Math.abs(t4) > Number.MAX_SAFE_INTEGER)
                  return u3.error(`Branch labels must be integers no larger than ${Number.MAX_SAFE_INTEGER}.`);
                if ("number" == typeof t4 && Math.floor(t4) !== t4)
                  return u3.error("Numeric branch labels must be integer values.");
                if (r3) {
                  if (u3.checkSubtype(r3, Re(t4)))
                    return null;
                } else
                  r3 = Re(t4);
                if (void 0 !== i3[String(t4)])
                  return u3.error("Branch labels must be unique.");
                i3[String(t4)] = s3.length;
              }
              const c3 = e3.parse(l2, a4, n3);
              if (!c3)
                return null;
              n3 = n3 || c3.type, s3.push(c3);
            }
            const a3 = e3.parse(t3[1], 1, fe);
            if (!a3)
              return null;
            const o3 = e3.parse(t3[t3.length - 1], t3.length - 1, n3);
            return o3 ? "value" !== a3.type.kind && e3.concat(1).checkSubtype(r3, a3.type) ? null : new hn(r3, n3, a3, i3, s3, o3) : null;
          }
          evaluate(t3) {
            const e3 = this.input.evaluate(t3);
            return (Re(e3) === this.inputType && this.outputs[this.cases[e3]] || this.otherwise).evaluate(t3);
          }
          eachChild(t3) {
            t3(this.input), this.outputs.forEach(t3), t3(this.otherwise);
          }
          outputDefined() {
            return this.outputs.every((t3) => t3.outputDefined()) && this.otherwise.outputDefined();
          }
          serialize() {
            const t3 = ["match", this.input.serialize()], e3 = Object.keys(this.cases).sort(), r3 = [], n3 = {};
            for (const t4 of e3) {
              const e4 = n3[this.cases[t4]];
              void 0 === e4 ? (n3[this.cases[t4]] = r3.length, r3.push([this.cases[t4], [t4]])) : r3[e4][1].push(t4);
            }
            const i3 = (t4) => "number" === this.inputType.kind ? Number(t4) : t4;
            for (const [e4, n4] of r3)
              t3.push(1 === n4.length ? i3(n4[0]) : n4.map(i3)), t3.push(this.outputs[e4].serialize());
            return t3.push(this.otherwise.serialize()), t3;
          }
        }
        var pn = hn;
        class dn {
          constructor(t3, e3, r3) {
            this.type = t3, this.branches = e3, this.otherwise = r3;
          }
          static parse(t3, e3) {
            if (t3.length < 4)
              return e3.error(`Expected at least 3 arguments, but found only ${t3.length - 1}.`);
            if (t3.length % 2 != 0)
              return e3.error("Expected an odd number of arguments.");
            let r3;
            e3.expectedType && "value" !== e3.expectedType.kind && (r3 = e3.expectedType);
            const n3 = [];
            for (let i4 = 1; i4 < t3.length - 1; i4 += 2) {
              const s3 = e3.parse(t3[i4], i4, he);
              if (!s3)
                return null;
              const a3 = e3.parse(t3[i4 + 1], i4 + 1, r3);
              if (!a3)
                return null;
              n3.push([s3, a3]), r3 = r3 || a3.type;
            }
            const i3 = e3.parse(t3[t3.length - 1], t3.length - 1, r3);
            return i3 ? new dn(r3, n3, i3) : null;
          }
          evaluate(t3) {
            for (const [e3, r3] of this.branches)
              if (e3.evaluate(t3))
                return r3.evaluate(t3);
            return this.otherwise.evaluate(t3);
          }
          eachChild(t3) {
            for (const [e3, r3] of this.branches)
              t3(e3), t3(r3);
            t3(this.otherwise);
          }
          outputDefined() {
            return this.branches.every(([t3, e3]) => e3.outputDefined()) && this.otherwise.outputDefined();
          }
          serialize() {
            const t3 = ["case"];
            return this.eachChild((e3) => {
              t3.push(e3.serialize());
            }), t3;
          }
        }
        var fn = dn;
        class yn {
          constructor(t3, e3, r3, n3) {
            this.type = t3, this.input = e3, this.beginIndex = r3, this.endIndex = n3;
          }
          static parse(t3, e3) {
            if (t3.length <= 2 || t3.length >= 5)
              return e3.error(`Expected 3 or 4 arguments, but found ${t3.length - 1} instead.`);
            const r3 = e3.parse(t3[1], 1, fe), n3 = e3.parse(t3[2], 2, ue);
            if (!r3 || !n3)
              return null;
            if (!_e(r3.type, [xe(fe), ce, fe]))
              return e3.error(`Expected first argument to be of type array or string, but found ${ve(r3.type)} instead`);
            if (4 === t3.length) {
              const i3 = e3.parse(t3[3], 3, ue);
              return i3 ? new yn(r3.type, r3, n3, i3) : null;
            }
            return new yn(r3.type, r3, n3);
          }
          evaluate(t3) {
            const e3 = this.input.evaluate(t3), r3 = this.beginIndex.evaluate(t3);
            if (!Ae(e3, ["string", "array"]))
              throw new Oe(`Expected first argument to be of type array or string, but found ${ve(Re(e3))} instead.`);
            if (this.endIndex) {
              const n3 = this.endIndex.evaluate(t3);
              return e3.slice(r3, n3);
            }
            return e3.slice(r3);
          }
          eachChild(t3) {
            t3(this.input), t3(this.beginIndex), this.endIndex && t3(this.endIndex);
          }
          outputDefined() {
            return false;
          }
          serialize() {
            if (null != this.endIndex && void 0 !== this.endIndex) {
              const t3 = this.endIndex.serialize();
              return ["slice", this.input.serialize(), this.beginIndex.serialize(), t3];
            }
            return ["slice", this.input.serialize(), this.beginIndex.serialize()];
          }
        }
        var mn = yn;
        function gn(t3, e3) {
          return "==" === t3 || "!=" === t3 ? "boolean" === e3.kind || "string" === e3.kind || "number" === e3.kind || "null" === e3.kind || "value" === e3.kind : "string" === e3.kind || "number" === e3.kind || "value" === e3.kind;
        }
        function xn(t3, e3, r3, n3) {
          return 0 === n3.compare(e3, r3);
        }
        function vn(t3, e3, r3) {
          const n3 = "==" !== t3 && "!=" !== t3;
          return class i3 {
            constructor(t4, e4, r4) {
              this.type = he, this.lhs = t4, this.rhs = e4, this.collator = r4, this.hasUntypedArgument = "value" === t4.type.kind || "value" === e4.type.kind;
            }
            static parse(t4, e4) {
              if (3 !== t4.length && 4 !== t4.length)
                return e4.error("Expected two or three arguments.");
              const r4 = t4[0];
              let s3 = e4.parse(t4[1], 1, fe);
              if (!s3)
                return null;
              if (!gn(r4, s3.type))
                return e4.concat(1).error(`"${r4}" comparisons are not supported for type '${ve(s3.type)}'.`);
              let a3 = e4.parse(t4[2], 2, fe);
              if (!a3)
                return null;
              if (!gn(r4, a3.type))
                return e4.concat(2).error(`"${r4}" comparisons are not supported for type '${ve(a3.type)}'.`);
              if (s3.type.kind !== a3.type.kind && "value" !== s3.type.kind && "value" !== a3.type.kind)
                return e4.error(`Cannot compare types '${ve(s3.type)}' and '${ve(a3.type)}'.`);
              n3 && ("value" === s3.type.kind && "value" !== a3.type.kind ? s3 = new Ge(a3.type, [s3]) : "value" !== s3.type.kind && "value" === a3.type.kind && (a3 = new Ge(s3.type, [a3])));
              let o3 = null;
              if (4 === t4.length) {
                if ("string" !== s3.type.kind && "string" !== a3.type.kind && "value" !== s3.type.kind && "value" !== a3.type.kind)
                  return e4.error("Cannot use collator to compare non-string types.");
                if (o3 = e4.parse(t4[3], 3, ye), !o3)
                  return null;
              }
              return new i3(s3, a3, o3);
            }
            evaluate(i4) {
              const s3 = this.lhs.evaluate(i4), a3 = this.rhs.evaluate(i4);
              if (n3 && this.hasUntypedArgument) {
                const e4 = Re(s3), r4 = Re(a3);
                if (e4.kind !== r4.kind || "string" !== e4.kind && "number" !== e4.kind)
                  throw new Oe(`Expected arguments for "${t3}" to be (string, string) or (number, number), but found (${e4.kind}, ${r4.kind}) instead.`);
              }
              if (this.collator && !n3 && this.hasUntypedArgument) {
                const t4 = Re(s3), r4 = Re(a3);
                if ("string" !== t4.kind || "string" !== r4.kind)
                  return e3(i4, s3, a3);
              }
              return this.collator ? r3(i4, s3, a3, this.collator.evaluate(i4)) : e3(i4, s3, a3);
            }
            eachChild(t4) {
              t4(this.lhs), t4(this.rhs), this.collator && t4(this.collator);
            }
            outputDefined() {
              return true;
            }
            serialize() {
              const e4 = [t3];
              return this.eachChild((t4) => {
                e4.push(t4.serialize());
              }), e4;
            }
          };
        }
        const bn = vn("==", function(t3, e3, r3) {
          return e3 === r3;
        }, xn), wn = vn("!=", function(t3, e3, r3) {
          return e3 !== r3;
        }, function(t3, e3, r3, n3) {
          return !xn(0, e3, r3, n3);
        }), _n = vn("<", function(t3, e3, r3) {
          return e3 < r3;
        }, function(t3, e3, r3, n3) {
          return n3.compare(e3, r3) < 0;
        }), An = vn(">", function(t3, e3, r3) {
          return e3 > r3;
        }, function(t3, e3, r3, n3) {
          return n3.compare(e3, r3) > 0;
        }), Sn = vn("<=", function(t3, e3, r3) {
          return e3 <= r3;
        }, function(t3, e3, r3, n3) {
          return n3.compare(e3, r3) <= 0;
        }), kn = vn(">=", function(t3, e3, r3) {
          return e3 >= r3;
        }, function(t3, e3, r3, n3) {
          return n3.compare(e3, r3) >= 0;
        });
        class In {
          constructor(t3, e3, r3, n3, i3, s3) {
            this.type = ce, this.number = t3, this.locale = e3, this.currency = r3, this.unit = n3, this.minFractionDigits = i3, this.maxFractionDigits = s3;
          }
          static parse(t3, e3) {
            if (3 !== t3.length)
              return e3.error("Expected two arguments.");
            const r3 = e3.parse(t3[1], 1, ue);
            if (!r3)
              return null;
            const n3 = t3[2];
            if ("object" != typeof n3 || Array.isArray(n3))
              return e3.error("NumberFormat options argument must be an object.");
            let i3 = null;
            if (n3.locale && (i3 = e3.parse(n3.locale, 1, ce), !i3))
              return null;
            let s3 = null;
            if (n3.currency && (s3 = e3.parse(n3.currency, 1, ce), !s3))
              return null;
            let a3 = null;
            if (n3.unit && (a3 = e3.parse(n3.unit, 1, ce), !a3))
              return null;
            let o3 = null;
            if (n3["min-fraction-digits"] && (o3 = e3.parse(n3["min-fraction-digits"], 1, ue), !o3))
              return null;
            let l2 = null;
            return n3["max-fraction-digits"] && (l2 = e3.parse(n3["max-fraction-digits"], 1, ue), !l2) ? null : new In(r3, i3, s3, a3, o3, l2);
          }
          evaluate(t3) {
            return new Intl.NumberFormat(this.locale ? this.locale.evaluate(t3) : [], { style: (this.currency ? "currency" : this.unit && "unit") || "decimal", currency: this.currency ? this.currency.evaluate(t3) : void 0, unit: this.unit ? this.unit.evaluate(t3) : void 0, minimumFractionDigits: this.minFractionDigits ? this.minFractionDigits.evaluate(t3) : void 0, maximumFractionDigits: this.maxFractionDigits ? this.maxFractionDigits.evaluate(t3) : void 0 }).format(this.number.evaluate(t3));
          }
          eachChild(t3) {
            t3(this.number), this.locale && t3(this.locale), this.currency && t3(this.currency), this.unit && t3(this.unit), this.minFractionDigits && t3(this.minFractionDigits), this.maxFractionDigits && t3(this.maxFractionDigits);
          }
          outputDefined() {
            return false;
          }
          serialize() {
            const t3 = {};
            return this.locale && (t3.locale = this.locale.serialize()), this.currency && (t3.currency = this.currency.serialize()), this.unit && (t3.unit = this.unit.serialize()), this.minFractionDigits && (t3["min-fraction-digits"] = this.minFractionDigits.serialize()), this.maxFractionDigits && (t3["max-fraction-digits"] = this.maxFractionDigits.serialize()), ["number-format", this.number.serialize(), t3];
          }
        }
        class Mn {
          constructor(t3) {
            this.type = ue, this.input = t3;
          }
          static parse(t3, e3) {
            if (2 !== t3.length)
              return e3.error(`Expected 1 argument, but found ${t3.length - 1} instead.`);
            const r3 = e3.parse(t3[1], 1);
            return r3 ? "array" !== r3.type.kind && "string" !== r3.type.kind && "value" !== r3.type.kind ? e3.error(`Expected argument of type string or array, but found ${ve(r3.type)} instead.`) : new Mn(r3) : null;
          }
          evaluate(t3) {
            const e3 = this.input.evaluate(t3);
            if ("string" == typeof e3)
              return e3.length;
            if (Array.isArray(e3))
              return e3.length;
            throw new Oe(`Expected value to be of type string or array, but found ${ve(Re(e3))} instead.`);
          }
          eachChild(t3) {
            t3(this.input);
          }
          outputDefined() {
            return false;
          }
          serialize() {
            const t3 = ["length"];
            return this.eachChild((e3) => {
              t3.push(e3.serialize());
            }), t3;
          }
        }
        const Tn = { "==": bn, "!=": wn, ">": An, "<": _n, ">=": kn, "<=": Sn, array: Ge, at: an, boolean: Ge, case: fn, coalesce: en, collator: er, format: Ze, image: Ke, in: ln, "index-of": cn, interpolate: Qr, "interpolate-hcl": Qr, "interpolate-lab": Qr, length: Mn, let: nn, literal: je, match: pn, number: Ge, "number-format": In, object: Ge, slice: mn, step: Br, string: Ge, "to-boolean": He, "to-color": He, "to-number": He, "to-string": He, var: Sr, within: vr };
        function zn(t3, [e3, r3, n3, i3]) {
          e3 = e3.evaluate(t3), r3 = r3.evaluate(t3), n3 = n3.evaluate(t3);
          const s3 = i3 ? i3.evaluate(t3) : 1, a3 = Le(e3, r3, n3, s3);
          if (a3)
            throw new Oe(a3);
          return new Ee(e3 / 255 * s3, r3 / 255 * s3, n3 / 255 * s3, s3);
        }
        function Bn(t3, e3) {
          return t3 in e3;
        }
        function En(t3, e3) {
          const r3 = e3[t3];
          return void 0 === r3 ? null : r3;
        }
        function Cn(t3) {
          return { type: t3 };
        }
        tr.register(Tn, { error: [{ kind: "error" }, [ce], (t3, [e3]) => {
          throw new Oe(e3.evaluate(t3));
        }], typeof: [ce, [fe], (t3, [e3]) => ve(Re(e3.evaluate(t3)))], "to-rgba": [xe(ue, 4), [pe], (t3, [e3]) => e3.evaluate(t3).toArray()], rgb: [pe, [ue, ue, ue], zn], rgba: [pe, [ue, ue, ue, ue], zn], has: { type: he, overloads: [[[ce], (t3, [e3]) => Bn(e3.evaluate(t3), t3.properties())], [[ce, de], (t3, [e3, r3]) => Bn(e3.evaluate(t3), r3.evaluate(t3))]] }, get: { type: fe, overloads: [[[ce], (t3, [e3]) => En(e3.evaluate(t3), t3.properties())], [[ce, de], (t3, [e3, r3]) => En(e3.evaluate(t3), r3.evaluate(t3))]] }, "feature-state": [fe, [ce], (t3, [e3]) => En(e3.evaluate(t3), t3.featureState || {})], properties: [de, [], (t3) => t3.properties()], "geometry-type": [ce, [], (t3) => t3.geometryType()], id: [fe, [], (t3) => t3.id()], zoom: [ue, [], (t3) => t3.globals.zoom], pitch: [ue, [], (t3) => t3.globals.pitch || 0], "distance-from-center": [ue, [], (t3) => t3.distanceFromCenter()], "heatmap-density": [ue, [], (t3) => t3.globals.heatmapDensity || 0], "line-progress": [ue, [], (t3) => t3.globals.lineProgress || 0], "sky-radial-progress": [ue, [], (t3) => t3.globals.skyRadialProgress || 0], accumulated: [fe, [], (t3) => void 0 === t3.globals.accumulated ? null : t3.globals.accumulated], "+": [ue, Cn(ue), (t3, e3) => {
          let r3 = 0;
          for (const n3 of e3)
            r3 += n3.evaluate(t3);
          return r3;
        }], "*": [ue, Cn(ue), (t3, e3) => {
          let r3 = 1;
          for (const n3 of e3)
            r3 *= n3.evaluate(t3);
          return r3;
        }], "-": { type: ue, overloads: [[[ue, ue], (t3, [e3, r3]) => e3.evaluate(t3) - r3.evaluate(t3)], [[ue], (t3, [e3]) => -e3.evaluate(t3)]] }, "/": [ue, [ue, ue], (t3, [e3, r3]) => e3.evaluate(t3) / r3.evaluate(t3)], "%": [ue, [ue, ue], (t3, [e3, r3]) => e3.evaluate(t3) % r3.evaluate(t3)], ln2: [ue, [], () => Math.LN2], pi: [ue, [], () => Math.PI], e: [ue, [], () => Math.E], "^": [ue, [ue, ue], (t3, [e3, r3]) => Math.pow(e3.evaluate(t3), r3.evaluate(t3))], sqrt: [ue, [ue], (t3, [e3]) => Math.sqrt(e3.evaluate(t3))], log10: [ue, [ue], (t3, [e3]) => Math.log(e3.evaluate(t3)) / Math.LN10], ln: [ue, [ue], (t3, [e3]) => Math.log(e3.evaluate(t3))], log2: [ue, [ue], (t3, [e3]) => Math.log(e3.evaluate(t3)) / Math.LN2], sin: [ue, [ue], (t3, [e3]) => Math.sin(e3.evaluate(t3))], cos: [ue, [ue], (t3, [e3]) => Math.cos(e3.evaluate(t3))], tan: [ue, [ue], (t3, [e3]) => Math.tan(e3.evaluate(t3))], asin: [ue, [ue], (t3, [e3]) => Math.asin(e3.evaluate(t3))], acos: [ue, [ue], (t3, [e3]) => Math.acos(e3.evaluate(t3))], atan: [ue, [ue], (t3, [e3]) => Math.atan(e3.evaluate(t3))], min: [ue, Cn(ue), (t3, e3) => Math.min(...e3.map((e4) => e4.evaluate(t3)))], max: [ue, Cn(ue), (t3, e3) => Math.max(...e3.map((e4) => e4.evaluate(t3)))], abs: [ue, [ue], (t3, [e3]) => Math.abs(e3.evaluate(t3))], round: [ue, [ue], (t3, [e3]) => {
          const r3 = e3.evaluate(t3);
          return r3 < 0 ? -Math.round(-r3) : Math.round(r3);
        }], floor: [ue, [ue], (t3, [e3]) => Math.floor(e3.evaluate(t3))], ceil: [ue, [ue], (t3, [e3]) => Math.ceil(e3.evaluate(t3))], "filter-==": [he, [ce, fe], (t3, [e3, r3]) => t3.properties()[e3.value] === r3.value], "filter-id-==": [he, [fe], (t3, [e3]) => t3.id() === e3.value], "filter-type-==": [he, [ce], (t3, [e3]) => t3.geometryType() === e3.value], "filter-<": [he, [ce, fe], (t3, [e3, r3]) => {
          const n3 = t3.properties()[e3.value], i3 = r3.value;
          return typeof n3 == typeof i3 && n3 < i3;
        }], "filter-id-<": [he, [fe], (t3, [e3]) => {
          const r3 = t3.id(), n3 = e3.value;
          return typeof r3 == typeof n3 && r3 < n3;
        }], "filter->": [he, [ce, fe], (t3, [e3, r3]) => {
          const n3 = t3.properties()[e3.value], i3 = r3.value;
          return typeof n3 == typeof i3 && n3 > i3;
        }], "filter-id->": [he, [fe], (t3, [e3]) => {
          const r3 = t3.id(), n3 = e3.value;
          return typeof r3 == typeof n3 && r3 > n3;
        }], "filter-<=": [he, [ce, fe], (t3, [e3, r3]) => {
          const n3 = t3.properties()[e3.value], i3 = r3.value;
          return typeof n3 == typeof i3 && n3 <= i3;
        }], "filter-id-<=": [he, [fe], (t3, [e3]) => {
          const r3 = t3.id(), n3 = e3.value;
          return typeof r3 == typeof n3 && r3 <= n3;
        }], "filter->=": [he, [ce, fe], (t3, [e3, r3]) => {
          const n3 = t3.properties()[e3.value], i3 = r3.value;
          return typeof n3 == typeof i3 && n3 >= i3;
        }], "filter-id->=": [he, [fe], (t3, [e3]) => {
          const r3 = t3.id(), n3 = e3.value;
          return typeof r3 == typeof n3 && r3 >= n3;
        }], "filter-has": [he, [fe], (t3, [e3]) => e3.value in t3.properties()], "filter-has-id": [he, [], (t3) => null !== t3.id() && void 0 !== t3.id()], "filter-type-in": [he, [xe(ce)], (t3, [e3]) => e3.value.indexOf(t3.geometryType()) >= 0], "filter-id-in": [he, [xe(fe)], (t3, [e3]) => e3.value.indexOf(t3.id()) >= 0], "filter-in-small": [he, [ce, xe(fe)], (t3, [e3, r3]) => r3.value.indexOf(t3.properties()[e3.value]) >= 0], "filter-in-large": [he, [ce, xe(fe)], (t3, [e3, r3]) => function(t4, e4, r4, n3) {
          for (; r4 <= n3; ) {
            const i3 = r4 + n3 >> 1;
            if (e4[i3] === t4)
              return true;
            e4[i3] > t4 ? n3 = i3 - 1 : r4 = i3 + 1;
          }
          return false;
        }(t3.properties()[e3.value], r3.value, 0, r3.value.length - 1)], all: { type: he, overloads: [[[he, he], (t3, [e3, r3]) => e3.evaluate(t3) && r3.evaluate(t3)], [Cn(he), (t3, e3) => {
          for (const r3 of e3)
            if (!r3.evaluate(t3))
              return false;
          return true;
        }]] }, any: { type: he, overloads: [[[he, he], (t3, [e3, r3]) => e3.evaluate(t3) || r3.evaluate(t3)], [Cn(he), (t3, e3) => {
          for (const r3 of e3)
            if (r3.evaluate(t3))
              return true;
          return false;
        }]] }, "!": [he, [he], (t3, [e3]) => !e3.evaluate(t3)], "is-supported-script": [he, [ce], (t3, [e3]) => {
          const r3 = t3.globals && t3.globals.isSupportedScript;
          return !r3 || r3(e3.evaluate(t3));
        }], upcase: [ce, [ce], (t3, [e3]) => e3.evaluate(t3).toUpperCase()], downcase: [ce, [ce], (t3, [e3]) => e3.evaluate(t3).toLowerCase()], concat: [ce, Cn(fe), (t3, e3) => e3.map((e4) => Ue(e4.evaluate(t3))).join("")], "resolved-locale": [ce, [ye], (t3, [e3]) => e3.evaluate(t3).resolvedLocale()] });
        var Pn = Tn;
        function Dn(t3) {
          return { result: "success", value: t3 };
        }
        function Vn(t3) {
          return { result: "error", value: t3 };
        }
        function Ln(t3) {
          return "data-driven" === t3["property-type"];
        }
        function Fn(t3) {
          return !!t3.expression && t3.expression.parameters.indexOf("zoom") > -1;
        }
        function Rn(t3) {
          return !!t3.expression && t3.expression.interpolated;
        }
        function Un(t3) {
          return t3 instanceof Number ? "number" : t3 instanceof String ? "string" : t3 instanceof Boolean ? "boolean" : Array.isArray(t3) ? "array" : null === t3 ? "null" : typeof t3;
        }
        function $n(t3) {
          return "object" == typeof t3 && null !== t3 && !Array.isArray(t3);
        }
        function jn(t3) {
          return t3;
        }
        function On(t3, e3) {
          const r3 = "color" === e3.type, n3 = t3.stops && "object" == typeof t3.stops[0][0], i3 = n3 || !(n3 || void 0 !== t3.property), s3 = t3.type || (Rn(e3) ? "exponential" : "interval");
          if (r3 && ((t3 = ee({}, t3)).stops && (t3.stops = t3.stops.map((t4) => [t4[0], Ee.parse(t4[1])])), t3.default = Ee.parse(t3.default ? t3.default : e3.default)), t3.colorSpace && "rgb" !== t3.colorSpace && !Hr[t3.colorSpace])
            throw new Error(`Unknown color space: ${t3.colorSpace}`);
          let a3, o3, l2;
          if ("exponential" === s3)
            a3 = Zn;
          else if ("interval" === s3)
            a3 = Gn;
          else if ("categorical" === s3) {
            a3 = Nn, o3 = /* @__PURE__ */ Object.create(null);
            for (const e4 of t3.stops)
              o3[e4[0]] = e4[1];
            l2 = typeof t3.stops[0][0];
          } else {
            if ("identity" !== s3)
              throw new Error(`Unknown function type "${s3}"`);
            a3 = Kn;
          }
          if (n3) {
            const r4 = {}, n4 = [];
            for (let e4 = 0; e4 < t3.stops.length; e4++) {
              const i5 = t3.stops[e4], s5 = i5[0].zoom;
              void 0 === r4[s5] && (r4[s5] = { zoom: s5, type: t3.type, property: t3.property, default: t3.default, stops: [] }, n4.push(s5)), r4[s5].stops.push([i5[0].value, i5[1]]);
            }
            const i4 = [];
            for (const t4 of n4)
              i4.push([r4[t4].zoom, On(r4[t4], e3)]);
            const s4 = { name: "linear" };
            return { kind: "composite", interpolationType: s4, interpolationFactor: Qr.interpolationFactor.bind(void 0, s4), zoomStops: i4.map((t4) => t4[0]), evaluate: ({ zoom: r5 }, n5) => Zn({ stops: i4, base: t3.base }, e3, r5).evaluate(r5, n5) };
          }
          if (i3) {
            const r4 = "exponential" === s3 ? { name: "exponential", base: void 0 !== t3.base ? t3.base : 1 } : null;
            return { kind: "camera", interpolationType: r4, interpolationFactor: Qr.interpolationFactor.bind(void 0, r4), zoomStops: t3.stops.map((t4) => t4[0]), evaluate: ({ zoom: r5 }) => a3(t3, e3, r5, o3, l2) };
          }
          return { kind: "source", evaluate(r4, n4) {
            const i4 = n4 && n4.properties ? n4.properties[t3.property] : void 0;
            return void 0 === i4 ? qn(t3.default, e3.default) : a3(t3, e3, i4, o3, l2);
          } };
        }
        function qn(t3, e3, r3) {
          return void 0 !== t3 ? t3 : void 0 !== e3 ? e3 : void 0 !== r3 ? r3 : void 0;
        }
        function Nn(t3, e3, r3, n3, i3) {
          return qn(typeof r3 === i3 ? n3[r3] : void 0, t3.default, e3.default);
        }
        function Gn(t3, e3, r3) {
          if ("number" !== Un(r3))
            return qn(t3.default, e3.default);
          const n3 = t3.stops.length;
          if (1 === n3)
            return t3.stops[0][1];
          if (r3 <= t3.stops[0][0])
            return t3.stops[0][1];
          if (r3 >= t3.stops[n3 - 1][0])
            return t3.stops[n3 - 1][1];
          const i3 = Tr(t3.stops.map((t4) => t4[0]), r3);
          return t3.stops[i3][1];
        }
        function Zn(t3, e3, r3) {
          const n3 = void 0 !== t3.base ? t3.base : 1;
          if ("number" !== Un(r3))
            return qn(t3.default, e3.default);
          const i3 = t3.stops.length;
          if (1 === i3)
            return t3.stops[0][1];
          if (r3 <= t3.stops[0][0])
            return t3.stops[0][1];
          if (r3 >= t3.stops[i3 - 1][0])
            return t3.stops[i3 - 1][1];
          const s3 = Tr(t3.stops.map((t4) => t4[0]), r3), a3 = function(t4, e4, r4, n4) {
            const i4 = n4 - r4, s4 = t4 - r4;
            return 0 === i4 ? 0 : 1 === e4 ? s4 / i4 : (Math.pow(e4, s4) - 1) / (Math.pow(e4, i4) - 1);
          }(r3, n3, t3.stops[s3][0], t3.stops[s3 + 1][0]), o3 = t3.stops[s3][1], l2 = t3.stops[s3 + 1][1];
          let u3 = Cr[e3.type] || jn;
          if (t3.colorSpace && "rgb" !== t3.colorSpace) {
            const e4 = Hr[t3.colorSpace];
            u3 = (t4, r4) => e4.reverse(e4.interpolate(e4.forward(t4), e4.forward(r4), a3));
          }
          return "function" == typeof o3.evaluate ? { evaluate(...t4) {
            const e4 = o3.evaluate.apply(void 0, t4), r4 = l2.evaluate.apply(void 0, t4);
            if (void 0 !== e4 && void 0 !== r4)
              return u3(e4, r4, a3);
          } } : u3(o3, l2, a3);
        }
        function Kn(t3, e3, r3) {
          return "color" === e3.type ? r3 = Ee.parse(r3) : "formatted" === e3.type ? r3 = De.fromString(r3.toString()) : "resolvedImage" === e3.type ? r3 = Ve.fromString(r3.toString()) : Un(r3) === e3.type || "enum" === e3.type && e3.values[r3] || (r3 = void 0), qn(r3, t3.default, e3.default);
        }
        class Xn {
          constructor(t3, e3) {
            this.expression = t3, this._warningHistory = {}, this._evaluator = new We(), this._defaultValue = e3 ? function(t4) {
              return "color" === t4.type && ($n(t4.default) || Array.isArray(t4.default)) ? new Ee(0, 0, 0, 0) : "color" === t4.type ? Ee.parse(t4.default) || null : void 0 === t4.default ? null : t4.default;
            }(e3) : null, this._enumValues = e3 && "enum" === e3.type ? e3.values : null;
          }
          evaluateWithoutErrorHandling(t3, e3, r3, n3, i3, s3, a3, o3) {
            return this._evaluator.globals = t3, this._evaluator.feature = e3, this._evaluator.featureState = r3, this._evaluator.canonical = n3 || null, this._evaluator.availableImages = i3 || null, this._evaluator.formattedSection = s3, this._evaluator.featureTileCoord = a3 || null, this._evaluator.featureDistanceData = o3 || null, this.expression.evaluate(this._evaluator);
          }
          evaluate(t3, e3, r3, n3, i3, s3, a3, o3) {
            this._evaluator.globals = t3, this._evaluator.feature = e3 || null, this._evaluator.featureState = r3 || null, this._evaluator.canonical = n3 || null, this._evaluator.availableImages = i3 || null, this._evaluator.formattedSection = s3 || null, this._evaluator.featureTileCoord = a3 || null, this._evaluator.featureDistanceData = o3 || null;
            try {
              const t4 = this.expression.evaluate(this._evaluator);
              if (null == t4 || "number" == typeof t4 && t4 != t4)
                return this._defaultValue;
              if (this._enumValues && !(t4 in this._enumValues))
                throw new Oe(`Expected value to be one of ${Object.keys(this._enumValues).map((t5) => JSON.stringify(t5)).join(", ")}, but found ${JSON.stringify(t4)} instead.`);
              return t4;
            } catch (t4) {
              return this._warningHistory[t4.message] || (this._warningHistory[t4.message] = true, "undefined" != typeof console && console.warn(t4.message)), this._defaultValue;
            }
          }
        }
        function Jn(t3) {
          return Array.isArray(t3) && t3.length > 0 && "string" == typeof t3[0] && t3[0] in Pn;
        }
        function Hn(t3, e3) {
          const r3 = new Ir(Pn, [], e3 ? function(t4) {
            const e4 = { color: pe, string: ce, number: ue, enum: ce, boolean: he, formatted: me, resolvedImage: ge };
            return "array" === t4.type ? xe(e4[t4.value] || fe, t4.length) : e4[t4.type];
          }(e3) : void 0), n3 = r3.parse(t3, void 0, void 0, void 0, e3 && "string" === e3.type ? { typeAnnotation: "coerce" } : void 0);
          return n3 ? Dn(new Xn(n3, e3)) : Vn(r3.errors);
        }
        class Yn {
          constructor(t3, e3) {
            this.kind = t3, this._styleExpression = e3, this.isStateDependent = "constant" !== t3 && !wr(e3.expression);
          }
          evaluateWithoutErrorHandling(t3, e3, r3, n3, i3, s3) {
            return this._styleExpression.evaluateWithoutErrorHandling(t3, e3, r3, n3, i3, s3);
          }
          evaluate(t3, e3, r3, n3, i3, s3) {
            return this._styleExpression.evaluate(t3, e3, r3, n3, i3, s3);
          }
        }
        class Wn {
          constructor(t3, e3, r3, n3) {
            this.kind = t3, this.zoomStops = r3, this._styleExpression = e3, this.isStateDependent = "camera" !== t3 && !wr(e3.expression), this.interpolationType = n3;
          }
          evaluateWithoutErrorHandling(t3, e3, r3, n3, i3, s3) {
            return this._styleExpression.evaluateWithoutErrorHandling(t3, e3, r3, n3, i3, s3);
          }
          evaluate(t3, e3, r3, n3, i3, s3) {
            return this._styleExpression.evaluate(t3, e3, r3, n3, i3, s3);
          }
          interpolationFactor(t3, e3, r3) {
            return this.interpolationType ? Qr.interpolationFactor(this.interpolationType, t3, e3, r3) : 0;
          }
        }
        function Qn(t3, e3) {
          if ("error" === (t3 = Hn(t3, e3)).result)
            return t3;
          const r3 = t3.value.expression, n3 = br(r3);
          if (!n3 && !Ln(e3))
            return Vn([new se("", "data expressions not supported")]);
          const i3 = _r(r3, ["zoom", "pitch", "distance-from-center"]);
          if (!i3 && !Fn(e3))
            return Vn([new se("", "zoom expressions not supported")]);
          const s3 = ei(r3);
          return s3 || i3 ? s3 instanceof se ? Vn([s3]) : s3 instanceof Qr && !Rn(e3) ? Vn([new se("", '"interpolate" expressions cannot be used with this property')]) : Dn(s3 ? new Wn(n3 ? "camera" : "composite", t3.value, s3.labels, s3 instanceof Qr ? s3.interpolation : void 0) : new Yn(n3 ? "constant" : "source", t3.value)) : Vn([new se("", '"zoom" expression may only be used as input to a top-level "step" or "interpolate" expression.')]);
        }
        class ti {
          constructor(t3, e3) {
            this._parameters = t3, this._specification = e3, ee(this, On(this._parameters, this._specification));
          }
          static deserialize(t3) {
            return new ti(t3._parameters, t3._specification);
          }
          static serialize(t3) {
            return { _parameters: t3._parameters, _specification: t3._specification };
          }
        }
        function ei(t3) {
          let e3 = null;
          if (t3 instanceof nn)
            e3 = ei(t3.result);
          else if (t3 instanceof en) {
            for (const r3 of t3.args)
              if (e3 = ei(r3), e3)
                break;
          } else
            (t3 instanceof Br || t3 instanceof Qr) && t3.input instanceof tr && "zoom" === t3.input.name && (e3 = t3);
          return e3 instanceof se || t3.eachChild((t4) => {
            const r3 = ei(t4);
            r3 instanceof se ? e3 = r3 : !e3 && r3 ? e3 = new se("", '"zoom" expression may only be used as input to a top-level "step" or "interpolate" expression.') : e3 && r3 && e3 !== r3 && (e3 = new se("", 'Only one zoom-based "step" or "interpolate" subexpression may be used in an expression.'));
          }), e3;
        }
        class ri {
          constructor(t3, e3, r3, n3) {
            this.message = (t3 ? `${t3}: ` : "") + r3, n3 && (this.identifier = n3), null != e3 && e3.__line__ && (this.line = e3.__line__);
          }
        }
        function ni(t3) {
          const e3 = t3.key, r3 = t3.value, n3 = t3.valueSpec || {}, i3 = t3.objectElementValidators || {}, s3 = t3.style, a3 = t3.styleSpec;
          let o3 = [];
          const l2 = Un(r3);
          if ("object" !== l2)
            return [new ri(e3, r3, `object expected, ${l2} found`)];
          for (const t4 in r3) {
            const l3 = t4.split(".")[0];
            let u3;
            i3[l3] ? u3 = i3[l3] : n3[l3] ? u3 = Fi : i3["*"] ? u3 = i3["*"] : n3["*"] && (u3 = Fi), u3 ? o3 = o3.concat(u3({ key: (e3 ? `${e3}.` : e3) + t4, value: r3[t4], valueSpec: n3[l3] || n3["*"], style: s3, styleSpec: a3, object: r3, objectKey: t4 }, r3)) : o3.push(new ri(e3, r3[t4], `unknown property "${t4}"`));
          }
          for (const t4 in n3)
            i3[t4] || n3[t4].required && void 0 === n3[t4].default && void 0 === r3[t4] && o3.push(new ri(e3, r3, `missing required property "${t4}"`));
          return o3;
        }
        function ii(t3) {
          const e3 = t3.value, r3 = t3.valueSpec, n3 = t3.style, i3 = t3.styleSpec, s3 = t3.key, a3 = t3.arrayElementValidator || Fi;
          if ("array" !== Un(e3))
            return [new ri(s3, e3, `array expected, ${Un(e3)} found`)];
          if (r3.length && e3.length !== r3.length)
            return [new ri(s3, e3, `array length ${r3.length} expected, length ${e3.length} found`)];
          if (r3["min-length"] && e3.length < r3["min-length"])
            return [new ri(s3, e3, `array length at least ${r3["min-length"]} expected, length ${e3.length} found`)];
          let o3 = { type: r3.value, values: r3.values, minimum: r3.minimum, maximum: r3.maximum, function: void 0 };
          i3.$version < 7 && (o3.function = r3.function), "object" === Un(r3.value) && (o3 = r3.value);
          let l2 = [];
          for (let t4 = 0; t4 < e3.length; t4++)
            l2 = l2.concat(a3({ array: e3, arrayIndex: t4, value: e3[t4], valueSpec: o3, style: n3, styleSpec: i3, key: `${s3}[${t4}]` }));
          return l2;
        }
        function si(t3) {
          const e3 = t3.key, r3 = t3.value, n3 = t3.valueSpec;
          let i3 = Un(r3);
          if ("number" === i3 && r3 != r3 && (i3 = "NaN"), "number" !== i3)
            return [new ri(e3, r3, `number expected, ${i3} found`)];
          if ("minimum" in n3) {
            let i4 = n3.minimum;
            if ("array" === Un(n3.minimum) && (i4 = n3.minimum[t3.arrayIndex]), r3 < i4)
              return [new ri(e3, r3, `${r3} is less than the minimum value ${i4}`)];
          }
          if ("maximum" in n3) {
            let i4 = n3.maximum;
            if ("array" === Un(n3.maximum) && (i4 = n3.maximum[t3.arrayIndex]), r3 > i4)
              return [new ri(e3, r3, `${r3} is greater than the maximum value ${i4}`)];
          }
          return [];
        }
        function ai(t3) {
          const e3 = t3.valueSpec, r3 = re(t3.value.type);
          let n3, i3, s3, a3 = {};
          const o3 = "categorical" !== r3 && void 0 === t3.value.property, l2 = !o3, u3 = "array" === Un(t3.value.stops) && "array" === Un(t3.value.stops[0]) && "object" === Un(t3.value.stops[0][0]), c3 = ni({ key: t3.key, value: t3.value, valueSpec: t3.styleSpec.function, style: t3.style, styleSpec: t3.styleSpec, objectElementValidators: { stops: function(t4) {
            if ("identity" === r3)
              return [new ri(t4.key, t4.value, 'identity function may not have a "stops" property')];
            let e4 = [];
            const n4 = t4.value;
            return e4 = e4.concat(ii({ key: t4.key, value: n4, valueSpec: t4.valueSpec, style: t4.style, styleSpec: t4.styleSpec, arrayElementValidator: h3 })), "array" === Un(n4) && 0 === n4.length && e4.push(new ri(t4.key, n4, "array must have at least one stop")), e4;
          }, default: function(t4) {
            return Fi({ key: t4.key, value: t4.value, valueSpec: e3, style: t4.style, styleSpec: t4.styleSpec });
          } } });
          return "identity" === r3 && o3 && c3.push(new ri(t3.key, t3.value, 'missing required property "property"')), "identity" === r3 || t3.value.stops || c3.push(new ri(t3.key, t3.value, 'missing required property "stops"')), "exponential" === r3 && t3.valueSpec.expression && !Rn(t3.valueSpec) && c3.push(new ri(t3.key, t3.value, "exponential functions not supported")), t3.styleSpec.$version >= 8 && (l2 && !Ln(t3.valueSpec) ? c3.push(new ri(t3.key, t3.value, "property functions not supported")) : o3 && !Fn(t3.valueSpec) && c3.push(new ri(t3.key, t3.value, "zoom functions not supported"))), "categorical" !== r3 && !u3 || void 0 !== t3.value.property || c3.push(new ri(t3.key, t3.value, '"property" property is required')), c3;
          function h3(t4) {
            let r4 = [];
            const n4 = t4.value, o4 = t4.key;
            if ("array" !== Un(n4))
              return [new ri(o4, n4, `array expected, ${Un(n4)} found`)];
            if (2 !== n4.length)
              return [new ri(o4, n4, `array length 2 expected, length ${n4.length} found`)];
            if (u3) {
              if ("object" !== Un(n4[0]))
                return [new ri(o4, n4, `object expected, ${Un(n4[0])} found`)];
              if (void 0 === n4[0].zoom)
                return [new ri(o4, n4, "object stop key must have zoom")];
              if (void 0 === n4[0].value)
                return [new ri(o4, n4, "object stop key must have value")];
              const e4 = re(n4[0].zoom);
              if ("number" != typeof e4)
                return [new ri(o4, n4[0].zoom, "stop zoom values must be numbers")];
              if (s3 && s3 > e4)
                return [new ri(o4, n4[0].zoom, "stop zoom values must appear in ascending order")];
              e4 !== s3 && (s3 = e4, i3 = void 0, a3 = {}), r4 = r4.concat(ni({ key: `${o4}[0]`, value: n4[0], valueSpec: { zoom: {} }, style: t4.style, styleSpec: t4.styleSpec, objectElementValidators: { zoom: si, value: p3 } }));
            } else
              r4 = r4.concat(p3({ key: `${o4}[0]`, value: n4[0], valueSpec: {}, style: t4.style, styleSpec: t4.styleSpec }, n4));
            return Jn(ne(n4[1])) ? r4.concat([new ri(`${o4}[1]`, n4[1], "expressions are not allowed in function stops.")]) : r4.concat(Fi({ key: `${o4}[1]`, value: n4[1], valueSpec: e3, style: t4.style, styleSpec: t4.styleSpec }));
          }
          function p3(t4, s4) {
            const o4 = Un(t4.value), l3 = re(t4.value), u4 = null !== t4.value ? t4.value : s4;
            if (n3) {
              if (o4 !== n3)
                return [new ri(t4.key, u4, `${o4} stop domain type must match previous stop domain type ${n3}`)];
            } else
              n3 = o4;
            if ("number" !== o4 && "string" !== o4 && "boolean" !== o4 && "number" != typeof l3 && "string" != typeof l3 && "boolean" != typeof l3)
              return [new ri(t4.key, u4, "stop domain value must be a number, string, or boolean")];
            if ("number" !== o4 && "categorical" !== r3) {
              let n4 = `number expected, ${o4} found`;
              return Ln(e3) && void 0 === r3 && (n4 += '\nIf you intended to use a categorical function, specify `"type": "categorical"`.'), [new ri(t4.key, u4, n4)];
            }
            return "categorical" !== r3 || "number" !== o4 || "number" == typeof l3 && isFinite(l3) && Math.floor(l3) === l3 ? "categorical" !== r3 && "number" === o4 && "number" == typeof l3 && "number" == typeof i3 && void 0 !== i3 && l3 < i3 ? [new ri(t4.key, u4, "stop domain values must appear in ascending order")] : (i3 = l3, "categorical" === r3 && l3 in a3 ? [new ri(t4.key, u4, "stop domain values must be unique")] : (a3[l3] = true, [])) : [new ri(t4.key, u4, `integer expected, found ${String(l3)}`)];
          }
        }
        function oi(t3) {
          const e3 = ("property" === t3.expressionContext ? Qn : Hn)(ne(t3.value), t3.valueSpec);
          if ("error" === e3.result)
            return e3.value.map((e4) => new ri(`${t3.key}${e4.key}`, t3.value, e4.message));
          const r3 = e3.value.expression || e3.value._styleExpression.expression;
          if ("property" === t3.expressionContext && "text-font" === t3.propertyKey && !r3.outputDefined())
            return [new ri(t3.key, t3.value, `Invalid data expression for "${t3.propertyKey}". Output values must be contained as literals within the expression.`)];
          if ("property" === t3.expressionContext && "layout" === t3.propertyType && !wr(r3))
            return [new ri(t3.key, t3.value, '"feature-state" data expressions are not supported with layout properties.')];
          if ("filter" === t3.expressionContext)
            return li(r3, t3);
          if (t3.expressionContext && 0 === t3.expressionContext.indexOf("cluster")) {
            if (!_r(r3, ["zoom", "feature-state"]))
              return [new ri(t3.key, t3.value, '"zoom" and "feature-state" expressions are not supported with cluster properties.')];
            if ("cluster-initial" === t3.expressionContext && !br(r3))
              return [new ri(t3.key, t3.value, "Feature data expressions are not supported with initial expression part of cluster properties.")];
          }
          return [];
        }
        function li(t3, e3) {
          const r3 = /* @__PURE__ */ new Set(["zoom", "feature-state", "pitch", "distance-from-center"]);
          if (e3.valueSpec && e3.valueSpec.expression)
            for (const t4 of e3.valueSpec.expression.parameters)
              r3.delete(t4);
          if (0 === r3.size)
            return [];
          const n3 = [];
          return t3 instanceof tr && r3.has(t3.name) ? [new ri(e3.key, e3.value, `["${t3.name}"] expression is not supported in a filter for a ${e3.object.type} layer with id: ${e3.object.id}`)] : (t3.eachChild((t4) => {
            n3.push(...li(t4, e3));
          }), n3);
        }
        function ui(t3) {
          const e3 = t3.key, r3 = t3.value, n3 = t3.valueSpec, i3 = [];
          return Array.isArray(n3.values) ? -1 === n3.values.indexOf(re(r3)) && i3.push(new ri(e3, r3, `expected one of [${n3.values.join(", ")}], ${JSON.stringify(r3)} found`)) : -1 === Object.keys(n3.values).indexOf(re(r3)) && i3.push(new ri(e3, r3, `expected one of [${Object.keys(n3.values).join(", ")}], ${JSON.stringify(r3)} found`)), i3;
        }
        function ci(t3) {
          if (true === t3 || false === t3)
            return true;
          if (!Array.isArray(t3) || 0 === t3.length)
            return false;
          switch (t3[0]) {
            case "has":
              return t3.length >= 2 && "$id" !== t3[1] && "$type" !== t3[1];
            case "in":
              return t3.length >= 3 && ("string" != typeof t3[1] || Array.isArray(t3[2]));
            case "!in":
            case "!has":
            case "none":
              return false;
            case "==":
            case "!=":
            case ">":
            case ">=":
            case "<":
            case "<=":
              return 3 !== t3.length || Array.isArray(t3[1]) || Array.isArray(t3[2]);
            case "any":
            case "all":
              for (const e3 of t3.slice(1))
                if (!ci(e3) && "boolean" != typeof e3)
                  return false;
              return true;
            default:
              return true;
          }
        }
        function hi(t3, e3 = "fill") {
          if (null == t3)
            return { filter: () => true, needGeometry: false, needFeature: false };
          ci(t3) || (t3 = xi(t3));
          const r3 = t3;
          let n3 = true;
          try {
            n3 = function(t4) {
              if (!fi(t4))
                return t4;
              let e4 = ne(t4);
              return di(e4), e4 = pi(e4), e4;
            }(r3);
          } catch (t4) {
            console.warn(`Failed to extract static filter. Filter will continue working, but at higher memory usage and slower framerate.
This is most likely a bug, please report this via https://github.com/mapbox/mapbox-gl-js/issues/new?assignees=&labels=&template=Bug_report.md
and paste the contents of this message in the report.
Thank you!
Filter Expression:
${JSON.stringify(r3, null, 2)}
        `);
          }
          const i3 = te[`filter_${e3}`], s3 = Hn(n3, i3);
          let a3 = null;
          if ("error" === s3.result)
            throw new Error(s3.value.map((t4) => `${t4.key}: ${t4.message}`).join(", "));
          a3 = (t4, e4, r4) => s3.value.evaluate(t4, e4, {}, r4);
          let o3 = null, l2 = null;
          if (n3 !== r3) {
            const t4 = Hn(r3, i3);
            if ("error" === t4.result)
              throw new Error(t4.value.map((t5) => `${t5.key}: ${t5.message}`).join(", "));
            o3 = (e4, r4, n4, i4, s4) => t4.value.evaluate(e4, r4, {}, n4, void 0, void 0, i4, s4), l2 = !br(t4.value.expression);
          }
          return { filter: a3, dynamicFilter: o3 || void 0, needGeometry: gi(n3), needFeature: !!l2 };
        }
        function pi(t3) {
          if (!Array.isArray(t3))
            return t3;
          const e3 = function(t4) {
            if (yi.has(t4[0])) {
              for (let e4 = 1; e4 < t4.length; e4++)
                if (fi(t4[e4]))
                  return true;
            }
            return t4;
          }(t3);
          return true === e3 ? e3 : e3.map((t4) => pi(t4));
        }
        function di(t3) {
          let e3 = false;
          const r3 = [];
          if ("case" === t3[0]) {
            for (let n3 = 1; n3 < t3.length - 1; n3 += 2)
              e3 = e3 || fi(t3[n3]), r3.push(t3[n3 + 1]);
            r3.push(t3[t3.length - 1]);
          } else if ("match" === t3[0]) {
            e3 = e3 || fi(t3[1]);
            for (let e4 = 2; e4 < t3.length - 1; e4 += 2)
              r3.push(t3[e4 + 1]);
            r3.push(t3[t3.length - 1]);
          } else if ("step" === t3[0]) {
            e3 = e3 || fi(t3[1]);
            for (let e4 = 1; e4 < t3.length - 1; e4 += 2)
              r3.push(t3[e4 + 1]);
          }
          e3 && (t3.length = 0, t3.push("any", ...r3));
          for (let e4 = 1; e4 < t3.length; e4++)
            di(t3[e4]);
        }
        function fi(t3) {
          if (!Array.isArray(t3))
            return false;
          if ("pitch" === (e3 = t3[0]) || "distance-from-center" === e3)
            return true;
          var e3;
          for (let e4 = 1; e4 < t3.length; e4++)
            if (fi(t3[e4]))
              return true;
          return false;
        }
        const yi = /* @__PURE__ */ new Set(["in", "==", "!=", ">", ">=", "<", "<=", "to-boolean"]);
        function mi(t3, e3) {
          return t3 < e3 ? -1 : t3 > e3 ? 1 : 0;
        }
        function gi(t3) {
          if (!Array.isArray(t3))
            return false;
          if ("within" === t3[0])
            return true;
          for (let e3 = 1; e3 < t3.length; e3++)
            if (gi(t3[e3]))
              return true;
          return false;
        }
        function xi(t3) {
          if (!t3)
            return true;
          const e3 = t3[0];
          return t3.length <= 1 ? "any" !== e3 : "==" === e3 ? vi(t3[1], t3[2], "==") : "!=" === e3 ? _i(vi(t3[1], t3[2], "==")) : "<" === e3 || ">" === e3 || "<=" === e3 || ">=" === e3 ? vi(t3[1], t3[2], e3) : "any" === e3 ? (r3 = t3.slice(1), ["any"].concat(r3.map(xi))) : "all" === e3 ? ["all"].concat(t3.slice(1).map(xi)) : "none" === e3 ? ["all"].concat(t3.slice(1).map(xi).map(_i)) : "in" === e3 ? bi(t3[1], t3.slice(2)) : "!in" === e3 ? _i(bi(t3[1], t3.slice(2))) : "has" === e3 ? wi(t3[1]) : "!has" === e3 ? _i(wi(t3[1])) : "within" !== e3 || t3;
          var r3;
        }
        function vi(t3, e3, r3) {
          switch (t3) {
            case "$type":
              return [`filter-type-${r3}`, e3];
            case "$id":
              return [`filter-id-${r3}`, e3];
            default:
              return [`filter-${r3}`, t3, e3];
          }
        }
        function bi(t3, e3) {
          if (0 === e3.length)
            return false;
          switch (t3) {
            case "$type":
              return ["filter-type-in", ["literal", e3]];
            case "$id":
              return ["filter-id-in", ["literal", e3]];
            default:
              return e3.length > 200 && !e3.some((t4) => typeof t4 != typeof e3[0]) ? ["filter-in-large", t3, ["literal", e3.sort(mi)]] : ["filter-in-small", t3, ["literal", e3]];
          }
        }
        function wi(t3) {
          switch (t3) {
            case "$type":
              return true;
            case "$id":
              return ["filter-has-id"];
            default:
              return ["filter-has", t3];
          }
        }
        function _i(t3) {
          return ["!", t3];
        }
        function Ai(t3) {
          return ci(ne(t3.value)) ? oi(ee({}, t3, { expressionContext: "filter", valueSpec: t3.styleSpec[`filter_${t3.layerType || "fill"}`] })) : Si(t3);
        }
        function Si(t3) {
          const e3 = t3.value, r3 = t3.key;
          if ("array" !== Un(e3))
            return [new ri(r3, e3, `array expected, ${Un(e3)} found`)];
          const n3 = t3.styleSpec;
          let i3, s3 = [];
          if (e3.length < 1)
            return [new ri(r3, e3, "filter array must have at least 1 element")];
          switch (s3 = s3.concat(ui({ key: `${r3}[0]`, value: e3[0], valueSpec: n3.filter_operator, style: t3.style, styleSpec: t3.styleSpec })), re(e3[0])) {
            case "<":
            case "<=":
            case ">":
            case ">=":
              e3.length >= 2 && "$type" === re(e3[1]) && s3.push(new ri(r3, e3, `"$type" cannot be use with operator "${e3[0]}"`));
            case "==":
            case "!=":
              3 !== e3.length && s3.push(new ri(r3, e3, `filter array for operator "${e3[0]}" must have 3 elements`));
            case "in":
            case "!in":
              e3.length >= 2 && (i3 = Un(e3[1]), "string" !== i3 && s3.push(new ri(`${r3}[1]`, e3[1], `string expected, ${i3} found`)));
              for (let a3 = 2; a3 < e3.length; a3++)
                i3 = Un(e3[a3]), "$type" === re(e3[1]) ? s3 = s3.concat(ui({ key: `${r3}[${a3}]`, value: e3[a3], valueSpec: n3.geometry_type, style: t3.style, styleSpec: t3.styleSpec })) : "string" !== i3 && "number" !== i3 && "boolean" !== i3 && s3.push(new ri(`${r3}[${a3}]`, e3[a3], `string, number, or boolean expected, ${i3} found`));
              break;
            case "any":
            case "all":
            case "none":
              for (let n4 = 1; n4 < e3.length; n4++)
                s3 = s3.concat(Si({ key: `${r3}[${n4}]`, value: e3[n4], style: t3.style, styleSpec: t3.styleSpec }));
              break;
            case "has":
            case "!has":
              i3 = Un(e3[1]), 2 !== e3.length ? s3.push(new ri(r3, e3, `filter array for "${e3[0]}" operator must have 2 elements`)) : "string" !== i3 && s3.push(new ri(`${r3}[1]`, e3[1], `string expected, ${i3} found`));
              break;
            case "within":
              i3 = Un(e3[1]), 2 !== e3.length ? s3.push(new ri(r3, e3, `filter array for "${e3[0]}" operator must have 2 elements`)) : "object" !== i3 && s3.push(new ri(`${r3}[1]`, e3[1], `object expected, ${i3} found`));
          }
          return s3;
        }
        function ki(t3, e3) {
          const r3 = t3.key, n3 = t3.style, i3 = t3.styleSpec, s3 = t3.value, a3 = t3.objectKey, o3 = i3[`${e3}_${t3.layerType}`];
          if (!o3)
            return [];
          const l2 = a3.match(/^(.*)-transition$/);
          if ("paint" === e3 && l2 && o3[l2[1]] && o3[l2[1]].transition)
            return Fi({ key: r3, value: s3, valueSpec: i3.transition, style: n3, styleSpec: i3 });
          const u3 = t3.valueSpec || o3[a3];
          if (!u3)
            return [new ri(r3, s3, `unknown property "${a3}"`)];
          let c3;
          if ("string" === Un(s3) && Ln(u3) && !u3.tokens && (c3 = /^{([^}]+)}$/.exec(s3))) {
            const t4 = `\`{ "type": "identity", "property": ${c3 ? JSON.stringify(c3[1]) : '"_"'} }\``;
            return [new ri(r3, s3, `"${a3}" does not support interpolation syntax
Use an identity property function instead: ${t4}.`)];
          }
          const h3 = [];
          return "symbol" === t3.layerType && ("text-field" === a3 && n3 && !n3.glyphs && h3.push(new ri(r3, s3, 'use of "text-field" requires a style "glyphs" property')), "text-font" === a3 && $n(ne(s3)) && "identity" === re(s3.type) && h3.push(new ri(r3, s3, '"text-font" does not support identity functions'))), h3.concat(Fi({ key: t3.key, value: s3, valueSpec: u3, style: n3, styleSpec: i3, expressionContext: "property", propertyType: e3, propertyKey: a3 }));
        }
        function Ii(t3) {
          return ki(t3, "paint");
        }
        function Mi(t3) {
          return ki(t3, "layout");
        }
        function Ti(t3) {
          let e3 = [];
          const r3 = t3.value, n3 = t3.key, i3 = t3.style, s3 = t3.styleSpec;
          r3.type || r3.ref || e3.push(new ri(n3, r3, 'either "type" or "ref" is required'));
          let a3 = re(r3.type);
          const o3 = re(r3.ref);
          if (r3.id) {
            const s4 = re(r3.id);
            for (let a4 = 0; a4 < t3.arrayIndex; a4++) {
              const t4 = i3.layers[a4];
              re(t4.id) === s4 && e3.push(new ri(n3, r3.id, `duplicate layer id "${r3.id}", previously used at line ${t4.id.__line__}`));
            }
          }
          if ("ref" in r3) {
            let t4;
            ["type", "source", "source-layer", "filter", "layout"].forEach((t5) => {
              t5 in r3 && e3.push(new ri(n3, r3[t5], `"${t5}" is prohibited for ref layers`));
            }), i3.layers.forEach((e4) => {
              re(e4.id) === o3 && (t4 = e4);
            }), t4 ? t4.ref ? e3.push(new ri(n3, r3.ref, "ref cannot reference another ref layer")) : a3 = re(t4.type) : "string" == typeof o3 && e3.push(new ri(n3, r3.ref, `ref layer "${o3}" not found`));
          } else if ("background" !== a3 && "sky" !== a3)
            if (r3.source) {
              const t4 = i3.sources && i3.sources[r3.source], s4 = t4 && re(t4.type);
              t4 ? "vector" === s4 && "raster" === a3 ? e3.push(new ri(n3, r3.source, `layer "${r3.id}" requires a raster source`)) : "raster" === s4 && "raster" !== a3 ? e3.push(new ri(n3, r3.source, `layer "${r3.id}" requires a vector source`)) : "vector" !== s4 || r3["source-layer"] ? "raster-dem" === s4 && "hillshade" !== a3 ? e3.push(new ri(n3, r3.source, "raster-dem source can only be used with layer type 'hillshade'.")) : "line" !== a3 || !r3.paint || !r3.paint["line-gradient"] && !r3.paint["line-trim-offset"] || "geojson" === s4 && t4.lineMetrics || e3.push(new ri(n3, r3, `layer "${r3.id}" specifies a line-gradient, which requires a GeoJSON source with \`lineMetrics\` enabled.`)) : e3.push(new ri(n3, r3, `layer "${r3.id}" must specify a "source-layer"`)) : e3.push(new ri(n3, r3.source, `source "${r3.source}" not found`));
            } else
              e3.push(new ri(n3, r3, 'missing required property "source"'));
          return e3 = e3.concat(ni({ key: n3, value: r3, valueSpec: s3.layer, style: t3.style, styleSpec: t3.styleSpec, objectElementValidators: { "*": () => [], type: () => Fi({ key: `${n3}.type`, value: r3.type, valueSpec: s3.layer.type, style: t3.style, styleSpec: t3.styleSpec, object: r3, objectKey: "type" }), filter: (t4) => Ai(ee({ layerType: a3 }, t4)), layout: (t4) => ni({ layer: r3, key: t4.key, value: t4.value, valueSpec: {}, style: t4.style, styleSpec: t4.styleSpec, objectElementValidators: { "*": (t5) => Mi(ee({ layerType: a3 }, t5)) } }), paint: (t4) => ni({ layer: r3, key: t4.key, value: t4.value, valueSpec: {}, style: t4.style, styleSpec: t4.styleSpec, objectElementValidators: { "*": (t5) => Ii(ee({ layerType: a3 }, t5)) } }) } })), e3;
        }
        function zi(t3) {
          const e3 = t3.value, r3 = t3.key, n3 = Un(e3);
          return "string" !== n3 ? [new ri(r3, e3, `string expected, ${n3} found`)] : [];
        }
        const Bi = { promoteId: function({ key: t3, value: e3 }) {
          if ("string" === Un(e3))
            return zi({ key: t3, value: e3 });
          {
            const r3 = [];
            for (const n3 in e3)
              r3.push(...zi({ key: `${t3}.${n3}`, value: e3[n3] }));
            return r3;
          }
        } };
        function Ei(t3) {
          const e3 = t3.value, r3 = t3.key, n3 = t3.styleSpec, i3 = t3.style;
          if (!e3.type)
            return [new ri(r3, e3, '"type" is required')];
          const s3 = re(e3.type);
          let a3;
          switch (s3) {
            case "vector":
            case "raster":
            case "raster-dem":
              return a3 = ni({ key: r3, value: e3, valueSpec: n3[`source_${s3.replace("-", "_")}`], style: t3.style, styleSpec: n3, objectElementValidators: Bi }), a3;
            case "geojson":
              if (a3 = ni({ key: r3, value: e3, valueSpec: n3.source_geojson, style: i3, styleSpec: n3, objectElementValidators: Bi }), e3.cluster)
                for (const t4 in e3.clusterProperties) {
                  const [n4, i4] = e3.clusterProperties[t4], s4 = "string" == typeof n4 ? [n4, ["accumulated"], ["get", t4]] : n4;
                  a3.push(...oi({ key: `${r3}.${t4}.map`, value: i4, expressionContext: "cluster-map" })), a3.push(...oi({ key: `${r3}.${t4}.reduce`, value: s4, expressionContext: "cluster-reduce" }));
                }
              return a3;
            case "video":
              return ni({ key: r3, value: e3, valueSpec: n3.source_video, style: i3, styleSpec: n3 });
            case "image":
              return ni({ key: r3, value: e3, valueSpec: n3.source_image, style: i3, styleSpec: n3 });
            case "canvas":
              return [new ri(r3, null, "Please use runtime APIs to add canvas sources, rather than including them in stylesheets.", "source.canvas")];
            default:
              return ui({ key: `${r3}.type`, value: e3.type, valueSpec: { values: Ci(n3) }, style: i3, styleSpec: n3 });
          }
        }
        function Ci(t3) {
          return t3.source.reduce((e3, r3) => {
            const n3 = t3[r3];
            return "enum" === n3.type.type && (e3 = e3.concat(Object.keys(n3.type.values))), e3;
          }, []);
        }
        function Pi(t3) {
          const e3 = t3.value, r3 = t3.styleSpec, n3 = r3.light, i3 = t3.style;
          let s3 = [];
          const a3 = Un(e3);
          if (void 0 === e3)
            return s3;
          if ("object" !== a3)
            return s3 = s3.concat([new ri("light", e3, `object expected, ${a3} found`)]), s3;
          for (const t4 in e3) {
            const a4 = t4.match(/^(.*)-transition$/);
            s3 = s3.concat(a4 && n3[a4[1]] && n3[a4[1]].transition ? Fi({ key: t4, value: e3[t4], valueSpec: r3.transition, style: i3, styleSpec: r3 }) : n3[t4] ? Fi({ key: t4, value: e3[t4], valueSpec: n3[t4], style: i3, styleSpec: r3 }) : [new ri(t4, e3[t4], `unknown property "${t4}"`)]);
          }
          return s3;
        }
        function Di(t3) {
          const e3 = t3.value, r3 = t3.key, n3 = t3.style, i3 = t3.styleSpec, s3 = i3.terrain;
          let a3 = [];
          const o3 = Un(e3);
          if (void 0 === e3)
            return a3;
          if ("object" !== o3)
            return a3 = a3.concat([new ri("terrain", e3, `object expected, ${o3} found`)]), a3;
          for (const t4 in e3) {
            const r4 = t4.match(/^(.*)-transition$/);
            a3 = a3.concat(r4 && s3[r4[1]] && s3[r4[1]].transition ? Fi({ key: t4, value: e3[t4], valueSpec: i3.transition, style: n3, styleSpec: i3 }) : s3[t4] ? Fi({ key: t4, value: e3[t4], valueSpec: s3[t4], style: n3, styleSpec: i3 }) : [new ri(t4, e3[t4], `unknown property "${t4}"`)]);
          }
          if (e3.source) {
            const t4 = n3.sources && n3.sources[e3.source], i4 = t4 && re(t4.type);
            t4 ? "raster-dem" !== i4 && a3.push(new ri(r3, e3.source, `terrain cannot be used with a source of type ${String(i4)}, it only be used with a "raster-dem" source type`)) : a3.push(new ri(r3, e3.source, `source "${e3.source}" not found`));
          } else
            a3.push(new ri(r3, e3, 'terrain is missing required property "source"'));
          return a3;
        }
        function Vi(t3) {
          const e3 = t3.value, r3 = t3.style, n3 = t3.styleSpec, i3 = n3.fog;
          let s3 = [];
          const a3 = Un(e3);
          if (void 0 === e3)
            return s3;
          if ("object" !== a3)
            return s3 = s3.concat([new ri("fog", e3, `object expected, ${a3} found`)]), s3;
          for (const t4 in e3) {
            const a4 = t4.match(/^(.*)-transition$/);
            s3 = s3.concat(a4 && i3[a4[1]] && i3[a4[1]].transition ? Fi({ key: t4, value: e3[t4], valueSpec: n3.transition, style: r3, styleSpec: n3 }) : i3[t4] ? Fi({ key: t4, value: e3[t4], valueSpec: i3[t4], style: r3, styleSpec: n3 }) : [new ri(t4, e3[t4], `unknown property "${t4}"`)]);
          }
          return s3;
        }
        const Li = { "*": () => [], array: ii, boolean: function(t3) {
          const e3 = t3.value, r3 = t3.key, n3 = Un(e3);
          return "boolean" !== n3 ? [new ri(r3, e3, `boolean expected, ${n3} found`)] : [];
        }, number: si, color: function(t3) {
          const e3 = t3.key, r3 = t3.value, n3 = Un(r3);
          return "string" !== n3 ? [new ri(e3, r3, `color expected, ${n3} found`)] : null === Se(r3) ? [new ri(e3, r3, `color expected, "${r3}" found`)] : [];
        }, enum: ui, filter: Ai, function: ai, layer: Ti, object: ni, source: Ei, light: Pi, terrain: Di, fog: Vi, string: zi, formatted: function(t3) {
          return 0 === zi(t3).length ? [] : oi(t3);
        }, resolvedImage: function(t3) {
          return 0 === zi(t3).length ? [] : oi(t3);
        }, projection: function(t3) {
          const e3 = t3.value, r3 = t3.styleSpec, n3 = r3.projection, i3 = t3.style;
          let s3 = [];
          const a3 = Un(e3);
          if ("object" === a3)
            for (const t4 in e3)
              s3 = s3.concat(Fi({ key: t4, value: e3[t4], valueSpec: n3[t4], style: i3, styleSpec: r3 }));
          else
            "string" !== a3 && (s3 = s3.concat([new ri("projection", e3, `object or string expected, ${a3} found`)]));
          return s3;
        } };
        function Fi(t3) {
          const e3 = t3.value, r3 = t3.valueSpec, n3 = t3.styleSpec;
          return r3.expression && $n(re(e3)) ? ai(t3) : r3.expression && Jn(ne(e3)) ? oi(t3) : r3.type && Li[r3.type] ? Li[r3.type](t3) : ni(ee({}, t3, { valueSpec: r3.type ? n3[r3.type] : r3 }));
        }
        function Ri(t3) {
          const e3 = t3.value, r3 = t3.key, n3 = zi(t3);
          return n3.length || (-1 === e3.indexOf("{fontstack}") && n3.push(new ri(r3, e3, '"glyphs" url must include a "{fontstack}" token')), -1 === e3.indexOf("{range}") && n3.push(new ri(r3, e3, '"glyphs" url must include a "{range}" token'))), n3;
        }
        function Ui(t3, e3 = te) {
          return Oi(Fi({ key: "", value: t3, valueSpec: e3.$root, styleSpec: e3, style: t3, objectElementValidators: { glyphs: Ri, "*": () => [] } }));
        }
        const $i = (t3) => Oi(Ii(t3)), ji = (t3) => Oi(Mi(t3));
        function Oi(t3) {
          return t3.slice().sort((t4, e3) => t4.line && e3.line ? t4.line - e3.line : 0);
        }
        function qi(t3, e3) {
          let r3 = false;
          if (e3 && e3.length)
            for (const n3 of e3)
              t3.fire(new Wt(new Error(n3.message))), r3 = true;
          return r3;
        }
        var Ni = Zi, Gi = 3;
        function Zi(t3, e3, r3) {
          var n3 = this.cells = [];
          if (t3 instanceof ArrayBuffer) {
            this.arrayBuffer = t3;
            var i3 = new Int32Array(this.arrayBuffer);
            t3 = i3[0], this.d = (e3 = i3[1]) + 2 * (r3 = i3[2]);
            for (var s3 = 0; s3 < this.d * this.d; s3++) {
              var a3 = i3[Gi + s3], o3 = i3[Gi + s3 + 1];
              n3.push(a3 === o3 ? null : i3.subarray(a3, o3));
            }
            var l2 = i3[Gi + n3.length + 1];
            this.keys = i3.subarray(i3[Gi + n3.length], l2), this.bboxes = i3.subarray(l2), this.insert = this._insertReadonly;
          } else {
            this.d = e3 + 2 * r3;
            for (var u3 = 0; u3 < this.d * this.d; u3++)
              n3.push([]);
            this.keys = [], this.bboxes = [];
          }
          this.n = e3, this.extent = t3, this.padding = r3, this.scale = e3 / t3, this.uid = 0;
          var c3 = r3 / e3 * t3;
          this.min = -c3, this.max = t3 + c3;
        }
        Zi.prototype.insert = function(t3, e3, r3, n3, i3) {
          this._forEachCell(e3, r3, n3, i3, this._insertCell, this.uid++), this.keys.push(t3), this.bboxes.push(e3), this.bboxes.push(r3), this.bboxes.push(n3), this.bboxes.push(i3);
        }, Zi.prototype._insertReadonly = function() {
          throw "Cannot insert into a GridIndex created from an ArrayBuffer.";
        }, Zi.prototype._insertCell = function(t3, e3, r3, n3, i3, s3) {
          this.cells[i3].push(s3);
        }, Zi.prototype.query = function(t3, e3, r3, n3, i3) {
          var s3 = this.min, a3 = this.max;
          if (t3 <= s3 && e3 <= s3 && a3 <= r3 && a3 <= n3 && !i3)
            return Array.prototype.slice.call(this.keys);
          var o3 = [];
          return this._forEachCell(t3, e3, r3, n3, this._queryCell, o3, {}, i3), o3;
        }, Zi.prototype._queryCell = function(t3, e3, r3, n3, i3, s3, a3, o3) {
          var l2 = this.cells[i3];
          if (null !== l2)
            for (var u3 = this.keys, c3 = this.bboxes, h3 = 0; h3 < l2.length; h3++) {
              var p3 = l2[h3];
              if (void 0 === a3[p3]) {
                var d3 = 4 * p3;
                (o3 ? o3(c3[d3 + 0], c3[d3 + 1], c3[d3 + 2], c3[d3 + 3]) : t3 <= c3[d3 + 2] && e3 <= c3[d3 + 3] && r3 >= c3[d3 + 0] && n3 >= c3[d3 + 1]) ? (a3[p3] = true, s3.push(u3[p3])) : a3[p3] = false;
              }
            }
        }, Zi.prototype._forEachCell = function(t3, e3, r3, n3, i3, s3, a3, o3) {
          for (var l2 = this._convertToCellCoord(t3), u3 = this._convertToCellCoord(e3), c3 = this._convertToCellCoord(r3), h3 = this._convertToCellCoord(n3), p3 = l2; p3 <= c3; p3++)
            for (var d3 = u3; d3 <= h3; d3++) {
              var f3 = this.d * d3 + p3;
              if ((!o3 || o3(this._convertFromCellCoord(p3), this._convertFromCellCoord(d3), this._convertFromCellCoord(p3 + 1), this._convertFromCellCoord(d3 + 1))) && i3.call(this, t3, e3, r3, n3, f3, s3, a3, o3))
                return;
            }
        }, Zi.prototype._convertFromCellCoord = function(t3) {
          return (t3 - this.padding) / this.scale;
        }, Zi.prototype._convertToCellCoord = function(t3) {
          return Math.max(0, Math.min(this.d - 1, Math.floor(t3 * this.scale) + this.padding));
        }, Zi.prototype.toArrayBuffer = function() {
          if (this.arrayBuffer)
            return this.arrayBuffer;
          for (var t3 = this.cells, e3 = Gi + this.cells.length + 1 + 1, r3 = 0, n3 = 0; n3 < this.cells.length; n3++)
            r3 += this.cells[n3].length;
          var i3 = new Int32Array(e3 + r3 + this.keys.length + this.bboxes.length);
          i3[0] = this.extent, i3[1] = this.n, i3[2] = this.padding;
          for (var s3 = e3, a3 = 0; a3 < t3.length; a3++) {
            var o3 = t3[a3];
            i3[Gi + a3] = s3, i3.set(o3, s3), s3 += o3.length;
          }
          return i3[Gi + t3.length] = s3, i3.set(this.keys, s3), i3[Gi + t3.length + 1] = s3 += this.keys.length, i3.set(this.bboxes, s3), s3 += this.bboxes.length, i3.buffer;
        };
        var Ki = p2(Ni);
        const Xi = {};
        function Ji(t3, e3, r3 = {}) {
          Object.defineProperty(t3, "_classRegistryKey", { value: e3, writeable: false }), Xi[e3] = { klass: t3, omit: r3.omit || [] };
        }
        Ji(Object, "Object"), Ki.serialize = function(t3, e3) {
          const r3 = t3.toArrayBuffer();
          return e3 && e3.push(r3), { buffer: r3 };
        }, Ki.deserialize = function(t3) {
          return new Ki(t3.buffer);
        }, Object.defineProperty(Ki, "name", { value: "Grid" }), Ji(Ki, "Grid"), Ji(Ee, "Color"), Ji(Error, "Error"), Ji(ut, "AJAXError"), Ji(Ve, "ResolvedImage"), Ji(ti, "StylePropertyFunction"), Ji(Xn, "StyleExpression", { omit: ["_evaluator"] }), Ji(Wn, "ZoomDependentExpression"), Ji(Yn, "ZoomConstantExpression"), Ji(tr, "CompoundExpression", { omit: ["_evaluate"] });
        for (const t3 in Pn)
          Xi[Pn[t3]._classRegistryKey] || Ji(Pn[t3], `Expression${t3}`);
        function Hi(t3) {
          return t3 && "undefined" != typeof ArrayBuffer && (t3 instanceof ArrayBuffer || t3.constructor && "ArrayBuffer" === t3.constructor.name);
        }
        function Yi(t3) {
          return e2.ImageBitmap && t3 instanceof e2.ImageBitmap;
        }
        function Wi(t3, r3) {
          if (null == t3 || "boolean" == typeof t3 || "number" == typeof t3 || "string" == typeof t3 || t3 instanceof Boolean || t3 instanceof Number || t3 instanceof String || t3 instanceof Date || t3 instanceof RegExp)
            return t3;
          if (Hi(t3) || Yi(t3))
            return r3 && r3.push(t3), t3;
          if (ArrayBuffer.isView(t3)) {
            const e3 = t3;
            return r3 && r3.push(e3.buffer), e3;
          }
          if (t3 instanceof e2.ImageData)
            return r3 && r3.push(t3.data.buffer), t3;
          if (Array.isArray(t3)) {
            const e3 = [];
            for (const n3 of t3)
              e3.push(Wi(n3, r3));
            return e3;
          }
          if ("object" == typeof t3) {
            const e3 = t3.constructor, n3 = e3._classRegistryKey;
            if (!n3)
              throw new Error(`can't serialize object of unregistered class ${n3}`);
            const i3 = e3.serialize ? e3.serialize(t3, r3) : {};
            if (!e3.serialize) {
              for (const e4 in t3)
                t3.hasOwnProperty(e4) && (Xi[n3].omit.indexOf(e4) >= 0 || (i3[e4] = Wi(t3[e4], r3)));
              t3 instanceof Error && (i3.message = t3.message);
            }
            if (i3.$name)
              throw new Error("$name property is reserved for worker serialization logic.");
            return "Object" !== n3 && (i3.$name = n3), i3;
          }
          throw new Error("can't serialize object of type " + typeof t3);
        }
        function Qi(t3) {
          if (null == t3 || "boolean" == typeof t3 || "number" == typeof t3 || "string" == typeof t3 || t3 instanceof Boolean || t3 instanceof Number || t3 instanceof String || t3 instanceof Date || t3 instanceof RegExp || Hi(t3) || Yi(t3) || ArrayBuffer.isView(t3) || t3 instanceof e2.ImageData)
            return t3;
          if (Array.isArray(t3))
            return t3.map(Qi);
          if ("object" == typeof t3) {
            const e3 = t3.$name || "Object", { klass: r3 } = Xi[e3];
            if (!r3)
              throw new Error(`can't deserialize unregistered class ${e3}`);
            if (r3.deserialize)
              return r3.deserialize(t3);
            const n3 = Object.create(r3.prototype);
            for (const e4 of Object.keys(t3))
              "$name" !== e4 && (n3[e4] = Qi(t3[e4]));
            return n3;
          }
          throw new Error("can't deserialize object of type " + typeof t3);
        }
        const ts = { "Latin-1 Supplement": (t3) => t3 >= 128 && t3 <= 255, Arabic: (t3) => t3 >= 1536 && t3 <= 1791, "Arabic Supplement": (t3) => t3 >= 1872 && t3 <= 1919, "Arabic Extended-A": (t3) => t3 >= 2208 && t3 <= 2303, "Hangul Jamo": (t3) => t3 >= 4352 && t3 <= 4607, "Unified Canadian Aboriginal Syllabics": (t3) => t3 >= 5120 && t3 <= 5759, Khmer: (t3) => t3 >= 6016 && t3 <= 6143, "Unified Canadian Aboriginal Syllabics Extended": (t3) => t3 >= 6320 && t3 <= 6399, "General Punctuation": (t3) => t3 >= 8192 && t3 <= 8303, "Letterlike Symbols": (t3) => t3 >= 8448 && t3 <= 8527, "Number Forms": (t3) => t3 >= 8528 && t3 <= 8591, "Miscellaneous Technical": (t3) => t3 >= 8960 && t3 <= 9215, "Control Pictures": (t3) => t3 >= 9216 && t3 <= 9279, "Optical Character Recognition": (t3) => t3 >= 9280 && t3 <= 9311, "Enclosed Alphanumerics": (t3) => t3 >= 9312 && t3 <= 9471, "Geometric Shapes": (t3) => t3 >= 9632 && t3 <= 9727, "Miscellaneous Symbols": (t3) => t3 >= 9728 && t3 <= 9983, "Miscellaneous Symbols and Arrows": (t3) => t3 >= 11008 && t3 <= 11263, "CJK Radicals Supplement": (t3) => t3 >= 11904 && t3 <= 12031, "Kangxi Radicals": (t3) => t3 >= 12032 && t3 <= 12255, "Ideographic Description Characters": (t3) => t3 >= 12272 && t3 <= 12287, "CJK Symbols and Punctuation": (t3) => t3 >= 12288 && t3 <= 12351, Hiragana: (t3) => t3 >= 12352 && t3 <= 12447, Katakana: (t3) => t3 >= 12448 && t3 <= 12543, Bopomofo: (t3) => t3 >= 12544 && t3 <= 12591, "Hangul Compatibility Jamo": (t3) => t3 >= 12592 && t3 <= 12687, Kanbun: (t3) => t3 >= 12688 && t3 <= 12703, "Bopomofo Extended": (t3) => t3 >= 12704 && t3 <= 12735, "CJK Strokes": (t3) => t3 >= 12736 && t3 <= 12783, "Katakana Phonetic Extensions": (t3) => t3 >= 12784 && t3 <= 12799, "Enclosed CJK Letters and Months": (t3) => t3 >= 12800 && t3 <= 13055, "CJK Compatibility": (t3) => t3 >= 13056 && t3 <= 13311, "CJK Unified Ideographs Extension A": (t3) => t3 >= 13312 && t3 <= 19903, "Yijing Hexagram Symbols": (t3) => t3 >= 19904 && t3 <= 19967, "CJK Unified Ideographs": (t3) => t3 >= 19968 && t3 <= 40959, "Yi Syllables": (t3) => t3 >= 40960 && t3 <= 42127, "Yi Radicals": (t3) => t3 >= 42128 && t3 <= 42191, "Hangul Jamo Extended-A": (t3) => t3 >= 43360 && t3 <= 43391, "Hangul Syllables": (t3) => t3 >= 44032 && t3 <= 55215, "Hangul Jamo Extended-B": (t3) => t3 >= 55216 && t3 <= 55295, "Private Use Area": (t3) => t3 >= 57344 && t3 <= 63743, "CJK Compatibility Ideographs": (t3) => t3 >= 63744 && t3 <= 64255, "Arabic Presentation Forms-A": (t3) => t3 >= 64336 && t3 <= 65023, "Vertical Forms": (t3) => t3 >= 65040 && t3 <= 65055, "CJK Compatibility Forms": (t3) => t3 >= 65072 && t3 <= 65103, "Small Form Variants": (t3) => t3 >= 65104 && t3 <= 65135, "Arabic Presentation Forms-B": (t3) => t3 >= 65136 && t3 <= 65279, "Halfwidth and Fullwidth Forms": (t3) => t3 >= 65280 && t3 <= 65519 };
        function es(t3) {
          for (const e3 of t3)
            if (is(e3.charCodeAt(0)))
              return true;
          return false;
        }
        function rs(t3) {
          for (const e3 of t3)
            if (!ns(e3.charCodeAt(0)))
              return false;
          return true;
        }
        function ns(t3) {
          return !(ts.Arabic(t3) || ts["Arabic Supplement"](t3) || ts["Arabic Extended-A"](t3) || ts["Arabic Presentation Forms-A"](t3) || ts["Arabic Presentation Forms-B"](t3));
        }
        function is(t3) {
          return !(746 !== t3 && 747 !== t3 && (t3 < 4352 || !(ts["Bopomofo Extended"](t3) || ts.Bopomofo(t3) || ts["CJK Compatibility Forms"](t3) && !(t3 >= 65097 && t3 <= 65103) || ts["CJK Compatibility Ideographs"](t3) || ts["CJK Compatibility"](t3) || ts["CJK Radicals Supplement"](t3) || ts["CJK Strokes"](t3) || !(!ts["CJK Symbols and Punctuation"](t3) || t3 >= 12296 && t3 <= 12305 || t3 >= 12308 && t3 <= 12319 || 12336 === t3) || ts["CJK Unified Ideographs Extension A"](t3) || ts["CJK Unified Ideographs"](t3) || ts["Enclosed CJK Letters and Months"](t3) || ts["Hangul Compatibility Jamo"](t3) || ts["Hangul Jamo Extended-A"](t3) || ts["Hangul Jamo Extended-B"](t3) || ts["Hangul Jamo"](t3) || ts["Hangul Syllables"](t3) || ts.Hiragana(t3) || ts["Ideographic Description Characters"](t3) || ts.Kanbun(t3) || ts["Kangxi Radicals"](t3) || ts["Katakana Phonetic Extensions"](t3) || ts.Katakana(t3) && 12540 !== t3 || !(!ts["Halfwidth and Fullwidth Forms"](t3) || 65288 === t3 || 65289 === t3 || 65293 === t3 || t3 >= 65306 && t3 <= 65310 || 65339 === t3 || 65341 === t3 || 65343 === t3 || t3 >= 65371 && t3 <= 65503 || 65507 === t3 || t3 >= 65512 && t3 <= 65519) || !(!ts["Small Form Variants"](t3) || t3 >= 65112 && t3 <= 65118 || t3 >= 65123 && t3 <= 65126) || ts["Unified Canadian Aboriginal Syllabics"](t3) || ts["Unified Canadian Aboriginal Syllabics Extended"](t3) || ts["Vertical Forms"](t3) || ts["Yijing Hexagram Symbols"](t3) || ts["Yi Syllables"](t3) || ts["Yi Radicals"](t3))));
        }
        function ss(t3) {
          return !(is(t3) || function(t4) {
            return !!(ts["Latin-1 Supplement"](t4) && (167 === t4 || 169 === t4 || 174 === t4 || 177 === t4 || 188 === t4 || 189 === t4 || 190 === t4 || 215 === t4 || 247 === t4) || ts["General Punctuation"](t4) && (8214 === t4 || 8224 === t4 || 8225 === t4 || 8240 === t4 || 8241 === t4 || 8251 === t4 || 8252 === t4 || 8258 === t4 || 8263 === t4 || 8264 === t4 || 8265 === t4 || 8273 === t4) || ts["Letterlike Symbols"](t4) || ts["Number Forms"](t4) || ts["Miscellaneous Technical"](t4) && (t4 >= 8960 && t4 <= 8967 || t4 >= 8972 && t4 <= 8991 || t4 >= 8996 && t4 <= 9e3 || 9003 === t4 || t4 >= 9085 && t4 <= 9114 || t4 >= 9150 && t4 <= 9165 || 9167 === t4 || t4 >= 9169 && t4 <= 9179 || t4 >= 9186 && t4 <= 9215) || ts["Control Pictures"](t4) && 9251 !== t4 || ts["Optical Character Recognition"](t4) || ts["Enclosed Alphanumerics"](t4) || ts["Geometric Shapes"](t4) || ts["Miscellaneous Symbols"](t4) && !(t4 >= 9754 && t4 <= 9759) || ts["Miscellaneous Symbols and Arrows"](t4) && (t4 >= 11026 && t4 <= 11055 || t4 >= 11088 && t4 <= 11097 || t4 >= 11192 && t4 <= 11243) || ts["CJK Symbols and Punctuation"](t4) || ts.Katakana(t4) || ts["Private Use Area"](t4) || ts["CJK Compatibility Forms"](t4) || ts["Small Form Variants"](t4) || ts["Halfwidth and Fullwidth Forms"](t4) || 8734 === t4 || 8756 === t4 || 8757 === t4 || t4 >= 9984 && t4 <= 10087 || t4 >= 10102 && t4 <= 10131 || 65532 === t4 || 65533 === t4);
          }(t3));
        }
        function as(t3) {
          return t3 >= 1424 && t3 <= 2303 || ts["Arabic Presentation Forms-A"](t3) || ts["Arabic Presentation Forms-B"](t3);
        }
        function os(t3, e3) {
          return !(!e3 && as(t3) || t3 >= 2304 && t3 <= 3583 || t3 >= 3840 && t3 <= 4255 || ts.Khmer(t3));
        }
        function ls(t3) {
          for (const e3 of t3)
            if (as(e3.charCodeAt(0)))
              return true;
          return false;
        }
        const us = "deferred", cs = "loading", hs = "loaded";
        let ps = null, ds = "unavailable", fs = null;
        const ys = function(t3) {
          t3 && "string" == typeof t3 && t3.indexOf("NetworkError") > -1 && (ds = "error"), ps && ps(t3);
        };
        function ms() {
          gs.fire(new Yt("pluginStateChange", { pluginStatus: ds, pluginURL: fs }));
        }
        const gs = new Qt(), xs = function() {
          return ds;
        }, vs = function() {
          if (ds !== us || !fs)
            throw new Error("rtl-text-plugin cannot be downloaded unless a pluginURL is specified");
          ds = cs, ms(), fs && pt({ url: fs }, (t3) => {
            t3 ? ys(t3) : (ds = hs, ms());
          });
        }, bs = { applyArabicShaping: null, processBidirectionalText: null, processStyledBidirectionalText: null, isLoaded: () => ds === hs || null != bs.applyArabicShaping, isLoading: () => ds === cs, setState(t3) {
          ds = t3.pluginStatus, fs = t3.pluginURL;
        }, isParsed: () => null != bs.applyArabicShaping && null != bs.processBidirectionalText && null != bs.processStyledBidirectionalText, getPluginURL: () => fs };
        class ws {
          constructor(t3, e3) {
            this.zoom = t3, e3 ? (this.now = e3.now, this.fadeDuration = e3.fadeDuration, this.transition = e3.transition, this.pitch = e3.pitch) : (this.now = 0, this.fadeDuration = 0, this.transition = {}, this.pitch = 0);
          }
          isSupportedScript(t3) {
            return function(t4, e3) {
              for (const r3 of t4)
                if (!os(r3.charCodeAt(0), e3))
                  return false;
              return true;
            }(t3, bs.isLoaded());
          }
        }
        class _s {
          constructor(t3, e3) {
            this.property = t3, this.value = e3, this.expression = function(t4, e4) {
              if ($n(t4))
                return new ti(t4, e4);
              if (Jn(t4)) {
                const r3 = Qn(t4, e4);
                if ("error" === r3.result)
                  throw new Error(r3.value.map((t5) => `${t5.key}: ${t5.message}`).join(", "));
                return r3.value;
              }
              {
                let r3 = t4;
                return "string" == typeof t4 && "color" === e4.type && (r3 = Ee.parse(t4)), { kind: "constant", evaluate: () => r3 };
              }
            }(void 0 === e3 ? t3.specification.default : e3, t3.specification);
          }
          isDataDriven() {
            return "source" === this.expression.kind || "composite" === this.expression.kind;
          }
          possiblyEvaluate(t3, e3, r3) {
            return this.property.possiblyEvaluate(this, t3, e3, r3);
          }
        }
        class As {
          constructor(t3) {
            this.property = t3, this.value = new _s(t3, void 0);
          }
          transitioned(t3, e3) {
            return new ks(this.property, this.value, e3, C({}, t3.transition, this.transition), t3.now);
          }
          untransitioned() {
            return new ks(this.property, this.value, null, {}, 0);
          }
        }
        class Ss {
          constructor(t3) {
            this._properties = t3, this._values = Object.create(t3.defaultTransitionablePropertyValues);
          }
          getValue(t3) {
            return O(this._values[t3].value.value);
          }
          setValue(t3, e3) {
            this._values.hasOwnProperty(t3) || (this._values[t3] = new As(this._values[t3].property)), this._values[t3].value = new _s(this._values[t3].property, null === e3 ? void 0 : O(e3));
          }
          getTransition(t3) {
            return O(this._values[t3].transition);
          }
          setTransition(t3, e3) {
            this._values.hasOwnProperty(t3) || (this._values[t3] = new As(this._values[t3].property)), this._values[t3].transition = O(e3) || void 0;
          }
          serialize() {
            const t3 = {};
            for (const e3 of Object.keys(this._values)) {
              const r3 = this.getValue(e3);
              void 0 !== r3 && (t3[e3] = r3);
              const n3 = this.getTransition(e3);
              void 0 !== n3 && (t3[`${e3}-transition`] = n3);
            }
            return t3;
          }
          transitioned(t3, e3) {
            const r3 = new Is(this._properties);
            for (const n3 of Object.keys(this._values))
              r3._values[n3] = this._values[n3].transitioned(t3, e3._values[n3]);
            return r3;
          }
          untransitioned() {
            const t3 = new Is(this._properties);
            for (const e3 of Object.keys(this._values))
              t3._values[e3] = this._values[e3].untransitioned();
            return t3;
          }
        }
        class ks {
          constructor(t3, e3, r3, n3, i3) {
            const s3 = n3.delay || 0, a3 = n3.duration || 0;
            i3 = i3 || 0, this.property = t3, this.value = e3, this.begin = i3 + s3, this.end = this.begin + a3, t3.specification.transition && (n3.delay || n3.duration) && (this.prior = r3);
          }
          possiblyEvaluate(t3, e3, r3) {
            const n3 = t3.now || 0, i3 = this.value.possiblyEvaluate(t3, e3, r3), s3 = this.prior;
            if (s3) {
              if (n3 > this.end)
                return this.prior = null, i3;
              if (this.value.isDataDriven())
                return this.prior = null, i3;
              if (n3 < this.begin)
                return s3.possiblyEvaluate(t3, e3, r3);
              {
                const a3 = (n3 - this.begin) / (this.end - this.begin);
                return this.property.interpolate(s3.possiblyEvaluate(t3, e3, r3), i3, S(a3));
              }
            }
            return i3;
          }
        }
        class Is {
          constructor(t3) {
            this._properties = t3, this._values = Object.create(t3.defaultTransitioningPropertyValues);
          }
          possiblyEvaluate(t3, e3, r3) {
            const n3 = new zs(this._properties);
            for (const i3 of Object.keys(this._values))
              n3._values[i3] = this._values[i3].possiblyEvaluate(t3, e3, r3);
            return n3;
          }
          hasTransition() {
            for (const t3 of Object.keys(this._values))
              if (this._values[t3].prior)
                return true;
            return false;
          }
        }
        class Ms {
          constructor(t3) {
            this._properties = t3, this._values = Object.create(t3.defaultPropertyValues);
          }
          getValue(t3) {
            return O(this._values[t3].value);
          }
          setValue(t3, e3) {
            this._values[t3] = new _s(this._values[t3].property, null === e3 ? void 0 : O(e3));
          }
          serialize() {
            const t3 = {};
            for (const e3 of Object.keys(this._values)) {
              const r3 = this.getValue(e3);
              void 0 !== r3 && (t3[e3] = r3);
            }
            return t3;
          }
          possiblyEvaluate(t3, e3, r3) {
            const n3 = new zs(this._properties);
            for (const i3 of Object.keys(this._values))
              n3._values[i3] = this._values[i3].possiblyEvaluate(t3, e3, r3);
            return n3;
          }
        }
        class Ts {
          constructor(t3, e3, r3) {
            this.property = t3, this.value = e3, this.parameters = r3;
          }
          isConstant() {
            return "constant" === this.value.kind;
          }
          constantOr(t3) {
            return "constant" === this.value.kind ? this.value.value : t3;
          }
          evaluate(t3, e3, r3, n3) {
            return this.property.evaluate(this.value, this.parameters, t3, e3, r3, n3);
          }
        }
        class zs {
          constructor(t3) {
            this._properties = t3, this._values = Object.create(t3.defaultPossiblyEvaluatedValues);
          }
          get(t3) {
            return this._values[t3];
          }
        }
        class Bs {
          constructor(t3) {
            this.specification = t3;
          }
          possiblyEvaluate(t3, e3) {
            return t3.expression.evaluate(e3);
          }
          interpolate(t3, e3, r3) {
            const n3 = Cr[this.specification.type];
            return n3 ? n3(t3, e3, r3) : t3;
          }
        }
        class Es {
          constructor(t3, e3) {
            this.specification = t3, this.overrides = e3;
          }
          possiblyEvaluate(t3, e3, r3, n3) {
            return new Ts(this, "constant" === t3.expression.kind || "camera" === t3.expression.kind ? { kind: "constant", value: t3.expression.evaluate(e3, null, {}, r3, n3) } : t3.expression, e3);
          }
          interpolate(t3, e3, r3) {
            if ("constant" !== t3.value.kind || "constant" !== e3.value.kind)
              return t3;
            if (void 0 === t3.value.value || void 0 === e3.value.value)
              return new Ts(this, { kind: "constant", value: void 0 }, t3.parameters);
            const n3 = Cr[this.specification.type];
            return n3 ? new Ts(this, { kind: "constant", value: n3(t3.value.value, e3.value.value, r3) }, t3.parameters) : t3;
          }
          evaluate(t3, e3, r3, n3, i3, s3) {
            return "constant" === t3.kind ? t3.value : t3.evaluate(e3, r3, n3, i3, s3);
          }
        }
        class Cs {
          constructor(t3) {
            this.specification = t3;
          }
          possiblyEvaluate(t3, e3, r3, n3) {
            return !!t3.expression.evaluate(e3, null, {}, r3, n3);
          }
          interpolate() {
            return false;
          }
        }
        class Ps {
          constructor(t3) {
            this.properties = t3, this.defaultPropertyValues = {}, this.defaultTransitionablePropertyValues = {}, this.defaultTransitioningPropertyValues = {}, this.defaultPossiblyEvaluatedValues = {}, this.overridableProperties = [];
            const e3 = new ws(0, {});
            for (const r3 in t3) {
              const n3 = t3[r3];
              n3.specification.overridable && this.overridableProperties.push(r3);
              const i3 = this.defaultPropertyValues[r3] = new _s(n3, void 0), s3 = this.defaultTransitionablePropertyValues[r3] = new As(n3);
              this.defaultTransitioningPropertyValues[r3] = s3.untransitioned(), this.defaultPossiblyEvaluatedValues[r3] = i3.possiblyEvaluate(e3);
            }
          }
        }
        function Ds(t3, e3) {
          return 256 * (t3 = M(Math.floor(t3), 0, 255)) + M(Math.floor(e3), 0, 255);
        }
        Ji(Es, "DataDrivenProperty"), Ji(Bs, "DataConstantProperty"), Ji(Cs, "ColorRampProperty");
        const Vs = { Int8: Int8Array, Uint8: Uint8Array, Int16: Int16Array, Uint16: Uint16Array, Int32: Int32Array, Uint32: Uint32Array, Float32: Float32Array };
        class Ls {
          constructor(t3, e3) {
            this._structArray = t3, this._pos1 = e3 * this.size, this._pos2 = this._pos1 / 2, this._pos4 = this._pos1 / 4, this._pos8 = this._pos1 / 8;
          }
        }
        class Fs {
          constructor() {
            this.isTransferred = false, this.capacity = -1, this.resize(0);
          }
          static serialize(t3, e3) {
            return t3._trim(), e3 && (t3.isTransferred = true, e3.push(t3.arrayBuffer)), { length: t3.length, arrayBuffer: t3.arrayBuffer };
          }
          static deserialize(t3) {
            const e3 = Object.create(this.prototype);
            return e3.arrayBuffer = t3.arrayBuffer, e3.length = t3.length, e3.capacity = t3.arrayBuffer.byteLength / e3.bytesPerElement, e3._refreshViews(), e3;
          }
          _trim() {
            this.length !== this.capacity && (this.capacity = this.length, this.arrayBuffer = this.arrayBuffer.slice(0, this.length * this.bytesPerElement), this._refreshViews());
          }
          clear() {
            this.length = 0;
          }
          resize(t3) {
            this.reserve(t3), this.length = t3;
          }
          reserve(t3) {
            if (t3 > this.capacity) {
              this.capacity = Math.max(t3, Math.floor(5 * this.capacity), 128), this.arrayBuffer = new ArrayBuffer(this.capacity * this.bytesPerElement);
              const e3 = this.uint8;
              this._refreshViews(), e3 && this.uint8.set(e3);
            }
          }
          _refreshViews() {
            throw new Error("_refreshViews() must be implemented by each concrete StructArray layout");
          }
          destroy() {
            this.int8 = this.uint8 = this.int16 = this.uint16 = this.int32 = this.uint32 = this.float32 = null, this.arrayBuffer = null;
          }
        }
        function Rs(t3, e3 = 1) {
          let r3 = 0, n3 = 0;
          return { members: t3.map((t4) => {
            const i3 = Vs[t4.type].BYTES_PER_ELEMENT, s3 = r3 = Us(r3, Math.max(e3, i3)), a3 = t4.components || 1;
            return n3 = Math.max(n3, i3), r3 += i3 * a3, { name: t4.name, type: t4.type, components: a3, offset: s3 };
          }), size: Us(r3, Math.max(n3, e3)), alignment: e3 };
        }
        function Us(t3, e3) {
          return Math.ceil(t3 / e3) * e3;
        }
        class $s extends Fs {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
          }
          emplaceBack(t3, e3) {
            const r3 = this.length;
            return this.resize(r3 + 1), this.emplace(r3, t3, e3);
          }
          emplace(t3, e3, r3) {
            const n3 = 2 * t3;
            return this.int16[n3 + 0] = e3, this.int16[n3 + 1] = r3, t3;
          }
        }
        $s.prototype.bytesPerElement = 4, Ji($s, "StructArrayLayout2i4");
        class js extends Fs {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
          }
          emplaceBack(t3, e3, r3) {
            const n3 = this.length;
            return this.resize(n3 + 1), this.emplace(n3, t3, e3, r3);
          }
          emplace(t3, e3, r3, n3) {
            const i3 = 3 * t3;
            return this.int16[i3 + 0] = e3, this.int16[i3 + 1] = r3, this.int16[i3 + 2] = n3, t3;
          }
        }
        js.prototype.bytesPerElement = 6, Ji(js, "StructArrayLayout3i6");
        class Os extends Fs {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
          }
          emplaceBack(t3, e3, r3, n3) {
            const i3 = this.length;
            return this.resize(i3 + 1), this.emplace(i3, t3, e3, r3, n3);
          }
          emplace(t3, e3, r3, n3, i3) {
            const s3 = 4 * t3;
            return this.int16[s3 + 0] = e3, this.int16[s3 + 1] = r3, this.int16[s3 + 2] = n3, this.int16[s3 + 3] = i3, t3;
          }
        }
        Os.prototype.bytesPerElement = 8, Ji(Os, "StructArrayLayout4i8");
        class qs extends Fs {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
          }
          emplaceBack(t3, e3, r3, n3, i3, s3, a3) {
            const o3 = this.length;
            return this.resize(o3 + 1), this.emplace(o3, t3, e3, r3, n3, i3, s3, a3);
          }
          emplace(t3, e3, r3, n3, i3, s3, a3, o3) {
            const l2 = 6 * t3, u3 = 12 * t3, c3 = 3 * t3;
            return this.int16[l2 + 0] = e3, this.int16[l2 + 1] = r3, this.uint8[u3 + 4] = n3, this.uint8[u3 + 5] = i3, this.uint8[u3 + 6] = s3, this.uint8[u3 + 7] = a3, this.float32[c3 + 2] = o3, t3;
          }
        }
        qs.prototype.bytesPerElement = 12, Ji(qs, "StructArrayLayout2i4ub1f12");
        class Ns extends Fs {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
          }
          emplaceBack(t3, e3, r3, n3) {
            const i3 = this.length;
            return this.resize(i3 + 1), this.emplace(i3, t3, e3, r3, n3);
          }
          emplace(t3, e3, r3, n3, i3) {
            const s3 = 4 * t3;
            return this.float32[s3 + 0] = e3, this.float32[s3 + 1] = r3, this.float32[s3 + 2] = n3, this.float32[s3 + 3] = i3, t3;
          }
        }
        Ns.prototype.bytesPerElement = 16, Ji(Ns, "StructArrayLayout4f16");
        class Gs extends Fs {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
          }
          emplaceBack(t3, e3, r3, n3, i3) {
            const s3 = this.length;
            return this.resize(s3 + 1), this.emplace(s3, t3, e3, r3, n3, i3);
          }
          emplace(t3, e3, r3, n3, i3, s3) {
            const a3 = 6 * t3, o3 = 3 * t3;
            return this.uint16[a3 + 0] = e3, this.uint16[a3 + 1] = r3, this.uint16[a3 + 2] = n3, this.uint16[a3 + 3] = i3, this.float32[o3 + 2] = s3, t3;
          }
        }
        Gs.prototype.bytesPerElement = 12, Ji(Gs, "StructArrayLayout4ui1f12");
        class Zs extends Fs {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
          }
          emplaceBack(t3, e3, r3, n3) {
            const i3 = this.length;
            return this.resize(i3 + 1), this.emplace(i3, t3, e3, r3, n3);
          }
          emplace(t3, e3, r3, n3, i3) {
            const s3 = 4 * t3;
            return this.uint16[s3 + 0] = e3, this.uint16[s3 + 1] = r3, this.uint16[s3 + 2] = n3, this.uint16[s3 + 3] = i3, t3;
          }
        }
        Zs.prototype.bytesPerElement = 8, Ji(Zs, "StructArrayLayout4ui8");
        class Ks extends Fs {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
          }
          emplaceBack(t3, e3, r3, n3, i3, s3) {
            const a3 = this.length;
            return this.resize(a3 + 1), this.emplace(a3, t3, e3, r3, n3, i3, s3);
          }
          emplace(t3, e3, r3, n3, i3, s3, a3) {
            const o3 = 6 * t3;
            return this.int16[o3 + 0] = e3, this.int16[o3 + 1] = r3, this.int16[o3 + 2] = n3, this.int16[o3 + 3] = i3, this.int16[o3 + 4] = s3, this.int16[o3 + 5] = a3, t3;
          }
        }
        Ks.prototype.bytesPerElement = 12, Ji(Ks, "StructArrayLayout6i12");
        class Xs extends Fs {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
          }
          emplaceBack(t3, e3, r3, n3, i3, s3, a3, o3, l2, u3, c3, h3) {
            const p3 = this.length;
            return this.resize(p3 + 1), this.emplace(p3, t3, e3, r3, n3, i3, s3, a3, o3, l2, u3, c3, h3);
          }
          emplace(t3, e3, r3, n3, i3, s3, a3, o3, l2, u3, c3, h3, p3) {
            const d3 = 12 * t3;
            return this.int16[d3 + 0] = e3, this.int16[d3 + 1] = r3, this.int16[d3 + 2] = n3, this.int16[d3 + 3] = i3, this.uint16[d3 + 4] = s3, this.uint16[d3 + 5] = a3, this.uint16[d3 + 6] = o3, this.uint16[d3 + 7] = l2, this.int16[d3 + 8] = u3, this.int16[d3 + 9] = c3, this.int16[d3 + 10] = h3, this.int16[d3 + 11] = p3, t3;
          }
        }
        Xs.prototype.bytesPerElement = 24, Ji(Xs, "StructArrayLayout4i4ui4i24");
        class Js extends Fs {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
          }
          emplaceBack(t3, e3, r3, n3, i3, s3) {
            const a3 = this.length;
            return this.resize(a3 + 1), this.emplace(a3, t3, e3, r3, n3, i3, s3);
          }
          emplace(t3, e3, r3, n3, i3, s3, a3) {
            const o3 = 10 * t3, l2 = 5 * t3;
            return this.int16[o3 + 0] = e3, this.int16[o3 + 1] = r3, this.int16[o3 + 2] = n3, this.float32[l2 + 2] = i3, this.float32[l2 + 3] = s3, this.float32[l2 + 4] = a3, t3;
          }
        }
        Js.prototype.bytesPerElement = 20, Ji(Js, "StructArrayLayout3i3f20");
        class Hs extends Fs {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer);
          }
          emplaceBack(t3) {
            const e3 = this.length;
            return this.resize(e3 + 1), this.emplace(e3, t3);
          }
          emplace(t3, e3) {
            return this.uint32[1 * t3 + 0] = e3, t3;
          }
        }
        Hs.prototype.bytesPerElement = 4, Ji(Hs, "StructArrayLayout1ul4");
        class Ys extends Fs {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
          }
          emplaceBack(t3, e3, r3, n3, i3, s3, a3, o3, l2, u3, c3, h3, p3) {
            const d3 = this.length;
            return this.resize(d3 + 1), this.emplace(d3, t3, e3, r3, n3, i3, s3, a3, o3, l2, u3, c3, h3, p3);
          }
          emplace(t3, e3, r3, n3, i3, s3, a3, o3, l2, u3, c3, h3, p3, d3) {
            const f3 = 20 * t3, y3 = 10 * t3;
            return this.int16[f3 + 0] = e3, this.int16[f3 + 1] = r3, this.int16[f3 + 2] = n3, this.int16[f3 + 3] = i3, this.int16[f3 + 4] = s3, this.float32[y3 + 3] = a3, this.float32[y3 + 4] = o3, this.float32[y3 + 5] = l2, this.float32[y3 + 6] = u3, this.int16[f3 + 14] = c3, this.uint32[y3 + 8] = h3, this.uint16[f3 + 18] = p3, this.uint16[f3 + 19] = d3, t3;
          }
        }
        Ys.prototype.bytesPerElement = 40, Ji(Ys, "StructArrayLayout5i4f1i1ul2ui40");
        class Ws extends Fs {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
          }
          emplaceBack(t3, e3, r3, n3, i3, s3, a3) {
            const o3 = this.length;
            return this.resize(o3 + 1), this.emplace(o3, t3, e3, r3, n3, i3, s3, a3);
          }
          emplace(t3, e3, r3, n3, i3, s3, a3, o3) {
            const l2 = 8 * t3;
            return this.int16[l2 + 0] = e3, this.int16[l2 + 1] = r3, this.int16[l2 + 2] = n3, this.int16[l2 + 4] = i3, this.int16[l2 + 5] = s3, this.int16[l2 + 6] = a3, this.int16[l2 + 7] = o3, t3;
          }
        }
        Ws.prototype.bytesPerElement = 16, Ji(Ws, "StructArrayLayout3i2i2i16");
        class Qs extends Fs {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
          }
          emplaceBack(t3, e3, r3, n3, i3) {
            const s3 = this.length;
            return this.resize(s3 + 1), this.emplace(s3, t3, e3, r3, n3, i3);
          }
          emplace(t3, e3, r3, n3, i3, s3) {
            const a3 = 4 * t3, o3 = 8 * t3;
            return this.float32[a3 + 0] = e3, this.float32[a3 + 1] = r3, this.float32[a3 + 2] = n3, this.int16[o3 + 6] = i3, this.int16[o3 + 7] = s3, t3;
          }
        }
        Qs.prototype.bytesPerElement = 16, Ji(Qs, "StructArrayLayout2f1f2i16");
        class ta extends Fs {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
          }
          emplaceBack(t3, e3, r3, n3) {
            const i3 = this.length;
            return this.resize(i3 + 1), this.emplace(i3, t3, e3, r3, n3);
          }
          emplace(t3, e3, r3, n3, i3) {
            const s3 = 12 * t3, a3 = 3 * t3;
            return this.uint8[s3 + 0] = e3, this.uint8[s3 + 1] = r3, this.float32[a3 + 1] = n3, this.float32[a3 + 2] = i3, t3;
          }
        }
        ta.prototype.bytesPerElement = 12, Ji(ta, "StructArrayLayout2ub2f12");
        class ea extends Fs {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
          }
          emplaceBack(t3, e3, r3) {
            const n3 = this.length;
            return this.resize(n3 + 1), this.emplace(n3, t3, e3, r3);
          }
          emplace(t3, e3, r3, n3) {
            const i3 = 3 * t3;
            return this.float32[i3 + 0] = e3, this.float32[i3 + 1] = r3, this.float32[i3 + 2] = n3, t3;
          }
        }
        ea.prototype.bytesPerElement = 12, Ji(ea, "StructArrayLayout3f12");
        class ra extends Fs {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
          }
          emplaceBack(t3, e3, r3) {
            const n3 = this.length;
            return this.resize(n3 + 1), this.emplace(n3, t3, e3, r3);
          }
          emplace(t3, e3, r3, n3) {
            const i3 = 3 * t3;
            return this.uint16[i3 + 0] = e3, this.uint16[i3 + 1] = r3, this.uint16[i3 + 2] = n3, t3;
          }
        }
        ra.prototype.bytesPerElement = 6, Ji(ra, "StructArrayLayout3ui6");
        class na extends Fs {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer);
          }
          emplaceBack(t3, e3, r3, n3, i3, s3, a3, o3, l2, u3, c3, h3, p3, d3, f3, y3, m3, g3, x3, v3, b2) {
            const w2 = this.length;
            return this.resize(w2 + 1), this.emplace(w2, t3, e3, r3, n3, i3, s3, a3, o3, l2, u3, c3, h3, p3, d3, f3, y3, m3, g3, x3, v3, b2);
          }
          emplace(t3, e3, r3, n3, i3, s3, a3, o3, l2, u3, c3, h3, p3, d3, f3, y3, m3, g3, x3, v3, b2, w2) {
            const _2 = 30 * t3, A2 = 15 * t3, S2 = 60 * t3;
            return this.int16[_2 + 0] = e3, this.int16[_2 + 1] = r3, this.int16[_2 + 2] = n3, this.float32[A2 + 2] = i3, this.float32[A2 + 3] = s3, this.uint16[_2 + 8] = a3, this.uint16[_2 + 9] = o3, this.uint32[A2 + 5] = l2, this.uint32[A2 + 6] = u3, this.uint32[A2 + 7] = c3, this.uint16[_2 + 16] = h3, this.uint16[_2 + 17] = p3, this.uint16[_2 + 18] = d3, this.float32[A2 + 10] = f3, this.float32[A2 + 11] = y3, this.uint8[S2 + 48] = m3, this.uint8[S2 + 49] = g3, this.uint8[S2 + 50] = x3, this.uint32[A2 + 13] = v3, this.int16[_2 + 28] = b2, this.uint8[S2 + 58] = w2, t3;
          }
        }
        na.prototype.bytesPerElement = 60, Ji(na, "StructArrayLayout3i2f2ui3ul3ui2f3ub1ul1i1ub60");
        class ia extends Fs {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer);
          }
          emplaceBack(t3, e3, r3, n3, i3, s3, a3, o3, l2, u3, c3, h3, p3, d3, f3, y3, m3, g3, x3, v3, b2, w2, _2, A2, S2, k2, I2, M2, T2, z2) {
            const B2 = this.length;
            return this.resize(B2 + 1), this.emplace(B2, t3, e3, r3, n3, i3, s3, a3, o3, l2, u3, c3, h3, p3, d3, f3, y3, m3, g3, x3, v3, b2, w2, _2, A2, S2, k2, I2, M2, T2, z2);
          }
          emplace(t3, e3, r3, n3, i3, s3, a3, o3, l2, u3, c3, h3, p3, d3, f3, y3, m3, g3, x3, v3, b2, w2, _2, A2, S2, k2, I2, M2, T2, z2, B2) {
            const E3 = 38 * t3, C2 = 19 * t3;
            return this.int16[E3 + 0] = e3, this.int16[E3 + 1] = r3, this.int16[E3 + 2] = n3, this.float32[C2 + 2] = i3, this.float32[C2 + 3] = s3, this.int16[E3 + 8] = a3, this.int16[E3 + 9] = o3, this.int16[E3 + 10] = l2, this.int16[E3 + 11] = u3, this.int16[E3 + 12] = c3, this.int16[E3 + 13] = h3, this.uint16[E3 + 14] = p3, this.uint16[E3 + 15] = d3, this.uint16[E3 + 16] = f3, this.uint16[E3 + 17] = y3, this.uint16[E3 + 18] = m3, this.uint16[E3 + 19] = g3, this.uint16[E3 + 20] = x3, this.uint16[E3 + 21] = v3, this.uint16[E3 + 22] = b2, this.uint16[E3 + 23] = w2, this.uint16[E3 + 24] = _2, this.uint16[E3 + 25] = A2, this.uint16[E3 + 26] = S2, this.uint16[E3 + 27] = k2, this.uint16[E3 + 28] = I2, this.uint32[C2 + 15] = M2, this.float32[C2 + 16] = T2, this.float32[C2 + 17] = z2, this.float32[C2 + 18] = B2, t3;
          }
        }
        ia.prototype.bytesPerElement = 76, Ji(ia, "StructArrayLayout3i2f6i15ui1ul3f76");
        class sa extends Fs {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
          }
          emplaceBack(t3) {
            const e3 = this.length;
            return this.resize(e3 + 1), this.emplace(e3, t3);
          }
          emplace(t3, e3) {
            return this.float32[1 * t3 + 0] = e3, t3;
          }
        }
        sa.prototype.bytesPerElement = 4, Ji(sa, "StructArrayLayout1f4");
        class aa extends Fs {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
          }
          emplaceBack(t3, e3, r3, n3, i3) {
            const s3 = this.length;
            return this.resize(s3 + 1), this.emplace(s3, t3, e3, r3, n3, i3);
          }
          emplace(t3, e3, r3, n3, i3, s3) {
            const a3 = 5 * t3;
            return this.float32[a3 + 0] = e3, this.float32[a3 + 1] = r3, this.float32[a3 + 2] = n3, this.float32[a3 + 3] = i3, this.float32[a3 + 4] = s3, t3;
          }
        }
        aa.prototype.bytesPerElement = 20, Ji(aa, "StructArrayLayout5f20");
        class oa extends Fs {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
          }
          emplaceBack(t3, e3, r3, n3) {
            const i3 = this.length;
            return this.resize(i3 + 1), this.emplace(i3, t3, e3, r3, n3);
          }
          emplace(t3, e3, r3, n3, i3) {
            const s3 = 6 * t3;
            return this.uint32[3 * t3 + 0] = e3, this.uint16[s3 + 2] = r3, this.uint16[s3 + 3] = n3, this.uint16[s3 + 4] = i3, t3;
          }
        }
        oa.prototype.bytesPerElement = 12, Ji(oa, "StructArrayLayout1ul3ui12");
        class la extends Fs {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
          }
          emplaceBack(t3, e3) {
            const r3 = this.length;
            return this.resize(r3 + 1), this.emplace(r3, t3, e3);
          }
          emplace(t3, e3, r3) {
            const n3 = 2 * t3;
            return this.uint16[n3 + 0] = e3, this.uint16[n3 + 1] = r3, t3;
          }
        }
        la.prototype.bytesPerElement = 4, Ji(la, "StructArrayLayout2ui4");
        class ua extends Fs {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
          }
          emplaceBack(t3) {
            const e3 = this.length;
            return this.resize(e3 + 1), this.emplace(e3, t3);
          }
          emplace(t3, e3) {
            return this.uint16[1 * t3 + 0] = e3, t3;
          }
        }
        ua.prototype.bytesPerElement = 2, Ji(ua, "StructArrayLayout1ui2");
        class ca extends Fs {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
          }
          emplaceBack(t3, e3) {
            const r3 = this.length;
            return this.resize(r3 + 1), this.emplace(r3, t3, e3);
          }
          emplace(t3, e3, r3) {
            const n3 = 2 * t3;
            return this.float32[n3 + 0] = e3, this.float32[n3 + 1] = r3, t3;
          }
        }
        ca.prototype.bytesPerElement = 8, Ji(ca, "StructArrayLayout2f8");
        class ha extends Ls {
          get projectedAnchorX() {
            return this._structArray.int16[this._pos2 + 0];
          }
          get projectedAnchorY() {
            return this._structArray.int16[this._pos2 + 1];
          }
          get projectedAnchorZ() {
            return this._structArray.int16[this._pos2 + 2];
          }
          get tileAnchorX() {
            return this._structArray.int16[this._pos2 + 3];
          }
          get tileAnchorY() {
            return this._structArray.int16[this._pos2 + 4];
          }
          get x1() {
            return this._structArray.float32[this._pos4 + 3];
          }
          get y1() {
            return this._structArray.float32[this._pos4 + 4];
          }
          get x2() {
            return this._structArray.float32[this._pos4 + 5];
          }
          get y2() {
            return this._structArray.float32[this._pos4 + 6];
          }
          get padding() {
            return this._structArray.int16[this._pos2 + 14];
          }
          get featureIndex() {
            return this._structArray.uint32[this._pos4 + 8];
          }
          get sourceLayerIndex() {
            return this._structArray.uint16[this._pos2 + 18];
          }
          get bucketIndex() {
            return this._structArray.uint16[this._pos2 + 19];
          }
        }
        ha.prototype.size = 40;
        class pa extends Ys {
          get(t3) {
            return new ha(this, t3);
          }
        }
        Ji(pa, "CollisionBoxArray");
        class da extends Ls {
          get projectedAnchorX() {
            return this._structArray.int16[this._pos2 + 0];
          }
          get projectedAnchorY() {
            return this._structArray.int16[this._pos2 + 1];
          }
          get projectedAnchorZ() {
            return this._structArray.int16[this._pos2 + 2];
          }
          get tileAnchorX() {
            return this._structArray.float32[this._pos4 + 2];
          }
          get tileAnchorY() {
            return this._structArray.float32[this._pos4 + 3];
          }
          get glyphStartIndex() {
            return this._structArray.uint16[this._pos2 + 8];
          }
          get numGlyphs() {
            return this._structArray.uint16[this._pos2 + 9];
          }
          get vertexStartIndex() {
            return this._structArray.uint32[this._pos4 + 5];
          }
          get lineStartIndex() {
            return this._structArray.uint32[this._pos4 + 6];
          }
          get lineLength() {
            return this._structArray.uint32[this._pos4 + 7];
          }
          get segment() {
            return this._structArray.uint16[this._pos2 + 16];
          }
          get lowerSize() {
            return this._structArray.uint16[this._pos2 + 17];
          }
          get upperSize() {
            return this._structArray.uint16[this._pos2 + 18];
          }
          get lineOffsetX() {
            return this._structArray.float32[this._pos4 + 10];
          }
          get lineOffsetY() {
            return this._structArray.float32[this._pos4 + 11];
          }
          get writingMode() {
            return this._structArray.uint8[this._pos1 + 48];
          }
          get placedOrientation() {
            return this._structArray.uint8[this._pos1 + 49];
          }
          set placedOrientation(t3) {
            this._structArray.uint8[this._pos1 + 49] = t3;
          }
          get hidden() {
            return this._structArray.uint8[this._pos1 + 50];
          }
          set hidden(t3) {
            this._structArray.uint8[this._pos1 + 50] = t3;
          }
          get crossTileID() {
            return this._structArray.uint32[this._pos4 + 13];
          }
          set crossTileID(t3) {
            this._structArray.uint32[this._pos4 + 13] = t3;
          }
          get associatedIconIndex() {
            return this._structArray.int16[this._pos2 + 28];
          }
          get flipState() {
            return this._structArray.uint8[this._pos1 + 58];
          }
          set flipState(t3) {
            this._structArray.uint8[this._pos1 + 58] = t3;
          }
        }
        da.prototype.size = 60;
        class fa extends na {
          get(t3) {
            return new da(this, t3);
          }
        }
        Ji(fa, "PlacedSymbolArray");
        class ya extends Ls {
          get projectedAnchorX() {
            return this._structArray.int16[this._pos2 + 0];
          }
          get projectedAnchorY() {
            return this._structArray.int16[this._pos2 + 1];
          }
          get projectedAnchorZ() {
            return this._structArray.int16[this._pos2 + 2];
          }
          get tileAnchorX() {
            return this._structArray.float32[this._pos4 + 2];
          }
          get tileAnchorY() {
            return this._structArray.float32[this._pos4 + 3];
          }
          get rightJustifiedTextSymbolIndex() {
            return this._structArray.int16[this._pos2 + 8];
          }
          get centerJustifiedTextSymbolIndex() {
            return this._structArray.int16[this._pos2 + 9];
          }
          get leftJustifiedTextSymbolIndex() {
            return this._structArray.int16[this._pos2 + 10];
          }
          get verticalPlacedTextSymbolIndex() {
            return this._structArray.int16[this._pos2 + 11];
          }
          get placedIconSymbolIndex() {
            return this._structArray.int16[this._pos2 + 12];
          }
          get verticalPlacedIconSymbolIndex() {
            return this._structArray.int16[this._pos2 + 13];
          }
          get key() {
            return this._structArray.uint16[this._pos2 + 14];
          }
          get textBoxStartIndex() {
            return this._structArray.uint16[this._pos2 + 15];
          }
          get textBoxEndIndex() {
            return this._structArray.uint16[this._pos2 + 16];
          }
          get verticalTextBoxStartIndex() {
            return this._structArray.uint16[this._pos2 + 17];
          }
          get verticalTextBoxEndIndex() {
            return this._structArray.uint16[this._pos2 + 18];
          }
          get iconBoxStartIndex() {
            return this._structArray.uint16[this._pos2 + 19];
          }
          get iconBoxEndIndex() {
            return this._structArray.uint16[this._pos2 + 20];
          }
          get verticalIconBoxStartIndex() {
            return this._structArray.uint16[this._pos2 + 21];
          }
          get verticalIconBoxEndIndex() {
            return this._structArray.uint16[this._pos2 + 22];
          }
          get featureIndex() {
            return this._structArray.uint16[this._pos2 + 23];
          }
          get numHorizontalGlyphVertices() {
            return this._structArray.uint16[this._pos2 + 24];
          }
          get numVerticalGlyphVertices() {
            return this._structArray.uint16[this._pos2 + 25];
          }
          get numIconVertices() {
            return this._structArray.uint16[this._pos2 + 26];
          }
          get numVerticalIconVertices() {
            return this._structArray.uint16[this._pos2 + 27];
          }
          get useRuntimeCollisionCircles() {
            return this._structArray.uint16[this._pos2 + 28];
          }
          get crossTileID() {
            return this._structArray.uint32[this._pos4 + 15];
          }
          set crossTileID(t3) {
            this._structArray.uint32[this._pos4 + 15] = t3;
          }
          get textOffset0() {
            return this._structArray.float32[this._pos4 + 16];
          }
          get textOffset1() {
            return this._structArray.float32[this._pos4 + 17];
          }
          get collisionCircleDiameter() {
            return this._structArray.float32[this._pos4 + 18];
          }
        }
        ya.prototype.size = 76;
        class ma extends ia {
          get(t3) {
            return new ya(this, t3);
          }
        }
        Ji(ma, "SymbolInstanceArray");
        class ga extends sa {
          getoffsetX(t3) {
            return this.float32[1 * t3 + 0];
          }
        }
        Ji(ga, "GlyphOffsetArray");
        class xa extends $s {
          getx(t3) {
            return this.int16[2 * t3 + 0];
          }
          gety(t3) {
            return this.int16[2 * t3 + 1];
          }
        }
        Ji(xa, "SymbolLineVertexArray");
        class va extends Ls {
          get featureIndex() {
            return this._structArray.uint32[this._pos4 + 0];
          }
          get sourceLayerIndex() {
            return this._structArray.uint16[this._pos2 + 2];
          }
          get bucketIndex() {
            return this._structArray.uint16[this._pos2 + 3];
          }
          get layoutVertexArrayOffset() {
            return this._structArray.uint16[this._pos2 + 4];
          }
        }
        va.prototype.size = 12;
        class ba extends oa {
          get(t3) {
            return new va(this, t3);
          }
        }
        Ji(ba, "FeatureIndexArray");
        class wa extends la {
          geta_centroid_pos0(t3) {
            return this.uint16[2 * t3 + 0];
          }
          geta_centroid_pos1(t3) {
            return this.uint16[2 * t3 + 1];
          }
        }
        Ji(wa, "FillExtrusionCentroidArray");
        const _a = Rs([{ name: "a_pattern", components: 4, type: "Uint16" }, { name: "a_pixel_ratio", components: 1, type: "Float32" }]), Aa = Rs([{ name: "a_dash", components: 4, type: "Uint16" }]);
        var Sa = { exports: {} }, ka = { exports: {} };
        ka.exports = function(t3, e3) {
          var r3, n3, i3, s3, a3, o3, l2, u3;
          for (n3 = t3.length - (r3 = 3 & t3.length), i3 = e3, a3 = 3432918353, o3 = 461845907, u3 = 0; u3 < n3; )
            l2 = 255 & t3.charCodeAt(u3) | (255 & t3.charCodeAt(++u3)) << 8 | (255 & t3.charCodeAt(++u3)) << 16 | (255 & t3.charCodeAt(++u3)) << 24, ++u3, i3 = 27492 + (65535 & (s3 = 5 * (65535 & (i3 = (i3 ^= l2 = (65535 & (l2 = (l2 = (65535 & l2) * a3 + (((l2 >>> 16) * a3 & 65535) << 16) & 4294967295) << 15 | l2 >>> 17)) * o3 + (((l2 >>> 16) * o3 & 65535) << 16) & 4294967295) << 13 | i3 >>> 19)) + ((5 * (i3 >>> 16) & 65535) << 16) & 4294967295)) + ((58964 + (s3 >>> 16) & 65535) << 16);
          switch (l2 = 0, r3) {
            case 3:
              l2 ^= (255 & t3.charCodeAt(u3 + 2)) << 16;
            case 2:
              l2 ^= (255 & t3.charCodeAt(u3 + 1)) << 8;
            case 1:
              i3 ^= l2 = (65535 & (l2 = (l2 = (65535 & (l2 ^= 255 & t3.charCodeAt(u3))) * a3 + (((l2 >>> 16) * a3 & 65535) << 16) & 4294967295) << 15 | l2 >>> 17)) * o3 + (((l2 >>> 16) * o3 & 65535) << 16) & 4294967295;
          }
          return i3 ^= t3.length, i3 = 2246822507 * (65535 & (i3 ^= i3 >>> 16)) + ((2246822507 * (i3 >>> 16) & 65535) << 16) & 4294967295, i3 = 3266489909 * (65535 & (i3 ^= i3 >>> 13)) + ((3266489909 * (i3 >>> 16) & 65535) << 16) & 4294967295, (i3 ^= i3 >>> 16) >>> 0;
        };
        var Ia = ka.exports, Ma = { exports: {} };
        Ma.exports = function(t3, e3) {
          for (var r3, n3 = t3.length, i3 = e3 ^ n3, s3 = 0; n3 >= 4; )
            r3 = 1540483477 * (65535 & (r3 = 255 & t3.charCodeAt(s3) | (255 & t3.charCodeAt(++s3)) << 8 | (255 & t3.charCodeAt(++s3)) << 16 | (255 & t3.charCodeAt(++s3)) << 24)) + ((1540483477 * (r3 >>> 16) & 65535) << 16), i3 = 1540483477 * (65535 & i3) + ((1540483477 * (i3 >>> 16) & 65535) << 16) ^ (r3 = 1540483477 * (65535 & (r3 ^= r3 >>> 24)) + ((1540483477 * (r3 >>> 16) & 65535) << 16)), n3 -= 4, ++s3;
          switch (n3) {
            case 3:
              i3 ^= (255 & t3.charCodeAt(s3 + 2)) << 16;
            case 2:
              i3 ^= (255 & t3.charCodeAt(s3 + 1)) << 8;
            case 1:
              i3 = 1540483477 * (65535 & (i3 ^= 255 & t3.charCodeAt(s3))) + ((1540483477 * (i3 >>> 16) & 65535) << 16);
          }
          return i3 = 1540483477 * (65535 & (i3 ^= i3 >>> 13)) + ((1540483477 * (i3 >>> 16) & 65535) << 16), (i3 ^= i3 >>> 15) >>> 0;
        };
        var Ta = Ia, za = Ma.exports;
        Sa.exports = Ta, Sa.exports.murmur3 = Ta, Sa.exports.murmur2 = za;
        var Ba = p2(Sa.exports);
        class Ea {
          constructor() {
            this.ids = [], this.positions = [], this.indexed = false;
          }
          add(t3, e3, r3, n3) {
            this.ids.push(Ca(t3)), this.positions.push(e3, r3, n3);
          }
          getPositions(t3) {
            const e3 = Ca(t3);
            let r3 = 0, n3 = this.ids.length - 1;
            for (; r3 < n3; ) {
              const t4 = r3 + n3 >> 1;
              this.ids[t4] >= e3 ? n3 = t4 : r3 = t4 + 1;
            }
            const i3 = [];
            for (; this.ids[r3] === e3; )
              i3.push({ index: this.positions[3 * r3], start: this.positions[3 * r3 + 1], end: this.positions[3 * r3 + 2] }), r3++;
            return i3;
          }
          static serialize(t3, e3) {
            const r3 = new Float64Array(t3.ids), n3 = new Uint32Array(t3.positions);
            return Pa(r3, n3, 0, r3.length - 1), e3 && e3.push(r3.buffer, n3.buffer), { ids: r3, positions: n3 };
          }
          static deserialize(t3) {
            const e3 = new Ea();
            return e3.ids = t3.ids, e3.positions = t3.positions, e3.indexed = true, e3;
          }
        }
        function Ca(t3) {
          const e3 = +t3;
          return !isNaN(e3) && Number.MIN_SAFE_INTEGER <= e3 && e3 <= Number.MAX_SAFE_INTEGER ? e3 : Ba(String(t3));
        }
        function Pa(t3, e3, r3, n3) {
          for (; r3 < n3; ) {
            const i3 = t3[r3 + n3 >> 1];
            let s3 = r3 - 1, a3 = n3 + 1;
            for (; ; ) {
              do {
                s3++;
              } while (t3[s3] < i3);
              do {
                a3--;
              } while (t3[a3] > i3);
              if (s3 >= a3)
                break;
              Da(t3, s3, a3), Da(e3, 3 * s3, 3 * a3), Da(e3, 3 * s3 + 1, 3 * a3 + 1), Da(e3, 3 * s3 + 2, 3 * a3 + 2);
            }
            a3 - r3 < n3 - a3 ? (Pa(t3, e3, r3, a3), r3 = a3 + 1) : (Pa(t3, e3, a3 + 1, n3), n3 = a3);
          }
        }
        function Da(t3, e3, r3) {
          const n3 = t3[e3];
          t3[e3] = t3[r3], t3[r3] = n3;
        }
        Ji(Ea, "FeaturePositionMap");
        class Va {
          constructor(t3) {
            this.gl = t3.gl, this.initialized = false;
          }
          fetchUniformLocation(t3, e3) {
            return this.location || this.initialized || (this.location = this.gl.getUniformLocation(t3, e3), this.initialized = true), !!this.location;
          }
        }
        class La extends Va {
          constructor(t3) {
            super(t3), this.current = 0;
          }
          set(t3, e3, r3) {
            this.fetchUniformLocation(t3, e3) && this.current !== r3 && (this.current = r3, this.gl.uniform1f(this.location, r3));
          }
        }
        class Fa extends Va {
          constructor(t3) {
            super(t3), this.current = [0, 0, 0, 0];
          }
          set(t3, e3, r3) {
            this.fetchUniformLocation(t3, e3) && (r3[0] === this.current[0] && r3[1] === this.current[1] && r3[2] === this.current[2] && r3[3] === this.current[3] || (this.current = r3, this.gl.uniform4f(this.location, r3[0], r3[1], r3[2], r3[3])));
          }
        }
        class Ra extends Va {
          constructor(t3) {
            super(t3), this.current = Ee.transparent;
          }
          set(t3, e3, r3) {
            this.fetchUniformLocation(t3, e3) && (r3.r === this.current.r && r3.g === this.current.g && r3.b === this.current.b && r3.a === this.current.a || (this.current = r3, this.gl.uniform4f(this.location, r3.r, r3.g, r3.b, r3.a)));
          }
        }
        const Ua = new Float32Array(16), $a = new Float32Array(9), ja = new Float32Array(4);
        function Oa(t3) {
          return [Ds(255 * t3.r, 255 * t3.g), Ds(255 * t3.b, 255 * t3.a)];
        }
        class qa {
          constructor(t3, e3, r3) {
            this.value = t3, this.uniformNames = e3.map((t4) => `u_${t4}`), this.type = r3;
          }
          setUniform(t3, e3, r3, n3, i3) {
            e3.set(t3, i3, n3.constantOr(this.value));
          }
          getBinding(t3, e3) {
            return "color" === this.type ? new Ra(t3) : new La(t3);
          }
        }
        class Na {
          constructor(t3, e3) {
            this.uniformNames = e3.map((t4) => `u_${t4}`), this.pattern = null, this.pixelRatio = 1;
          }
          setConstantPatternPositions(t3) {
            this.pixelRatio = t3.pixelRatio || 1, this.pattern = t3.tl.concat(t3.br);
          }
          setUniform(t3, e3, r3, n3, i3) {
            const s3 = "u_pattern" === i3 || "u_dash" === i3 ? this.pattern : "u_pixel_ratio" === i3 ? this.pixelRatio : null;
            s3 && e3.set(t3, i3, s3);
          }
          getBinding(t3, e3) {
            return "u_pattern" === e3 || "u_dash" === e3 ? new Fa(t3) : new La(t3);
          }
        }
        class Ga {
          constructor(t3, e3, r3, n3) {
            this.expression = t3, this.type = r3, this.maxValue = 0, this.paintVertexAttributes = e3.map((t4) => ({ name: `a_${t4}`, type: "Float32", components: "color" === r3 ? 2 : 1, offset: 0 })), this.paintVertexArray = new n3();
          }
          populatePaintArray(t3, e3, r3, n3, i3, s3) {
            const a3 = this.paintVertexArray.length, o3 = this.expression.evaluate(new ws(0), e3, {}, i3, n3, s3);
            this.paintVertexArray.resize(t3), this._setPaintValue(a3, t3, o3);
          }
          updatePaintArray(t3, e3, r3, n3, i3) {
            const s3 = this.expression.evaluate({ zoom: 0 }, r3, n3, void 0, i3);
            this._setPaintValue(t3, e3, s3);
          }
          _setPaintValue(t3, e3, r3) {
            if ("color" === this.type) {
              const n3 = Oa(r3);
              for (let r4 = t3; r4 < e3; r4++)
                this.paintVertexArray.emplace(r4, n3[0], n3[1]);
            } else {
              for (let n3 = t3; n3 < e3; n3++)
                this.paintVertexArray.emplace(n3, r3);
              this.maxValue = Math.max(this.maxValue, Math.abs(r3));
            }
          }
          upload(t3) {
            this.paintVertexArray && this.paintVertexArray.arrayBuffer && (this.paintVertexBuffer && this.paintVertexBuffer.buffer ? this.paintVertexBuffer.updateData(this.paintVertexArray) : this.paintVertexBuffer = t3.createVertexBuffer(this.paintVertexArray, this.paintVertexAttributes, this.expression.isStateDependent));
          }
          destroy() {
            this.paintVertexBuffer && this.paintVertexBuffer.destroy();
          }
        }
        class Za {
          constructor(t3, e3, r3, n3, i3, s3) {
            this.expression = t3, this.uniformNames = e3.map((t4) => `u_${t4}_t`), this.type = r3, this.useIntegerZoom = n3, this.zoom = i3, this.maxValue = 0, this.paintVertexAttributes = e3.map((t4) => ({ name: `a_${t4}`, type: "Float32", components: "color" === r3 ? 4 : 2, offset: 0 })), this.paintVertexArray = new s3();
          }
          populatePaintArray(t3, e3, r3, n3, i3, s3) {
            const a3 = this.expression.evaluate(new ws(this.zoom), e3, {}, i3, n3, s3), o3 = this.expression.evaluate(new ws(this.zoom + 1), e3, {}, i3, n3, s3), l2 = this.paintVertexArray.length;
            this.paintVertexArray.resize(t3), this._setPaintValue(l2, t3, a3, o3);
          }
          updatePaintArray(t3, e3, r3, n3, i3) {
            const s3 = this.expression.evaluate({ zoom: this.zoom }, r3, n3, void 0, i3), a3 = this.expression.evaluate({ zoom: this.zoom + 1 }, r3, n3, void 0, i3);
            this._setPaintValue(t3, e3, s3, a3);
          }
          _setPaintValue(t3, e3, r3, n3) {
            if ("color" === this.type) {
              const i3 = Oa(r3), s3 = Oa(n3);
              for (let r4 = t3; r4 < e3; r4++)
                this.paintVertexArray.emplace(r4, i3[0], i3[1], s3[0], s3[1]);
            } else {
              for (let i3 = t3; i3 < e3; i3++)
                this.paintVertexArray.emplace(i3, r3, n3);
              this.maxValue = Math.max(this.maxValue, Math.abs(r3), Math.abs(n3));
            }
          }
          upload(t3) {
            this.paintVertexArray && this.paintVertexArray.arrayBuffer && (this.paintVertexBuffer && this.paintVertexBuffer.buffer ? this.paintVertexBuffer.updateData(this.paintVertexArray) : this.paintVertexBuffer = t3.createVertexBuffer(this.paintVertexArray, this.paintVertexAttributes, this.expression.isStateDependent));
          }
          destroy() {
            this.paintVertexBuffer && this.paintVertexBuffer.destroy();
          }
          setUniform(t3, e3, r3, n3, i3) {
            const s3 = this.useIntegerZoom ? Math.floor(r3.zoom) : r3.zoom, a3 = M(this.expression.interpolationFactor(s3, this.zoom, this.zoom + 1), 0, 1);
            e3.set(t3, i3, a3);
          }
          getBinding(t3, e3) {
            return new La(t3);
          }
        }
        class Ka {
          constructor(t3, e3, r3, n3, i3) {
            this.expression = t3, this.layerId = i3, this.paintVertexAttributes = ("array" === r3 ? Aa : _a).members;
            for (let t4 = 0; t4 < e3.length; ++t4)
              ;
            this.paintVertexArray = new n3();
          }
          populatePaintArray(t3, e3, r3) {
            const n3 = this.paintVertexArray.length;
            this.paintVertexArray.resize(t3), this._setPaintValues(n3, t3, e3.patterns && e3.patterns[this.layerId], r3);
          }
          updatePaintArray(t3, e3, r3, n3, i3, s3) {
            this._setPaintValues(t3, e3, r3.patterns && r3.patterns[this.layerId], s3);
          }
          _setPaintValues(t3, e3, r3, n3) {
            if (!n3 || !r3)
              return;
            const i3 = n3[r3];
            if (!i3)
              return;
            const { tl: s3, br: a3, pixelRatio: o3 } = i3;
            for (let r4 = t3; r4 < e3; r4++)
              this.paintVertexArray.emplace(r4, s3[0], s3[1], a3[0], a3[1], o3);
          }
          upload(t3) {
            this.paintVertexArray && this.paintVertexArray.arrayBuffer && (this.paintVertexBuffer = t3.createVertexBuffer(this.paintVertexArray, this.paintVertexAttributes, this.expression.isStateDependent));
          }
          destroy() {
            this.paintVertexBuffer && this.paintVertexBuffer.destroy();
          }
        }
        class Xa {
          constructor(t3, e3, r3 = () => true) {
            this.binders = {}, this._buffers = [];
            const n3 = [];
            for (const i3 in t3.paint._values) {
              if (!r3(i3))
                continue;
              const s3 = t3.paint.get(i3);
              if (!(s3 instanceof Ts && Ln(s3.property.specification)))
                continue;
              const a3 = Ya(i3, t3.type), o3 = s3.value, l2 = s3.property.specification.type, u3 = !!s3.property.useIntegerZoom, c3 = "line-dasharray" === i3 || i3.endsWith("pattern"), h3 = "line-dasharray" === i3 && "constant" !== t3.layout.get("line-cap").value.kind;
              if ("constant" !== o3.kind || h3)
                if ("source" === o3.kind || h3 || c3) {
                  const e4 = to(i3, l2, "source");
                  this.binders[i3] = c3 ? new Ka(o3, a3, l2, e4, t3.id) : new Ga(o3, a3, l2, e4), n3.push(`/a_${i3}`);
                } else {
                  const t4 = to(i3, l2, "composite");
                  this.binders[i3] = new Za(o3, a3, l2, u3, e3, t4), n3.push(`/z_${i3}`);
                }
              else
                this.binders[i3] = c3 ? new Na(o3.value, a3) : new qa(o3.value, a3, l2), n3.push(`/u_${i3}`);
            }
            this.cacheKey = n3.sort().join("");
          }
          getMaxValue(t3) {
            const e3 = this.binders[t3];
            return e3 instanceof Ga || e3 instanceof Za ? e3.maxValue : 0;
          }
          populatePaintArrays(t3, e3, r3, n3, i3, s3) {
            for (const a3 in this.binders) {
              const o3 = this.binders[a3];
              (o3 instanceof Ga || o3 instanceof Za || o3 instanceof Ka) && o3.populatePaintArray(t3, e3, r3, n3, i3, s3);
            }
          }
          setConstantPatternPositions(t3) {
            for (const e3 in this.binders) {
              const r3 = this.binders[e3];
              r3 instanceof Na && r3.setConstantPatternPositions(t3);
            }
          }
          updatePaintArrays(t3, e3, r3, n3, i3, s3) {
            let a3 = false;
            for (const o3 in t3) {
              const l2 = e3.getPositions(o3);
              for (const e4 of l2) {
                const l3 = r3.feature(e4.index);
                for (const r4 in this.binders) {
                  const u3 = this.binders[r4];
                  if ((u3 instanceof Ga || u3 instanceof Za || u3 instanceof Ka) && true === u3.expression.isStateDependent) {
                    const c3 = n3.paint.get(r4);
                    u3.expression = c3.value, u3.updatePaintArray(e4.start, e4.end, l3, t3[o3], i3, s3), a3 = true;
                  }
                }
              }
            }
            return a3;
          }
          defines() {
            const t3 = [];
            for (const e3 in this.binders) {
              const r3 = this.binders[e3];
              (r3 instanceof qa || r3 instanceof Na) && t3.push(...r3.uniformNames.map((t4) => `#define HAS_UNIFORM_${t4}`));
            }
            return t3;
          }
          getBinderAttributes() {
            const t3 = [];
            for (const e3 in this.binders) {
              const r3 = this.binders[e3];
              if (r3 instanceof Ga || r3 instanceof Za || r3 instanceof Ka)
                for (let e4 = 0; e4 < r3.paintVertexAttributes.length; e4++)
                  t3.push(r3.paintVertexAttributes[e4].name);
            }
            return t3;
          }
          getBinderUniforms() {
            const t3 = [];
            for (const e3 in this.binders) {
              const r3 = this.binders[e3];
              if (r3 instanceof qa || r3 instanceof Na || r3 instanceof Za)
                for (const e4 of r3.uniformNames)
                  t3.push(e4);
            }
            return t3;
          }
          getPaintVertexBuffers() {
            return this._buffers;
          }
          getUniforms(t3) {
            const e3 = [];
            for (const r3 in this.binders) {
              const n3 = this.binders[r3];
              if (n3 instanceof qa || n3 instanceof Na || n3 instanceof Za)
                for (const i3 of n3.uniformNames)
                  e3.push({ name: i3, property: r3, binding: n3.getBinding(t3, i3) });
            }
            return e3;
          }
          setUniforms(t3, e3, r3, n3, i3) {
            for (const { name: e4, property: s3, binding: a3 } of r3)
              this.binders[s3].setUniform(t3, a3, i3, n3.get(s3), e4);
          }
          updatePaintBuffers() {
            this._buffers = [];
            for (const t3 in this.binders) {
              const e3 = this.binders[t3];
              (e3 instanceof Ga || e3 instanceof Za || e3 instanceof Ka) && e3.paintVertexBuffer && this._buffers.push(e3.paintVertexBuffer);
            }
          }
          upload(t3) {
            for (const e3 in this.binders) {
              const r3 = this.binders[e3];
              (r3 instanceof Ga || r3 instanceof Za || r3 instanceof Ka) && r3.upload(t3);
            }
            this.updatePaintBuffers();
          }
          destroy() {
            for (const t3 in this.binders) {
              const e3 = this.binders[t3];
              (e3 instanceof Ga || e3 instanceof Za || e3 instanceof Ka) && e3.destroy();
            }
          }
        }
        class Ja {
          constructor(t3, e3, r3 = () => true) {
            this.programConfigurations = {};
            for (const n3 of t3)
              this.programConfigurations[n3.id] = new Xa(n3, e3, r3);
            this.needsUpload = false, this._featureMap = new Ea(), this._bufferOffset = 0;
          }
          populatePaintArrays(t3, e3, r3, n3, i3, s3, a3) {
            for (const r4 in this.programConfigurations)
              this.programConfigurations[r4].populatePaintArrays(t3, e3, n3, i3, s3, a3);
            void 0 !== e3.id && this._featureMap.add(e3.id, r3, this._bufferOffset, t3), this._bufferOffset = t3, this.needsUpload = true;
          }
          updatePaintArrays(t3, e3, r3, n3, i3) {
            for (const s3 of r3)
              this.needsUpload = this.programConfigurations[s3.id].updatePaintArrays(t3, this._featureMap, e3, s3, n3, i3) || this.needsUpload;
          }
          get(t3) {
            return this.programConfigurations[t3];
          }
          upload(t3) {
            if (this.needsUpload) {
              for (const e3 in this.programConfigurations)
                this.programConfigurations[e3].upload(t3);
              this.needsUpload = false;
            }
          }
          destroy() {
            for (const t3 in this.programConfigurations)
              this.programConfigurations[t3].destroy();
          }
        }
        const Ha = { "text-opacity": ["opacity"], "icon-opacity": ["opacity"], "text-color": ["fill_color"], "icon-color": ["fill_color"], "text-halo-color": ["halo_color"], "icon-halo-color": ["halo_color"], "text-halo-blur": ["halo_blur"], "icon-halo-blur": ["halo_blur"], "text-halo-width": ["halo_width"], "icon-halo-width": ["halo_width"], "line-gap-width": ["gapwidth"], "line-pattern": ["pattern", "pixel_ratio"], "fill-pattern": ["pattern", "pixel_ratio"], "fill-extrusion-pattern": ["pattern", "pixel_ratio"], "line-dasharray": ["dash"] };
        function Ya(t3, e3) {
          return Ha[t3] || [t3.replace(`${e3}-`, "").replace(/-/g, "_")];
        }
        const Wa = { "line-pattern": { source: Gs, composite: Gs }, "fill-pattern": { source: Gs, composite: Gs }, "fill-extrusion-pattern": { source: Gs, composite: Gs }, "line-dasharray": { source: Zs, composite: Zs } }, Qa = { color: { source: ca, composite: Ns }, number: { source: sa, composite: ca } };
        function to(t3, e3, r3) {
          const n3 = Wa[t3];
          return n3 && n3[r3] || Qa[e3][r3];
        }
        Ji(qa, "ConstantBinder"), Ji(Na, "PatternConstantBinder"), Ji(Ga, "SourceExpressionBinder"), Ji(Ka, "PatternCompositeBinder"), Ji(Za, "CompositeExpressionBinder"), Ji(Xa, "ProgramConfiguration", { omit: ["_buffers"] }), Ji(Ja, "ProgramConfigurationSet");
        const eo = "-transition";
        class ro extends Qt {
          constructor(t3, e3) {
            if (super(), this.id = t3.id, this.type = t3.type, this._featureFilter = { filter: () => true, needGeometry: false, needFeature: false }, this._filterCompiled = false, "custom" !== t3.type && (this.metadata = t3.metadata, this.minzoom = t3.minzoom, this.maxzoom = t3.maxzoom, "background" !== t3.type && "sky" !== t3.type && (this.source = t3.source, this.sourceLayer = t3["source-layer"], this.filter = t3.filter), e3.layout && (this._unevaluatedLayout = new Ms(e3.layout)), e3.paint)) {
              this._transitionablePaint = new Ss(e3.paint);
              for (const e4 in t3.paint)
                this.setPaintProperty(e4, t3.paint[e4], { validate: false });
              for (const e4 in t3.layout)
                this.setLayoutProperty(e4, t3.layout[e4], { validate: false });
              this._transitioningPaint = this._transitionablePaint.untransitioned(), this.paint = new zs(e3.paint);
            }
          }
          getLayoutProperty(t3) {
            return "visibility" === t3 ? this.visibility : this._unevaluatedLayout.getValue(t3);
          }
          setLayoutProperty(t3, e3, r3 = {}) {
            null != e3 && this._validate(ji, `layers.${this.id}.layout.${t3}`, t3, e3, r3) || ("visibility" !== t3 ? this._unevaluatedLayout.setValue(t3, e3) : this.visibility = e3);
          }
          getPaintProperty(t3) {
            return U(t3, eo) ? this._transitionablePaint.getTransition(t3.slice(0, -11)) : this._transitionablePaint.getValue(t3);
          }
          setPaintProperty(t3, e3, r3 = {}) {
            if (null != e3 && this._validate($i, `layers.${this.id}.paint.${t3}`, t3, e3, r3))
              return false;
            if (U(t3, eo))
              return this._transitionablePaint.setTransition(t3.slice(0, -11), e3 || void 0), false;
            {
              const r4 = this._transitionablePaint._values[t3], n3 = r4.value.isDataDriven(), i3 = r4.value;
              this._transitionablePaint.setValue(t3, e3), this._handleSpecialPaintPropertyUpdate(t3);
              const s3 = this._transitionablePaint._values[t3].value, a3 = s3.isDataDriven(), o3 = U(t3, "pattern") || "line-dasharray" === t3;
              return a3 || n3 || o3 || this._handleOverridablePaintPropertyUpdate(t3, i3, s3);
            }
          }
          _handleSpecialPaintPropertyUpdate(t3) {
          }
          getProgramIds() {
            return null;
          }
          getProgramConfiguration(t3) {
            return null;
          }
          _handleOverridablePaintPropertyUpdate(t3, e3, r3) {
            return false;
          }
          isHidden(t3) {
            return !!(this.minzoom && t3 < this.minzoom) || !!(this.maxzoom && t3 >= this.maxzoom) || "none" === this.visibility;
          }
          updateTransitions(t3) {
            this._transitioningPaint = this._transitionablePaint.transitioned(t3, this._transitioningPaint);
          }
          hasTransition() {
            return this._transitioningPaint.hasTransition();
          }
          recalculate(t3, e3) {
            this._unevaluatedLayout && (this.layout = this._unevaluatedLayout.possiblyEvaluate(t3, void 0, e3)), this.paint = this._transitioningPaint.possiblyEvaluate(t3, void 0, e3);
          }
          serialize() {
            const t3 = { id: this.id, type: this.type, source: this.source, "source-layer": this.sourceLayer, metadata: this.metadata, minzoom: this.minzoom, maxzoom: this.maxzoom, filter: this.filter, layout: this._unevaluatedLayout && this._unevaluatedLayout.serialize(), paint: this._transitionablePaint && this._transitionablePaint.serialize() };
            return this.visibility && (t3.layout = t3.layout || {}, t3.layout.visibility = this.visibility), j(t3, (t4, e3) => !(void 0 === t4 || "layout" === e3 && !Object.keys(t4).length || "paint" === e3 && !Object.keys(t4).length));
          }
          _validate(t3, e3, r3, n3, i3 = {}) {
            return (!i3 || false !== i3.validate) && qi(this, t3.call(Ui, { key: e3, layerType: this.type, objectKey: r3, value: n3, styleSpec: te, style: { glyphs: true, sprite: true } }));
          }
          is3D() {
            return false;
          }
          isSky() {
            return false;
          }
          isTileClipped() {
            return false;
          }
          hasOffscreenPass() {
            return false;
          }
          resize() {
          }
          isStateDependent() {
            for (const t3 in this.paint._values) {
              const e3 = this.paint.get(t3);
              if (e3 instanceof Ts && Ln(e3.property.specification) && ("source" === e3.value.kind || "composite" === e3.value.kind) && e3.value.isStateDependent)
                return true;
            }
            return false;
          }
          compileFilter() {
            this._filterCompiled || (this._featureFilter = hi(this.filter), this._filterCompiled = true);
          }
          invalidateCompiledFilter() {
            this._filterCompiled = false;
          }
          dynamicFilter() {
            return this._featureFilter.dynamicFilter;
          }
          dynamicFilterNeedsFeature() {
            return this._featureFilter.needFeature;
          }
        }
        const no = Rs([{ name: "a_pos", components: 2, type: "Int16" }], 4), io = Rs([{ name: "a_pos_3", components: 3, type: "Int16" }, { name: "a_pos_normal_3", components: 3, type: "Int16" }]);
        class so {
          constructor(t3 = []) {
            this.segments = t3;
          }
          prepareSegment(t3, e3, r3, n3) {
            let i3 = this.segments[this.segments.length - 1];
            return t3 > so.MAX_VERTEX_ARRAY_LENGTH && N(`Max vertices per segment is ${so.MAX_VERTEX_ARRAY_LENGTH}: bucket requested ${t3}`), (!i3 || i3.vertexLength + t3 > so.MAX_VERTEX_ARRAY_LENGTH || i3.sortKey !== n3) && (i3 = { vertexOffset: e3.length, primitiveOffset: r3.length, vertexLength: 0, primitiveLength: 0 }, void 0 !== n3 && (i3.sortKey = n3), this.segments.push(i3)), i3;
          }
          get() {
            return this.segments;
          }
          destroy() {
            for (const t3 of this.segments)
              for (const e3 in t3.vaos)
                t3.vaos[e3].destroy();
          }
          static simpleSegment(t3, e3, r3, n3) {
            return new so([{ vertexOffset: t3, primitiveOffset: e3, vertexLength: r3, primitiveLength: n3, vaos: {}, sortKey: 0 }]);
          }
        }
        so.MAX_VERTEX_ARRAY_LENGTH = Math.pow(2, 16) - 1, Ji(so, "SegmentVector");
        var ao = 8192;
        class oo {
          constructor(t3, e3) {
            t3 && (e3 ? this.setSouthWest(t3).setNorthEast(e3) : 4 === t3.length ? this.setSouthWest([t3[0], t3[1]]).setNorthEast([t3[2], t3[3]]) : this.setSouthWest(t3[0]).setNorthEast(t3[1]));
          }
          setNorthEast(t3) {
            return this._ne = t3 instanceof Ol ? new Ol(t3.lng, t3.lat) : Ol.convert(t3), this;
          }
          setSouthWest(t3) {
            return this._sw = t3 instanceof Ol ? new Ol(t3.lng, t3.lat) : Ol.convert(t3), this;
          }
          extend(t3) {
            const e3 = this._sw, r3 = this._ne;
            let n3, i3;
            if (t3 instanceof Ol)
              n3 = t3, i3 = t3;
            else {
              if (!(t3 instanceof oo))
                return Array.isArray(t3) ? 4 === t3.length || t3.every(Array.isArray) ? this.extend(oo.convert(t3)) : this.extend(Ol.convert(t3)) : "object" == typeof t3 && null !== t3 && t3.hasOwnProperty("lat") && (t3.hasOwnProperty("lon") || t3.hasOwnProperty("lng")) ? this.extend(Ol.convert(t3)) : this;
              if (n3 = t3._sw, i3 = t3._ne, !n3 || !i3)
                return this;
            }
            return e3 || r3 ? (e3.lng = Math.min(n3.lng, e3.lng), e3.lat = Math.min(n3.lat, e3.lat), r3.lng = Math.max(i3.lng, r3.lng), r3.lat = Math.max(i3.lat, r3.lat)) : (this._sw = new Ol(n3.lng, n3.lat), this._ne = new Ol(i3.lng, i3.lat)), this;
          }
          getCenter() {
            return new Ol((this._sw.lng + this._ne.lng) / 2, (this._sw.lat + this._ne.lat) / 2);
          }
          getSouthWest() {
            return this._sw;
          }
          getNorthEast() {
            return this._ne;
          }
          getNorthWest() {
            return new Ol(this.getWest(), this.getNorth());
          }
          getSouthEast() {
            return new Ol(this.getEast(), this.getSouth());
          }
          getWest() {
            return this._sw.lng;
          }
          getSouth() {
            return this._sw.lat;
          }
          getEast() {
            return this._ne.lng;
          }
          getNorth() {
            return this._ne.lat;
          }
          toArray() {
            return [this._sw.toArray(), this._ne.toArray()];
          }
          toString() {
            return `LngLatBounds(${this._sw.toString()}, ${this._ne.toString()})`;
          }
          isEmpty() {
            return !(this._sw && this._ne);
          }
          contains(t3) {
            const { lng: e3, lat: r3 } = Ol.convert(t3);
            let n3 = this._sw.lng <= e3 && e3 <= this._ne.lng;
            return this._sw.lng > this._ne.lng && (n3 = this._sw.lng >= e3 && e3 >= this._ne.lng), this._sw.lat <= r3 && r3 <= this._ne.lat && n3;
          }
          static convert(t3) {
            return !t3 || t3 instanceof oo ? t3 : new oo(t3);
          }
        }
        var lo = 1e-6, uo = "undefined" != typeof Float32Array ? Float32Array : Array;
        function co() {
          var t3 = new uo(9);
          return uo != Float32Array && (t3[1] = 0, t3[2] = 0, t3[3] = 0, t3[5] = 0, t3[6] = 0, t3[7] = 0), t3[0] = 1, t3[4] = 1, t3[8] = 1, t3;
        }
        function ho(t3, e3, r3) {
          var n3 = e3[0], i3 = e3[1], s3 = e3[2], a3 = e3[3], o3 = e3[4], l2 = e3[5], u3 = e3[6], c3 = e3[7], h3 = e3[8], p3 = r3[0], d3 = r3[1], f3 = r3[2], y3 = r3[3], m3 = r3[4], g3 = r3[5], x3 = r3[6], v3 = r3[7], b2 = r3[8];
          return t3[0] = p3 * n3 + d3 * a3 + f3 * u3, t3[1] = p3 * i3 + d3 * o3 + f3 * c3, t3[2] = p3 * s3 + d3 * l2 + f3 * h3, t3[3] = y3 * n3 + m3 * a3 + g3 * u3, t3[4] = y3 * i3 + m3 * o3 + g3 * c3, t3[5] = y3 * s3 + m3 * l2 + g3 * h3, t3[6] = x3 * n3 + v3 * a3 + b2 * u3, t3[7] = x3 * i3 + v3 * o3 + b2 * c3, t3[8] = x3 * s3 + v3 * l2 + b2 * h3, t3;
        }
        function po(t3) {
          return t3[0] = 1, t3[1] = 0, t3[2] = 0, t3[3] = 0, t3[4] = 0, t3[5] = 1, t3[6] = 0, t3[7] = 0, t3[8] = 0, t3[9] = 0, t3[10] = 1, t3[11] = 0, t3[12] = 0, t3[13] = 0, t3[14] = 0, t3[15] = 1, t3;
        }
        function fo(t3, e3) {
          var r3 = e3[0], n3 = e3[1], i3 = e3[2], s3 = e3[3], a3 = e3[4], o3 = e3[5], l2 = e3[6], u3 = e3[7], c3 = e3[8], h3 = e3[9], p3 = e3[10], d3 = e3[11], f3 = e3[12], y3 = e3[13], m3 = e3[14], g3 = e3[15], x3 = r3 * o3 - n3 * a3, v3 = r3 * l2 - i3 * a3, b2 = r3 * u3 - s3 * a3, w2 = n3 * l2 - i3 * o3, _2 = n3 * u3 - s3 * o3, A2 = i3 * u3 - s3 * l2, S2 = c3 * y3 - h3 * f3, k2 = c3 * m3 - p3 * f3, I2 = c3 * g3 - d3 * f3, M2 = h3 * m3 - p3 * y3, T2 = h3 * g3 - d3 * y3, z2 = p3 * g3 - d3 * m3, B2 = x3 * z2 - v3 * T2 + b2 * M2 + w2 * I2 - _2 * k2 + A2 * S2;
          return B2 ? (t3[0] = (o3 * z2 - l2 * T2 + u3 * M2) * (B2 = 1 / B2), t3[1] = (i3 * T2 - n3 * z2 - s3 * M2) * B2, t3[2] = (y3 * A2 - m3 * _2 + g3 * w2) * B2, t3[3] = (p3 * _2 - h3 * A2 - d3 * w2) * B2, t3[4] = (l2 * I2 - a3 * z2 - u3 * k2) * B2, t3[5] = (r3 * z2 - i3 * I2 + s3 * k2) * B2, t3[6] = (m3 * b2 - f3 * A2 - g3 * v3) * B2, t3[7] = (c3 * A2 - p3 * b2 + d3 * v3) * B2, t3[8] = (a3 * T2 - o3 * I2 + u3 * S2) * B2, t3[9] = (n3 * I2 - r3 * T2 - s3 * S2) * B2, t3[10] = (f3 * _2 - y3 * b2 + g3 * x3) * B2, t3[11] = (h3 * b2 - c3 * _2 - d3 * x3) * B2, t3[12] = (o3 * k2 - a3 * M2 - l2 * S2) * B2, t3[13] = (r3 * M2 - n3 * k2 + i3 * S2) * B2, t3[14] = (y3 * v3 - f3 * w2 - m3 * x3) * B2, t3[15] = (c3 * w2 - h3 * v3 + p3 * x3) * B2, t3) : null;
        }
        function yo(t3, e3, r3) {
          var n3 = e3[0], i3 = e3[1], s3 = e3[2], a3 = e3[3], o3 = e3[4], l2 = e3[5], u3 = e3[6], c3 = e3[7], h3 = e3[8], p3 = e3[9], d3 = e3[10], f3 = e3[11], y3 = e3[12], m3 = e3[13], g3 = e3[14], x3 = e3[15], v3 = r3[0], b2 = r3[1], w2 = r3[2], _2 = r3[3];
          return t3[0] = v3 * n3 + b2 * o3 + w2 * h3 + _2 * y3, t3[1] = v3 * i3 + b2 * l2 + w2 * p3 + _2 * m3, t3[2] = v3 * s3 + b2 * u3 + w2 * d3 + _2 * g3, t3[3] = v3 * a3 + b2 * c3 + w2 * f3 + _2 * x3, t3[4] = (v3 = r3[4]) * n3 + (b2 = r3[5]) * o3 + (w2 = r3[6]) * h3 + (_2 = r3[7]) * y3, t3[5] = v3 * i3 + b2 * l2 + w2 * p3 + _2 * m3, t3[6] = v3 * s3 + b2 * u3 + w2 * d3 + _2 * g3, t3[7] = v3 * a3 + b2 * c3 + w2 * f3 + _2 * x3, t3[8] = (v3 = r3[8]) * n3 + (b2 = r3[9]) * o3 + (w2 = r3[10]) * h3 + (_2 = r3[11]) * y3, t3[9] = v3 * i3 + b2 * l2 + w2 * p3 + _2 * m3, t3[10] = v3 * s3 + b2 * u3 + w2 * d3 + _2 * g3, t3[11] = v3 * a3 + b2 * c3 + w2 * f3 + _2 * x3, t3[12] = (v3 = r3[12]) * n3 + (b2 = r3[13]) * o3 + (w2 = r3[14]) * h3 + (_2 = r3[15]) * y3, t3[13] = v3 * i3 + b2 * l2 + w2 * p3 + _2 * m3, t3[14] = v3 * s3 + b2 * u3 + w2 * d3 + _2 * g3, t3[15] = v3 * a3 + b2 * c3 + w2 * f3 + _2 * x3, t3;
        }
        function mo(t3, e3, r3) {
          var n3, i3, s3, a3, o3, l2, u3, c3, h3, p3, d3, f3, y3 = r3[0], m3 = r3[1], g3 = r3[2];
          return e3 === t3 ? (t3[12] = e3[0] * y3 + e3[4] * m3 + e3[8] * g3 + e3[12], t3[13] = e3[1] * y3 + e3[5] * m3 + e3[9] * g3 + e3[13], t3[14] = e3[2] * y3 + e3[6] * m3 + e3[10] * g3 + e3[14], t3[15] = e3[3] * y3 + e3[7] * m3 + e3[11] * g3 + e3[15]) : (i3 = e3[1], s3 = e3[2], a3 = e3[3], o3 = e3[4], l2 = e3[5], u3 = e3[6], c3 = e3[7], h3 = e3[8], p3 = e3[9], d3 = e3[10], f3 = e3[11], t3[0] = n3 = e3[0], t3[1] = i3, t3[2] = s3, t3[3] = a3, t3[4] = o3, t3[5] = l2, t3[6] = u3, t3[7] = c3, t3[8] = h3, t3[9] = p3, t3[10] = d3, t3[11] = f3, t3[12] = n3 * y3 + o3 * m3 + h3 * g3 + e3[12], t3[13] = i3 * y3 + l2 * m3 + p3 * g3 + e3[13], t3[14] = s3 * y3 + u3 * m3 + d3 * g3 + e3[14], t3[15] = a3 * y3 + c3 * m3 + f3 * g3 + e3[15]), t3;
        }
        function go(t3, e3, r3) {
          var n3 = r3[0], i3 = r3[1], s3 = r3[2];
          return t3[0] = e3[0] * n3, t3[1] = e3[1] * n3, t3[2] = e3[2] * n3, t3[3] = e3[3] * n3, t3[4] = e3[4] * i3, t3[5] = e3[5] * i3, t3[6] = e3[6] * i3, t3[7] = e3[7] * i3, t3[8] = e3[8] * s3, t3[9] = e3[9] * s3, t3[10] = e3[10] * s3, t3[11] = e3[11] * s3, t3[12] = e3[12], t3[13] = e3[13], t3[14] = e3[14], t3[15] = e3[15], t3;
        }
        function xo(t3, e3, r3) {
          var n3 = Math.sin(r3), i3 = Math.cos(r3), s3 = e3[4], a3 = e3[5], o3 = e3[6], l2 = e3[7], u3 = e3[8], c3 = e3[9], h3 = e3[10], p3 = e3[11];
          return e3 !== t3 && (t3[0] = e3[0], t3[1] = e3[1], t3[2] = e3[2], t3[3] = e3[3], t3[12] = e3[12], t3[13] = e3[13], t3[14] = e3[14], t3[15] = e3[15]), t3[4] = s3 * i3 + u3 * n3, t3[5] = a3 * i3 + c3 * n3, t3[6] = o3 * i3 + h3 * n3, t3[7] = l2 * i3 + p3 * n3, t3[8] = u3 * i3 - s3 * n3, t3[9] = c3 * i3 - a3 * n3, t3[10] = h3 * i3 - o3 * n3, t3[11] = p3 * i3 - l2 * n3, t3;
        }
        function vo(t3, e3, r3) {
          var n3 = Math.sin(r3), i3 = Math.cos(r3), s3 = e3[0], a3 = e3[1], o3 = e3[2], l2 = e3[3], u3 = e3[8], c3 = e3[9], h3 = e3[10], p3 = e3[11];
          return e3 !== t3 && (t3[4] = e3[4], t3[5] = e3[5], t3[6] = e3[6], t3[7] = e3[7], t3[12] = e3[12], t3[13] = e3[13], t3[14] = e3[14], t3[15] = e3[15]), t3[0] = s3 * i3 - u3 * n3, t3[1] = a3 * i3 - c3 * n3, t3[2] = o3 * i3 - h3 * n3, t3[3] = l2 * i3 - p3 * n3, t3[8] = s3 * n3 + u3 * i3, t3[9] = a3 * n3 + c3 * i3, t3[10] = o3 * n3 + h3 * i3, t3[11] = l2 * n3 + p3 * i3, t3;
        }
        function bo(t3, e3) {
          return t3[0] = e3[0], t3[1] = 0, t3[2] = 0, t3[3] = 0, t3[4] = 0, t3[5] = e3[1], t3[6] = 0, t3[7] = 0, t3[8] = 0, t3[9] = 0, t3[10] = e3[2], t3[11] = 0, t3[12] = 0, t3[13] = 0, t3[14] = 0, t3[15] = 1, t3;
        }
        function wo(t3, e3, r3) {
          var n3, i3, s3, a3 = r3[0], o3 = r3[1], l2 = r3[2], u3 = Math.hypot(a3, o3, l2);
          return u3 < lo ? null : (a3 *= u3 = 1 / u3, o3 *= u3, l2 *= u3, n3 = Math.sin(e3), i3 = Math.cos(e3), t3[0] = a3 * a3 * (s3 = 1 - i3) + i3, t3[1] = o3 * a3 * s3 + l2 * n3, t3[2] = l2 * a3 * s3 - o3 * n3, t3[3] = 0, t3[4] = a3 * o3 * s3 - l2 * n3, t3[5] = o3 * o3 * s3 + i3, t3[6] = l2 * o3 * s3 + a3 * n3, t3[7] = 0, t3[8] = a3 * l2 * s3 + o3 * n3, t3[9] = o3 * l2 * s3 - a3 * n3, t3[10] = l2 * l2 * s3 + i3, t3[11] = 0, t3[12] = 0, t3[13] = 0, t3[14] = 0, t3[15] = 1, t3);
        }
        Math.hypot || (Math.hypot = function() {
          for (var t3 = 0, e3 = arguments.length; e3--; )
            t3 += arguments[e3] * arguments[e3];
          return Math.sqrt(t3);
        });
        var _o = yo;
        function Ao() {
          var t3 = new uo(3);
          return uo != Float32Array && (t3[0] = 0, t3[1] = 0, t3[2] = 0), t3;
        }
        function So(t3) {
          var e3 = new uo(3);
          return e3[0] = t3[0], e3[1] = t3[1], e3[2] = t3[2], e3;
        }
        function ko(t3) {
          return Math.hypot(t3[0], t3[1], t3[2]);
        }
        function Io(t3, e3, r3) {
          var n3 = new uo(3);
          return n3[0] = t3, n3[1] = e3, n3[2] = r3, n3;
        }
        function Mo(t3, e3, r3) {
          return t3[0] = e3[0] + r3[0], t3[1] = e3[1] + r3[1], t3[2] = e3[2] + r3[2], t3;
        }
        function To(t3, e3, r3) {
          return t3[0] = e3[0] - r3[0], t3[1] = e3[1] - r3[1], t3[2] = e3[2] - r3[2], t3;
        }
        function zo(t3, e3, r3) {
          return t3[0] = e3[0] * r3[0], t3[1] = e3[1] * r3[1], t3[2] = e3[2] * r3[2], t3;
        }
        function Bo(t3, e3, r3) {
          return t3[0] = Math.min(e3[0], r3[0]), t3[1] = Math.min(e3[1], r3[1]), t3[2] = Math.min(e3[2], r3[2]), t3;
        }
        function Eo(t3, e3, r3) {
          return t3[0] = Math.max(e3[0], r3[0]), t3[1] = Math.max(e3[1], r3[1]), t3[2] = Math.max(e3[2], r3[2]), t3;
        }
        function Co(t3, e3, r3) {
          return t3[0] = e3[0] * r3, t3[1] = e3[1] * r3, t3[2] = e3[2] * r3, t3;
        }
        function Po(t3, e3, r3, n3) {
          return t3[0] = e3[0] + r3[0] * n3, t3[1] = e3[1] + r3[1] * n3, t3[2] = e3[2] + r3[2] * n3, t3;
        }
        function Do(t3, e3) {
          var r3 = e3[0], n3 = e3[1], i3 = e3[2], s3 = r3 * r3 + n3 * n3 + i3 * i3;
          return s3 > 0 && (s3 = 1 / Math.sqrt(s3)), t3[0] = e3[0] * s3, t3[1] = e3[1] * s3, t3[2] = e3[2] * s3, t3;
        }
        function Vo(t3, e3) {
          return t3[0] * e3[0] + t3[1] * e3[1] + t3[2] * e3[2];
        }
        function Lo(t3, e3, r3) {
          var n3 = e3[0], i3 = e3[1], s3 = e3[2], a3 = r3[0], o3 = r3[1], l2 = r3[2];
          return t3[0] = i3 * l2 - s3 * o3, t3[1] = s3 * a3 - n3 * l2, t3[2] = n3 * o3 - i3 * a3, t3;
        }
        function Fo(t3, e3, r3) {
          var n3 = e3[0], i3 = e3[1], s3 = e3[2], a3 = r3[3] * n3 + r3[7] * i3 + r3[11] * s3 + r3[15];
          return t3[0] = (r3[0] * n3 + r3[4] * i3 + r3[8] * s3 + r3[12]) / (a3 = a3 || 1), t3[1] = (r3[1] * n3 + r3[5] * i3 + r3[9] * s3 + r3[13]) / a3, t3[2] = (r3[2] * n3 + r3[6] * i3 + r3[10] * s3 + r3[14]) / a3, t3;
        }
        function Ro(t3, e3, r3) {
          var n3 = r3[0], i3 = r3[1], s3 = r3[2], a3 = e3[0], o3 = e3[1], l2 = e3[2], u3 = i3 * l2 - s3 * o3, c3 = s3 * a3 - n3 * l2, h3 = n3 * o3 - i3 * a3, p3 = i3 * h3 - s3 * c3, d3 = s3 * u3 - n3 * h3, f3 = n3 * c3 - i3 * u3, y3 = 2 * r3[3];
          return c3 *= y3, h3 *= y3, d3 *= 2, f3 *= 2, t3[0] = a3 + (u3 *= y3) + (p3 *= 2), t3[1] = o3 + c3 + d3, t3[2] = l2 + h3 + f3, t3;
        }
        var Uo, $o = To, jo = zo, Oo = ko;
        function qo(t3, e3, r3) {
          return t3[0] = e3[0] * r3, t3[1] = e3[1] * r3, t3[2] = e3[2] * r3, t3[3] = e3[3] * r3, t3;
        }
        function No(t3, e3) {
          var r3 = e3[0], n3 = e3[1], i3 = e3[2], s3 = e3[3], a3 = r3 * r3 + n3 * n3 + i3 * i3 + s3 * s3;
          return a3 > 0 && (a3 = 1 / Math.sqrt(a3)), t3[0] = r3 * a3, t3[1] = n3 * a3, t3[2] = i3 * a3, t3[3] = s3 * a3, t3;
        }
        function Go(t3, e3, r3) {
          var n3 = e3[0], i3 = e3[1], s3 = e3[2], a3 = e3[3];
          return t3[0] = r3[0] * n3 + r3[4] * i3 + r3[8] * s3 + r3[12] * a3, t3[1] = r3[1] * n3 + r3[5] * i3 + r3[9] * s3 + r3[13] * a3, t3[2] = r3[2] * n3 + r3[6] * i3 + r3[10] * s3 + r3[14] * a3, t3[3] = r3[3] * n3 + r3[7] * i3 + r3[11] * s3 + r3[15] * a3, t3;
        }
        function Zo() {
          var t3 = new uo(4);
          return uo != Float32Array && (t3[0] = 0, t3[1] = 0, t3[2] = 0), t3[3] = 1, t3;
        }
        function Ko(t3) {
          return t3[0] = 0, t3[1] = 0, t3[2] = 0, t3[3] = 1, t3;
        }
        function Xo(t3, e3, r3) {
          r3 *= 0.5;
          var n3 = e3[0], i3 = e3[1], s3 = e3[2], a3 = e3[3], o3 = Math.sin(r3), l2 = Math.cos(r3);
          return t3[0] = n3 * l2 + a3 * o3, t3[1] = i3 * l2 + s3 * o3, t3[2] = s3 * l2 - i3 * o3, t3[3] = a3 * l2 - n3 * o3, t3;
        }
        function Jo(t3, e3, r3) {
          r3 *= 0.5;
          var n3 = e3[0], i3 = e3[1], s3 = e3[2], a3 = e3[3], o3 = Math.sin(r3), l2 = Math.cos(r3);
          return t3[0] = n3 * l2 - s3 * o3, t3[1] = i3 * l2 + a3 * o3, t3[2] = s3 * l2 + n3 * o3, t3[3] = a3 * l2 - i3 * o3, t3;
        }
        Ao(), Uo = new uo(4), uo != Float32Array && (Uo[0] = 0, Uo[1] = 0, Uo[2] = 0, Uo[3] = 0);
        var Ho = No;
        Ao(), Io(1, 0, 0), Io(0, 1, 0), Zo(), Zo(), co();
        const Yo = Rs([{ type: "Float32", name: "a_globe_pos", components: 3 }, { type: "Float32", name: "a_uv", components: 2 }]), { members: Wo } = Yo, Qo = Rs([{ name: "a_pos_3", components: 3, type: "Int16" }]);
        var tl = Rs([{ name: "a_pos", type: "Int16", components: 2 }]);
        class el {
          constructor(t3, e3) {
            this.pos = t3, this.dir = e3;
          }
          intersectsPlane(t3, e3, r3) {
            const n3 = Vo(e3, this.dir);
            if (Math.abs(n3) < 1e-6)
              return false;
            const i3 = ((t3[0] - this.pos[0]) * e3[0] + (t3[1] - this.pos[1]) * e3[1] + (t3[2] - this.pos[2]) * e3[2]) / n3;
            return r3[0] = this.pos[0] + this.dir[0] * i3, r3[1] = this.pos[1] + this.dir[1] * i3, r3[2] = this.pos[2] + this.dir[2] * i3, true;
          }
          closestPointOnSphere(t3, e3, r3) {
            if (function(t4, e4) {
              var r4 = t4[0], n4 = t4[1], i4 = t4[2], s4 = e4[0], a4 = e4[1], o4 = e4[2];
              return Math.abs(r4 - s4) <= lo * Math.max(1, Math.abs(r4), Math.abs(s4)) && Math.abs(n4 - a4) <= lo * Math.max(1, Math.abs(n4), Math.abs(a4)) && Math.abs(i4 - o4) <= lo * Math.max(1, Math.abs(i4), Math.abs(o4));
            }(this.pos, t3) || 0 === e3)
              return r3[0] = r3[1] = r3[2] = 0, false;
            const [n3, i3, s3] = this.dir, a3 = this.pos[0] - t3[0], o3 = this.pos[1] - t3[1], l2 = this.pos[2] - t3[2], u3 = n3 * n3 + i3 * i3 + s3 * s3, c3 = 2 * (a3 * n3 + o3 * i3 + l2 * s3), h3 = c3 * c3 - 4 * u3 * (a3 * a3 + o3 * o3 + l2 * l2 - e3 * e3);
            if (h3 < 0) {
              const t4 = Math.max(-c3 / 2, 0), u4 = a3 + n3 * t4, h4 = o3 + i3 * t4, p3 = l2 + s3 * t4, d3 = Math.hypot(u4, h4, p3);
              return r3[0] = u4 * e3 / d3, r3[1] = h4 * e3 / d3, r3[2] = p3 * e3 / d3, false;
            }
            {
              const t4 = (-c3 - Math.sqrt(h3)) / (2 * u3);
              if (t4 < 0) {
                const t5 = Math.hypot(a3, o3, l2);
                return r3[0] = a3 * e3 / t5, r3[1] = o3 * e3 / t5, r3[2] = l2 * e3 / t5, false;
              }
              return r3[0] = a3 + n3 * t4, r3[1] = o3 + i3 * t4, r3[2] = l2 + s3 * t4, true;
            }
          }
        }
        class rl {
          constructor(t3, e3, r3, n3, i3) {
            this.TL = t3, this.TR = e3, this.BR = r3, this.BL = n3, this.horizon = i3;
          }
          static fromInvProjectionMatrix(t3, e3, r3) {
            const n3 = [-1, 1, 1], i3 = [1, 1, 1], s3 = [1, -1, 1], a3 = [-1, -1, 1], o3 = Fo(n3, n3, t3), l2 = Fo(i3, i3, t3), u3 = Fo(s3, s3, t3), c3 = Fo(a3, a3, t3);
            return new rl(o3, l2, u3, c3, e3 / r3);
          }
        }
        class nl {
          constructor(t3, e3) {
            this.points = t3, this.planes = e3;
          }
          static fromInvProjectionMatrix(t3, e3, r3, n3) {
            const i3 = Math.pow(2, r3), s3 = [[-1, 1, -1, 1], [1, 1, -1, 1], [1, -1, -1, 1], [-1, -1, -1, 1], [-1, 1, 1, 1], [1, 1, 1, 1], [1, -1, 1, 1], [-1, -1, 1, 1]].map((r4) => {
              const s4 = Go([], r4, t3), a4 = 1 / s4[3] / e3 * i3;
              return function(t4, e4, r5) {
                return t4[0] = e4[0] * r5[0], t4[1] = e4[1] * r5[1], t4[2] = e4[2] * r5[2], t4[3] = e4[3] * r5[3], t4;
              }(s4, s4, [a4, a4, n3 ? 1 / s4[3] : a4, a4]);
            }), a3 = [[0, 1, 2], [6, 5, 4], [0, 3, 7], [2, 1, 5], [3, 2, 6], [0, 4, 5]].map((t4) => {
              const e4 = Do([], Lo([], $o([], s3[t4[0]], s3[t4[1]]), $o([], s3[t4[2]], s3[t4[1]]))), r4 = -Vo(e4, s3[t4[1]]);
              return e4.concat(r4);
            });
            return new nl(s3, a3);
          }
        }
        class il {
          static fromPoints(t3) {
            const e3 = [1 / 0, 1 / 0, 1 / 0], r3 = [-1 / 0, -1 / 0, -1 / 0];
            for (const n3 of t3)
              Bo(e3, e3, n3), Eo(r3, r3, n3);
            return new il(e3, r3);
          }
          static applyTransform(t3, e3) {
            const r3 = t3.getCorners();
            for (let t4 = 0; t4 < r3.length; ++t4)
              Fo(r3[t4], r3[t4], e3);
            return il.fromPoints(r3);
          }
          constructor(t3, e3) {
            this.min = t3, this.max = e3, this.center = Co([], Mo([], this.min, this.max), 0.5);
          }
          quadrant(t3) {
            const e3 = [t3 % 2 == 0, t3 < 2], r3 = So(this.min), n3 = So(this.max);
            for (let t4 = 0; t4 < e3.length; t4++)
              r3[t4] = e3[t4] ? this.min[t4] : this.center[t4], n3[t4] = e3[t4] ? this.center[t4] : this.max[t4];
            return n3[2] = this.max[2], new il(r3, n3);
          }
          distanceX(t3) {
            return Math.max(Math.min(this.max[0], t3[0]), this.min[0]) - t3[0];
          }
          distanceY(t3) {
            return Math.max(Math.min(this.max[1], t3[1]), this.min[1]) - t3[1];
          }
          distanceZ(t3) {
            return Math.max(Math.min(this.max[2], t3[2]), this.min[2]) - t3[2];
          }
          getCorners() {
            const t3 = this.min, e3 = this.max;
            return [[t3[0], t3[1], t3[2]], [e3[0], t3[1], t3[2]], [e3[0], e3[1], t3[2]], [t3[0], e3[1], t3[2]], [t3[0], t3[1], e3[2]], [e3[0], t3[1], e3[2]], [e3[0], e3[1], e3[2]], [t3[0], e3[1], e3[2]]];
          }
          intersects(t3) {
            const e3 = this.getCorners();
            let r3 = true;
            for (let n3 = 0; n3 < t3.planes.length; n3++) {
              const i3 = t3.planes[n3];
              let s3 = 0;
              for (let t4 = 0; t4 < e3.length; t4++)
                s3 += Vo(i3, e3[t4]) + i3[3] >= 0;
              if (0 === s3)
                return 0;
              s3 !== e3.length && (r3 = false);
            }
            if (r3)
              return 2;
            for (let e4 = 0; e4 < 3; e4++) {
              let r4 = Number.MAX_VALUE, n3 = -Number.MAX_VALUE;
              for (let i3 = 0; i3 < t3.points.length; i3++) {
                const s3 = t3.points[i3][e4] - this.min[e4];
                r4 = Math.min(r4, s3), n3 = Math.max(n3, s3);
              }
              if (n3 < 0 || r4 > this.max[e4] - this.min[e4])
                return 0;
            }
            return 1;
          }
        }
        const sl = 5, al = 6, ol = ao / Math.PI / 2, ll = 16383, ul = 64, cl = [ul, 32, 16], hl = -ol, pl = ol, dl = [new il([hl, hl, hl], [pl, pl, pl]), new il([hl, hl, hl], [0, 0, pl]), new il([0, hl, hl], [pl, 0, pl]), new il([hl, 0, hl], [0, pl, pl]), new il([0, 0, hl], [pl, pl, pl])];
        function fl(t3) {
          return t3 * ol / Ul;
        }
        function yl(t3, e3, r3, n3 = true) {
          const i3 = Co([], t3._camera.position, t3.worldSize), s3 = [e3, r3, 1, 1];
          Go(s3, s3, t3.pixelMatrixInverse), qo(s3, s3, 1 / s3[3]);
          const a3 = Do([], $o([], s3, i3)), o3 = t3.globeMatrix, l2 = [o3[12], o3[13], o3[14]], u3 = $o([], l2, i3), c3 = ko(u3), h3 = Do([], u3), p3 = t3.worldSize / (2 * Math.PI), d3 = Vo(h3, a3), f3 = Math.asin(p3 / c3);
          if (f3 < Math.acos(d3)) {
            if (!n3)
              return null;
            const t4 = [], e4 = [];
            Co(t4, a3, c3 / d3), Do(e4, $o(e4, t4, u3)), Do(a3, Mo(a3, u3, Co(a3, e4, Math.tan(f3) * c3)));
          }
          const y3 = [];
          new el(i3, a3).closestPointOnSphere(l2, p3, y3);
          const m3 = Do([], W(o3, 0)), g3 = Do([], W(o3, 1)), x3 = Do([], W(o3, 2)), v3 = Vo(m3, y3), b2 = Vo(g3, y3), w2 = Vo(x3, y3), A2 = _(Math.asin(-b2 / p3));
          let S2 = _(Math.atan2(v3, w2));
          S2 = t3.center.lng + function(t4, e4) {
            const r4 = (e4 - t4 + 180) % 360 - 180;
            return r4 < -180 ? r4 + 360 : r4;
          }(t3.center.lng, S2);
          const k2 = Nl(S2), I2 = M(Gl(A2), 0, 1);
          return new Wl(k2, I2);
        }
        class ml {
          constructor(t3, e3, r3) {
            this.a = $o([], t3, r3), this.b = $o([], e3, r3), this.center = r3;
            const n3 = Do([], this.a), i3 = Do([], this.b);
            this.angle = Math.acos(Vo(n3, i3));
          }
        }
        function gl(t3, e3) {
          if (0 === t3.angle)
            return null;
          let r3;
          return r3 = 0 === t3.a[e3] ? 1 / t3.angle * 0.5 * Math.PI : 1 / t3.angle * Math.atan(t3.b[e3] / t3.a[e3] / Math.sin(t3.angle) - 1 / Math.tan(t3.angle)), r3 < 0 || r3 > 1 ? null : function(t4, e4, r4, n3) {
            const i3 = Math.sin(r4);
            return t4 * (Math.sin((1 - n3) * r4) / i3) + e4 * (Math.sin(n3 * r4) / i3);
          }(t3.a[e3], t3.b[e3], t3.angle, M(r3, 0, 1)) + t3.center[e3];
        }
        function xl(t3) {
          if (t3.z <= 1)
            return dl[t3.z + 2 * t3.y + t3.x];
          const e3 = Sl(Al(t3));
          return il.fromPoints(e3);
        }
        function vl(t3, e3, r3) {
          return Co(t3, t3, 1 - r3), Po(t3, t3, e3, r3);
        }
        function bl(t3, e3) {
          const r3 = Pl(e3.zoom);
          if (0 === r3)
            return xl(t3);
          const n3 = Al(t3), i3 = Sl(n3), s3 = Nl(n3.getWest()) * e3.worldSize, a3 = Nl(n3.getEast()) * e3.worldSize, o3 = Gl(n3.getNorth()) * e3.worldSize, l2 = Gl(n3.getSouth()) * e3.worldSize, u3 = [s3, o3, 0], c3 = [a3, o3, 0], h3 = [s3, l2, 0], p3 = [a3, l2, 0], d3 = fo([], e3.globeMatrix);
          return Fo(u3, u3, d3), Fo(c3, c3, d3), Fo(h3, h3, d3), Fo(p3, p3, d3), i3[0] = vl(i3[0], h3, r3), i3[1] = vl(i3[1], p3, r3), i3[2] = vl(i3[2], c3, r3), i3[3] = vl(i3[3], u3, r3), il.fromPoints(i3);
        }
        function wl(t3, e3, r3) {
          for (const n3 of t3)
            Fo(n3, n3, e3), Co(n3, n3, r3);
        }
        function _l(t3, e3, r3) {
          const n3 = e3 / t3.worldSize, i3 = t3.globeMatrix;
          if (r3.z <= 1) {
            const t4 = xl(r3).getCorners();
            return wl(t4, i3, n3), il.fromPoints(t4);
          }
          const s3 = Al(r3), a3 = Sl(s3);
          wl(a3, i3, n3);
          const o3 = Number.MAX_VALUE, l2 = [-o3, -o3, -o3], u3 = [o3, o3, o3];
          if (s3.contains(t3.center)) {
            for (const t4 of a3)
              Bo(u3, u3, t4), Eo(l2, l2, t4);
            l2[2] = 0;
            const e4 = t3.point, r4 = [e4.x * n3, e4.y * n3, 0];
            return Bo(u3, u3, r4), Eo(l2, l2, r4), new il(u3, l2);
          }
          const c3 = [i3[12] * n3, i3[13] * n3, i3[14] * n3], h3 = s3.getCenter(), p3 = M(t3.center.lat, -Hl, Hl), d3 = M(h3.lat, -Hl, Hl), f3 = Nl(t3.center.lng), y3 = Gl(p3);
          let m3 = f3 - Nl(h3.lng);
          const g3 = y3 - Gl(d3);
          m3 > 0.5 ? m3 -= 1 : m3 < -0.5 && (m3 += 1);
          let x3 = 0;
          Math.abs(m3) > Math.abs(g3) ? x3 = m3 >= 0 ? 1 : 3 : (x3 = g3 >= 0 ? 0 : 2, Po(c3, c3, [i3[4] * n3, i3[5] * n3, i3[6] * n3], -Math.sin(w(g3 >= 0 ? s3.getSouth() : s3.getNorth())) * ol));
          const v3 = a3[x3], b2 = a3[(x3 + 1) % 4], _2 = new ml(v3, b2, c3), A2 = [gl(_2, 0) || v3[0], gl(_2, 1) || v3[1], gl(_2, 2) || v3[2]], S2 = Pl(t3.zoom);
          if (S2 > 0) {
            const n4 = function({ x: t4, y: e4, z: r4 }, n5, i5, s4, a4) {
              const o4 = 1 / (1 << r4);
              let l3 = t4 * o4, u4 = l3 + o4, c4 = e4 * o4, h4 = c4 + o4, p4 = 0;
              const d4 = (l3 + u4) / 2 - s4;
              return d4 > 0.5 ? p4 = -1 : d4 < -0.5 && (p4 = 1), l3 = ((l3 + p4) * n5 - (s4 *= n5)) * i5 + s4, u4 = ((u4 + p4) * n5 - s4) * i5 + s4, c4 = (c4 * n5 - (a4 *= n5)) * i5 + a4, h4 = (h4 * n5 - a4) * i5 + a4, [[l3, h4, 0], [u4, h4, 0], [u4, c4, 0], [l3, c4, 0]];
            }(r3, e3, t3._pixelsPerMercatorPixel, f3, y3);
            for (let t4 = 0; t4 < a3.length; t4++)
              vl(a3[t4], n4[t4], S2);
            const i4 = Mo([], n4[x3], n4[(x3 + 1) % 4]);
            Co(i4, i4, 0.5), vl(A2, i4, S2);
          }
          for (const t4 of a3)
            Bo(u3, u3, t4), Eo(l2, l2, t4);
          return u3[2] = Math.min(v3[2], b2[2]), Bo(u3, u3, A2), Eo(l2, l2, A2), new il(u3, l2);
        }
        function Al({ x: t3, y: e3, z: r3 }) {
          const n3 = 1 / (1 << r3), i3 = new Ol(Kl(t3 * n3), Xl((e3 + 1) * n3)), s3 = new Ol(Kl((t3 + 1) * n3), Xl(e3 * n3));
          return new oo(i3, s3);
        }
        function Sl(t3) {
          const e3 = w(t3.getNorth()), r3 = w(t3.getSouth()), n3 = Math.cos(e3), i3 = Math.cos(r3), s3 = Math.sin(e3), a3 = Math.sin(r3), o3 = t3.getWest(), l2 = t3.getEast();
          return [kl(i3, a3, o3), kl(i3, a3, l2), kl(n3, s3, l2), kl(n3, s3, o3)];
        }
        function kl(t3, e3, r3, n3 = ol) {
          return r3 = w(r3), [t3 * Math.sin(r3) * n3, -e3 * n3, t3 * Math.cos(r3) * n3];
        }
        function Il(t3, e3, r3) {
          return kl(Math.cos(w(t3)), Math.sin(w(t3)), e3, r3);
        }
        function Ml(t3, e3, r3, n3) {
          const i3 = 1 << r3.z, s3 = (t3 / ao + r3.x) / i3;
          return Il(Xl((e3 / ao + r3.y) / i3), Kl(s3), n3);
        }
        function Tl({ min: t3, max: e3 }) {
          return ll / Math.max(e3[0] - t3[0], e3[1] - t3[1], e3[2] - t3[2]);
        }
        const zl = new Float64Array(16);
        function Bl(t3) {
          const e3 = Tl(t3), r3 = bo(zl, [e3, e3, e3]);
          return mo(r3, r3, ((n3 = [])[0] = -(i3 = t3.min)[0], n3[1] = -i3[1], n3[2] = -i3[2], n3));
          var n3, i3;
        }
        function El(t3) {
          const e3 = (n3 = t3.min, (r3 = zl)[0] = 1, r3[1] = 0, r3[2] = 0, r3[3] = 0, r3[4] = 0, r3[5] = 1, r3[6] = 0, r3[7] = 0, r3[8] = 0, r3[9] = 0, r3[10] = 1, r3[11] = 0, r3[12] = n3[0], r3[13] = n3[1], r3[14] = n3[2], r3[15] = 1, r3);
          var r3, n3;
          const i3 = 1 / Tl(t3);
          return go(e3, e3, [i3, i3, i3]);
        }
        function Cl(t3, e3, r3, n3, i3) {
          const s3 = function(t4) {
            const e4 = ao / (2 * Math.PI);
            return t4 / (2 * Math.PI) / e4;
          }(r3), a3 = [t3, e3, -r3 / (2 * Math.PI)], o3 = po(new Float64Array(16));
          return mo(o3, o3, a3), go(o3, o3, [s3, s3, s3]), xo(o3, o3, w(-i3)), vo(o3, o3, w(-n3)), o3;
        }
        function Pl(t3) {
          return T(sl, al, t3);
        }
        function Dl(t3, e3) {
          const r3 = Il(e3.lat, e3.lng), n3 = function(t4) {
            const e4 = Il(t4._center.lat, t4._center.lng);
            let r4 = Lo([], Io(0, 1, 0), e4);
            const n4 = wo([], -t4.angle, e4);
            r4 = Fo(r4, r4, n4), wo(n4, -t4._pitch, r4);
            const i4 = Do([], e4);
            return Co(i4, i4, fl(t4.cameraToCenterDistance / t4.pixelsPerMeter)), Fo(i4, i4, n4), Mo([], e4, i4);
          }(t3);
          return a3 = (i3 = To([], n3, r3))[0], o3 = i3[1], l2 = i3[2], u3 = (s3 = r3)[0], c3 = s3[1], h3 = s3[2], d3 = (p3 = Math.sqrt(a3 * a3 + o3 * o3 + l2 * l2) * Math.sqrt(u3 * u3 + c3 * c3 + h3 * h3)) && Vo(i3, s3) / p3, Math.acos(Math.min(Math.max(d3, -1), 1));
          var i3, s3, a3, o3, l2, u3, c3, h3, p3, d3;
        }
        function Vl(t3, e3) {
          return Dl(t3, e3) > Math.PI / 2 * 1.01;
        }
        const Ll = w(85), Fl = Math.cos(Ll), Rl = Math.sin(Ll), Ul = 63710088e-1, $l = 2 * Math.PI * Ul;
        class jl {
          constructor(t3, e3) {
            if (isNaN(t3) || isNaN(e3))
              throw new Error(`Invalid LngLat object: (${t3}, ${e3})`);
            if (this.lng = +t3, this.lat = +e3, this.lat > 90 || this.lat < -90)
              throw new Error("Invalid LngLat latitude value: must be between -90 and 90");
          }
          wrap() {
            return new jl(z(this.lng, -180, 180), this.lat);
          }
          toArray() {
            return [this.lng, this.lat];
          }
          toString() {
            return `LngLat(${this.lng}, ${this.lat})`;
          }
          distanceTo(t3) {
            const e3 = Math.PI / 180, r3 = this.lat * e3, n3 = t3.lat * e3, i3 = Math.sin(r3) * Math.sin(n3) + Math.cos(r3) * Math.cos(n3) * Math.cos((t3.lng - this.lng) * e3);
            return Ul * Math.acos(Math.min(i3, 1));
          }
          toBounds(t3 = 0) {
            const e3 = 360 * t3 / 40075017, r3 = e3 / Math.cos(Math.PI / 180 * this.lat);
            return new oo(new jl(this.lng - r3, this.lat - e3), new jl(this.lng + r3, this.lat + e3));
          }
          toEcef(t3) {
            const e3 = fl(t3);
            return Il(this.lat, this.lng, ol + e3);
          }
          static convert(t3) {
            if (t3 instanceof jl)
              return t3;
            if (Array.isArray(t3) && (2 === t3.length || 3 === t3.length))
              return new jl(Number(t3[0]), Number(t3[1]));
            if (!Array.isArray(t3) && "object" == typeof t3 && null !== t3)
              return new jl(Number("lng" in t3 ? t3.lng : t3.lon), Number(t3.lat));
            throw new Error("`LngLatLike` argument must be specified as a LngLat instance, an object {lng: <lng>, lat: <lat>}, an object {lon: <lng>, lat: <lat>}, or an array of [<lng>, <lat>]");
          }
        }
        var Ol = jl;
        function ql(t3) {
          return $l * Math.cos(t3 * Math.PI / 180);
        }
        function Nl(t3) {
          return (180 + t3) / 360;
        }
        function Gl(t3) {
          return (180 - 180 / Math.PI * Math.log(Math.tan(Math.PI / 4 + t3 * Math.PI / 360))) / 360;
        }
        function Zl(t3, e3) {
          return t3 / ql(e3);
        }
        function Kl(t3) {
          return 360 * t3 - 180;
        }
        function Xl(t3) {
          return 360 / Math.PI * Math.atan(Math.exp((180 - 360 * t3) * Math.PI / 180)) - 90;
        }
        function Jl(t3, e3) {
          return t3 * ql(Xl(e3));
        }
        const Hl = 85.051129;
        function Yl(t3) {
          return 1 / Math.cos(t3 * Math.PI / 180);
        }
        class Wl {
          constructor(t3, e3, r3 = 0) {
            this.x = +t3, this.y = +e3, this.z = +r3;
          }
          static fromLngLat(t3, e3 = 0) {
            const r3 = Ol.convert(t3);
            return new Wl(Nl(r3.lng), Gl(r3.lat), Zl(e3, r3.lat));
          }
          toLngLat() {
            return new Ol(Kl(this.x), Xl(this.y));
          }
          toAltitude() {
            return Jl(this.z, this.y);
          }
          meterInMercatorCoordinateUnits() {
            return 1 / $l * Yl(Xl(this.y));
          }
        }
        function Ql(t3, e3, r3, n3, i3, s3, a3, o3, l2) {
          const u3 = (e3 + n3) / 2, c3 = (r3 + i3) / 2, h3 = new x2(u3, c3);
          o3(h3), function(t4, e4, r4, n4, i4, s4) {
            const a4 = r4 - i4, o4 = n4 - s4;
            return Math.abs((n4 - e4) * a4 - (r4 - t4) * o4) / Math.hypot(a4, o4);
          }(h3.x, h3.y, s3.x, s3.y, a3.x, a3.y) >= l2 ? (Ql(t3, e3, r3, u3, c3, s3, h3, o3, l2), Ql(t3, u3, c3, n3, i3, h3, a3, o3, l2)) : t3.push(a3);
        }
        function tu(t3, e3, r3) {
          let n3 = t3[0], i3 = n3.x, s3 = n3.y;
          e3(n3);
          const a3 = [n3];
          for (let o3 = 1; o3 < t3.length; o3++) {
            const l2 = t3[o3], { x: u3, y: c3 } = l2;
            e3(l2), Ql(a3, i3, s3, u3, c3, n3, l2, e3, r3), i3 = u3, s3 = c3, n3 = l2;
          }
          return a3;
        }
        function eu(t3, e3, r3, n3) {
          if (n3(e3, r3)) {
            const i3 = e3.add(r3)._mult(0.5);
            eu(t3, e3, i3, n3), eu(t3, i3, r3, n3);
          } else
            t3.push(r3);
        }
        function ru(t3, e3) {
          let r3 = t3[0];
          const n3 = [r3];
          for (let i3 = 1; i3 < t3.length; i3++) {
            const s3 = t3[i3];
            eu(n3, r3, s3, e3), r3 = s3;
          }
          return n3;
        }
        const nu = Math.pow(2, 14) - 1, iu = -nu - 1;
        function su(t3, e3) {
          const r3 = Math.round(t3.x * e3), n3 = Math.round(t3.y * e3);
          return t3.x = M(r3, iu, nu), t3.y = M(n3, iu, nu), (r3 < t3.x || r3 > t3.x + 1 || n3 < t3.y || n3 > t3.y + 1) && N("Geometry exceeds allowed extent, reduce your vector tile buffer size"), t3;
        }
        function au(t3, e3, r3) {
          const n3 = t3.loadGeometry(), i3 = t3.extent, s3 = ao / i3;
          if (e3 && r3 && r3.projection.isReprojectedInTileSpace) {
            const s4 = 1 << e3.z, { scale: a3, x: o3, y: l2, projection: u3 } = r3, c3 = (t4) => {
              const r4 = Kl((e3.x + t4.x / i3) / s4), n4 = Xl((e3.y + t4.y / i3) / s4), c4 = u3.project(r4, n4);
              t4.x = (c4.x * a3 - o3) * i3, t4.y = (c4.y * a3 - l2) * i3;
            };
            for (let e4 = 0; e4 < n3.length; e4++)
              if (1 !== t3.type)
                n3[e4] = tu(n3[e4], c3, 1);
              else {
                const t4 = [];
                for (const r4 of n3[e4])
                  r4.x < 0 || r4.x >= i3 || r4.y < 0 || r4.y >= i3 || (c3(r4), t4.push(r4));
                n3[e4] = t4;
              }
          }
          for (const t4 of n3)
            for (const e4 of t4)
              su(e4, s3);
          return n3;
        }
        function ou(t3, e3) {
          return { type: t3.type, id: t3.id, properties: t3.properties, geometry: e3 ? au(t3) : [] };
        }
        function lu(t3, e3, r3, n3, i3) {
          t3.emplaceBack(2 * e3 + (n3 + 1) / 2, 2 * r3 + (i3 + 1) / 2);
        }
        function uu(t3, e3, r3) {
          const n3 = 16384;
          t3.emplaceBack(e3.x, e3.y, e3.z, r3[0] * n3, r3[1] * n3, r3[2] * n3);
        }
        class cu {
          constructor(t3) {
            this.zoom = t3.zoom, this.overscaling = t3.overscaling, this.layers = t3.layers, this.layerIds = this.layers.map((t4) => t4.id), this.index = t3.index, this.hasPattern = false, this.projection = t3.projection, this.layoutVertexArray = new $s(), this.indexArray = new ra(), this.segments = new so(), this.programConfigurations = new Ja(t3.layers, t3.zoom), this.stateDependentLayerIds = this.layers.filter((t4) => t4.isStateDependent()).map((t4) => t4.id);
          }
          populate(t3, e3, r3, n3) {
            const i3 = this.layers[0], s3 = [];
            let a3 = null;
            "circle" === i3.type && (a3 = i3.layout.get("circle-sort-key"));
            for (const { feature: e4, id: i4, index: o4, sourceLayerIndex: l2 } of t3) {
              const t4 = this.layers[0]._featureFilter.needGeometry, u3 = ou(e4, t4);
              if (!this.layers[0]._featureFilter.filter(new ws(this.zoom), u3, r3))
                continue;
              const c3 = a3 ? a3.evaluate(u3, {}, r3) : void 0, h3 = { id: i4, properties: e4.properties, type: e4.type, sourceLayerIndex: l2, index: o4, geometry: t4 ? u3.geometry : au(e4, r3, n3), patterns: {}, sortKey: c3 };
              s3.push(h3);
            }
            a3 && s3.sort((t4, e4) => t4.sortKey - e4.sortKey);
            let o3 = null;
            "globe" === n3.projection.name && (this.globeExtVertexArray = new Ks(), o3 = n3.projection);
            for (const n4 of s3) {
              const { geometry: i4, index: s4, sourceLayerIndex: a4 } = n4, l2 = t3[s4].feature;
              this.addFeature(n4, i4, s4, e3.availableImages, r3, o3), e3.featureIndex.insert(l2, i4, s4, a4, this.index);
            }
          }
          update(t3, e3, r3, n3) {
            this.stateDependentLayers.length && this.programConfigurations.updatePaintArrays(t3, e3, this.stateDependentLayers, r3, n3);
          }
          isEmpty() {
            return 0 === this.layoutVertexArray.length;
          }
          uploadPending() {
            return !this.uploaded || this.programConfigurations.needsUpload;
          }
          upload(t3) {
            this.uploaded || (this.layoutVertexBuffer = t3.createVertexBuffer(this.layoutVertexArray, no.members), this.indexBuffer = t3.createIndexBuffer(this.indexArray), this.globeExtVertexArray && (this.globeExtVertexBuffer = t3.createVertexBuffer(this.globeExtVertexArray, io.members))), this.programConfigurations.upload(t3), this.uploaded = true;
          }
          destroy() {
            this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy(), this.globeExtVertexBuffer && this.globeExtVertexBuffer.destroy());
          }
          addFeature(t3, e3, r3, n3, i3, s3) {
            for (const r4 of e3)
              for (const e4 of r4) {
                const r5 = e4.x, n4 = e4.y;
                if (r5 < 0 || r5 >= ao || n4 < 0 || n4 >= ao)
                  continue;
                if (s3) {
                  const t4 = s3.projectTilePoint(r5, n4, i3), e5 = s3.upVector(i3, r5, n4), a4 = this.globeExtVertexArray;
                  uu(a4, t4, e5), uu(a4, t4, e5), uu(a4, t4, e5), uu(a4, t4, e5);
                }
                const a3 = this.segments.prepareSegment(4, this.layoutVertexArray, this.indexArray, t3.sortKey), o3 = a3.vertexLength;
                lu(this.layoutVertexArray, r5, n4, -1, -1), lu(this.layoutVertexArray, r5, n4, 1, -1), lu(this.layoutVertexArray, r5, n4, 1, 1), lu(this.layoutVertexArray, r5, n4, -1, 1), this.indexArray.emplaceBack(o3, o3 + 1, o3 + 2), this.indexArray.emplaceBack(o3, o3 + 2, o3 + 3), a3.vertexLength += 4, a3.primitiveLength += 2;
              }
            this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, t3, r3, {}, n3, i3);
          }
        }
        function hu(t3, e3) {
          for (let r3 = 0; r3 < t3.length; r3++)
            if (bu(e3, t3[r3]))
              return true;
          for (let r3 = 0; r3 < e3.length; r3++)
            if (bu(t3, e3[r3]))
              return true;
          return !!yu(t3, e3);
        }
        function pu(t3, e3, r3) {
          return !!bu(t3, e3) || !!gu(e3, t3, r3);
        }
        function du(t3, e3) {
          if (1 === t3.length)
            return vu(e3, t3[0]);
          for (let r3 = 0; r3 < e3.length; r3++) {
            const n3 = e3[r3];
            for (let e4 = 0; e4 < n3.length; e4++)
              if (bu(t3, n3[e4]))
                return true;
          }
          for (let r3 = 0; r3 < t3.length; r3++)
            if (vu(e3, t3[r3]))
              return true;
          for (let r3 = 0; r3 < e3.length; r3++)
            if (yu(t3, e3[r3]))
              return true;
          return false;
        }
        function fu(t3, e3, r3) {
          if (t3.length > 1) {
            if (yu(t3, e3))
              return true;
            for (let n3 = 0; n3 < e3.length; n3++)
              if (gu(e3[n3], t3, r3))
                return true;
          }
          for (let n3 = 0; n3 < t3.length; n3++)
            if (gu(t3[n3], e3, r3))
              return true;
          return false;
        }
        function yu(t3, e3) {
          if (0 === t3.length || 0 === e3.length)
            return false;
          for (let r3 = 0; r3 < t3.length - 1; r3++) {
            const n3 = t3[r3], i3 = t3[r3 + 1];
            for (let t4 = 0; t4 < e3.length - 1; t4++)
              if (mu(n3, i3, e3[t4], e3[t4 + 1]))
                return true;
          }
          return false;
        }
        function mu(t3, e3, r3, n3) {
          return G(t3, r3, n3) !== G(e3, r3, n3) && G(t3, e3, r3) !== G(t3, e3, n3);
        }
        function gu(t3, e3, r3) {
          const n3 = r3 * r3;
          if (1 === e3.length)
            return t3.distSqr(e3[0]) < n3;
          for (let r4 = 1; r4 < e3.length; r4++)
            if (xu(t3, e3[r4 - 1], e3[r4]) < n3)
              return true;
          return false;
        }
        function xu(t3, e3, r3) {
          const n3 = e3.distSqr(r3);
          if (0 === n3)
            return t3.distSqr(e3);
          const i3 = ((t3.x - e3.x) * (r3.x - e3.x) + (t3.y - e3.y) * (r3.y - e3.y)) / n3;
          return t3.distSqr(i3 < 0 ? e3 : i3 > 1 ? r3 : r3.sub(e3)._mult(i3)._add(e3));
        }
        function vu(t3, e3) {
          let r3, n3, i3, s3 = false;
          for (let a3 = 0; a3 < t3.length; a3++) {
            r3 = t3[a3];
            for (let t4 = 0, a4 = r3.length - 1; t4 < r3.length; a4 = t4++)
              n3 = r3[t4], i3 = r3[a4], n3.y > e3.y != i3.y > e3.y && e3.x < (i3.x - n3.x) * (e3.y - n3.y) / (i3.y - n3.y) + n3.x && (s3 = !s3);
          }
          return s3;
        }
        function bu(t3, e3) {
          let r3 = false;
          for (let n3 = 0, i3 = t3.length - 1; n3 < t3.length; i3 = n3++) {
            const s3 = t3[n3], a3 = t3[i3];
            s3.y > e3.y != a3.y > e3.y && e3.x < (a3.x - s3.x) * (e3.y - s3.y) / (a3.y - s3.y) + s3.x && (r3 = !r3);
          }
          return r3;
        }
        function wu(t3, e3, r3, n3, i3) {
          for (const s4 of t3)
            if (e3 <= s4.x && r3 <= s4.y && n3 >= s4.x && i3 >= s4.y)
              return true;
          const s3 = [new x2(e3, r3), new x2(e3, i3), new x2(n3, i3), new x2(n3, r3)];
          if (t3.length > 2) {
            for (const e4 of s3)
              if (bu(t3, e4))
                return true;
          }
          for (let e4 = 0; e4 < t3.length - 1; e4++)
            if (_u(t3[e4], t3[e4 + 1], s3))
              return true;
          return false;
        }
        function _u(t3, e3, r3) {
          const n3 = r3[0], i3 = r3[2];
          if (t3.x < n3.x && e3.x < n3.x || t3.x > i3.x && e3.x > i3.x || t3.y < n3.y && e3.y < n3.y || t3.y > i3.y && e3.y > i3.y)
            return false;
          const s3 = G(t3, e3, r3[0]);
          return s3 !== G(t3, e3, r3[1]) || s3 !== G(t3, e3, r3[2]) || s3 !== G(t3, e3, r3[3]);
        }
        function Au(t3, e3, r3) {
          const n3 = e3.paint.get(t3).value;
          return "constant" === n3.kind ? n3.value : r3.programConfigurations.get(e3.id).getMaxValue(t3);
        }
        function Su(t3) {
          return Math.sqrt(t3[0] * t3[0] + t3[1] * t3[1]);
        }
        function ku(t3, e3, r3, n3, i3) {
          if (!e3[0] && !e3[1])
            return t3;
          const s3 = x2.convert(e3)._mult(i3);
          "viewport" === r3 && s3._rotate(-n3);
          const a3 = [];
          for (let e4 = 0; e4 < t3.length; e4++)
            a3.push(t3[e4].sub(s3));
          return a3;
        }
        function Iu(t3, e3, r3, n3) {
          const i3 = x2.convert(t3)._mult(n3);
          return "viewport" === e3 && i3._rotate(-r3), i3;
        }
        Ji(cu, "CircleBucket", { omit: ["layers"] });
        const Mu = new Ps({ "circle-sort-key": new Es(te.layout_circle["circle-sort-key"]) });
        var Tu = { paint: new Ps({ "circle-radius": new Es(te.paint_circle["circle-radius"]), "circle-color": new Es(te.paint_circle["circle-color"]), "circle-blur": new Es(te.paint_circle["circle-blur"]), "circle-opacity": new Es(te.paint_circle["circle-opacity"]), "circle-translate": new Bs(te.paint_circle["circle-translate"]), "circle-translate-anchor": new Bs(te.paint_circle["circle-translate-anchor"]), "circle-pitch-scale": new Bs(te.paint_circle["circle-pitch-scale"]), "circle-pitch-alignment": new Bs(te.paint_circle["circle-pitch-alignment"]), "circle-stroke-width": new Es(te.paint_circle["circle-stroke-width"]), "circle-stroke-color": new Es(te.paint_circle["circle-stroke-color"]), "circle-stroke-opacity": new Es(te.paint_circle["circle-stroke-opacity"]) }), layout: Mu };
        function zu(t3, e3, r3, n3, i3, s3, a3, o3, l2) {
          if (s3 && t3.queryGeometry.isAboveHorizon)
            return false;
          s3 && (l2 *= t3.pixelToTileUnitsFactor);
          const u3 = t3.tileID.canonical, c3 = r3.projection.upVectorScale(u3, r3.center.lat, r3.worldSize).metersToTile;
          for (const h3 of e3)
            for (const e4 of h3) {
              const h4 = e4.add(o3), p3 = i3 && r3.elevation ? r3.elevation.exaggeration() * i3.getElevationAt(h4.x, h4.y, true) : 0, d3 = r3.projection.projectTilePoint(h4.x, h4.y, u3);
              if (p3 > 0) {
                const t4 = r3.projection.upVector(u3, h4.x, h4.y);
                d3.x += t4[0] * c3 * p3, d3.y += t4[1] * c3 * p3, d3.z += t4[2] * c3 * p3;
              }
              const f3 = s3 ? h4 : Bu(d3.x, d3.y, d3.z, n3), y3 = s3 ? t3.tilespaceRays.map((t4) => Pu(t4, p3)) : t3.queryGeometry.screenGeometry, m3 = Go([], [d3.x, d3.y, d3.z, 1], n3);
              if (!a3 && s3 ? l2 *= m3[3] / r3.cameraToCenterDistance : a3 && !s3 && (l2 *= r3.cameraToCenterDistance / m3[3]), s3) {
                const t4 = Xl((e4.y / ao + u3.y) / (1 << u3.z));
                l2 /= r3.projection.pixelsPerMeter(t4, 1) / Zl(1, t4);
              }
              if (pu(y3, f3, l2))
                return true;
            }
          return false;
        }
        function Bu(t3, e3, r3, n3) {
          const i3 = Go([], [t3, e3, r3, 1], n3);
          return new x2(i3[0] / i3[3], i3[1] / i3[3]);
        }
        const Eu = Io(0, 0, 0), Cu = Io(0, 0, 1);
        function Pu(t3, e3) {
          const r3 = Ao();
          return Eu[2] = e3, t3.intersectsPlane(Eu, Cu, r3), new x2(r3[0], r3[1]);
        }
        class Du extends cu {
        }
        function Vu(t3, { width: e3, height: r3 }, n3, i3) {
          if (i3) {
            if (i3 instanceof Uint8ClampedArray)
              i3 = new Uint8Array(i3.buffer);
            else if (i3.length !== e3 * r3 * n3)
              throw new RangeError("mismatched image size");
          } else
            i3 = new Uint8Array(e3 * r3 * n3);
          return t3.width = e3, t3.height = r3, t3.data = i3, t3;
        }
        function Lu(t3, e3, r3) {
          const { width: n3, height: i3 } = e3;
          n3 === t3.width && i3 === t3.height || (Fu(t3, e3, { x: 0, y: 0 }, { x: 0, y: 0 }, { width: Math.min(t3.width, n3), height: Math.min(t3.height, i3) }, r3), t3.width = n3, t3.height = i3, t3.data = e3.data);
        }
        function Fu(t3, e3, r3, n3, i3, s3) {
          if (0 === i3.width || 0 === i3.height)
            return e3;
          if (i3.width > t3.width || i3.height > t3.height || r3.x > t3.width - i3.width || r3.y > t3.height - i3.height)
            throw new RangeError("out of range source coordinates for image copy");
          if (i3.width > e3.width || i3.height > e3.height || n3.x > e3.width - i3.width || n3.y > e3.height - i3.height)
            throw new RangeError("out of range destination coordinates for image copy");
          const a3 = t3.data, o3 = e3.data;
          for (let l2 = 0; l2 < i3.height; l2++) {
            const u3 = ((r3.y + l2) * t3.width + r3.x) * s3, c3 = ((n3.y + l2) * e3.width + n3.x) * s3;
            for (let t4 = 0; t4 < i3.width * s3; t4++)
              o3[c3 + t4] = a3[u3 + t4];
          }
          return e3;
        }
        Ji(Du, "HeatmapBucket", { omit: ["layers"] });
        class Ru {
          constructor(t3, e3) {
            Vu(this, t3, 1, e3);
          }
          resize(t3) {
            Lu(this, new Ru(t3), 1);
          }
          clone() {
            return new Ru({ width: this.width, height: this.height }, new Uint8Array(this.data));
          }
          static copy(t3, e3, r3, n3, i3) {
            Fu(t3, e3, r3, n3, i3, 1);
          }
        }
        class Uu {
          constructor(t3, e3) {
            Vu(this, t3, 4, e3);
          }
          resize(t3) {
            Lu(this, new Uu(t3), 4);
          }
          replace(t3, e3) {
            e3 ? this.data.set(t3) : this.data = t3 instanceof Uint8ClampedArray ? new Uint8Array(t3.buffer) : t3;
          }
          clone() {
            return new Uu({ width: this.width, height: this.height }, new Uint8Array(this.data));
          }
          static copy(t3, e3, r3, n3, i3) {
            Fu(t3, e3, r3, n3, i3, 4);
          }
        }
        Ji(Ru, "AlphaImage"), Ji(Uu, "RGBAImage");
        var $u = { paint: new Ps({ "heatmap-radius": new Es(te.paint_heatmap["heatmap-radius"]), "heatmap-weight": new Es(te.paint_heatmap["heatmap-weight"]), "heatmap-intensity": new Bs(te.paint_heatmap["heatmap-intensity"]), "heatmap-color": new Cs(te.paint_heatmap["heatmap-color"]), "heatmap-opacity": new Bs(te.paint_heatmap["heatmap-opacity"]) }) };
        function ju(t3) {
          const e3 = {}, r3 = t3.resolution || 256, n3 = t3.clips ? t3.clips.length : 1, i3 = t3.image || new Uu({ width: r3, height: n3 }), s3 = (r4, n4, s4) => {
            e3[t3.evaluationKey] = s4;
            const a3 = t3.expression.evaluate(e3);
            i3.data[r4 + n4 + 0] = Math.floor(255 * a3.r / a3.a), i3.data[r4 + n4 + 1] = Math.floor(255 * a3.g / a3.a), i3.data[r4 + n4 + 2] = Math.floor(255 * a3.b / a3.a), i3.data[r4 + n4 + 3] = Math.floor(255 * a3.a);
          };
          if (t3.clips)
            for (let e4 = 0, i4 = 0; e4 < n3; ++e4, i4 += 4 * r3)
              for (let n4 = 0, a3 = 0; n4 < r3; n4++, a3 += 4) {
                const o3 = n4 / (r3 - 1), { start: l2, end: u3 } = t3.clips[e4];
                s3(i4, a3, l2 * (1 - o3) + u3 * o3);
              }
          else
            for (let t4 = 0, e4 = 0; t4 < r3; t4++, e4 += 4)
              s3(0, e4, t4 / (r3 - 1));
          return i3;
        }
        var Ou = { paint: new Ps({ "hillshade-illumination-direction": new Bs(te.paint_hillshade["hillshade-illumination-direction"]), "hillshade-illumination-anchor": new Bs(te.paint_hillshade["hillshade-illumination-anchor"]), "hillshade-exaggeration": new Bs(te.paint_hillshade["hillshade-exaggeration"]), "hillshade-shadow-color": new Bs(te.paint_hillshade["hillshade-shadow-color"]), "hillshade-highlight-color": new Bs(te.paint_hillshade["hillshade-highlight-color"]), "hillshade-accent-color": new Bs(te.paint_hillshade["hillshade-accent-color"]) }) };
        const qu = Rs([{ name: "a_pos", components: 2, type: "Int16" }], 4), { members: Nu } = qu;
        var Gu = { exports: {} };
        function Zu(t3, e3, r3) {
          r3 = r3 || 2;
          var n3, i3, s3, a3, o3, l2, u3, c3 = e3 && e3.length, h3 = c3 ? e3[0] * r3 : t3.length, p3 = Ku(t3, 0, h3, r3, true), d3 = [];
          if (!p3 || p3.next === p3.prev)
            return d3;
          if (c3 && (p3 = function(t4, e4, r4, n4) {
            var i4, s4, a4, o4 = [];
            for (i4 = 0, s4 = e4.length; i4 < s4; i4++)
              (a4 = Ku(t4, e4[i4] * n4, i4 < s4 - 1 ? e4[i4 + 1] * n4 : t4.length, n4, false)) === a4.next && (a4.steiner = true), o4.push(ic(a4));
            for (o4.sort(tc), i4 = 0; i4 < o4.length; i4++)
              r4 = ec(o4[i4], r4);
            return r4;
          }(t3, e3, p3, r3)), t3.length > 80 * r3) {
            n3 = s3 = t3[0], i3 = a3 = t3[1];
            for (var f3 = r3; f3 < h3; f3 += r3)
              (o3 = t3[f3]) < n3 && (n3 = o3), (l2 = t3[f3 + 1]) < i3 && (i3 = l2), o3 > s3 && (s3 = o3), l2 > a3 && (a3 = l2);
            u3 = 0 !== (u3 = Math.max(s3 - n3, a3 - i3)) ? 32767 / u3 : 0;
          }
          return Ju(p3, d3, r3, n3, i3, u3, 0), d3;
        }
        function Ku(t3, e3, r3, n3, i3) {
          var s3, a3;
          if (i3 === gc(t3, e3, r3, n3) > 0)
            for (s3 = e3; s3 < r3; s3 += n3)
              a3 = fc(s3, t3[s3], t3[s3 + 1], a3);
          else
            for (s3 = r3 - n3; s3 >= e3; s3 -= n3)
              a3 = fc(s3, t3[s3], t3[s3 + 1], a3);
          return a3 && lc(a3, a3.next) && (yc(a3), a3 = a3.next), a3;
        }
        function Xu(t3, e3) {
          if (!t3)
            return t3;
          e3 || (e3 = t3);
          var r3, n3 = t3;
          do {
            if (r3 = false, n3.steiner || !lc(n3, n3.next) && 0 !== oc(n3.prev, n3, n3.next))
              n3 = n3.next;
            else {
              if (yc(n3), (n3 = e3 = n3.prev) === n3.next)
                break;
              r3 = true;
            }
          } while (r3 || n3 !== e3);
          return e3;
        }
        function Ju(t3, e3, r3, n3, i3, s3, a3) {
          if (t3) {
            !a3 && s3 && function(t4, e4, r4, n4) {
              var i4 = t4;
              do {
                0 === i4.z && (i4.z = nc(i4.x, i4.y, e4, r4, n4)), i4.prevZ = i4.prev, i4.nextZ = i4.next, i4 = i4.next;
              } while (i4 !== t4);
              i4.prevZ.nextZ = null, i4.prevZ = null, function(t5) {
                var e5, r5, n5, i5, s4, a4, o4, l3, u4 = 1;
                do {
                  for (r5 = t5, t5 = null, s4 = null, a4 = 0; r5; ) {
                    for (a4++, n5 = r5, o4 = 0, e5 = 0; e5 < u4 && (o4++, n5 = n5.nextZ); e5++)
                      ;
                    for (l3 = u4; o4 > 0 || l3 > 0 && n5; )
                      0 !== o4 && (0 === l3 || !n5 || r5.z <= n5.z) ? (i5 = r5, r5 = r5.nextZ, o4--) : (i5 = n5, n5 = n5.nextZ, l3--), s4 ? s4.nextZ = i5 : t5 = i5, i5.prevZ = s4, s4 = i5;
                    r5 = n5;
                  }
                  s4.nextZ = null, u4 *= 2;
                } while (a4 > 1);
              }(i4);
            }(t3, n3, i3, s3);
            for (var o3, l2, u3 = t3; t3.prev !== t3.next; )
              if (o3 = t3.prev, l2 = t3.next, s3 ? Yu(t3, n3, i3, s3) : Hu(t3))
                e3.push(o3.i / r3 | 0), e3.push(t3.i / r3 | 0), e3.push(l2.i / r3 | 0), yc(t3), t3 = l2.next, u3 = l2.next;
              else if ((t3 = l2) === u3) {
                a3 ? 1 === a3 ? Ju(t3 = Wu(Xu(t3), e3, r3), e3, r3, n3, i3, s3, 2) : 2 === a3 && Qu(t3, e3, r3, n3, i3, s3) : Ju(Xu(t3), e3, r3, n3, i3, s3, 1);
                break;
              }
          }
        }
        function Hu(t3) {
          var e3 = t3.prev, r3 = t3, n3 = t3.next;
          if (oc(e3, r3, n3) >= 0)
            return false;
          for (var i3 = e3.x, s3 = r3.x, a3 = n3.x, o3 = e3.y, l2 = r3.y, u3 = n3.y, c3 = i3 < s3 ? i3 < a3 ? i3 : a3 : s3 < a3 ? s3 : a3, h3 = o3 < l2 ? o3 < u3 ? o3 : u3 : l2 < u3 ? l2 : u3, p3 = i3 > s3 ? i3 > a3 ? i3 : a3 : s3 > a3 ? s3 : a3, d3 = o3 > l2 ? o3 > u3 ? o3 : u3 : l2 > u3 ? l2 : u3, f3 = n3.next; f3 !== e3; ) {
            if (f3.x >= c3 && f3.x <= p3 && f3.y >= h3 && f3.y <= d3 && sc(i3, o3, s3, l2, a3, u3, f3.x, f3.y) && oc(f3.prev, f3, f3.next) >= 0)
              return false;
            f3 = f3.next;
          }
          return true;
        }
        function Yu(t3, e3, r3, n3) {
          var i3 = t3.prev, s3 = t3, a3 = t3.next;
          if (oc(i3, s3, a3) >= 0)
            return false;
          for (var o3 = i3.x, l2 = s3.x, u3 = a3.x, c3 = i3.y, h3 = s3.y, p3 = a3.y, d3 = o3 < l2 ? o3 < u3 ? o3 : u3 : l2 < u3 ? l2 : u3, f3 = c3 < h3 ? c3 < p3 ? c3 : p3 : h3 < p3 ? h3 : p3, y3 = o3 > l2 ? o3 > u3 ? o3 : u3 : l2 > u3 ? l2 : u3, m3 = c3 > h3 ? c3 > p3 ? c3 : p3 : h3 > p3 ? h3 : p3, g3 = nc(d3, f3, e3, r3, n3), x3 = nc(y3, m3, e3, r3, n3), v3 = t3.prevZ, b2 = t3.nextZ; v3 && v3.z >= g3 && b2 && b2.z <= x3; ) {
            if (v3.x >= d3 && v3.x <= y3 && v3.y >= f3 && v3.y <= m3 && v3 !== i3 && v3 !== a3 && sc(o3, c3, l2, h3, u3, p3, v3.x, v3.y) && oc(v3.prev, v3, v3.next) >= 0)
              return false;
            if (v3 = v3.prevZ, b2.x >= d3 && b2.x <= y3 && b2.y >= f3 && b2.y <= m3 && b2 !== i3 && b2 !== a3 && sc(o3, c3, l2, h3, u3, p3, b2.x, b2.y) && oc(b2.prev, b2, b2.next) >= 0)
              return false;
            b2 = b2.nextZ;
          }
          for (; v3 && v3.z >= g3; ) {
            if (v3.x >= d3 && v3.x <= y3 && v3.y >= f3 && v3.y <= m3 && v3 !== i3 && v3 !== a3 && sc(o3, c3, l2, h3, u3, p3, v3.x, v3.y) && oc(v3.prev, v3, v3.next) >= 0)
              return false;
            v3 = v3.prevZ;
          }
          for (; b2 && b2.z <= x3; ) {
            if (b2.x >= d3 && b2.x <= y3 && b2.y >= f3 && b2.y <= m3 && b2 !== i3 && b2 !== a3 && sc(o3, c3, l2, h3, u3, p3, b2.x, b2.y) && oc(b2.prev, b2, b2.next) >= 0)
              return false;
            b2 = b2.nextZ;
          }
          return true;
        }
        function Wu(t3, e3, r3) {
          var n3 = t3;
          do {
            var i3 = n3.prev, s3 = n3.next.next;
            !lc(i3, s3) && uc(i3, n3, n3.next, s3) && pc(i3, s3) && pc(s3, i3) && (e3.push(i3.i / r3 | 0), e3.push(n3.i / r3 | 0), e3.push(s3.i / r3 | 0), yc(n3), yc(n3.next), n3 = t3 = s3), n3 = n3.next;
          } while (n3 !== t3);
          return Xu(n3);
        }
        function Qu(t3, e3, r3, n3, i3, s3) {
          var a3 = t3;
          do {
            for (var o3 = a3.next.next; o3 !== a3.prev; ) {
              if (a3.i !== o3.i && ac(a3, o3)) {
                var l2 = dc(a3, o3);
                return a3 = Xu(a3, a3.next), l2 = Xu(l2, l2.next), Ju(a3, e3, r3, n3, i3, s3, 0), void Ju(l2, e3, r3, n3, i3, s3, 0);
              }
              o3 = o3.next;
            }
            a3 = a3.next;
          } while (a3 !== t3);
        }
        function tc(t3, e3) {
          return t3.x - e3.x;
        }
        function ec(t3, e3) {
          var r3 = function(t4, e4) {
            var r4, n4 = e4, i3 = t4.x, s3 = t4.y, a3 = -1 / 0;
            do {
              if (s3 <= n4.y && s3 >= n4.next.y && n4.next.y !== n4.y) {
                var o3 = n4.x + (s3 - n4.y) * (n4.next.x - n4.x) / (n4.next.y - n4.y);
                if (o3 <= i3 && o3 > a3 && (a3 = o3, r4 = n4.x < n4.next.x ? n4 : n4.next, o3 === i3))
                  return r4;
              }
              n4 = n4.next;
            } while (n4 !== e4);
            if (!r4)
              return null;
            var l2, u3 = r4, c3 = r4.x, h3 = r4.y, p3 = 1 / 0;
            n4 = r4;
            do {
              i3 >= n4.x && n4.x >= c3 && i3 !== n4.x && sc(s3 < h3 ? i3 : a3, s3, c3, h3, s3 < h3 ? a3 : i3, s3, n4.x, n4.y) && (l2 = Math.abs(s3 - n4.y) / (i3 - n4.x), pc(n4, t4) && (l2 < p3 || l2 === p3 && (n4.x > r4.x || n4.x === r4.x && rc(r4, n4))) && (r4 = n4, p3 = l2)), n4 = n4.next;
            } while (n4 !== u3);
            return r4;
          }(t3, e3);
          if (!r3)
            return e3;
          var n3 = dc(r3, t3);
          return Xu(n3, n3.next), Xu(r3, r3.next);
        }
        function rc(t3, e3) {
          return oc(t3.prev, t3, e3.prev) < 0 && oc(e3.next, t3, t3.next) < 0;
        }
        function nc(t3, e3, r3, n3, i3) {
          return (t3 = 1431655765 & ((t3 = 858993459 & ((t3 = 252645135 & ((t3 = 16711935 & ((t3 = (t3 - r3) * i3 | 0) | t3 << 8)) | t3 << 4)) | t3 << 2)) | t3 << 1)) | (e3 = 1431655765 & ((e3 = 858993459 & ((e3 = 252645135 & ((e3 = 16711935 & ((e3 = (e3 - n3) * i3 | 0) | e3 << 8)) | e3 << 4)) | e3 << 2)) | e3 << 1)) << 1;
        }
        function ic(t3) {
          var e3 = t3, r3 = t3;
          do {
            (e3.x < r3.x || e3.x === r3.x && e3.y < r3.y) && (r3 = e3), e3 = e3.next;
          } while (e3 !== t3);
          return r3;
        }
        function sc(t3, e3, r3, n3, i3, s3, a3, o3) {
          return (i3 - a3) * (e3 - o3) >= (t3 - a3) * (s3 - o3) && (t3 - a3) * (n3 - o3) >= (r3 - a3) * (e3 - o3) && (r3 - a3) * (s3 - o3) >= (i3 - a3) * (n3 - o3);
        }
        function ac(t3, e3) {
          return t3.next.i !== e3.i && t3.prev.i !== e3.i && !function(t4, e4) {
            var r3 = t4;
            do {
              if (r3.i !== t4.i && r3.next.i !== t4.i && r3.i !== e4.i && r3.next.i !== e4.i && uc(r3, r3.next, t4, e4))
                return true;
              r3 = r3.next;
            } while (r3 !== t4);
            return false;
          }(t3, e3) && (pc(t3, e3) && pc(e3, t3) && function(t4, e4) {
            var r3 = t4, n3 = false, i3 = (t4.x + e4.x) / 2, s3 = (t4.y + e4.y) / 2;
            do {
              r3.y > s3 != r3.next.y > s3 && r3.next.y !== r3.y && i3 < (r3.next.x - r3.x) * (s3 - r3.y) / (r3.next.y - r3.y) + r3.x && (n3 = !n3), r3 = r3.next;
            } while (r3 !== t4);
            return n3;
          }(t3, e3) && (oc(t3.prev, t3, e3.prev) || oc(t3, e3.prev, e3)) || lc(t3, e3) && oc(t3.prev, t3, t3.next) > 0 && oc(e3.prev, e3, e3.next) > 0);
        }
        function oc(t3, e3, r3) {
          return (e3.y - t3.y) * (r3.x - e3.x) - (e3.x - t3.x) * (r3.y - e3.y);
        }
        function lc(t3, e3) {
          return t3.x === e3.x && t3.y === e3.y;
        }
        function uc(t3, e3, r3, n3) {
          var i3 = hc(oc(t3, e3, r3)), s3 = hc(oc(t3, e3, n3)), a3 = hc(oc(r3, n3, t3)), o3 = hc(oc(r3, n3, e3));
          return i3 !== s3 && a3 !== o3 || !(0 !== i3 || !cc(t3, r3, e3)) || !(0 !== s3 || !cc(t3, n3, e3)) || !(0 !== a3 || !cc(r3, t3, n3)) || !(0 !== o3 || !cc(r3, e3, n3));
        }
        function cc(t3, e3, r3) {
          return e3.x <= Math.max(t3.x, r3.x) && e3.x >= Math.min(t3.x, r3.x) && e3.y <= Math.max(t3.y, r3.y) && e3.y >= Math.min(t3.y, r3.y);
        }
        function hc(t3) {
          return t3 > 0 ? 1 : t3 < 0 ? -1 : 0;
        }
        function pc(t3, e3) {
          return oc(t3.prev, t3, t3.next) < 0 ? oc(t3, e3, t3.next) >= 0 && oc(t3, t3.prev, e3) >= 0 : oc(t3, e3, t3.prev) < 0 || oc(t3, t3.next, e3) < 0;
        }
        function dc(t3, e3) {
          var r3 = new mc(t3.i, t3.x, t3.y), n3 = new mc(e3.i, e3.x, e3.y), i3 = t3.next, s3 = e3.prev;
          return t3.next = e3, e3.prev = t3, r3.next = i3, i3.prev = r3, n3.next = r3, r3.prev = n3, s3.next = n3, n3.prev = s3, n3;
        }
        function fc(t3, e3, r3, n3) {
          var i3 = new mc(t3, e3, r3);
          return n3 ? (i3.next = n3.next, i3.prev = n3, n3.next.prev = i3, n3.next = i3) : (i3.prev = i3, i3.next = i3), i3;
        }
        function yc(t3) {
          t3.next.prev = t3.prev, t3.prev.next = t3.next, t3.prevZ && (t3.prevZ.nextZ = t3.nextZ), t3.nextZ && (t3.nextZ.prevZ = t3.prevZ);
        }
        function mc(t3, e3, r3) {
          this.i = t3, this.x = e3, this.y = r3, this.prev = null, this.next = null, this.z = 0, this.prevZ = null, this.nextZ = null, this.steiner = false;
        }
        function gc(t3, e3, r3, n3) {
          for (var i3 = 0, s3 = e3, a3 = r3 - n3; s3 < r3; s3 += n3)
            i3 += (t3[a3] - t3[s3]) * (t3[s3 + 1] + t3[a3 + 1]), a3 = s3;
          return i3;
        }
        Gu.exports = Zu, Gu.exports.default = Zu, Zu.deviation = function(t3, e3, r3, n3) {
          var i3 = e3 && e3.length, s3 = Math.abs(gc(t3, 0, i3 ? e3[0] * r3 : t3.length, r3));
          if (i3)
            for (var a3 = 0, o3 = e3.length; a3 < o3; a3++)
              s3 -= Math.abs(gc(t3, e3[a3] * r3, a3 < o3 - 1 ? e3[a3 + 1] * r3 : t3.length, r3));
          var l2 = 0;
          for (a3 = 0; a3 < n3.length; a3 += 3) {
            var u3 = n3[a3] * r3, c3 = n3[a3 + 1] * r3, h3 = n3[a3 + 2] * r3;
            l2 += Math.abs((t3[u3] - t3[h3]) * (t3[c3 + 1] - t3[u3 + 1]) - (t3[u3] - t3[c3]) * (t3[h3 + 1] - t3[u3 + 1]));
          }
          return 0 === s3 && 0 === l2 ? 0 : Math.abs((l2 - s3) / s3);
        }, Zu.flatten = function(t3) {
          for (var e3 = t3[0][0].length, r3 = { vertices: [], holes: [], dimensions: e3 }, n3 = 0, i3 = 0; i3 < t3.length; i3++) {
            for (var s3 = 0; s3 < t3[i3].length; s3++)
              for (var a3 = 0; a3 < e3; a3++)
                r3.vertices.push(t3[i3][s3][a3]);
            i3 > 0 && r3.holes.push(n3 += t3[i3 - 1].length);
          }
          return r3;
        };
        var xc = p2(Gu.exports);
        function vc(t3, e3, r3, n3, i3) {
          bc(t3, e3, r3 || 0, n3 || t3.length - 1, i3 || _c);
        }
        function bc(t3, e3, r3, n3, i3) {
          for (; n3 > r3; ) {
            if (n3 - r3 > 600) {
              var s3 = n3 - r3 + 1, a3 = e3 - r3 + 1, o3 = Math.log(s3), l2 = 0.5 * Math.exp(2 * o3 / 3), u3 = 0.5 * Math.sqrt(o3 * l2 * (s3 - l2) / s3) * (a3 - s3 / 2 < 0 ? -1 : 1);
              bc(t3, e3, Math.max(r3, Math.floor(e3 - a3 * l2 / s3 + u3)), Math.min(n3, Math.floor(e3 + (s3 - a3) * l2 / s3 + u3)), i3);
            }
            var c3 = t3[e3], h3 = r3, p3 = n3;
            for (wc(t3, r3, e3), i3(t3[n3], c3) > 0 && wc(t3, r3, n3); h3 < p3; ) {
              for (wc(t3, h3, p3), h3++, p3--; i3(t3[h3], c3) < 0; )
                h3++;
              for (; i3(t3[p3], c3) > 0; )
                p3--;
            }
            0 === i3(t3[r3], c3) ? wc(t3, r3, p3) : wc(t3, ++p3, n3), p3 <= e3 && (r3 = p3 + 1), e3 <= p3 && (n3 = p3 - 1);
          }
        }
        function wc(t3, e3, r3) {
          var n3 = t3[e3];
          t3[e3] = t3[r3], t3[r3] = n3;
        }
        function _c(t3, e3) {
          return t3 < e3 ? -1 : t3 > e3 ? 1 : 0;
        }
        function Ac(t3, e3) {
          const r3 = t3.length;
          if (r3 <= 1)
            return [t3];
          const n3 = [];
          let i3, s3;
          for (let e4 = 0; e4 < r3; e4++) {
            const r4 = Z(t3[e4]);
            0 !== r4 && (t3[e4].area = Math.abs(r4), void 0 === s3 && (s3 = r4 < 0), s3 === r4 < 0 ? (i3 && n3.push(i3), i3 = [t3[e4]]) : i3.push(t3[e4]));
          }
          if (i3 && n3.push(i3), e3 > 1)
            for (let t4 = 0; t4 < n3.length; t4++)
              n3[t4].length <= e3 || (vc(n3[t4], e3, 1, n3[t4].length - 1, Sc), n3[t4] = n3[t4].slice(0, e3));
          return n3;
        }
        function Sc(t3, e3) {
          return e3.area - t3.area;
        }
        function kc(t3, e3, r3) {
          const n3 = r3.patternDependencies;
          let i3 = false;
          for (const r4 of e3) {
            const e4 = r4.paint.get(`${t3}-pattern`);
            e4.isConstant() || (i3 = true);
            const s3 = e4.constantOr(null);
            s3 && (i3 = true, n3[s3] = true);
          }
          return i3;
        }
        function Ic(t3, e3, r3, n3, i3) {
          const s3 = i3.patternDependencies;
          for (const a3 of e3) {
            const e4 = a3.paint.get(`${t3}-pattern`).value;
            if ("constant" !== e4.kind) {
              let t4 = e4.evaluate({ zoom: n3 }, r3, {}, i3.availableImages);
              t4 = t4 && t4.name ? t4.name : t4, s3[t4] = true, r3.patterns[a3.id] = t4;
            }
          }
          return r3;
        }
        class Mc {
          constructor(t3) {
            this.zoom = t3.zoom, this.overscaling = t3.overscaling, this.layers = t3.layers, this.layerIds = this.layers.map((t4) => t4.id), this.index = t3.index, this.hasPattern = false, this.patternFeatures = [], this.layoutVertexArray = new $s(), this.indexArray = new ra(), this.indexArray2 = new la(), this.programConfigurations = new Ja(t3.layers, t3.zoom), this.segments = new so(), this.segments2 = new so(), this.stateDependentLayerIds = this.layers.filter((t4) => t4.isStateDependent()).map((t4) => t4.id), this.projection = t3.projection;
          }
          populate(t3, e3, r3, n3) {
            this.hasPattern = kc("fill", this.layers, e3);
            const i3 = this.layers[0].layout.get("fill-sort-key"), s3 = [];
            for (const { feature: a3, id: o3, index: l2, sourceLayerIndex: u3 } of t3) {
              const t4 = this.layers[0]._featureFilter.needGeometry, c3 = ou(a3, t4);
              if (!this.layers[0]._featureFilter.filter(new ws(this.zoom), c3, r3))
                continue;
              const h3 = i3 ? i3.evaluate(c3, {}, r3, e3.availableImages) : void 0, p3 = { id: o3, properties: a3.properties, type: a3.type, sourceLayerIndex: u3, index: l2, geometry: t4 ? c3.geometry : au(a3, r3, n3), patterns: {}, sortKey: h3 };
              s3.push(p3);
            }
            i3 && s3.sort((t4, e4) => t4.sortKey - e4.sortKey);
            for (const n4 of s3) {
              const { geometry: i4, index: s4, sourceLayerIndex: a3 } = n4;
              if (this.hasPattern) {
                const t4 = Ic("fill", this.layers, n4, this.zoom, e3);
                this.patternFeatures.push(t4);
              } else
                this.addFeature(n4, i4, s4, r3, {}, e3.availableImages);
              e3.featureIndex.insert(t3[s4].feature, i4, s4, a3, this.index);
            }
          }
          update(t3, e3, r3, n3) {
            this.stateDependentLayers.length && this.programConfigurations.updatePaintArrays(t3, e3, this.stateDependentLayers, r3, n3);
          }
          addFeatures(t3, e3, r3, n3, i3) {
            for (const t4 of this.patternFeatures)
              this.addFeature(t4, t4.geometry, t4.index, e3, r3, n3);
          }
          isEmpty() {
            return 0 === this.layoutVertexArray.length;
          }
          uploadPending() {
            return !this.uploaded || this.programConfigurations.needsUpload;
          }
          upload(t3) {
            this.uploaded || (this.layoutVertexBuffer = t3.createVertexBuffer(this.layoutVertexArray, Nu), this.indexBuffer = t3.createIndexBuffer(this.indexArray), this.indexBuffer2 = t3.createIndexBuffer(this.indexArray2)), this.programConfigurations.upload(t3), this.uploaded = true;
          }
          destroy() {
            this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.indexBuffer2.destroy(), this.programConfigurations.destroy(), this.segments.destroy(), this.segments2.destroy());
          }
          addFeature(t3, e3, r3, n3, i3, s3 = []) {
            for (const t4 of Ac(e3, 500)) {
              let e4 = 0;
              for (const r5 of t4)
                e4 += r5.length;
              const r4 = this.segments.prepareSegment(e4, this.layoutVertexArray, this.indexArray), n4 = r4.vertexLength, i4 = [], s4 = [];
              for (const e5 of t4) {
                if (0 === e5.length)
                  continue;
                e5 !== t4[0] && s4.push(i4.length / 2);
                const r5 = this.segments2.prepareSegment(e5.length, this.layoutVertexArray, this.indexArray2), n5 = r5.vertexLength;
                this.layoutVertexArray.emplaceBack(e5[0].x, e5[0].y), this.indexArray2.emplaceBack(n5 + e5.length - 1, n5), i4.push(e5[0].x), i4.push(e5[0].y);
                for (let t5 = 1; t5 < e5.length; t5++)
                  this.layoutVertexArray.emplaceBack(e5[t5].x, e5[t5].y), this.indexArray2.emplaceBack(n5 + t5 - 1, n5 + t5), i4.push(e5[t5].x), i4.push(e5[t5].y);
                r5.vertexLength += e5.length, r5.primitiveLength += e5.length;
              }
              const a3 = xc(i4, s4);
              for (let t5 = 0; t5 < a3.length; t5 += 3)
                this.indexArray.emplaceBack(n4 + a3[t5], n4 + a3[t5 + 1], n4 + a3[t5 + 2]);
              r4.vertexLength += e4, r4.primitiveLength += a3.length / 3;
            }
            this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, t3, r3, i3, s3, n3);
          }
        }
        Ji(Mc, "FillBucket", { omit: ["layers", "patternFeatures"] });
        const Tc = new Ps({ "fill-sort-key": new Es(te.layout_fill["fill-sort-key"]) });
        var zc = { paint: new Ps({ "fill-antialias": new Bs(te.paint_fill["fill-antialias"]), "fill-opacity": new Es(te.paint_fill["fill-opacity"]), "fill-color": new Es(te.paint_fill["fill-color"]), "fill-outline-color": new Es(te.paint_fill["fill-outline-color"]), "fill-translate": new Bs(te.paint_fill["fill-translate"]), "fill-translate-anchor": new Bs(te.paint_fill["fill-translate-anchor"]), "fill-pattern": new Es(te.paint_fill["fill-pattern"]) }), layout: Tc };
        const Bc = Rs([{ name: "a_pos_normal_ed", components: 4, type: "Int16" }]), Ec = Rs([{ name: "a_centroid_pos", components: 2, type: "Uint16" }]), Cc = Rs([{ name: "a_pos_3", components: 3, type: "Int16" }, { name: "a_pos_normal_3", components: 3, type: "Int16" }]), { members: Pc } = Bc;
        var Dc = {}, Vc = m2, Lc = Fc;
        function Fc(t3, e3, r3, n3, i3) {
          this.properties = {}, this.extent = r3, this.type = 0, this._pbf = t3, this._geometry = -1, this._keys = n3, this._values = i3, t3.readFields(Rc, this, e3);
        }
        function Rc(t3, e3, r3) {
          1 == t3 ? e3.id = r3.readVarint() : 2 == t3 ? function(t4, e4) {
            for (var r4 = t4.readVarint() + t4.pos; t4.pos < r4; ) {
              var n3 = e4._keys[t4.readVarint()], i3 = e4._values[t4.readVarint()];
              e4.properties[n3] = i3;
            }
          }(r3, e3) : 3 == t3 ? e3.type = r3.readVarint() : 4 == t3 && (e3._geometry = r3.pos);
        }
        function Uc(t3) {
          for (var e3, r3, n3 = 0, i3 = 0, s3 = t3.length, a3 = s3 - 1; i3 < s3; a3 = i3++)
            n3 += ((r3 = t3[a3]).x - (e3 = t3[i3]).x) * (e3.y + r3.y);
          return n3;
        }
        Fc.types = ["Unknown", "Point", "LineString", "Polygon"], Fc.prototype.loadGeometry = function() {
          var t3 = this._pbf;
          t3.pos = this._geometry;
          for (var e3, r3 = t3.readVarint() + t3.pos, n3 = 1, i3 = 0, s3 = 0, a3 = 0, o3 = []; t3.pos < r3; ) {
            if (i3 <= 0) {
              var l2 = t3.readVarint();
              n3 = 7 & l2, i3 = l2 >> 3;
            }
            if (i3--, 1 === n3 || 2 === n3)
              s3 += t3.readSVarint(), a3 += t3.readSVarint(), 1 === n3 && (e3 && o3.push(e3), e3 = []), e3.push(new Vc(s3, a3));
            else {
              if (7 !== n3)
                throw new Error("unknown command " + n3);
              e3 && e3.push(e3[0].clone());
            }
          }
          return e3 && o3.push(e3), o3;
        }, Fc.prototype.bbox = function() {
          var t3 = this._pbf;
          t3.pos = this._geometry;
          for (var e3 = t3.readVarint() + t3.pos, r3 = 1, n3 = 0, i3 = 0, s3 = 0, a3 = 1 / 0, o3 = -1 / 0, l2 = 1 / 0, u3 = -1 / 0; t3.pos < e3; ) {
            if (n3 <= 0) {
              var c3 = t3.readVarint();
              r3 = 7 & c3, n3 = c3 >> 3;
            }
            if (n3--, 1 === r3 || 2 === r3)
              (i3 += t3.readSVarint()) < a3 && (a3 = i3), i3 > o3 && (o3 = i3), (s3 += t3.readSVarint()) < l2 && (l2 = s3), s3 > u3 && (u3 = s3);
            else if (7 !== r3)
              throw new Error("unknown command " + r3);
          }
          return [a3, l2, o3, u3];
        }, Fc.prototype.toGeoJSON = function(t3, e3, r3) {
          var n3, i3, s3 = this.extent * Math.pow(2, r3), a3 = this.extent * t3, o3 = this.extent * e3, l2 = this.loadGeometry(), u3 = Fc.types[this.type];
          function c3(t4) {
            for (var e4 = 0; e4 < t4.length; e4++) {
              var r4 = t4[e4];
              t4[e4] = [360 * (r4.x + a3) / s3 - 180, 360 / Math.PI * Math.atan(Math.exp((180 - 360 * (r4.y + o3) / s3) * Math.PI / 180)) - 90];
            }
          }
          switch (this.type) {
            case 1:
              var h3 = [];
              for (n3 = 0; n3 < l2.length; n3++)
                h3[n3] = l2[n3][0];
              c3(l2 = h3);
              break;
            case 2:
              for (n3 = 0; n3 < l2.length; n3++)
                c3(l2[n3]);
              break;
            case 3:
              for (l2 = function(t4) {
                var e4 = t4.length;
                if (e4 <= 1)
                  return [t4];
                for (var r4, n4, i4 = [], s4 = 0; s4 < e4; s4++) {
                  var a4 = Uc(t4[s4]);
                  0 !== a4 && (void 0 === n4 && (n4 = a4 < 0), n4 === a4 < 0 ? (r4 && i4.push(r4), r4 = [t4[s4]]) : r4.push(t4[s4]));
                }
                return r4 && i4.push(r4), i4;
              }(l2), n3 = 0; n3 < l2.length; n3++)
                for (i3 = 0; i3 < l2[n3].length; i3++)
                  c3(l2[n3][i3]);
          }
          1 === l2.length ? l2 = l2[0] : u3 = "Multi" + u3;
          var p3 = { type: "Feature", geometry: { type: u3, coordinates: l2 }, properties: this.properties };
          return "id" in this && (p3.id = this.id), p3;
        };
        var $c = Lc, jc = Oc;
        function Oc(t3, e3) {
          this.version = 1, this.name = null, this.extent = 4096, this.length = 0, this._pbf = t3, this._keys = [], this._values = [], this._features = [], t3.readFields(qc, this, e3), this.length = this._features.length;
        }
        function qc(t3, e3, r3) {
          15 === t3 ? e3.version = r3.readVarint() : 1 === t3 ? e3.name = r3.readString() : 5 === t3 ? e3.extent = r3.readVarint() : 2 === t3 ? e3._features.push(r3.pos) : 3 === t3 ? e3._keys.push(r3.readString()) : 4 === t3 && e3._values.push(function(t4) {
            for (var e4 = null, r4 = t4.readVarint() + t4.pos; t4.pos < r4; ) {
              var n3 = t4.readVarint() >> 3;
              e4 = 1 === n3 ? t4.readString() : 2 === n3 ? t4.readFloat() : 3 === n3 ? t4.readDouble() : 4 === n3 ? t4.readVarint64() : 5 === n3 ? t4.readVarint() : 6 === n3 ? t4.readSVarint() : 7 === n3 ? t4.readBoolean() : null;
            }
            return e4;
          }(r3));
        }
        Oc.prototype.feature = function(t3) {
          if (t3 < 0 || t3 >= this._features.length)
            throw new Error("feature index out of bounds");
          this._pbf.pos = this._features[t3];
          var e3 = this._pbf.readVarint() + this._pbf.pos;
          return new $c(this._pbf, e3, this.extent, this._keys, this._values);
        };
        var Nc = jc;
        function Gc(t3, e3, r3) {
          if (3 === t3) {
            var n3 = new Nc(r3, r3.readVarint() + r3.pos);
            n3.length && (e3[n3.name] = n3);
          }
        }
        var Zc = Dc.VectorTile = function(t3, e3) {
          this.layers = t3.readFields(Gc, {}, e3);
        }, Kc = Dc.VectorTileFeature = Lc;
        function Xc(t3, e3, r3, n3) {
          const i3 = [], s3 = 0 === n3 ? (t4, e4, r4, n4, i4, s4) => {
            t4.push(new x2(s4, r4 + (s4 - e4) / (n4 - e4) * (i4 - r4)));
          } : (t4, e4, r4, n4, i4, s4) => {
            t4.push(new x2(e4 + (s4 - r4) / (i4 - r4) * (n4 - e4), s4));
          };
          for (const a3 of t3) {
            const t4 = [];
            for (const i4 of a3) {
              if (i4.length <= 2)
                continue;
              const a4 = [];
              for (let t5 = 0; t5 < i4.length - 1; t5++) {
                const o4 = i4[t5].x, l3 = i4[t5].y, u3 = i4[t5 + 1].x, c3 = i4[t5 + 1].y, h3 = 0 === n3 ? o4 : l3, p3 = 0 === n3 ? u3 : c3;
                h3 < e3 ? p3 > e3 && s3(a4, o4, l3, u3, c3, e3) : h3 > r3 ? p3 < r3 && s3(a4, o4, l3, u3, c3, r3) : a4.push(i4[t5]), p3 < e3 && h3 >= e3 && s3(a4, o4, l3, u3, c3, e3), p3 > r3 && h3 <= r3 && s3(a4, o4, l3, u3, c3, r3);
              }
              let o3 = i4[i4.length - 1];
              const l2 = 0 === n3 ? o3.x : o3.y;
              l2 >= e3 && l2 <= r3 && a4.push(o3), a4.length && (o3 = a4[a4.length - 1], a4[0].x === o3.x && a4[0].y === o3.y || a4.push(a4[0]), t4.push(a4));
            }
            t4.length && i3.push(t4);
          }
          return i3;
        }
        Dc.VectorTileLayer = jc;
        const Jc = Kc.types, Hc = Math.pow(2, 13);
        function Yc(t3, e3, r3, n3, i3, s3, a3, o3) {
          t3.emplaceBack((e3 << 1) + a3, (r3 << 1) + s3, (Math.floor(n3 * Hc) << 1) + i3, Math.round(o3));
        }
        function Wc(t3, e3, r3) {
          const n3 = 16384;
          t3.emplaceBack(e3.x, e3.y, e3.z, r3[0] * n3, r3[1] * n3, r3[2] * n3);
        }
        class Qc {
          constructor() {
            this.acc = new x2(0, 0), this.polyCount = [];
          }
          startRing(t3) {
            this.currentPolyCount = { edges: 0, top: 0 }, this.polyCount.push(this.currentPolyCount), this.min || (this.min = new x2(t3.x, t3.y), this.max = new x2(t3.x, t3.y));
          }
          append(t3, e3) {
            this.currentPolyCount.edges++, this.acc._add(t3);
            const r3 = this.min, n3 = this.max;
            t3.x < r3.x ? r3.x = t3.x : t3.x > n3.x && (n3.x = t3.x), t3.y < r3.y ? r3.y = t3.y : t3.y > n3.y && (n3.y = t3.y), ((0 === t3.x || t3.x === ao) && t3.x === e3.x) != ((0 === t3.y || t3.y === ao) && t3.y === e3.y) && this.processBorderOverlap(t3, e3), e3.x < 0 != t3.x < 0 && this.addBorderIntersection(0, Er(e3.y, t3.y, (0 - e3.x) / (t3.x - e3.x))), e3.x > ao != t3.x > ao && this.addBorderIntersection(1, Er(e3.y, t3.y, (ao - e3.x) / (t3.x - e3.x))), e3.y < 0 != t3.y < 0 && this.addBorderIntersection(2, Er(e3.x, t3.x, (0 - e3.y) / (t3.y - e3.y))), e3.y > ao != t3.y > ao && this.addBorderIntersection(3, Er(e3.x, t3.x, (ao - e3.y) / (t3.y - e3.y)));
          }
          addBorderIntersection(t3, e3) {
            this.borders || (this.borders = [[Number.MAX_VALUE, -Number.MAX_VALUE], [Number.MAX_VALUE, -Number.MAX_VALUE], [Number.MAX_VALUE, -Number.MAX_VALUE], [Number.MAX_VALUE, -Number.MAX_VALUE]]);
            const r3 = this.borders[t3];
            e3 < r3[0] && (r3[0] = e3), e3 > r3[1] && (r3[1] = e3);
          }
          processBorderOverlap(t3, e3) {
            if (t3.x === e3.x) {
              if (t3.y === e3.y)
                return;
              const r3 = 0 === t3.x ? 0 : 1;
              this.addBorderIntersection(r3, e3.y), this.addBorderIntersection(r3, t3.y);
            } else {
              const r3 = 0 === t3.y ? 2 : 3;
              this.addBorderIntersection(r3, e3.x), this.addBorderIntersection(r3, t3.x);
            }
          }
          centroid() {
            const t3 = this.polyCount.reduce((t4, e3) => t4 + e3.edges, 0);
            return 0 !== t3 ? this.acc.div(t3)._round() : new x2(0, 0);
          }
          span() {
            return new x2(this.max.x - this.min.x, this.max.y - this.min.y);
          }
          intersectsCount() {
            return this.borders.reduce((t3, e3) => t3 + +(e3[0] !== Number.MAX_VALUE), 0);
          }
        }
        class th {
          constructor(t3) {
            this.zoom = t3.zoom, this.canonical = t3.canonical, this.overscaling = t3.overscaling, this.layers = t3.layers, this.layerIds = this.layers.map((t4) => t4.id), this.index = t3.index, this.hasPattern = false, this.edgeRadius = 0, this.projection = t3.projection, this.layoutVertexArray = new Os(), this.centroidVertexArray = new wa(), this.indexArray = new ra(), this.programConfigurations = new Ja(t3.layers, t3.zoom), this.segments = new so(), this.stateDependentLayerIds = this.layers.filter((t4) => t4.isStateDependent()).map((t4) => t4.id), this.enableTerrain = t3.enableTerrain;
          }
          populate(t3, e3, r3, n3) {
            this.features = [], this.hasPattern = kc("fill-extrusion", this.layers, e3), this.featuresOnBorder = [], this.borders = [[], [], [], []], this.borderDoneWithNeighborZ = [-1, -1, -1, -1], this.tileToMeter = function(t4) {
              const e4 = Math.exp(Math.PI * (1 - t4.y / (1 << t4.z) * 2));
              return 80150034 * e4 / (e4 * e4 + 1) / ao / (1 << t4.z);
            }(r3), this.edgeRadius = this.layers[0].layout.get("fill-extrusion-edge-radius") / this.tileToMeter;
            for (const { feature: i3, id: s3, index: a3, sourceLayerIndex: o3 } of t3) {
              const t4 = this.layers[0]._featureFilter.needGeometry, l2 = ou(i3, t4);
              if (!this.layers[0]._featureFilter.filter(new ws(this.zoom), l2, r3))
                continue;
              const u3 = { id: s3, sourceLayerIndex: o3, index: a3, geometry: t4 ? l2.geometry : au(i3, r3, n3), properties: i3.properties, type: i3.type, patterns: {} }, c3 = this.layoutVertexArray.length;
              this.hasPattern ? this.features.push(Ic("fill-extrusion", this.layers, u3, this.zoom, e3)) : this.addFeature(u3, u3.geometry, a3, r3, {}, e3.availableImages, n3), e3.featureIndex.insert(i3, u3.geometry, a3, o3, this.index, c3);
            }
            this.sortBorders();
          }
          addFeatures(t3, e3, r3, n3, i3) {
            for (const t4 of this.features) {
              const { geometry: s3 } = t4;
              this.addFeature(t4, s3, t4.index, e3, r3, n3, i3);
            }
            this.sortBorders();
          }
          update(t3, e3, r3, n3) {
            this.stateDependentLayers.length && this.programConfigurations.updatePaintArrays(t3, e3, this.stateDependentLayers, r3, n3);
          }
          isEmpty() {
            return 0 === this.layoutVertexArray.length;
          }
          uploadPending() {
            return !this.uploaded || this.programConfigurations.needsUpload;
          }
          upload(t3) {
            this.uploaded || (this.layoutVertexBuffer = t3.createVertexBuffer(this.layoutVertexArray, Pc), this.indexBuffer = t3.createIndexBuffer(this.indexArray), this.layoutVertexExtArray && (this.layoutVertexExtBuffer = t3.createVertexBuffer(this.layoutVertexExtArray, Cc.members, true))), this.programConfigurations.upload(t3), this.uploaded = true;
          }
          uploadCentroid(t3) {
            0 !== this.centroidVertexArray.length && (this.centroidVertexBuffer ? this.needsCentroidUpdate && this.centroidVertexBuffer.updateData(this.centroidVertexArray) : this.centroidVertexBuffer = t3.createVertexBuffer(this.centroidVertexArray, Ec.members, true), this.needsCentroidUpdate = false);
          }
          destroy() {
            this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.centroidVertexBuffer && this.centroidVertexBuffer.destroy(), this.layoutVertexExtBuffer && this.layoutVertexExtBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy());
          }
          addFeature(t3, e3, r3, n3, i3, s3, a3) {
            const o3 = [new x2(0, 0), new x2(ao, ao)], l2 = a3.projection, u3 = "globe" === l2.name, c3 = this.enableTerrain && !u3 ? new Qc() : null, h3 = "Polygon" === Jc[t3.type];
            u3 && !this.layoutVertexExtArray && (this.layoutVertexExtArray = new Ks());
            const p3 = Ac(e3, 500);
            for (let t4 = p3.length - 1; t4 >= 0; t4--) {
              const e4 = p3[t4];
              (0 === e4.length || (d3 = e4[0]).every((t5) => t5.x <= 0) || d3.every((t5) => t5.x >= ao) || d3.every((t5) => t5.y <= 0) || d3.every((t5) => t5.y >= ao)) && p3.splice(t4, 1);
            }
            var d3;
            let f3;
            if (u3)
              f3 = lh(p3, o3, n3);
            else {
              f3 = [];
              for (const t4 of p3)
                f3.push({ polygon: t4, bounds: o3 });
            }
            const y3 = h3 ? this.edgeRadius : 0;
            for (const { polygon: t4, bounds: e4 } of f3) {
              let r4 = 0, i4 = 0;
              for (const e5 of t4)
                h3 && !e5[0].equals(e5[e5.length - 1]) && e5.push(e5[0]), i4 += h3 ? e5.length - 1 : e5.length;
              const s4 = this.segments.prepareSegment((h3 ? 5 : 4) * i4, this.layoutVertexArray, this.indexArray);
              if (h3) {
                const e5 = [], i5 = [];
                r4 = s4.vertexLength;
                for (const r5 of t4) {
                  let a5, o4;
                  r5.length && r5 !== t4[0] && i5.push(e5.length / 2), a5 = r5[1].sub(r5[0])._perp()._unit();
                  for (let t5 = 1; t5 < r5.length; t5++) {
                    const i6 = r5[t5], c4 = r5[t5 === r5.length - 1 ? 1 : t5 + 1];
                    let { x: h4, y: p4 } = i6;
                    if (y3) {
                      o4 = c4.sub(i6)._perp()._unit();
                      const t6 = a5.add(o4)._unit(), e6 = y3 * Math.min(4, 1 / (a5.x * t6.x + a5.y * t6.y));
                      h4 += e6 * t6.x, p4 += e6 * t6.y, a5 = o4;
                    }
                    Yc(this.layoutVertexArray, h4, p4, 0, 0, 1, 1, 0), s4.vertexLength++, e5.push(i6.x, i6.y), u3 && Wc(this.layoutVertexExtArray, l2.projectTilePoint(h4, p4, n3), l2.upVector(n3, h4, p4));
                  }
                }
                const a4 = xc(e5, i5);
                for (let t5 = 0; t5 < a4.length; t5 += 3)
                  this.indexArray.emplaceBack(r4 + a4[t5], r4 + a4[t5 + 2], r4 + a4[t5 + 1]), s4.primitiveLength++;
              }
              for (const i5 of t4) {
                c3 && i5.length && c3.startRing(i5[0]);
                let t5, a4, o4, p4 = i5.length > 4 && sh(i5[i5.length - 2], i5[0], i5[1]), d4 = y3 ? rh(i5[i5.length - 2], i5[0], i5[1], y3) : 0;
                a4 = i5[1].sub(i5[0])._perp()._unit();
                let f4 = true;
                for (let m3 = 1, g3 = 0; m3 < i5.length; m3++) {
                  let x3 = i5[m3 - 1], v3 = i5[m3];
                  const b2 = i5[m3 === i5.length - 1 ? 1 : m3 + 1];
                  if (c3 && h3 && c3.currentPolyCount.top++, ih(v3, x3, e4)) {
                    y3 && (a4 = b2.sub(v3)._perp()._unit(), f4 = !f4);
                    continue;
                  }
                  c3 && c3.append(v3, x3);
                  const w2 = v3.sub(x3)._perp(), _2 = w2.x / (Math.abs(w2.x) + Math.abs(w2.y)), A2 = w2.y > 0 ? 1 : 0, S2 = x3.dist(v3);
                  if (g3 + S2 > 32768 && (g3 = 0), y3) {
                    o4 = b2.sub(v3)._perp()._unit();
                    let t6 = nh(x3, v3, b2, eh(a4, o4), y3);
                    isNaN(t6) && (t6 = 0);
                    const e5 = v3.sub(x3)._unit();
                    x3 = x3.add(e5.mult(d4))._round(), v3 = v3.add(e5.mult(-t6))._round(), d4 = t6, a4 = o4;
                  }
                  const k2 = s4.vertexLength, I2 = i5.length > 4 && sh(x3, v3, b2);
                  let M2 = ah(g3, p4, f4);
                  if (Yc(this.layoutVertexArray, x3.x, x3.y, _2, A2, 0, 0, M2), Yc(this.layoutVertexArray, x3.x, x3.y, _2, A2, 0, 1, M2), g3 += S2, M2 = ah(g3, I2, !f4), p4 = I2, Yc(this.layoutVertexArray, v3.x, v3.y, _2, A2, 0, 0, M2), Yc(this.layoutVertexArray, v3.x, v3.y, _2, A2, 0, 1, M2), s4.vertexLength += 4, this.indexArray.emplaceBack(k2 + 0, k2 + 1, k2 + 2), this.indexArray.emplaceBack(k2 + 1, k2 + 3, k2 + 2), s4.primitiveLength += 2, y3) {
                    const n4 = r4 + (1 === m3 ? i5.length - 2 : m3 - 2), a5 = 1 === m3 ? r4 : n4 + 1;
                    if (this.indexArray.emplaceBack(k2 + 1, n4, k2 + 3), this.indexArray.emplaceBack(n4, a5, k2 + 3), s4.primitiveLength += 2, void 0 === t5 && (t5 = k2), !ih(b2, i5[m3], e4)) {
                      const e5 = m3 === i5.length - 1 ? t5 : s4.vertexLength;
                      this.indexArray.emplaceBack(k2 + 2, k2 + 3, e5), this.indexArray.emplaceBack(k2 + 3, e5 + 1, e5), this.indexArray.emplaceBack(k2 + 3, a5, e5 + 1), s4.primitiveLength += 3;
                    }
                    f4 = !f4;
                  }
                  if (u3) {
                    const t6 = this.layoutVertexExtArray, e5 = l2.projectTilePoint(x3.x, x3.y, n3), r5 = l2.projectTilePoint(v3.x, v3.y, n3), i6 = l2.upVector(n3, x3.x, x3.y), s5 = l2.upVector(n3, v3.x, v3.y);
                    Wc(t6, e5, i6), Wc(t6, e5, i6), Wc(t6, r5, s5), Wc(t6, r5, s5);
                  }
                }
                h3 && (r4 += i5.length - 1);
              }
            }
            if (c3 && c3.polyCount.length > 0) {
              if (c3.borders) {
                c3.vertexArrayOffset = this.centroidVertexArray.length;
                const t4 = c3.borders, e4 = this.featuresOnBorder.push(c3) - 1;
                for (let r4 = 0; r4 < 4; r4++)
                  t4[r4][0] !== Number.MAX_VALUE && this.borders[r4].push(e4);
              }
              this.encodeCentroid(c3.borders ? void 0 : c3.centroid(), c3);
            }
            this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, t3, r3, i3, s3, n3);
          }
          sortBorders() {
            for (let t3 = 0; t3 < 4; t3++)
              this.borders[t3].sort((e3, r3) => this.featuresOnBorder[e3].borders[t3][0] - this.featuresOnBorder[r3].borders[t3][0]);
          }
          encodeCentroid(t3, e3, r3 = true) {
            let n3, i3;
            if (t3)
              if (0 !== t3.y) {
                const r4 = e3.span()._mult(this.tileToMeter);
                n3 = (Math.max(t3.x, 1) << 3) + Math.min(7, Math.round(r4.x / 10)), i3 = (Math.max(t3.y, 1) << 3) + Math.min(7, Math.round(r4.y / 10));
              } else
                n3 = Math.ceil(7 * (t3.x + 450)), i3 = 0;
            else
              n3 = 0, i3 = +r3;
            let s3 = r3 ? this.centroidVertexArray.length : e3.vertexArrayOffset;
            for (const t4 of e3.polyCount) {
              r3 && this.centroidVertexArray.resize(this.centroidVertexArray.length + 4 * t4.edges + t4.top);
              for (let e4 = 0; e4 < t4.top; e4++)
                this.centroidVertexArray.emplace(s3++, n3, i3);
              for (let e4 = 0; e4 < 2 * t4.edges; e4++)
                this.centroidVertexArray.emplace(s3++, 0, i3), this.centroidVertexArray.emplace(s3++, n3, i3);
            }
          }
        }
        function eh(t3, e3) {
          const r3 = t3.add(e3)._unit();
          return t3.x * r3.x + t3.y * r3.y;
        }
        function rh(t3, e3, r3, n3) {
          const i3 = e3.sub(t3)._perp()._unit(), s3 = r3.sub(e3)._perp()._unit();
          return nh(t3, e3, r3, eh(i3, s3), n3);
        }
        function nh(t3, e3, r3, n3, i3) {
          const s3 = Math.sqrt(1 - n3 * n3);
          return Math.min(t3.dist(e3) / 3, e3.dist(r3) / 3, i3 * s3 / n3);
        }
        function ih(t3, e3, r3) {
          return t3.x < r3[0].x && e3.x < r3[0].x || t3.x > r3[1].x && e3.x > r3[1].x || t3.y < r3[0].y && e3.y < r3[0].y || t3.y > r3[1].y && e3.y > r3[1].y;
        }
        function sh(t3, e3, r3) {
          if (t3.x < 0 || t3.x >= ao || e3.x < 0 || e3.x >= ao || r3.x < 0 || r3.x >= ao)
            return false;
          const n3 = r3.sub(e3), i3 = n3.perp(), s3 = t3.sub(e3);
          return (n3.x * s3.x + n3.y * s3.y) / Math.sqrt((n3.x * n3.x + n3.y * n3.y) * (s3.x * s3.x + s3.y * s3.y)) > -0.866 && i3.x * s3.x + i3.y * s3.y < 0;
        }
        function ah(t3, e3, r3) {
          const n3 = e3 ? 2 | t3 : -3 & t3;
          return r3 ? 1 | n3 : -2 & n3;
        }
        function oh() {
          const t3 = Math.PI / 32, e3 = Math.tan(t3), r3 = Ul;
          return r3 * Math.sqrt(1 + 2 * e3 * e3) - r3;
        }
        function lh(t3, e3, r3) {
          const n3 = 1 << r3.z, i3 = Kl(r3.x / n3), s3 = Kl((r3.x + 1) / n3), a3 = Xl(r3.y / n3), o3 = Xl((r3.y + 1) / n3);
          return function(t4, e4, r4, n4, i4 = 0, s4) {
            const a4 = [];
            if (!t4.length || !r4 || !n4)
              return a4;
            const o4 = (t5, e5) => {
              for (const r5 of t5)
                a4.push({ polygon: r5, bounds: e5 });
            }, l2 = Math.ceil(Math.log2(r4)), u3 = Math.ceil(Math.log2(n4)), c3 = l2 - u3, h3 = [];
            for (let t5 = 0; t5 < Math.abs(c3); t5++)
              h3.push(c3 > 0 ? 0 : 1);
            for (let t5 = 0; t5 < Math.min(l2, u3); t5++)
              h3.push(0), h3.push(1);
            let p3 = t4;
            if (p3 = Xc(p3, e4[0].y - i4, e4[1].y + i4, 1), p3 = Xc(p3, e4[0].x - i4, e4[1].x + i4, 0), !p3.length)
              return a4;
            const d3 = [];
            for (h3.length ? d3.push({ polygons: p3, bounds: e4, depth: 0 }) : o4(p3, e4); d3.length; ) {
              const t5 = d3.pop(), e5 = t5.depth, r5 = h3[e5], n5 = t5.bounds[0], a5 = t5.bounds[1], l3 = 0 === r5 ? n5.x : n5.y, u4 = 0 === r5 ? a5.x : a5.y, c4 = s4 ? s4(r5, l3, u4) : 0.5 * (l3 + u4), p4 = Xc(t5.polygons, l3 - i4, c4 + i4, r5), f3 = Xc(t5.polygons, c4 - i4, u4 + i4, r5);
              if (p4.length) {
                const t6 = [n5, new x2(0 === r5 ? c4 : a5.x, 1 === r5 ? c4 : a5.y)];
                h3.length > e5 + 1 ? d3.push({ polygons: p4, bounds: t6, depth: e5 + 1 }) : o4(p4, t6);
              }
              if (f3.length) {
                const t6 = [new x2(0 === r5 ? c4 : n5.x, 1 === r5 ? c4 : n5.y), a5];
                h3.length > e5 + 1 ? d3.push({ polygons: f3, bounds: t6, depth: e5 + 1 }) : o4(f3, t6);
              }
            }
            return a4;
          }(t3, e3, Math.ceil((s3 - i3) / 11.25), Math.ceil((a3 - o3) / 11.25), 1, (t4, e4, i4) => {
            if (0 === t4)
              return 0.5 * (e4 + i4);
            {
              const t5 = Xl((r3.y + e4 / ao) / n3);
              return (Gl(0.5 * (Xl((r3.y + i4 / ao) / n3) + t5)) * n3 - r3.y) * ao;
            }
          });
        }
        Ji(th, "FillExtrusionBucket", { omit: ["layers", "features"] }), Ji(Qc, "PartMetadata");
        const uh = new Ps({ "fill-extrusion-edge-radius": new Bs(te["layout_fill-extrusion"]["fill-extrusion-edge-radius"]) });
        var ch = { paint: new Ps({ "fill-extrusion-opacity": new Bs(te["paint_fill-extrusion"]["fill-extrusion-opacity"]), "fill-extrusion-color": new Es(te["paint_fill-extrusion"]["fill-extrusion-color"]), "fill-extrusion-translate": new Bs(te["paint_fill-extrusion"]["fill-extrusion-translate"]), "fill-extrusion-translate-anchor": new Bs(te["paint_fill-extrusion"]["fill-extrusion-translate-anchor"]), "fill-extrusion-pattern": new Es(te["paint_fill-extrusion"]["fill-extrusion-pattern"]), "fill-extrusion-height": new Es(te["paint_fill-extrusion"]["fill-extrusion-height"]), "fill-extrusion-base": new Es(te["paint_fill-extrusion"]["fill-extrusion-base"]), "fill-extrusion-vertical-gradient": new Bs(te["paint_fill-extrusion"]["fill-extrusion-vertical-gradient"]), "fill-extrusion-ambient-occlusion-intensity": new Bs(te["paint_fill-extrusion"]["fill-extrusion-ambient-occlusion-intensity"]), "fill-extrusion-ambient-occlusion-radius": new Bs(te["paint_fill-extrusion"]["fill-extrusion-ambient-occlusion-radius"]), "fill-extrusion-rounded-roof": new Bs(te["paint_fill-extrusion"]["fill-extrusion-rounded-roof"]) }), layout: uh };
        function hh(t3, e3, r3) {
          var n3 = 2 * Math.PI * 6378137 / 256 / Math.pow(2, r3);
          return [t3 * n3 - 2 * Math.PI * 6378137 / 2, e3 * n3 - 2 * Math.PI * 6378137 / 2];
        }
        class ph {
          constructor(t3, e3, r3) {
            this.z = t3, this.x = e3, this.y = r3, this.key = yh(0, t3, t3, e3, r3);
          }
          equals(t3) {
            return this.z === t3.z && this.x === t3.x && this.y === t3.y;
          }
          url(t3, e3) {
            const r3 = function(t4, e4, r4) {
              var n4 = hh(256 * t4, 256 * (e4 = Math.pow(2, r4) - e4 - 1), r4), i3 = hh(256 * (t4 + 1), 256 * (e4 + 1), r4);
              return n4[0] + "," + n4[1] + "," + i3[0] + "," + i3[1];
            }(this.x, this.y, this.z), n3 = function(t4, e4, r4) {
              let n4, i3 = "";
              for (let s3 = t4; s3 > 0; s3--)
                n4 = 1 << s3 - 1, i3 += (e4 & n4 ? 1 : 0) + (r4 & n4 ? 2 : 0);
              return i3;
            }(this.z, this.x, this.y);
            return t3[(this.x + this.y) % t3.length].replace("{prefix}", (this.x % 16).toString(16) + (this.y % 16).toString(16)).replace(/{z}/g, String(this.z)).replace(/{x}/g, String(this.x)).replace(/{y}/g, String("tms" === e3 ? Math.pow(2, this.z) - this.y - 1 : this.y)).replace("{quadkey}", n3).replace("{bbox-epsg-3857}", r3);
          }
          toString() {
            return `${this.z}/${this.x}/${this.y}`;
          }
        }
        class dh {
          constructor(t3, e3) {
            this.wrap = t3, this.canonical = e3, this.key = yh(t3, e3.z, e3.z, e3.x, e3.y);
          }
        }
        class fh {
          constructor(t3, e3, r3, n3, i3) {
            this.overscaledZ = t3, this.wrap = e3, this.canonical = new ph(r3, +n3, +i3), this.key = 0 === e3 && t3 === r3 ? this.canonical.key : yh(e3, t3, r3, n3, i3);
          }
          equals(t3) {
            return this.overscaledZ === t3.overscaledZ && this.wrap === t3.wrap && this.canonical.equals(t3.canonical);
          }
          scaledTo(t3) {
            const e3 = this.canonical.z - t3;
            return t3 > this.canonical.z ? new fh(t3, this.wrap, this.canonical.z, this.canonical.x, this.canonical.y) : new fh(t3, this.wrap, t3, this.canonical.x >> e3, this.canonical.y >> e3);
          }
          calculateScaledKey(t3, e3 = true) {
            if (this.overscaledZ === t3 && e3)
              return this.key;
            if (t3 > this.canonical.z)
              return yh(this.wrap * +e3, t3, this.canonical.z, this.canonical.x, this.canonical.y);
            {
              const r3 = this.canonical.z - t3;
              return yh(this.wrap * +e3, t3, t3, this.canonical.x >> r3, this.canonical.y >> r3);
            }
          }
          isChildOf(t3) {
            if (t3.wrap !== this.wrap)
              return false;
            const e3 = this.canonical.z - t3.canonical.z;
            return 0 === t3.overscaledZ || t3.overscaledZ < this.overscaledZ && t3.canonical.x === this.canonical.x >> e3 && t3.canonical.y === this.canonical.y >> e3;
          }
          children(t3) {
            if (this.overscaledZ >= t3)
              return [new fh(this.overscaledZ + 1, this.wrap, this.canonical.z, this.canonical.x, this.canonical.y)];
            const e3 = this.canonical.z + 1, r3 = 2 * this.canonical.x, n3 = 2 * this.canonical.y;
            return [new fh(e3, this.wrap, e3, r3, n3), new fh(e3, this.wrap, e3, r3 + 1, n3), new fh(e3, this.wrap, e3, r3, n3 + 1), new fh(e3, this.wrap, e3, r3 + 1, n3 + 1)];
          }
          isLessThan(t3) {
            return this.wrap < t3.wrap || !(this.wrap > t3.wrap) && (this.overscaledZ < t3.overscaledZ || !(this.overscaledZ > t3.overscaledZ) && (this.canonical.x < t3.canonical.x || !(this.canonical.x > t3.canonical.x) && this.canonical.y < t3.canonical.y));
          }
          wrapped() {
            return new fh(this.overscaledZ, 0, this.canonical.z, this.canonical.x, this.canonical.y);
          }
          unwrapTo(t3) {
            return new fh(this.overscaledZ, t3, this.canonical.z, this.canonical.x, this.canonical.y);
          }
          overscaleFactor() {
            return Math.pow(2, this.overscaledZ - this.canonical.z);
          }
          toUnwrapped() {
            return new dh(this.wrap, this.canonical);
          }
          toString() {
            return `${this.overscaledZ}/${this.canonical.x}/${this.canonical.y}`;
          }
        }
        function yh(t3, e3, r3, n3, i3) {
          const s3 = 1 << Math.min(r3, 22);
          let a3 = s3 * (i3 % s3) + n3 % s3;
          return t3 && r3 < 22 && (a3 += s3 * s3 * ((t3 < 0 ? -2 * t3 - 1 : 2 * t3) % (1 << 2 * (22 - r3)))), 16 * (32 * a3 + r3) + (e3 - r3);
        }
        Ji(ph, "CanonicalTileID"), Ji(fh, "OverscaledTileID", { omit: ["projMatrix"] });
        class mh extends x2 {
          constructor(t3, e3, r3) {
            super(t3, e3), this.z = r3;
          }
        }
        function gh(t3, e3) {
          return t3.x * e3.x + t3.y * e3.y;
        }
        function xh(t3, e3) {
          if (1 === t3.length) {
            let r3 = 0;
            const n3 = e3[r3++];
            let i3;
            for (; !i3 || n3.equals(i3); )
              if (i3 = e3[r3++], !i3)
                return 1 / 0;
            for (; r3 < e3.length; r3++) {
              const s3 = e3[r3], a3 = t3[0], o3 = i3.sub(n3), l2 = s3.sub(n3), u3 = a3.sub(n3), c3 = gh(o3, o3), h3 = gh(o3, l2), p3 = gh(l2, l2), d3 = gh(u3, o3), f3 = gh(u3, l2), y3 = c3 * p3 - h3 * h3, m3 = (p3 * d3 - h3 * f3) / y3, g3 = (c3 * f3 - h3 * d3) / y3, x3 = n3.z * (1 - m3 - g3) + i3.z * m3 + s3.z * g3;
              if (isFinite(x3))
                return x3;
            }
            return 1 / 0;
          }
          {
            let t4 = 1 / 0;
            for (const r3 of e3)
              t4 = Math.min(t4, r3.z);
            return t4;
          }
        }
        function vh(t3, e3, r3, n3, i3, s3, a3, o3) {
          const l2 = a3 * i3.getElevationAt(t3, e3, true, true), u3 = 0 !== s3[0], c3 = u3 ? 0 === s3[1] ? a3 * (s3[0] / 7 - 450) : a3 * function(t4, e4, r4) {
            const n4 = Math.floor(e4[0] / 8), i4 = Math.floor(e4[1] / 8), s4 = 10 * (e4[0] - 8 * n4), a4 = 10 * (e4[1] - 8 * i4), o4 = t4.getElevationAt(n4, i4, true, true), l3 = t4.getMeterToDEM(r4), u4 = Math.floor(0.5 * (s4 * l3 - 1)), c4 = Math.floor(0.5 * (a4 * l3 - 1)), h3 = t4.tileCoordToPixel(n4, i4), p3 = 2 * u4 + 1, d3 = 2 * c4 + 1, f3 = function(t5, e5, r5, n5, i5) {
              return [t5.getElevationAtPixel(e5, r5, true), t5.getElevationAtPixel(e5 + i5, r5, true), t5.getElevationAtPixel(e5, r5 + i5, true), t5.getElevationAtPixel(e5 + n5, r5 + i5, true)];
            }(t4, h3.x - u4, h3.y - c4, p3, d3), y3 = Math.abs(f3[0] - f3[1]), m3 = Math.abs(f3[2] - f3[3]), g3 = Math.abs(f3[0] - f3[2]) + Math.abs(f3[1] - f3[3]), x3 = Math.min(0.25, 0.5 * l3 * (y3 + m3) / p3), v3 = Math.min(0.25, 0.5 * l3 * g3 / d3);
            return o4 + Math.max(x3 * s4, v3 * a4);
          }(i3, s3, o3) : l2;
          return { base: l2 + (0 === r3) ? -1 : r3, top: u3 ? Math.max(c3 + n3, l2 + r3 + 2) : l2 + n3 };
        }
        const bh = Rs([{ name: "a_pos_normal", components: 2, type: "Int16" }, { name: "a_data", components: 4, type: "Uint8" }, { name: "a_linesofar", components: 1, type: "Float32" }], 4), { members: wh } = bh, _h = Rs([{ name: "a_packed", components: 4, type: "Float32" }]), { members: Ah } = _h, Sh = Kc.types, kh = Math.cos(Math.PI / 180 * 37.5);
        class Ih {
          constructor(t3) {
            this.zoom = t3.zoom, this.overscaling = t3.overscaling, this.layers = t3.layers, this.layerIds = this.layers.map((t4) => t4.id), this.index = t3.index, this.projection = t3.projection, this.hasPattern = false, this.patternFeatures = [], this.lineClipsArray = [], this.gradients = {}, this.layers.forEach((t4) => {
              this.gradients[t4.id] = {};
            }), this.layoutVertexArray = new qs(), this.layoutVertexArray2 = new Ns(), this.indexArray = new ra(), this.programConfigurations = new Ja(t3.layers, t3.zoom), this.segments = new so(), this.maxLineLength = 0, this.stateDependentLayerIds = this.layers.filter((t4) => t4.isStateDependent()).map((t4) => t4.id);
          }
          populate(t3, e3, r3, n3) {
            this.hasPattern = kc("line", this.layers, e3);
            const i3 = this.layers[0].layout.get("line-sort-key"), s3 = [];
            for (const { feature: e4, id: a4, index: o4, sourceLayerIndex: l3 } of t3) {
              const t4 = this.layers[0]._featureFilter.needGeometry, u3 = ou(e4, t4);
              if (!this.layers[0]._featureFilter.filter(new ws(this.zoom), u3, r3))
                continue;
              const c3 = i3 ? i3.evaluate(u3, {}, r3) : void 0, h3 = { id: a4, properties: e4.properties, type: e4.type, sourceLayerIndex: l3, index: o4, geometry: t4 ? u3.geometry : au(e4, r3, n3), patterns: {}, sortKey: c3 };
              s3.push(h3);
            }
            i3 && s3.sort((t4, e4) => t4.sortKey - e4.sortKey);
            const { lineAtlas: a3, featureIndex: o3 } = e3, l2 = this.addConstantDashes(a3);
            for (const n4 of s3) {
              const { geometry: i4, index: s4, sourceLayerIndex: u3 } = n4;
              if (l2 && this.addFeatureDashes(n4, a3), this.hasPattern) {
                const t4 = Ic("line", this.layers, n4, this.zoom, e3);
                this.patternFeatures.push(t4);
              } else
                this.addFeature(n4, i4, s4, r3, a3.positions, e3.availableImages);
              o3.insert(t3[s4].feature, i4, s4, u3, this.index);
            }
          }
          addConstantDashes(t3) {
            let e3 = false;
            for (const r3 of this.layers) {
              const n3 = r3.paint.get("line-dasharray").value, i3 = r3.layout.get("line-cap").value;
              if ("constant" !== n3.kind || "constant" !== i3.kind)
                e3 = true;
              else {
                const e4 = i3.value, r4 = n3.value;
                if (!r4)
                  continue;
                t3.addDash(r4, e4);
              }
            }
            return e3;
          }
          addFeatureDashes(t3, e3) {
            const r3 = this.zoom;
            for (const n3 of this.layers) {
              const i3 = n3.paint.get("line-dasharray").value, s3 = n3.layout.get("line-cap").value;
              if ("constant" === i3.kind && "constant" === s3.kind)
                continue;
              let a3, o3;
              if ("constant" === i3.kind) {
                if (a3 = i3.value, !a3)
                  continue;
              } else
                a3 = i3.evaluate({ zoom: r3 }, t3);
              o3 = "constant" === s3.kind ? s3.value : s3.evaluate({ zoom: r3 }, t3), e3.addDash(a3, o3), t3.patterns[n3.id] = e3.getKey(a3, o3);
            }
          }
          update(t3, e3, r3, n3) {
            this.stateDependentLayers.length && this.programConfigurations.updatePaintArrays(t3, e3, this.stateDependentLayers, r3, n3);
          }
          addFeatures(t3, e3, r3, n3, i3) {
            for (const t4 of this.patternFeatures)
              this.addFeature(t4, t4.geometry, t4.index, e3, r3, n3);
          }
          isEmpty() {
            return 0 === this.layoutVertexArray.length;
          }
          uploadPending() {
            return !this.uploaded || this.programConfigurations.needsUpload;
          }
          upload(t3) {
            this.uploaded || (0 !== this.layoutVertexArray2.length && (this.layoutVertexBuffer2 = t3.createVertexBuffer(this.layoutVertexArray2, Ah)), this.layoutVertexBuffer = t3.createVertexBuffer(this.layoutVertexArray, wh), this.indexBuffer = t3.createIndexBuffer(this.indexArray)), this.programConfigurations.upload(t3), this.uploaded = true;
          }
          destroy() {
            this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy());
          }
          lineFeatureClips(t3) {
            if (t3.properties && t3.properties.hasOwnProperty("mapbox_clip_start") && t3.properties.hasOwnProperty("mapbox_clip_end"))
              return { start: +t3.properties.mapbox_clip_start, end: +t3.properties.mapbox_clip_end };
          }
          addFeature(t3, e3, r3, n3, i3, s3) {
            const a3 = this.layers[0].layout, o3 = a3.get("line-join").evaluate(t3, {}), l2 = a3.get("line-cap").evaluate(t3, {}), u3 = a3.get("line-miter-limit"), c3 = a3.get("line-round-limit");
            this.lineClips = this.lineFeatureClips(t3);
            for (const r4 of e3)
              this.addLine(r4, t3, o3, l2, u3, c3);
            this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, t3, r3, i3, s3, n3);
          }
          addLine(t3, e3, r3, n3, i3, s3) {
            if (this.distance = 0, this.scaledDistance = 0, this.totalDistance = 0, this.lineSoFar = 0, this.lineClips) {
              this.lineClipsArray.push(this.lineClips);
              for (let e4 = 0; e4 < t3.length - 1; e4++)
                this.totalDistance += t3[e4].dist(t3[e4 + 1]);
              this.updateScaledDistance(), this.maxLineLength = Math.max(this.maxLineLength, this.totalDistance);
            }
            const a3 = "Polygon" === Sh[e3.type];
            let o3 = t3.length;
            for (; o3 >= 2 && t3[o3 - 1].equals(t3[o3 - 2]); )
              o3--;
            let l2 = 0;
            for (; l2 < o3 - 1 && t3[l2].equals(t3[l2 + 1]); )
              l2++;
            if (o3 < (a3 ? 3 : 2))
              return;
            "bevel" === r3 && (i3 = 1.05);
            const u3 = this.overscaling <= 16 ? 15 * ao / (512 * this.overscaling) : 0, c3 = this.segments.prepareSegment(10 * o3, this.layoutVertexArray, this.indexArray);
            let h3, p3, d3, f3, y3;
            this.e1 = this.e2 = -1, a3 && (h3 = t3[o3 - 2], y3 = t3[l2].sub(h3)._unit()._perp());
            for (let e4 = l2; e4 < o3; e4++) {
              if (d3 = e4 === o3 - 1 ? a3 ? t3[l2 + 1] : void 0 : t3[e4 + 1], d3 && t3[e4].equals(d3))
                continue;
              y3 && (f3 = y3), h3 && (p3 = h3), h3 = t3[e4], y3 = d3 ? d3.sub(h3)._unit()._perp() : f3, f3 = f3 || y3;
              let m3 = f3.add(y3);
              0 === m3.x && 0 === m3.y || m3._unit();
              const g3 = f3.x * y3.x + f3.y * y3.y, x3 = m3.x * y3.x + m3.y * y3.y, v3 = 0 !== x3 ? 1 / x3 : 1 / 0, b2 = 2 * Math.sqrt(2 - 2 * x3), w2 = x3 < kh && p3 && d3, _2 = f3.x * y3.y - f3.y * y3.x > 0;
              if (w2 && e4 > l2) {
                const t4 = h3.dist(p3);
                if (t4 > 2 * u3) {
                  const e5 = h3.sub(h3.sub(p3)._mult(u3 / t4)._round());
                  this.updateDistance(p3, e5), this.addCurrentVertex(e5, f3, 0, 0, c3), p3 = e5;
                }
              }
              const A2 = p3 && d3;
              let S2 = A2 ? r3 : a3 ? "butt" : n3;
              if (A2 && "round" === S2 && (v3 < s3 ? S2 = "miter" : v3 <= 2 && (S2 = "fakeround")), "miter" === S2 && v3 > i3 && (S2 = "bevel"), "bevel" === S2 && (v3 > 2 && (S2 = "flipbevel"), v3 < i3 && (S2 = "miter")), p3 && this.updateDistance(p3, h3), "miter" === S2)
                m3._mult(v3), this.addCurrentVertex(h3, m3, 0, 0, c3);
              else if ("flipbevel" === S2) {
                if (v3 > 100)
                  m3 = y3.mult(-1);
                else {
                  const t4 = v3 * f3.add(y3).mag() / f3.sub(y3).mag();
                  m3._perp()._mult(t4 * (_2 ? -1 : 1));
                }
                this.addCurrentVertex(h3, m3, 0, 0, c3), this.addCurrentVertex(h3, m3.mult(-1), 0, 0, c3);
              } else if ("bevel" === S2 || "fakeround" === S2) {
                const t4 = -Math.sqrt(v3 * v3 - 1), e5 = _2 ? t4 : 0, r4 = _2 ? 0 : t4;
                if (p3 && this.addCurrentVertex(h3, f3, e5, r4, c3), "fakeround" === S2) {
                  const t5 = Math.round(180 * b2 / Math.PI / 20);
                  for (let e6 = 1; e6 < t5; e6++) {
                    let r5 = e6 / t5;
                    if (0.5 !== r5) {
                      const t6 = r5 - 0.5;
                      r5 += r5 * t6 * (r5 - 1) * ((1.0904 + g3 * (g3 * (3.55645 - 1.43519 * g3) - 3.2452)) * t6 * t6 + (0.848013 + g3 * (0.215638 * g3 - 1.06021)));
                    }
                    const n4 = y3.sub(f3)._mult(r5)._add(f3)._unit()._mult(_2 ? -1 : 1);
                    this.addHalfVertex(h3, n4.x, n4.y, false, _2, 0, c3);
                  }
                }
                d3 && this.addCurrentVertex(h3, y3, -e5, -r4, c3);
              } else if ("butt" === S2)
                this.addCurrentVertex(h3, m3, 0, 0, c3);
              else if ("square" === S2) {
                const t4 = p3 ? 1 : -1;
                p3 || this.addCurrentVertex(h3, m3, t4, t4, c3), this.addCurrentVertex(h3, m3, 0, 0, c3), p3 && this.addCurrentVertex(h3, m3, t4, t4, c3);
              } else
                "round" === S2 && (p3 && (this.addCurrentVertex(h3, f3, 0, 0, c3), this.addCurrentVertex(h3, f3, 1, 1, c3, true)), d3 && (this.addCurrentVertex(h3, y3, -1, -1, c3, true), this.addCurrentVertex(h3, y3, 0, 0, c3)));
              if (w2 && e4 < o3 - 1) {
                const t4 = h3.dist(d3);
                if (t4 > 2 * u3) {
                  const e5 = h3.add(d3.sub(h3)._mult(u3 / t4)._round());
                  this.updateDistance(h3, e5), this.addCurrentVertex(e5, y3, 0, 0, c3), h3 = e5;
                }
              }
            }
          }
          addCurrentVertex(t3, e3, r3, n3, i3, s3 = false) {
            const a3 = e3.y * n3 - e3.x, o3 = -e3.y - e3.x * n3;
            this.addHalfVertex(t3, e3.x + e3.y * r3, e3.y - e3.x * r3, s3, false, r3, i3), this.addHalfVertex(t3, a3, o3, s3, true, -n3, i3);
          }
          addHalfVertex({ x: t3, y: e3 }, r3, n3, i3, s3, a3, o3) {
            this.layoutVertexArray.emplaceBack((t3 << 1) + (i3 ? 1 : 0), (e3 << 1) + (s3 ? 1 : 0), Math.round(63 * r3) + 128, Math.round(63 * n3) + 128, 1 + (0 === a3 ? 0 : a3 < 0 ? -1 : 1), 0, this.lineSoFar), this.lineClips && this.layoutVertexArray2.emplaceBack(this.scaledDistance, this.lineClipsArray.length, this.lineClips.start, this.lineClips.end);
            const l2 = o3.vertexLength++;
            this.e1 >= 0 && this.e2 >= 0 && (this.indexArray.emplaceBack(this.e1, this.e2, l2), o3.primitiveLength++), s3 ? this.e2 = l2 : this.e1 = l2;
          }
          updateScaledDistance() {
            if (this.lineClips) {
              const t3 = this.totalDistance / (this.lineClips.end - this.lineClips.start);
              this.scaledDistance = this.distance / this.totalDistance, this.lineSoFar = t3 * this.lineClips.start + this.distance;
            } else
              this.lineSoFar = this.distance;
          }
          updateDistance(t3, e3) {
            this.distance += t3.dist(e3), this.updateScaledDistance();
          }
        }
        Ji(Ih, "LineBucket", { omit: ["layers", "patternFeatures"] });
        const Mh = new Ps({ "line-cap": new Es(te.layout_line["line-cap"]), "line-join": new Es(te.layout_line["line-join"]), "line-miter-limit": new Bs(te.layout_line["line-miter-limit"]), "line-round-limit": new Bs(te.layout_line["line-round-limit"]), "line-sort-key": new Es(te.layout_line["line-sort-key"]) });
        var Th = { paint: new Ps({ "line-opacity": new Es(te.paint_line["line-opacity"]), "line-color": new Es(te.paint_line["line-color"]), "line-translate": new Bs(te.paint_line["line-translate"]), "line-translate-anchor": new Bs(te.paint_line["line-translate-anchor"]), "line-width": new Es(te.paint_line["line-width"]), "line-gap-width": new Es(te.paint_line["line-gap-width"]), "line-offset": new Es(te.paint_line["line-offset"]), "line-blur": new Es(te.paint_line["line-blur"]), "line-dasharray": new Es(te.paint_line["line-dasharray"]), "line-pattern": new Es(te.paint_line["line-pattern"]), "line-gradient": new Cs(te.paint_line["line-gradient"]), "line-trim-offset": new Bs(te.paint_line["line-trim-offset"]) }), layout: Mh };
        const zh = new class extends Es {
          possiblyEvaluate(t3, e3) {
            return e3 = new ws(Math.floor(e3.zoom), { now: e3.now, fadeDuration: e3.fadeDuration, transition: e3.transition }), super.possiblyEvaluate(t3, e3);
          }
          evaluate(t3, e3, r3, n3) {
            return e3 = C({}, e3, { zoom: Math.floor(e3.zoom) }), super.evaluate(t3, e3, r3, n3);
          }
        }(Th.paint.properties["line-width"].specification);
        function Bh(t3, e3) {
          return e3 > 0 ? e3 + 2 * t3 : t3;
        }
        zh.useIntegerZoom = true;
        const Eh = Rs([{ name: "a_pos_offset", components: 4, type: "Int16" }, { name: "a_tex_size", components: 4, type: "Uint16" }, { name: "a_pixeloffset", components: 4, type: "Int16" }], 4), Ch = Rs([{ name: "a_globe_anchor", components: 3, type: "Int16" }, { name: "a_globe_normal", components: 3, type: "Float32" }], 4), Ph = Rs([{ name: "a_projected_pos", components: 4, type: "Float32" }], 4);
        Rs([{ name: "a_fade_opacity", components: 1, type: "Uint32" }], 4);
        const Dh = Rs([{ name: "a_placed", components: 2, type: "Uint8" }, { name: "a_shift", components: 2, type: "Float32" }]), Vh = Rs([{ name: "a_size_scale", components: 1, type: "Float32" }, { name: "a_padding", components: 2, type: "Float32" }]);
        Rs([{ type: "Int16", name: "projectedAnchorX" }, { type: "Int16", name: "projectedAnchorY" }, { type: "Int16", name: "projectedAnchorZ" }, { type: "Int16", name: "tileAnchorX" }, { type: "Int16", name: "tileAnchorY" }, { type: "Float32", name: "x1" }, { type: "Float32", name: "y1" }, { type: "Float32", name: "x2" }, { type: "Float32", name: "y2" }, { type: "Int16", name: "padding" }, { type: "Uint32", name: "featureIndex" }, { type: "Uint16", name: "sourceLayerIndex" }, { type: "Uint16", name: "bucketIndex" }]);
        const Lh = Rs([{ name: "a_pos", components: 3, type: "Int16" }, { name: "a_anchor_pos", components: 2, type: "Int16" }, { name: "a_extrude", components: 2, type: "Int16" }], 4), Fh = Rs([{ name: "a_pos_2f", components: 2, type: "Float32" }, { name: "a_radius", components: 1, type: "Float32" }, { name: "a_flags", components: 2, type: "Int16" }], 4);
        Rs([{ name: "triangle", components: 3, type: "Uint16" }]), Rs([{ type: "Int16", name: "projectedAnchorX" }, { type: "Int16", name: "projectedAnchorY" }, { type: "Int16", name: "projectedAnchorZ" }, { type: "Float32", name: "tileAnchorX" }, { type: "Float32", name: "tileAnchorY" }, { type: "Uint16", name: "glyphStartIndex" }, { type: "Uint16", name: "numGlyphs" }, { type: "Uint32", name: "vertexStartIndex" }, { type: "Uint32", name: "lineStartIndex" }, { type: "Uint32", name: "lineLength" }, { type: "Uint16", name: "segment" }, { type: "Uint16", name: "lowerSize" }, { type: "Uint16", name: "upperSize" }, { type: "Float32", name: "lineOffsetX" }, { type: "Float32", name: "lineOffsetY" }, { type: "Uint8", name: "writingMode" }, { type: "Uint8", name: "placedOrientation" }, { type: "Uint8", name: "hidden" }, { type: "Uint32", name: "crossTileID" }, { type: "Int16", name: "associatedIconIndex" }, { type: "Uint8", name: "flipState" }]), Rs([{ type: "Int16", name: "projectedAnchorX" }, { type: "Int16", name: "projectedAnchorY" }, { type: "Int16", name: "projectedAnchorZ" }, { type: "Float32", name: "tileAnchorX" }, { type: "Float32", name: "tileAnchorY" }, { type: "Int16", name: "rightJustifiedTextSymbolIndex" }, { type: "Int16", name: "centerJustifiedTextSymbolIndex" }, { type: "Int16", name: "leftJustifiedTextSymbolIndex" }, { type: "Int16", name: "verticalPlacedTextSymbolIndex" }, { type: "Int16", name: "placedIconSymbolIndex" }, { type: "Int16", name: "verticalPlacedIconSymbolIndex" }, { type: "Uint16", name: "key" }, { type: "Uint16", name: "textBoxStartIndex" }, { type: "Uint16", name: "textBoxEndIndex" }, { type: "Uint16", name: "verticalTextBoxStartIndex" }, { type: "Uint16", name: "verticalTextBoxEndIndex" }, { type: "Uint16", name: "iconBoxStartIndex" }, { type: "Uint16", name: "iconBoxEndIndex" }, { type: "Uint16", name: "verticalIconBoxStartIndex" }, { type: "Uint16", name: "verticalIconBoxEndIndex" }, { type: "Uint16", name: "featureIndex" }, { type: "Uint16", name: "numHorizontalGlyphVertices" }, { type: "Uint16", name: "numVerticalGlyphVertices" }, { type: "Uint16", name: "numIconVertices" }, { type: "Uint16", name: "numVerticalIconVertices" }, { type: "Uint16", name: "useRuntimeCollisionCircles" }, { type: "Uint32", name: "crossTileID" }, { type: "Float32", components: 2, name: "textOffset" }, { type: "Float32", name: "collisionCircleDiameter" }]), Rs([{ type: "Float32", name: "offsetX" }]), Rs([{ type: "Int16", name: "x" }, { type: "Int16", name: "y" }]);
        var Rh = 24;
        const Uh = 128;
        function $h(t3, e3) {
          const { expression: r3 } = e3;
          if ("constant" === r3.kind)
            return { kind: "constant", layoutSize: r3.evaluate(new ws(t3 + 1)) };
          if ("source" === r3.kind)
            return { kind: "source" };
          {
            const { zoomStops: e4, interpolationType: n3 } = r3;
            let i3 = 0;
            for (; i3 < e4.length && e4[i3] <= t3; )
              i3++;
            i3 = Math.max(0, i3 - 1);
            let s3 = i3;
            for (; s3 < e4.length && e4[s3] < t3 + 1; )
              s3++;
            s3 = Math.min(e4.length - 1, s3);
            const a3 = e4[i3], o3 = e4[s3];
            return "composite" === r3.kind ? { kind: "composite", minZoom: a3, maxZoom: o3, interpolationType: n3 } : { kind: "camera", minZoom: a3, maxZoom: o3, minSize: r3.evaluate(new ws(a3)), maxSize: r3.evaluate(new ws(o3)), interpolationType: n3 };
          }
        }
        function jh(t3, { uSize: e3, uSizeT: r3 }, { lowerSize: n3, upperSize: i3 }) {
          return "source" === t3.kind ? n3 / Uh : "composite" === t3.kind ? Er(n3 / Uh, i3 / Uh, r3) : e3;
        }
        function Oh(t3, e3) {
          let r3 = 0, n3 = 0;
          if ("constant" === t3.kind)
            n3 = t3.layoutSize;
          else if ("source" !== t3.kind) {
            const { interpolationType: i3, minZoom: s3, maxZoom: a3 } = t3, o3 = i3 ? M(Qr.interpolationFactor(i3, e3, s3, a3), 0, 1) : 0;
            "camera" === t3.kind ? n3 = Er(t3.minSize, t3.maxSize, o3) : r3 = o3;
          }
          return { uSizeT: r3, uSize: n3 };
        }
        var qh = Object.freeze({ __proto__: null, SIZE_PACK_FACTOR: Uh, evaluateSizeForFeature: jh, evaluateSizeForZoom: Oh, getSizeData: $h });
        function Nh(t3, e3, r3) {
          return t3.sections.forEach((t4) => {
            t4.text = function(t5, e4, r4) {
              const n3 = e4.layout.get("text-transform").evaluate(r4, {});
              return "uppercase" === n3 ? t5 = t5.toLocaleUpperCase() : "lowercase" === n3 && (t5 = t5.toLocaleLowerCase()), bs.applyArabicShaping && (t5 = bs.applyArabicShaping(t5)), t5;
            }(t4.text, e3, r3);
          }), t3;
        }
        const Gh = { "!": "\uFE15", "#": "\uFF03", $: "\uFF04", "%": "\uFF05", "&": "\uFF06", "(": "\uFE35", ")": "\uFE36", "*": "\uFF0A", "+": "\uFF0B", ",": "\uFE10", "-": "\uFE32", ".": "\u30FB", "/": "\uFF0F", ":": "\uFE13", ";": "\uFE14", "<": "\uFE3F", "=": "\uFF1D", ">": "\uFE40", "?": "\uFE16", "@": "\uFF20", "[": "\uFE47", "\\": "\uFF3C", "]": "\uFE48", "^": "\uFF3E", _: "\uFE33", "`": "\uFF40", "{": "\uFE37", "|": "\u2015", "}": "\uFE38", "~": "\uFF5E", "\xA2": "\uFFE0", "\xA3": "\uFFE1", "\xA5": "\uFFE5", "\xA6": "\uFFE4", "\xAC": "\uFFE2", "\xAF": "\uFFE3", "\u2013": "\uFE32", "\u2014": "\uFE31", "\u2018": "\uFE43", "\u2019": "\uFE44", "\u201C": "\uFE41", "\u201D": "\uFE42", "\u2026": "\uFE19", "\u2027": "\u30FB", "\u20A9": "\uFFE6", "\u3001": "\uFE11", "\u3002": "\uFE12", "\u3008": "\uFE3F", "\u3009": "\uFE40", "\u300A": "\uFE3D", "\u300B": "\uFE3E", "\u300C": "\uFE41", "\u300D": "\uFE42", "\u300E": "\uFE43", "\u300F": "\uFE44", "\u3010": "\uFE3B", "\u3011": "\uFE3C", "\u3014": "\uFE39", "\u3015": "\uFE3A", "\u3016": "\uFE17", "\u3017": "\uFE18", "\uFF01": "\uFE15", "\uFF08": "\uFE35", "\uFF09": "\uFE36", "\uFF0C": "\uFE10", "\uFF0D": "\uFE32", "\uFF0E": "\u30FB", "\uFF1A": "\uFE13", "\uFF1B": "\uFE14", "\uFF1C": "\uFE3F", "\uFF1E": "\uFE40", "\uFF1F": "\uFE16", "\uFF3B": "\uFE47", "\uFF3D": "\uFE48", "\uFF3F": "\uFE33", "\uFF5B": "\uFE37", "\uFF5C": "\u2015", "\uFF5D": "\uFE38", "\uFF5F": "\uFE35", "\uFF60": "\uFE36", "\uFF61": "\uFE12", "\uFF62": "\uFE41", "\uFF63": "\uFE42", "\u2190": "\u2191", "\u2192": "\u2193" };
        function Zh(t3) {
          return "\uFE36" === t3 || "\uFE48" === t3 || "\uFE38" === t3 || "\uFE44" === t3 || "\uFE42" === t3 || "\uFE3E" === t3 || "\uFE3C" === t3 || "\uFE3A" === t3 || "\uFE18" === t3 || "\uFE40" === t3 || "\uFE10" === t3 || "\uFE13" === t3 || "\uFE14" === t3 || "\uFF40" === t3 || "\uFFE3" === t3 || "\uFE11" === t3 || "\uFE12" === t3;
        }
        function Kh(t3) {
          return "\uFE35" === t3 || "\uFE47" === t3 || "\uFE37" === t3 || "\uFE43" === t3 || "\uFE41" === t3 || "\uFE3D" === t3 || "\uFE3B" === t3 || "\uFE39" === t3 || "\uFE17" === t3 || "\uFE3F" === t3;
        }
        var Xh = Yh, Jh = function(t3, e3, r3, n3, i3) {
          var s3, a3, o3 = 8 * i3 - n3 - 1, l2 = (1 << o3) - 1, u3 = l2 >> 1, c3 = -7, h3 = r3 ? i3 - 1 : 0, p3 = r3 ? -1 : 1, d3 = t3[e3 + h3];
          for (h3 += p3, s3 = d3 & (1 << -c3) - 1, d3 >>= -c3, c3 += o3; c3 > 0; s3 = 256 * s3 + t3[e3 + h3], h3 += p3, c3 -= 8)
            ;
          for (a3 = s3 & (1 << -c3) - 1, s3 >>= -c3, c3 += n3; c3 > 0; a3 = 256 * a3 + t3[e3 + h3], h3 += p3, c3 -= 8)
            ;
          if (0 === s3)
            s3 = 1 - u3;
          else {
            if (s3 === l2)
              return a3 ? NaN : 1 / 0 * (d3 ? -1 : 1);
            a3 += Math.pow(2, n3), s3 -= u3;
          }
          return (d3 ? -1 : 1) * a3 * Math.pow(2, s3 - n3);
        }, Hh = function(t3, e3, r3, n3, i3, s3) {
          var a3, o3, l2, u3 = 8 * s3 - i3 - 1, c3 = (1 << u3) - 1, h3 = c3 >> 1, p3 = 23 === i3 ? Math.pow(2, -24) - Math.pow(2, -77) : 0, d3 = n3 ? 0 : s3 - 1, f3 = n3 ? 1 : -1, y3 = e3 < 0 || 0 === e3 && 1 / e3 < 0 ? 1 : 0;
          for (e3 = Math.abs(e3), isNaN(e3) || e3 === 1 / 0 ? (o3 = isNaN(e3) ? 1 : 0, a3 = c3) : (a3 = Math.floor(Math.log(e3) / Math.LN2), e3 * (l2 = Math.pow(2, -a3)) < 1 && (a3--, l2 *= 2), (e3 += a3 + h3 >= 1 ? p3 / l2 : p3 * Math.pow(2, 1 - h3)) * l2 >= 2 && (a3++, l2 /= 2), a3 + h3 >= c3 ? (o3 = 0, a3 = c3) : a3 + h3 >= 1 ? (o3 = (e3 * l2 - 1) * Math.pow(2, i3), a3 += h3) : (o3 = e3 * Math.pow(2, h3 - 1) * Math.pow(2, i3), a3 = 0)); i3 >= 8; t3[r3 + d3] = 255 & o3, d3 += f3, o3 /= 256, i3 -= 8)
            ;
          for (a3 = a3 << i3 | o3, u3 += i3; u3 > 0; t3[r3 + d3] = 255 & a3, d3 += f3, a3 /= 256, u3 -= 8)
            ;
          t3[r3 + d3 - f3] |= 128 * y3;
        };
        function Yh(t3) {
          this.buf = ArrayBuffer.isView && ArrayBuffer.isView(t3) ? t3 : new Uint8Array(t3 || 0), this.pos = 0, this.type = 0, this.length = this.buf.length;
        }
        Yh.Varint = 0, Yh.Fixed64 = 1, Yh.Bytes = 2, Yh.Fixed32 = 5;
        var Wh = 4294967296, Qh = 1 / Wh, tp = "undefined" == typeof TextDecoder ? null : new TextDecoder("utf8");
        function ep(t3) {
          return t3.type === Yh.Bytes ? t3.readVarint() + t3.pos : t3.pos + 1;
        }
        function rp(t3, e3, r3) {
          return r3 ? 4294967296 * e3 + (t3 >>> 0) : 4294967296 * (e3 >>> 0) + (t3 >>> 0);
        }
        function np(t3, e3, r3) {
          var n3 = e3 <= 16383 ? 1 : e3 <= 2097151 ? 2 : e3 <= 268435455 ? 3 : Math.floor(Math.log(e3) / (7 * Math.LN2));
          r3.realloc(n3);
          for (var i3 = r3.pos - 1; i3 >= t3; i3--)
            r3.buf[i3 + n3] = r3.buf[i3];
        }
        function ip(t3, e3) {
          for (var r3 = 0; r3 < t3.length; r3++)
            e3.writeVarint(t3[r3]);
        }
        function sp(t3, e3) {
          for (var r3 = 0; r3 < t3.length; r3++)
            e3.writeSVarint(t3[r3]);
        }
        function ap(t3, e3) {
          for (var r3 = 0; r3 < t3.length; r3++)
            e3.writeFloat(t3[r3]);
        }
        function op(t3, e3) {
          for (var r3 = 0; r3 < t3.length; r3++)
            e3.writeDouble(t3[r3]);
        }
        function lp(t3, e3) {
          for (var r3 = 0; r3 < t3.length; r3++)
            e3.writeBoolean(t3[r3]);
        }
        function up(t3, e3) {
          for (var r3 = 0; r3 < t3.length; r3++)
            e3.writeFixed32(t3[r3]);
        }
        function cp(t3, e3) {
          for (var r3 = 0; r3 < t3.length; r3++)
            e3.writeSFixed32(t3[r3]);
        }
        function hp(t3, e3) {
          for (var r3 = 0; r3 < t3.length; r3++)
            e3.writeFixed64(t3[r3]);
        }
        function pp(t3, e3) {
          for (var r3 = 0; r3 < t3.length; r3++)
            e3.writeSFixed64(t3[r3]);
        }
        function dp(t3, e3) {
          return (t3[e3] | t3[e3 + 1] << 8 | t3[e3 + 2] << 16) + 16777216 * t3[e3 + 3];
        }
        function fp(t3, e3, r3) {
          t3[r3] = e3, t3[r3 + 1] = e3 >>> 8, t3[r3 + 2] = e3 >>> 16, t3[r3 + 3] = e3 >>> 24;
        }
        function yp(t3, e3) {
          return (t3[e3] | t3[e3 + 1] << 8 | t3[e3 + 2] << 16) + (t3[e3 + 3] << 24);
        }
        Yh.prototype = { destroy: function() {
          this.buf = null;
        }, readFields: function(t3, e3, r3) {
          for (r3 = r3 || this.length; this.pos < r3; ) {
            var n3 = this.readVarint(), i3 = n3 >> 3, s3 = this.pos;
            this.type = 7 & n3, t3(i3, e3, this), this.pos === s3 && this.skip(n3);
          }
          return e3;
        }, readMessage: function(t3, e3) {
          return this.readFields(t3, e3, this.readVarint() + this.pos);
        }, readFixed32: function() {
          var t3 = dp(this.buf, this.pos);
          return this.pos += 4, t3;
        }, readSFixed32: function() {
          var t3 = yp(this.buf, this.pos);
          return this.pos += 4, t3;
        }, readFixed64: function() {
          var t3 = dp(this.buf, this.pos) + dp(this.buf, this.pos + 4) * Wh;
          return this.pos += 8, t3;
        }, readSFixed64: function() {
          var t3 = dp(this.buf, this.pos) + yp(this.buf, this.pos + 4) * Wh;
          return this.pos += 8, t3;
        }, readFloat: function() {
          var t3 = Jh(this.buf, this.pos, true, 23, 4);
          return this.pos += 4, t3;
        }, readDouble: function() {
          var t3 = Jh(this.buf, this.pos, true, 52, 8);
          return this.pos += 8, t3;
        }, readVarint: function(t3) {
          var e3, r3, n3 = this.buf;
          return e3 = 127 & (r3 = n3[this.pos++]), r3 < 128 ? e3 : (e3 |= (127 & (r3 = n3[this.pos++])) << 7, r3 < 128 ? e3 : (e3 |= (127 & (r3 = n3[this.pos++])) << 14, r3 < 128 ? e3 : (e3 |= (127 & (r3 = n3[this.pos++])) << 21, r3 < 128 ? e3 : function(t4, e4, r4) {
            var n4, i3, s3 = r4.buf;
            if (n4 = (112 & (i3 = s3[r4.pos++])) >> 4, i3 < 128)
              return rp(t4, n4, e4);
            if (n4 |= (127 & (i3 = s3[r4.pos++])) << 3, i3 < 128)
              return rp(t4, n4, e4);
            if (n4 |= (127 & (i3 = s3[r4.pos++])) << 10, i3 < 128)
              return rp(t4, n4, e4);
            if (n4 |= (127 & (i3 = s3[r4.pos++])) << 17, i3 < 128)
              return rp(t4, n4, e4);
            if (n4 |= (127 & (i3 = s3[r4.pos++])) << 24, i3 < 128)
              return rp(t4, n4, e4);
            if (n4 |= (1 & (i3 = s3[r4.pos++])) << 31, i3 < 128)
              return rp(t4, n4, e4);
            throw new Error("Expected varint not more than 10 bytes");
          }(e3 |= (15 & (r3 = n3[this.pos])) << 28, t3, this))));
        }, readVarint64: function() {
          return this.readVarint(true);
        }, readSVarint: function() {
          var t3 = this.readVarint();
          return t3 % 2 == 1 ? (t3 + 1) / -2 : t3 / 2;
        }, readBoolean: function() {
          return Boolean(this.readVarint());
        }, readString: function() {
          var t3 = this.readVarint() + this.pos, e3 = this.pos;
          return this.pos = t3, t3 - e3 >= 12 && tp ? function(t4, e4, r3) {
            return tp.decode(t4.subarray(e4, r3));
          }(this.buf, e3, t3) : function(t4, e4, r3) {
            for (var n3 = "", i3 = e4; i3 < r3; ) {
              var s3, a3, o3, l2 = t4[i3], u3 = null, c3 = l2 > 239 ? 4 : l2 > 223 ? 3 : l2 > 191 ? 2 : 1;
              if (i3 + c3 > r3)
                break;
              1 === c3 ? l2 < 128 && (u3 = l2) : 2 === c3 ? 128 == (192 & (s3 = t4[i3 + 1])) && (u3 = (31 & l2) << 6 | 63 & s3) <= 127 && (u3 = null) : 3 === c3 ? (a3 = t4[i3 + 2], 128 == (192 & (s3 = t4[i3 + 1])) && 128 == (192 & a3) && ((u3 = (15 & l2) << 12 | (63 & s3) << 6 | 63 & a3) <= 2047 || u3 >= 55296 && u3 <= 57343) && (u3 = null)) : 4 === c3 && (a3 = t4[i3 + 2], o3 = t4[i3 + 3], 128 == (192 & (s3 = t4[i3 + 1])) && 128 == (192 & a3) && 128 == (192 & o3) && ((u3 = (15 & l2) << 18 | (63 & s3) << 12 | (63 & a3) << 6 | 63 & o3) <= 65535 || u3 >= 1114112) && (u3 = null)), null === u3 ? (u3 = 65533, c3 = 1) : u3 > 65535 && (u3 -= 65536, n3 += String.fromCharCode(u3 >>> 10 & 1023 | 55296), u3 = 56320 | 1023 & u3), n3 += String.fromCharCode(u3), i3 += c3;
            }
            return n3;
          }(this.buf, e3, t3);
        }, readBytes: function() {
          var t3 = this.readVarint() + this.pos, e3 = this.buf.subarray(this.pos, t3);
          return this.pos = t3, e3;
        }, readPackedVarint: function(t3, e3) {
          if (this.type !== Yh.Bytes)
            return t3.push(this.readVarint(e3));
          var r3 = ep(this);
          for (t3 = t3 || []; this.pos < r3; )
            t3.push(this.readVarint(e3));
          return t3;
        }, readPackedSVarint: function(t3) {
          if (this.type !== Yh.Bytes)
            return t3.push(this.readSVarint());
          var e3 = ep(this);
          for (t3 = t3 || []; this.pos < e3; )
            t3.push(this.readSVarint());
          return t3;
        }, readPackedBoolean: function(t3) {
          if (this.type !== Yh.Bytes)
            return t3.push(this.readBoolean());
          var e3 = ep(this);
          for (t3 = t3 || []; this.pos < e3; )
            t3.push(this.readBoolean());
          return t3;
        }, readPackedFloat: function(t3) {
          if (this.type !== Yh.Bytes)
            return t3.push(this.readFloat());
          var e3 = ep(this);
          for (t3 = t3 || []; this.pos < e3; )
            t3.push(this.readFloat());
          return t3;
        }, readPackedDouble: function(t3) {
          if (this.type !== Yh.Bytes)
            return t3.push(this.readDouble());
          var e3 = ep(this);
          for (t3 = t3 || []; this.pos < e3; )
            t3.push(this.readDouble());
          return t3;
        }, readPackedFixed32: function(t3) {
          if (this.type !== Yh.Bytes)
            return t3.push(this.readFixed32());
          var e3 = ep(this);
          for (t3 = t3 || []; this.pos < e3; )
            t3.push(this.readFixed32());
          return t3;
        }, readPackedSFixed32: function(t3) {
          if (this.type !== Yh.Bytes)
            return t3.push(this.readSFixed32());
          var e3 = ep(this);
          for (t3 = t3 || []; this.pos < e3; )
            t3.push(this.readSFixed32());
          return t3;
        }, readPackedFixed64: function(t3) {
          if (this.type !== Yh.Bytes)
            return t3.push(this.readFixed64());
          var e3 = ep(this);
          for (t3 = t3 || []; this.pos < e3; )
            t3.push(this.readFixed64());
          return t3;
        }, readPackedSFixed64: function(t3) {
          if (this.type !== Yh.Bytes)
            return t3.push(this.readSFixed64());
          var e3 = ep(this);
          for (t3 = t3 || []; this.pos < e3; )
            t3.push(this.readSFixed64());
          return t3;
        }, skip: function(t3) {
          var e3 = 7 & t3;
          if (e3 === Yh.Varint)
            for (; this.buf[this.pos++] > 127; )
              ;
          else if (e3 === Yh.Bytes)
            this.pos = this.readVarint() + this.pos;
          else if (e3 === Yh.Fixed32)
            this.pos += 4;
          else {
            if (e3 !== Yh.Fixed64)
              throw new Error("Unimplemented type: " + e3);
            this.pos += 8;
          }
        }, writeTag: function(t3, e3) {
          this.writeVarint(t3 << 3 | e3);
        }, realloc: function(t3) {
          for (var e3 = this.length || 16; e3 < this.pos + t3; )
            e3 *= 2;
          if (e3 !== this.length) {
            var r3 = new Uint8Array(e3);
            r3.set(this.buf), this.buf = r3, this.length = e3;
          }
        }, finish: function() {
          return this.length = this.pos, this.pos = 0, this.buf.subarray(0, this.length);
        }, writeFixed32: function(t3) {
          this.realloc(4), fp(this.buf, t3, this.pos), this.pos += 4;
        }, writeSFixed32: function(t3) {
          this.realloc(4), fp(this.buf, t3, this.pos), this.pos += 4;
        }, writeFixed64: function(t3) {
          this.realloc(8), fp(this.buf, -1 & t3, this.pos), fp(this.buf, Math.floor(t3 * Qh), this.pos + 4), this.pos += 8;
        }, writeSFixed64: function(t3) {
          this.realloc(8), fp(this.buf, -1 & t3, this.pos), fp(this.buf, Math.floor(t3 * Qh), this.pos + 4), this.pos += 8;
        }, writeVarint: function(t3) {
          (t3 = +t3 || 0) > 268435455 || t3 < 0 ? function(t4, e3) {
            var r3, n3;
            if (t4 >= 0 ? (r3 = t4 % 4294967296 | 0, n3 = t4 / 4294967296 | 0) : (n3 = ~(-t4 / 4294967296), 4294967295 ^ (r3 = ~(-t4 % 4294967296)) ? r3 = r3 + 1 | 0 : (r3 = 0, n3 = n3 + 1 | 0)), t4 >= 18446744073709552e3 || t4 < -18446744073709552e3)
              throw new Error("Given varint doesn't fit into 10 bytes");
            e3.realloc(10), function(t5, e4, r4) {
              r4.buf[r4.pos++] = 127 & t5 | 128, t5 >>>= 7, r4.buf[r4.pos++] = 127 & t5 | 128, t5 >>>= 7, r4.buf[r4.pos++] = 127 & t5 | 128, t5 >>>= 7, r4.buf[r4.pos++] = 127 & t5 | 128, r4.buf[r4.pos] = 127 & (t5 >>>= 7);
            }(r3, 0, e3), function(t5, e4) {
              var r4 = (7 & t5) << 4;
              e4.buf[e4.pos++] |= r4 | ((t5 >>>= 3) ? 128 : 0), t5 && (e4.buf[e4.pos++] = 127 & t5 | ((t5 >>>= 7) ? 128 : 0), t5 && (e4.buf[e4.pos++] = 127 & t5 | ((t5 >>>= 7) ? 128 : 0), t5 && (e4.buf[e4.pos++] = 127 & t5 | ((t5 >>>= 7) ? 128 : 0), t5 && (e4.buf[e4.pos++] = 127 & t5 | ((t5 >>>= 7) ? 128 : 0), t5 && (e4.buf[e4.pos++] = 127 & t5)))));
            }(n3, e3);
          }(t3, this) : (this.realloc(4), this.buf[this.pos++] = 127 & t3 | (t3 > 127 ? 128 : 0), t3 <= 127 || (this.buf[this.pos++] = 127 & (t3 >>>= 7) | (t3 > 127 ? 128 : 0), t3 <= 127 || (this.buf[this.pos++] = 127 & (t3 >>>= 7) | (t3 > 127 ? 128 : 0), t3 <= 127 || (this.buf[this.pos++] = t3 >>> 7 & 127))));
        }, writeSVarint: function(t3) {
          this.writeVarint(t3 < 0 ? 2 * -t3 - 1 : 2 * t3);
        }, writeBoolean: function(t3) {
          this.writeVarint(Boolean(t3));
        }, writeString: function(t3) {
          t3 = String(t3), this.realloc(4 * t3.length), this.pos++;
          var e3 = this.pos;
          this.pos = function(t4, e4, r4) {
            for (var n3, i3, s3 = 0; s3 < e4.length; s3++) {
              if ((n3 = e4.charCodeAt(s3)) > 55295 && n3 < 57344) {
                if (!i3) {
                  n3 > 56319 || s3 + 1 === e4.length ? (t4[r4++] = 239, t4[r4++] = 191, t4[r4++] = 189) : i3 = n3;
                  continue;
                }
                if (n3 < 56320) {
                  t4[r4++] = 239, t4[r4++] = 191, t4[r4++] = 189, i3 = n3;
                  continue;
                }
                n3 = i3 - 55296 << 10 | n3 - 56320 | 65536, i3 = null;
              } else
                i3 && (t4[r4++] = 239, t4[r4++] = 191, t4[r4++] = 189, i3 = null);
              n3 < 128 ? t4[r4++] = n3 : (n3 < 2048 ? t4[r4++] = n3 >> 6 | 192 : (n3 < 65536 ? t4[r4++] = n3 >> 12 | 224 : (t4[r4++] = n3 >> 18 | 240, t4[r4++] = n3 >> 12 & 63 | 128), t4[r4++] = n3 >> 6 & 63 | 128), t4[r4++] = 63 & n3 | 128);
            }
            return r4;
          }(this.buf, t3, this.pos);
          var r3 = this.pos - e3;
          r3 >= 128 && np(e3, r3, this), this.pos = e3 - 1, this.writeVarint(r3), this.pos += r3;
        }, writeFloat: function(t3) {
          this.realloc(4), Hh(this.buf, t3, this.pos, true, 23, 4), this.pos += 4;
        }, writeDouble: function(t3) {
          this.realloc(8), Hh(this.buf, t3, this.pos, true, 52, 8), this.pos += 8;
        }, writeBytes: function(t3) {
          var e3 = t3.length;
          this.writeVarint(e3), this.realloc(e3);
          for (var r3 = 0; r3 < e3; r3++)
            this.buf[this.pos++] = t3[r3];
        }, writeRawMessage: function(t3, e3) {
          this.pos++;
          var r3 = this.pos;
          t3(e3, this);
          var n3 = this.pos - r3;
          n3 >= 128 && np(r3, n3, this), this.pos = r3 - 1, this.writeVarint(n3), this.pos += n3;
        }, writeMessage: function(t3, e3, r3) {
          this.writeTag(t3, Yh.Bytes), this.writeRawMessage(e3, r3);
        }, writePackedVarint: function(t3, e3) {
          e3.length && this.writeMessage(t3, ip, e3);
        }, writePackedSVarint: function(t3, e3) {
          e3.length && this.writeMessage(t3, sp, e3);
        }, writePackedBoolean: function(t3, e3) {
          e3.length && this.writeMessage(t3, lp, e3);
        }, writePackedFloat: function(t3, e3) {
          e3.length && this.writeMessage(t3, ap, e3);
        }, writePackedDouble: function(t3, e3) {
          e3.length && this.writeMessage(t3, op, e3);
        }, writePackedFixed32: function(t3, e3) {
          e3.length && this.writeMessage(t3, up, e3);
        }, writePackedSFixed32: function(t3, e3) {
          e3.length && this.writeMessage(t3, cp, e3);
        }, writePackedFixed64: function(t3, e3) {
          e3.length && this.writeMessage(t3, hp, e3);
        }, writePackedSFixed64: function(t3, e3) {
          e3.length && this.writeMessage(t3, pp, e3);
        }, writeBytesField: function(t3, e3) {
          this.writeTag(t3, Yh.Bytes), this.writeBytes(e3);
        }, writeFixed32Field: function(t3, e3) {
          this.writeTag(t3, Yh.Fixed32), this.writeFixed32(e3);
        }, writeSFixed32Field: function(t3, e3) {
          this.writeTag(t3, Yh.Fixed32), this.writeSFixed32(e3);
        }, writeFixed64Field: function(t3, e3) {
          this.writeTag(t3, Yh.Fixed64), this.writeFixed64(e3);
        }, writeSFixed64Field: function(t3, e3) {
          this.writeTag(t3, Yh.Fixed64), this.writeSFixed64(e3);
        }, writeVarintField: function(t3, e3) {
          this.writeTag(t3, Yh.Varint), this.writeVarint(e3);
        }, writeSVarintField: function(t3, e3) {
          this.writeTag(t3, Yh.Varint), this.writeSVarint(e3);
        }, writeStringField: function(t3, e3) {
          this.writeTag(t3, Yh.Bytes), this.writeString(e3);
        }, writeFloatField: function(t3, e3) {
          this.writeTag(t3, Yh.Fixed32), this.writeFloat(e3);
        }, writeDoubleField: function(t3, e3) {
          this.writeTag(t3, Yh.Fixed64), this.writeDouble(e3);
        }, writeBooleanField: function(t3, e3) {
          this.writeVarintField(t3, Boolean(e3));
        } };
        var mp = p2(Xh);
        const gp = 3;
        function xp(t3, e3, r3) {
          e3.glyphs = [], 1 === t3 && r3.readMessage(vp, e3);
        }
        function vp(t3, e3, r3) {
          if (3 === t3) {
            const { id: t4, bitmap: n3, width: i3, height: s3, left: a3, top: o3, advance: l2 } = r3.readMessage(bp, {});
            e3.glyphs.push({ id: t4, bitmap: new Ru({ width: i3 + 2 * gp, height: s3 + 2 * gp }, n3), metrics: { width: i3, height: s3, left: a3, top: o3, advance: l2 } });
          } else
            4 === t3 ? e3.ascender = r3.readSVarint() : 5 === t3 && (e3.descender = r3.readSVarint());
        }
        function bp(t3, e3, r3) {
          1 === t3 ? e3.id = r3.readVarint() : 2 === t3 ? e3.bitmap = r3.readBytes() : 3 === t3 ? e3.width = r3.readVarint() : 4 === t3 ? e3.height = r3.readVarint() : 5 === t3 ? e3.left = r3.readSVarint() : 6 === t3 ? e3.top = r3.readSVarint() : 7 === t3 && (e3.advance = r3.readVarint());
        }
        const wp = gp;
        function _p(t3) {
          let e3 = 0, r3 = 0;
          for (const n4 of t3)
            e3 += n4.w * n4.h, r3 = Math.max(r3, n4.w);
          t3.sort((t4, e4) => e4.h - t4.h);
          const n3 = [{ x: 0, y: 0, w: Math.max(Math.ceil(Math.sqrt(e3 / 0.95)), r3), h: 1 / 0 }];
          let i3 = 0, s3 = 0;
          for (const e4 of t3)
            for (let t4 = n3.length - 1; t4 >= 0; t4--) {
              const r4 = n3[t4];
              if (!(e4.w > r4.w || e4.h > r4.h)) {
                if (e4.x = r4.x, e4.y = r4.y, s3 = Math.max(s3, e4.y + e4.h), i3 = Math.max(i3, e4.x + e4.w), e4.w === r4.w && e4.h === r4.h) {
                  const e5 = n3.pop();
                  t4 < n3.length && (n3[t4] = e5);
                } else
                  e4.h === r4.h ? (r4.x += e4.w, r4.w -= e4.w) : e4.w === r4.w ? (r4.y += e4.h, r4.h -= e4.h) : (n3.push({ x: r4.x + e4.w, y: r4.y, w: r4.w - e4.w, h: e4.h }), r4.y += e4.h, r4.h -= e4.h);
                break;
              }
            }
          return { w: i3, h: s3, fill: e3 / (i3 * s3) || 0 };
        }
        const Ap = 1;
        class Sp {
          constructor(t3, { pixelRatio: e3, version: r3, stretchX: n3, stretchY: i3, content: s3 }) {
            this.paddedRect = t3, this.pixelRatio = e3, this.stretchX = n3, this.stretchY = i3, this.content = s3, this.version = r3;
          }
          get tl() {
            return [this.paddedRect.x + Ap, this.paddedRect.y + Ap];
          }
          get br() {
            return [this.paddedRect.x + this.paddedRect.w - Ap, this.paddedRect.y + this.paddedRect.h - Ap];
          }
          get displaySize() {
            return [(this.paddedRect.w - 2 * Ap) / this.pixelRatio, (this.paddedRect.h - 2 * Ap) / this.pixelRatio];
          }
        }
        class kp {
          constructor(t3, e3) {
            const r3 = {}, n3 = {};
            this.haveRenderCallbacks = [];
            const i3 = [];
            this.addImages(t3, r3, i3), this.addImages(e3, n3, i3);
            const { w: s3, h: a3 } = _p(i3), o3 = new Uu({ width: s3 || 1, height: a3 || 1 });
            for (const e4 in t3) {
              const n4 = t3[e4], i4 = r3[e4].paddedRect;
              Uu.copy(n4.data, o3, { x: 0, y: 0 }, { x: i4.x + Ap, y: i4.y + Ap }, n4.data);
            }
            for (const t4 in e3) {
              const r4 = e3[t4], i4 = n3[t4].paddedRect, s4 = i4.x + Ap, a4 = i4.y + Ap, l2 = r4.data.width, u3 = r4.data.height;
              Uu.copy(r4.data, o3, { x: 0, y: 0 }, { x: s4, y: a4 }, r4.data), Uu.copy(r4.data, o3, { x: 0, y: u3 - 1 }, { x: s4, y: a4 - 1 }, { width: l2, height: 1 }), Uu.copy(r4.data, o3, { x: 0, y: 0 }, { x: s4, y: a4 + u3 }, { width: l2, height: 1 }), Uu.copy(r4.data, o3, { x: l2 - 1, y: 0 }, { x: s4 - 1, y: a4 }, { width: 1, height: u3 }), Uu.copy(r4.data, o3, { x: 0, y: 0 }, { x: s4 + l2, y: a4 }, { width: 1, height: u3 });
            }
            this.image = o3, this.iconPositions = r3, this.patternPositions = n3;
          }
          addImages(t3, e3, r3) {
            for (const n3 in t3) {
              const i3 = t3[n3], s3 = { x: 0, y: 0, w: i3.data.width + 2 * Ap, h: i3.data.height + 2 * Ap };
              r3.push(s3), e3[n3] = new Sp(s3, i3), i3.hasRenderCallback && this.haveRenderCallbacks.push(n3);
            }
          }
          patchUpdatedImages(t3, e3) {
            this.haveRenderCallbacks = this.haveRenderCallbacks.filter((e4) => t3.hasImage(e4)), t3.dispatchRenderCallbacks(this.haveRenderCallbacks);
            for (const r3 in t3.updatedImages)
              this.patchUpdatedImage(this.iconPositions[r3], t3.getImage(r3), e3), this.patchUpdatedImage(this.patternPositions[r3], t3.getImage(r3), e3);
          }
          patchUpdatedImage(t3, e3, r3) {
            if (!t3 || !e3)
              return;
            if (t3.version === e3.version)
              return;
            t3.version = e3.version;
            const [n3, i3] = t3.tl;
            r3.update(e3.data, void 0, { x: n3, y: i3 });
          }
        }
        Ji(Sp, "ImagePosition"), Ji(kp, "ImageAtlas");
        const Ip = { horizontal: 1, vertical: 2, horizontalOnly: 3 }, Mp = -17;
        class Tp {
          constructor() {
            this.scale = 1, this.fontStack = "", this.imageName = null;
          }
          static forText(t3, e3) {
            const r3 = new Tp();
            return r3.scale = t3 || 1, r3.fontStack = e3, r3;
          }
          static forImage(t3) {
            const e3 = new Tp();
            return e3.imageName = t3, e3;
          }
        }
        class zp {
          constructor() {
            this.text = "", this.sectionIndex = [], this.sections = [], this.imageSectionID = null;
          }
          static fromFeature(t3, e3) {
            const r3 = new zp();
            for (let n3 = 0; n3 < t3.sections.length; n3++) {
              const i3 = t3.sections[n3];
              i3.image ? r3.addImageSection(i3) : r3.addTextSection(i3, e3);
            }
            return r3;
          }
          length() {
            return this.text.length;
          }
          getSection(t3) {
            return this.sections[this.sectionIndex[t3]];
          }
          getSections() {
            return this.sections;
          }
          getSectionIndex(t3) {
            return this.sectionIndex[t3];
          }
          getCharCode(t3) {
            return this.text.charCodeAt(t3);
          }
          verticalizePunctuation(t3) {
            this.text = function(t4, e3) {
              let r3 = "";
              for (let n3 = 0; n3 < t4.length; n3++) {
                const i3 = t4.charCodeAt(n3 + 1) || null, s3 = t4.charCodeAt(n3 - 1) || null;
                r3 += !e3 && (i3 && ss(i3) && !Gh[t4[n3 + 1]] || s3 && ss(s3) && !Gh[t4[n3 - 1]]) || !Gh[t4[n3]] ? t4[n3] : Gh[t4[n3]];
              }
              return r3;
            }(this.text, t3);
          }
          trim() {
            let t3 = 0;
            for (let e4 = 0; e4 < this.text.length && Ep[this.text.charCodeAt(e4)]; e4++)
              t3++;
            let e3 = this.text.length;
            for (let r3 = this.text.length - 1; r3 >= 0 && r3 >= t3 && Ep[this.text.charCodeAt(r3)]; r3--)
              e3--;
            this.text = this.text.substring(t3, e3), this.sectionIndex = this.sectionIndex.slice(t3, e3);
          }
          substring(t3, e3) {
            const r3 = new zp();
            return r3.text = this.text.substring(t3, e3), r3.sectionIndex = this.sectionIndex.slice(t3, e3), r3.sections = this.sections, r3;
          }
          toString() {
            return this.text;
          }
          getMaxScale() {
            return this.sectionIndex.reduce((t3, e3) => Math.max(t3, this.sections[e3].scale), 0);
          }
          addTextSection(t3, e3) {
            this.text += t3.text, this.sections.push(Tp.forText(t3.scale, t3.fontStack || e3));
            const r3 = this.sections.length - 1;
            for (let e4 = 0; e4 < t3.text.length; ++e4)
              this.sectionIndex.push(r3);
          }
          addImageSection(t3) {
            const e3 = t3.image ? t3.image.name : "";
            if (0 === e3.length)
              return void N("Can't add FormattedSection with an empty image.");
            const r3 = this.getNextImageSectionCharCode();
            r3 ? (this.text += String.fromCharCode(r3), this.sections.push(Tp.forImage(e3)), this.sectionIndex.push(this.sections.length - 1)) : N("Reached maximum number of images 6401");
          }
          getNextImageSectionCharCode() {
            return this.imageSectionID ? this.imageSectionID >= 63743 ? null : ++this.imageSectionID : (this.imageSectionID = 57344, this.imageSectionID);
          }
        }
        function Bp(t3, e3, r3, n3, i3, s3, a3, o3, l2, u3, c3, h3, p3, d3, f3) {
          const y3 = zp.fromFeature(t3, i3);
          h3 === Ip.vertical && y3.verticalizePunctuation(p3);
          let m3 = [];
          const g3 = function(t4, e4, r4, n4, i4, s4) {
            if (!t4)
              return [];
            const a4 = [], o4 = function(t5, e5, r5, n5, i5, s5) {
              let a5 = 0;
              for (let r6 = 0; r6 < t5.length(); r6++) {
                const o5 = t5.getSection(r6);
                a5 += Pp(t5.getCharCode(r6), o5, n5, i5, e5, s5);
              }
              return a5 / Math.max(1, Math.ceil(a5 / r5));
            }(t4, e4, r4, n4, i4, s4), l3 = t4.text.indexOf("\u200B") >= 0;
            let u4 = 0;
            for (let r5 = 0; r5 < t4.length(); r5++) {
              const h4 = t4.getSection(r5), p4 = t4.getCharCode(r5);
              if (Ep[p4] || (u4 += Pp(p4, h4, n4, i4, e4, s4)), r5 < t4.length() - 1) {
                const e5 = !((c4 = p4) < 11904 || !(ts["Bopomofo Extended"](c4) || ts.Bopomofo(c4) || ts["CJK Compatibility Forms"](c4) || ts["CJK Compatibility Ideographs"](c4) || ts["CJK Compatibility"](c4) || ts["CJK Radicals Supplement"](c4) || ts["CJK Strokes"](c4) || ts["CJK Symbols and Punctuation"](c4) || ts["CJK Unified Ideographs Extension A"](c4) || ts["CJK Unified Ideographs"](c4) || ts["Enclosed CJK Letters and Months"](c4) || ts["Halfwidth and Fullwidth Forms"](c4) || ts.Hiragana(c4) || ts["Ideographic Description Characters"](c4) || ts["Kangxi Radicals"](c4) || ts["Katakana Phonetic Extensions"](c4) || ts.Katakana(c4) || ts["Vertical Forms"](c4) || ts["Yi Radicals"](c4) || ts["Yi Syllables"](c4)));
                (Cp[p4] || e5 || h4.imageName) && a4.push(Lp(r5 + 1, u4, o4, a4, Vp(p4, t4.getCharCode(r5 + 1), e5 && l3), false));
              }
            }
            var c4;
            return Fp(Lp(t4.length(), u4, o4, a4, 0, true));
          }(y3, u3, s3, e3, n3, d3), { processBidirectionalText: x3, processStyledBidirectionalText: v3 } = bs;
          if (x3 && 1 === y3.sections.length) {
            const t4 = x3(y3.toString(), g3);
            for (const e4 of t4) {
              const t5 = new zp();
              t5.text = e4, t5.sections = y3.sections;
              for (let r4 = 0; r4 < e4.length; r4++)
                t5.sectionIndex.push(0);
              m3.push(t5);
            }
          } else if (v3) {
            const t4 = v3(y3.text, y3.sectionIndex, g3);
            for (const e4 of t4) {
              const t5 = new zp();
              t5.text = e4[0], t5.sectionIndex = e4[1], t5.sections = y3.sections, m3.push(t5);
            }
          } else
            m3 = function(t4, e4) {
              const r4 = [], n4 = t4.text;
              let i4 = 0;
              for (const n5 of e4)
                r4.push(t4.substring(i4, n5)), i4 = n5;
              return i4 < n4.length && r4.push(t4.substring(i4, n4.length)), r4;
            }(y3, g3);
          const b2 = [], w2 = { positionedLines: b2, text: y3.toString(), top: c3[1], bottom: c3[1], left: c3[0], right: c3[0], writingMode: h3, iconsInText: false, verticalizable: false, hasBaseline: false };
          return function(t4, e4, r4, n4, i4, s4, a4, o4, l3, u4, c4, h4) {
            let p4 = 0, d4 = 0, f4 = 0;
            const y4 = "right" === o4 ? 1 : "left" === o4 ? 0 : 0.5;
            let m4 = false;
            for (const t5 of i4) {
              const r5 = t5.getSections();
              for (const t6 of r5) {
                if (t6.imageName)
                  continue;
                const r6 = e4[t6.fontStack];
                if (r6 && (m4 = void 0 !== r6.ascender && void 0 !== r6.descender, !m4))
                  break;
              }
              if (!m4)
                break;
            }
            let g4 = 0;
            for (const a5 of i4) {
              a5.trim();
              const i5 = a5.getMaxScale(), o5 = (i5 - 1) * Rh, v5 = { positionedGlyphs: [], lineOffset: 0 };
              t4.positionedLines[g4] = v5;
              const b4 = v5.positionedGlyphs;
              let w4 = 0;
              if (!a5.length()) {
                d4 += s4, ++g4;
                continue;
              }
              let _2 = 0, A2 = 0;
              for (let s5 = 0; s5 < a5.length(); s5++) {
                const o6 = a5.getSection(s5), f5 = a5.getSectionIndex(s5), y5 = a5.getCharCode(s5);
                let g5 = o6.scale, v6 = null, S3 = null, k2 = null, I2 = Rh, M2 = 0;
                const T2 = !(l3 === Ip.horizontal || !c4 && !is(y5) || c4 && (Ep[y5] || (x4 = y5, ts.Arabic(x4) || ts["Arabic Supplement"](x4) || ts["Arabic Extended-A"](x4) || ts["Arabic Presentation Forms-A"](x4) || ts["Arabic Presentation Forms-B"](x4))));
                if (o6.imageName) {
                  const e5 = n4[o6.imageName];
                  if (!e5)
                    continue;
                  k2 = o6.imageName, t4.iconsInText = t4.iconsInText || true, S3 = e5.paddedRect;
                  const r5 = e5.displaySize;
                  g5 = g5 * Rh / h4, v6 = { width: r5[0], height: r5[1], left: Ap, top: -wp, advance: T2 ? r5[1] : r5[0], localGlyph: false }, M2 = m4 ? -v6.height * g5 : Mp + i5 * Rh - r5[1] * g5, I2 = v6.advance;
                  const s6 = (T2 ? r5[0] : r5[1]) * g5 - Rh * i5;
                  s6 > 0 && s6 > w4 && (w4 = s6);
                } else {
                  const t5 = r4[o6.fontStack];
                  if (!t5)
                    continue;
                  t5[y5] && (S3 = t5[y5]);
                  const n5 = e4[o6.fontStack];
                  if (!n5)
                    continue;
                  const s6 = n5.glyphs[y5];
                  if (!s6)
                    continue;
                  if (v6 = s6.metrics, I2 = 8203 !== y5 ? Rh : 0, m4) {
                    const t6 = void 0 !== n5.ascender ? Math.abs(n5.ascender) : 0, e5 = void 0 !== n5.descender ? Math.abs(n5.descender) : 0, r5 = (t6 + e5) * g5;
                    _2 < r5 && (_2 = r5, A2 = (t6 - e5) / 2 * g5), M2 = -t6 * g5;
                  } else
                    M2 = Mp + (i5 - g5) * Rh;
                }
                T2 ? (t4.verticalizable = true, b4.push({ glyph: y5, imageName: k2, x: p4, y: d4 + M2, vertical: T2, scale: g5, localGlyph: v6.localGlyph, fontStack: o6.fontStack, sectionIndex: f5, metrics: v6, rect: S3 }), p4 += I2 * g5 + u4) : (b4.push({ glyph: y5, imageName: k2, x: p4, y: d4 + M2, vertical: T2, scale: g5, localGlyph: v6.localGlyph, fontStack: o6.fontStack, sectionIndex: f5, metrics: v6, rect: S3 }), p4 += v6.advance * g5 + u4);
              }
              0 !== b4.length && (f4 = Math.max(p4 - u4, f4), m4 ? Up(b4, y4, w4, A2, s4 * i5 / 2) : Up(b4, y4, w4, 0, s4 / 2)), p4 = 0;
              const S2 = s4 * i5 + w4;
              v5.lineOffset = Math.max(w4, o5), d4 += S2, ++g4;
            }
            var x4;
            const v4 = d4, { horizontalAlign: b3, verticalAlign: w3 } = Rp(a4);
            (function(t5, e5, r5, n5, i5, s5) {
              const a5 = (e5 - r5) * i5, o5 = -s5 * n5;
              for (const e6 of t5)
                for (const t6 of e6.positionedGlyphs)
                  t6.x += a5, t6.y += o5;
            })(t4.positionedLines, y4, b3, w3, f4, v4), t4.top += -w3 * v4, t4.bottom = t4.top + v4, t4.left += -b3 * f4, t4.right = t4.left + f4, t4.hasBaseline = m4;
          }(w2, e3, r3, n3, m3, a3, o3, l2, h3, u3, p3, f3), !function(t4) {
            for (const e4 of t4)
              if (0 !== e4.positionedGlyphs.length)
                return false;
            return true;
          }(b2) && w2;
        }
        const Ep = { 9: true, 10: true, 11: true, 12: true, 13: true, 32: true }, Cp = { 10: true, 32: true, 38: true, 40: true, 41: true, 43: true, 45: true, 47: true, 173: true, 183: true, 8203: true, 8208: true, 8211: true, 8231: true };
        function Pp(t3, e3, r3, n3, i3, s3) {
          if (e3.imageName) {
            const t4 = n3[e3.imageName];
            return t4 ? t4.displaySize[0] * e3.scale * Rh / s3 + i3 : 0;
          }
          {
            const n4 = r3[e3.fontStack], s4 = n4 && n4.glyphs[t3];
            return s4 ? s4.metrics.advance * e3.scale + i3 : 0;
          }
        }
        function Dp(t3, e3, r3, n3) {
          const i3 = Math.pow(t3 - e3, 2);
          return n3 ? t3 < e3 ? i3 / 2 : 2 * i3 : i3 + Math.abs(r3) * r3;
        }
        function Vp(t3, e3, r3) {
          let n3 = 0;
          return 10 === t3 && (n3 -= 1e4), r3 && (n3 += 150), 40 !== t3 && 65288 !== t3 || (n3 += 50), 41 !== e3 && 65289 !== e3 || (n3 += 50), n3;
        }
        function Lp(t3, e3, r3, n3, i3, s3) {
          let a3 = null, o3 = Dp(e3, r3, i3, s3);
          for (const t4 of n3) {
            const n4 = Dp(e3 - t4.x, r3, i3, s3) + t4.badness;
            n4 <= o3 && (a3 = t4, o3 = n4);
          }
          return { index: t3, x: e3, priorBreak: a3, badness: o3 };
        }
        function Fp(t3) {
          return t3 ? Fp(t3.priorBreak).concat(t3.index) : [];
        }
        function Rp(t3) {
          let e3 = 0.5, r3 = 0.5;
          switch (t3) {
            case "right":
            case "top-right":
            case "bottom-right":
              e3 = 1;
              break;
            case "left":
            case "top-left":
            case "bottom-left":
              e3 = 0;
          }
          switch (t3) {
            case "bottom":
            case "bottom-right":
            case "bottom-left":
              r3 = 1;
              break;
            case "top":
            case "top-right":
            case "top-left":
              r3 = 0;
          }
          return { horizontalAlign: e3, verticalAlign: r3 };
        }
        function Up(t3, e3, r3, n3, i3) {
          if (!(e3 || r3 || n3 || i3))
            return;
          const s3 = t3.length - 1, a3 = t3[s3], o3 = (a3.x + a3.metrics.advance * a3.scale) * e3;
          for (let e4 = 0; e4 <= s3; e4++)
            t3[e4].x -= o3, t3[e4].y += r3 + n3 + i3;
        }
        function $p(t3, e3, r3) {
          const { horizontalAlign: n3, verticalAlign: i3 } = Rp(r3), s3 = e3[0] - t3.displaySize[0] * n3, a3 = e3[1] - t3.displaySize[1] * i3;
          return { image: t3, top: a3, bottom: a3 + t3.displaySize[1], left: s3, right: s3 + t3.displaySize[0] };
        }
        function jp(t3, e3, r3, n3, i3, s3) {
          const a3 = t3.image;
          let o3;
          if (a3.content) {
            const t4 = a3.content, e4 = a3.pixelRatio || 1;
            o3 = [t4[0] / e4, t4[1] / e4, a3.displaySize[0] - t4[2] / e4, a3.displaySize[1] - t4[3] / e4];
          }
          const l2 = e3.left * s3, u3 = e3.right * s3;
          let c3, h3, p3, d3;
          "width" === r3 || "both" === r3 ? (d3 = i3[0] + l2 - n3[3], h3 = i3[0] + u3 + n3[1]) : (d3 = i3[0] + (l2 + u3 - a3.displaySize[0]) / 2, h3 = d3 + a3.displaySize[0]);
          const f3 = e3.top * s3, y3 = e3.bottom * s3;
          return "height" === r3 || "both" === r3 ? (c3 = i3[1] + f3 - n3[0], p3 = i3[1] + y3 + n3[2]) : (c3 = i3[1] + (f3 + y3 - a3.displaySize[1]) / 2, p3 = c3 + a3.displaySize[1]), { image: a3, top: c3, right: h3, bottom: p3, left: d3, collisionPadding: o3 };
        }
        class Op extends x2 {
          constructor(t3, e3, r3, n3, i3) {
            super(t3, e3), this.angle = n3, this.z = r3, void 0 !== i3 && (this.segment = i3);
          }
          clone() {
            return new Op(this.x, this.y, this.z, this.angle, this.segment);
          }
        }
        function qp(t3, e3, r3, n3, i3) {
          if (void 0 === e3.segment)
            return true;
          let s3 = e3, a3 = e3.segment + 1, o3 = 0;
          for (; o3 > -r3 / 2; ) {
            if (a3--, a3 < 0)
              return false;
            o3 -= t3[a3].dist(s3), s3 = t3[a3];
          }
          o3 += t3[a3].dist(t3[a3 + 1]), a3++;
          const l2 = [];
          let u3 = 0;
          for (; o3 < r3 / 2; ) {
            const e4 = t3[a3], r4 = t3[a3 + 1];
            if (!r4)
              return false;
            let s4 = t3[a3 - 1].angleTo(e4) - e4.angleTo(r4);
            for (s4 = Math.abs((s4 + 3 * Math.PI) % (2 * Math.PI) - Math.PI), l2.push({ distance: o3, angleDelta: s4 }), u3 += s4; o3 - l2[0].distance > n3; )
              u3 -= l2.shift().angleDelta;
            if (u3 > i3)
              return false;
            a3++, o3 += e4.dist(r4);
          }
          return true;
        }
        function Np(t3) {
          let e3 = 0;
          for (let r3 = 0; r3 < t3.length - 1; r3++)
            e3 += t3[r3].dist(t3[r3 + 1]);
          return e3;
        }
        function Gp(t3, e3, r3) {
          return t3 ? 0.6 * e3 * r3 : 0;
        }
        function Zp(t3, e3) {
          return Math.max(t3 ? t3.right - t3.left : 0, e3 ? e3.right - e3.left : 0);
        }
        function Kp(t3, e3, r3, n3, i3, s3) {
          const a3 = Gp(r3, i3, s3), o3 = Zp(r3, n3) * s3;
          let l2 = 0;
          const u3 = Np(t3) / 2;
          for (let r4 = 0; r4 < t3.length - 1; r4++) {
            const n4 = t3[r4], i4 = t3[r4 + 1], s4 = n4.dist(i4);
            if (l2 + s4 > u3) {
              const c3 = (u3 - l2) / s4, h3 = Er(n4.x, i4.x, c3), p3 = Er(n4.y, i4.y, c3), d3 = new Op(h3, p3, 0, i4.angleTo(n4), r4);
              return !a3 || qp(t3, d3, o3, a3, e3) ? d3 : void 0;
            }
            l2 += s4;
          }
        }
        function Xp(t3, e3, r3, n3, i3, s3, a3, o3, l2) {
          const u3 = Gp(n3, s3, a3), c3 = Zp(n3, i3), h3 = c3 * a3, p3 = 0 === t3[0].x || t3[0].x === l2 || 0 === t3[0].y || t3[0].y === l2;
          return e3 - h3 < e3 / 4 && (e3 = h3 + e3 / 4), Jp(t3, p3 ? e3 / 2 * o3 % e3 : (c3 / 2 + 2 * s3) * a3 * o3 % e3, e3, u3, r3, h3, p3, false, l2);
        }
        function Jp(t3, e3, r3, n3, i3, s3, a3, o3, l2) {
          const u3 = s3 / 2, c3 = Np(t3);
          let h3 = 0, p3 = e3 - r3, d3 = [];
          for (let e4 = 0; e4 < t3.length - 1; e4++) {
            const a4 = t3[e4], o4 = t3[e4 + 1], f3 = a4.dist(o4), y3 = o4.angleTo(a4);
            for (; p3 + r3 < h3 + f3; ) {
              p3 += r3;
              const m3 = (p3 - h3) / f3, g3 = Er(a4.x, o4.x, m3), x3 = Er(a4.y, o4.y, m3);
              if (g3 >= 0 && g3 < l2 && x3 >= 0 && x3 < l2 && p3 - u3 >= 0 && p3 + u3 <= c3) {
                const r4 = new Op(g3, x3, 0, y3, e4);
                r4._round(), n3 && !qp(t3, r4, s3, n3, i3) || d3.push(r4);
              }
            }
            h3 += f3;
          }
          return o3 || d3.length || a3 || (d3 = Jp(t3, h3 / 2, r3, n3, i3, s3, a3, true, l2)), d3;
        }
        function Hp(t3, e3, r3, n3, i3) {
          const s3 = [];
          for (let a3 = 0; a3 < t3.length; a3++) {
            const o3 = t3[a3];
            let l2;
            for (let t4 = 0; t4 < o3.length - 1; t4++) {
              let a4 = o3[t4], u3 = o3[t4 + 1];
              a4.x < e3 && u3.x < e3 || (a4.x < e3 ? a4 = new x2(e3, a4.y + (e3 - a4.x) / (u3.x - a4.x) * (u3.y - a4.y))._round() : u3.x < e3 && (u3 = new x2(e3, a4.y + (e3 - a4.x) / (u3.x - a4.x) * (u3.y - a4.y))._round()), a4.y < r3 && u3.y < r3 || (a4.y < r3 ? a4 = new x2(a4.x + (r3 - a4.y) / (u3.y - a4.y) * (u3.x - a4.x), r3)._round() : u3.y < r3 && (u3 = new x2(a4.x + (r3 - a4.y) / (u3.y - a4.y) * (u3.x - a4.x), r3)._round()), a4.x >= n3 && u3.x >= n3 || (a4.x >= n3 ? a4 = new x2(n3, a4.y + (n3 - a4.x) / (u3.x - a4.x) * (u3.y - a4.y))._round() : u3.x >= n3 && (u3 = new x2(n3, a4.y + (n3 - a4.x) / (u3.x - a4.x) * (u3.y - a4.y))._round()), a4.y >= i3 && u3.y >= i3 || (a4.y >= i3 ? a4 = new x2(a4.x + (i3 - a4.y) / (u3.y - a4.y) * (u3.x - a4.x), i3)._round() : u3.y >= i3 && (u3 = new x2(a4.x + (i3 - a4.y) / (u3.y - a4.y) * (u3.x - a4.x), i3)._round()), l2 && a4.equals(l2[l2.length - 1]) || (l2 = [a4], s3.push(l2)), l2.push(u3)))));
            }
          }
          return s3;
        }
        Ji(Op, "Anchor");
        const Yp = 1e20;
        function Wp(t3, e3, r3, n3, i3, s3, a3, o3, l2) {
          for (let u3 = e3; u3 < e3 + n3; u3++)
            Qp(t3, r3 * s3 + u3, s3, i3, a3, o3, l2);
          for (let u3 = r3; u3 < r3 + i3; u3++)
            Qp(t3, u3 * s3 + e3, 1, n3, a3, o3, l2);
        }
        function Qp(t3, e3, r3, n3, i3, s3, a3) {
          s3[0] = 0, a3[0] = -Yp, a3[1] = Yp, i3[0] = t3[e3];
          for (let o3 = 1, l2 = 0, u3 = 0; o3 < n3; o3++) {
            i3[o3] = t3[e3 + o3 * r3];
            const n4 = o3 * o3;
            do {
              const t4 = s3[l2];
              u3 = (i3[o3] - i3[t4] + n4 - t4 * t4) / (o3 - t4) / 2;
            } while (u3 <= a3[l2] && --l2 > -1);
            l2++, s3[l2] = o3, a3[l2] = u3, a3[l2 + 1] = Yp;
          }
          for (let o3 = 0, l2 = 0; o3 < n3; o3++) {
            for (; a3[l2 + 1] < o3; )
              l2++;
            const n4 = s3[l2], u3 = o3 - n4;
            t3[e3 + o3 * r3] = i3[n4] + u3 * u3;
          }
        }
        const td = 2, ed = { none: 0, ideographs: 1, all: 2 };
        class rd {
          constructor(t3, e3, r3) {
            this.requestManager = t3, this.localGlyphMode = e3, this.localFontFamily = r3, this.entries = {}, this.localGlyphs = { 200: {}, 400: {}, 500: {}, 900: {} };
          }
          setURL(t3) {
            this.url = t3;
          }
          getGlyphs(t3, e3) {
            const r3 = [];
            for (const e4 in t3)
              for (const n3 of t3[e4])
                r3.push({ stack: e4, id: n3 });
            B(r3, ({ stack: t4, id: e4 }, r4) => {
              let n3 = this.entries[t4];
              n3 || (n3 = this.entries[t4] = { glyphs: {}, requests: {}, ranges: {}, ascender: void 0, descender: void 0 });
              let i3 = n3.glyphs[e4];
              if (void 0 !== i3)
                return void r4(null, { stack: t4, id: e4, glyph: i3 });
              if (i3 = this._tinySDF(n3, t4, e4), i3)
                return n3.glyphs[e4] = i3, void r4(null, { stack: t4, id: e4, glyph: i3 });
              const s3 = Math.floor(e4 / 256);
              if (256 * s3 > 65535)
                return void r4(new Error("glyphs > 65535 not supported"));
              if (n3.ranges[s3])
                return void r4(null, { stack: t4, id: e4, glyph: i3 });
              let a3 = n3.requests[s3];
              a3 || (a3 = n3.requests[s3] = [], rd.loadGlyphRange(t4, s3, this.url, this.requestManager, (t5, e5) => {
                if (e5) {
                  n3.ascender = e5.ascender, n3.descender = e5.descender;
                  for (const t6 in e5.glyphs)
                    this._doesCharSupportLocalGlyph(+t6) || (n3.glyphs[+t6] = e5.glyphs[+t6]);
                  n3.ranges[s3] = true;
                }
                for (const r5 of a3)
                  r5(t5, e5);
                delete n3.requests[s3];
              })), a3.push((n4, i4) => {
                n4 ? r4(n4) : i4 && r4(null, { stack: t4, id: e4, glyph: i4.glyphs[e4] || null });
              });
            }, (t4, r4) => {
              if (t4)
                e3(t4);
              else if (r4) {
                const t5 = {};
                for (const { stack: e4, id: n3, glyph: i3 } of r4)
                  void 0 === t5[e4] && (t5[e4] = {}), void 0 === t5[e4].glyphs && (t5[e4].glyphs = {}), t5[e4].glyphs[n3] = i3 && { id: i3.id, bitmap: i3.bitmap.clone(), metrics: i3.metrics }, t5[e4].ascender = this.entries[e4].ascender, t5[e4].descender = this.entries[e4].descender;
                e3(null, t5);
              }
            });
          }
          _doesCharSupportLocalGlyph(t3) {
            return this.localGlyphMode !== ed.none && (this.localGlyphMode === ed.all ? !!this.localFontFamily : !!this.localFontFamily && (ts["CJK Unified Ideographs"](t3) || ts["Hangul Syllables"](t3) || ts.Hiragana(t3) || ts.Katakana(t3) || ts["CJK Symbols and Punctuation"](t3)));
          }
          _tinySDF(t3, e3, r3) {
            const n3 = this.localFontFamily;
            if (!n3 || !this._doesCharSupportLocalGlyph(r3))
              return;
            let i3 = t3.tinySDF;
            if (!i3) {
              let r4 = "400";
              /bold/i.test(e3) ? r4 = "900" : /medium/i.test(e3) ? r4 = "500" : /light/i.test(e3) && (r4 = "200"), i3 = t3.tinySDF = new rd.TinySDF({ fontFamily: n3, fontWeight: r4, fontSize: 24 * td, buffer: 3 * td, radius: 8 * td }), i3.fontWeight = r4;
            }
            if (this.localGlyphs[i3.fontWeight][r3])
              return this.localGlyphs[i3.fontWeight][r3];
            const s3 = String.fromCharCode(r3), { data: a3, width: o3, height: l2, glyphWidth: u3, glyphHeight: c3, glyphLeft: h3, glyphTop: p3, glyphAdvance: d3 } = i3.draw(s3);
            return this.localGlyphs[i3.fontWeight][r3] = { id: r3, bitmap: new Ru({ width: o3, height: l2 }, a3), metrics: { width: u3 / td, height: c3 / td, left: h3 / td, top: p3 / td - 27, advance: d3 / td, localGlyph: true } };
          }
        }
        rd.loadGlyphRange = function(t3, e3, r3, n3, i3) {
          const s3 = 256 * e3, a3 = s3 + 255, o3 = n3.transformRequest(n3.normalizeGlyphsURL(r3).replace("{fontstack}", t3).replace("{range}", `${s3}-${a3}`), lt.Glyphs);
          pt(o3, (t4, e4) => {
            if (t4)
              i3(t4);
            else if (e4) {
              const t5 = {}, r4 = function(t6) {
                return new mp(t6).readFields(xp, {});
              }(e4);
              for (const e5 of r4.glyphs)
                t5[e5.id] = e5;
              i3(null, { glyphs: t5, ascender: r4.ascender, descender: r4.descender });
            }
          });
        }, rd.TinySDF = class {
          constructor({ fontSize: t3 = 24, buffer: e3 = 3, radius: r3 = 8, cutoff: n3 = 0.25, fontFamily: i3 = "sans-serif", fontWeight: s3 = "normal", fontStyle: a3 = "normal" } = {}) {
            this.buffer = e3, this.cutoff = n3, this.radius = r3;
            const o3 = this.size = t3 + 4 * e3, l2 = this._createCanvas(o3), u3 = this.ctx = l2.getContext("2d", { willReadFrequently: true });
            u3.font = `${a3} ${s3} ${t3}px ${i3}`, u3.textBaseline = "alphabetic", u3.textAlign = "left", u3.fillStyle = "black", this.gridOuter = new Float64Array(o3 * o3), this.gridInner = new Float64Array(o3 * o3), this.f = new Float64Array(o3), this.z = new Float64Array(o3 + 1), this.v = new Uint16Array(o3);
          }
          _createCanvas(t3) {
            const e3 = document.createElement("canvas");
            return e3.width = e3.height = t3, e3;
          }
          draw(t3) {
            const { width: e3, actualBoundingBoxAscent: r3, actualBoundingBoxDescent: n3, actualBoundingBoxLeft: i3, actualBoundingBoxRight: s3 } = this.ctx.measureText(t3), a3 = Math.ceil(r3), o3 = Math.max(0, Math.min(this.size - this.buffer, Math.ceil(s3 - i3))), l2 = Math.min(this.size - this.buffer, a3 + Math.ceil(n3)), u3 = o3 + 2 * this.buffer, c3 = l2 + 2 * this.buffer, h3 = Math.max(u3 * c3, 0), p3 = new Uint8ClampedArray(h3), d3 = { data: p3, width: u3, height: c3, glyphWidth: o3, glyphHeight: l2, glyphTop: a3, glyphLeft: 0, glyphAdvance: e3 };
            if (0 === o3 || 0 === l2)
              return d3;
            const { ctx: f3, buffer: y3, gridInner: m3, gridOuter: g3 } = this;
            f3.clearRect(y3, y3, o3, l2), f3.fillText(t3, y3, y3 + a3);
            const x3 = f3.getImageData(y3, y3, o3, l2);
            g3.fill(Yp, 0, h3), m3.fill(0, 0, h3);
            for (let t4 = 0; t4 < l2; t4++)
              for (let e4 = 0; e4 < o3; e4++) {
                const r4 = x3.data[4 * (t4 * o3 + e4) + 3] / 255;
                if (0 === r4)
                  continue;
                const n4 = (t4 + y3) * u3 + e4 + y3;
                if (1 === r4)
                  g3[n4] = 0, m3[n4] = Yp;
                else {
                  const t5 = 0.5 - r4;
                  g3[n4] = t5 > 0 ? t5 * t5 : 0, m3[n4] = t5 < 0 ? t5 * t5 : 0;
                }
              }
            Wp(g3, 0, 0, u3, c3, u3, this.f, this.v, this.z), Wp(m3, y3, y3, o3, l2, u3, this.f, this.v, this.z);
            for (let t4 = 0; t4 < h3; t4++) {
              const e4 = Math.sqrt(g3[t4]) - Math.sqrt(m3[t4]);
              p3[t4] = Math.round(255 - 255 * (e4 / this.radius + this.cutoff));
            }
            return d3;
          }
        };
        const nd = Ap;
        function id2(t3, e3, r3, n3) {
          const i3 = [], s3 = t3.image, a3 = s3.pixelRatio, o3 = s3.paddedRect.w - 2 * nd, l2 = s3.paddedRect.h - 2 * nd, u3 = t3.right - t3.left, c3 = t3.bottom - t3.top, h3 = s3.stretchX || [[0, o3]], p3 = s3.stretchY || [[0, l2]], d3 = (t4, e4) => t4 + e4[1] - e4[0], f3 = h3.reduce(d3, 0), y3 = p3.reduce(d3, 0), m3 = o3 - f3, g3 = l2 - y3;
          let v3 = 0, b2 = f3, w2 = 0, _2 = y3, A2 = 0, S2 = m3, k2 = 0, I2 = g3;
          if (s3.content && n3) {
            const t4 = s3.content;
            v3 = sd(h3, 0, t4[0]), w2 = sd(p3, 0, t4[1]), b2 = sd(h3, t4[0], t4[2]), _2 = sd(p3, t4[1], t4[3]), A2 = t4[0] - v3, k2 = t4[1] - w2, S2 = t4[2] - t4[0] - b2, I2 = t4[3] - t4[1] - _2;
          }
          const M2 = (n4, i4, o4, l3) => {
            const h4 = od(n4.stretch - v3, b2, u3, t3.left), p4 = ld(n4.fixed - A2, S2, n4.stretch, f3), d4 = od(i4.stretch - w2, _2, c3, t3.top), m4 = ld(i4.fixed - k2, I2, i4.stretch, y3), g4 = od(o4.stretch - v3, b2, u3, t3.left), M3 = ld(o4.fixed - A2, S2, o4.stretch, f3), T2 = od(l3.stretch - w2, _2, c3, t3.top), z2 = ld(l3.fixed - k2, I2, l3.stretch, y3), B2 = new x2(h4, d4), E3 = new x2(g4, d4), C2 = new x2(g4, T2), P2 = new x2(h4, T2), D2 = new x2(p4 / a3, m4 / a3), V2 = new x2(M3 / a3, z2 / a3), L2 = e3 * Math.PI / 180;
            if (L2) {
              const t4 = Math.sin(L2), e4 = Math.cos(L2), r4 = [e4, -t4, t4, e4];
              B2._matMult(r4), E3._matMult(r4), P2._matMult(r4), C2._matMult(r4);
            }
            const F2 = n4.stretch + n4.fixed, R2 = i4.stretch + i4.fixed;
            return { tl: B2, tr: E3, bl: P2, br: C2, tex: { x: s3.paddedRect.x + nd + F2, y: s3.paddedRect.y + nd + R2, w: o4.stretch + o4.fixed - F2, h: l3.stretch + l3.fixed - R2 }, writingMode: void 0, glyphOffset: [0, 0], sectionIndex: 0, pixelOffsetTL: D2, pixelOffsetBR: V2, minFontScaleX: S2 / a3 / u3, minFontScaleY: I2 / a3 / c3, isSDF: r3 };
          };
          if (n3 && (s3.stretchX || s3.stretchY)) {
            const t4 = ad(h3, m3, f3), e4 = ad(p3, g3, y3);
            for (let r4 = 0; r4 < t4.length - 1; r4++) {
              const n4 = t4[r4], s4 = t4[r4 + 1];
              for (let t5 = 0; t5 < e4.length - 1; t5++)
                i3.push(M2(n4, e4[t5], s4, e4[t5 + 1]));
            }
          } else
            i3.push(M2({ fixed: 0, stretch: -1 }, { fixed: 0, stretch: -1 }, { fixed: 0, stretch: o3 + 1 }, { fixed: 0, stretch: l2 + 1 }));
          return i3;
        }
        function sd(t3, e3, r3) {
          let n3 = 0;
          for (const i3 of t3)
            n3 += Math.max(e3, Math.min(r3, i3[1])) - Math.max(e3, Math.min(r3, i3[0]));
          return n3;
        }
        function ad(t3, e3, r3) {
          const n3 = [{ fixed: -nd, stretch: 0 }];
          for (const [e4, r4] of t3) {
            const t4 = n3[n3.length - 1];
            n3.push({ fixed: e4 - t4.stretch, stretch: t4.stretch }), n3.push({ fixed: e4 - t4.stretch, stretch: t4.stretch + (r4 - e4) });
          }
          return n3.push({ fixed: e3 + nd, stretch: r3 }), n3;
        }
        function od(t3, e3, r3, n3) {
          return t3 / e3 * r3 + n3;
        }
        function ld(t3, e3, r3, n3) {
          return t3 - e3 * r3 / n3;
        }
        function ud(t3, e3, r3, n3) {
          const i3 = e3 + t3.positionedLines[n3].lineOffset;
          return 0 === n3 ? r3 + i3 / 2 : r3 + (i3 + (e3 + t3.positionedLines[n3 - 1].lineOffset)) / 2;
        }
        class cd {
          constructor(t3 = [], e3 = hd) {
            if (this.data = t3, this.length = this.data.length, this.compare = e3, this.length > 0)
              for (let t4 = (this.length >> 1) - 1; t4 >= 0; t4--)
                this._down(t4);
          }
          push(t3) {
            this.data.push(t3), this.length++, this._up(this.length - 1);
          }
          pop() {
            if (0 === this.length)
              return;
            const t3 = this.data[0], e3 = this.data.pop();
            return this.length--, this.length > 0 && (this.data[0] = e3, this._down(0)), t3;
          }
          peek() {
            return this.data[0];
          }
          _up(t3) {
            const { data: e3, compare: r3 } = this, n3 = e3[t3];
            for (; t3 > 0; ) {
              const i3 = t3 - 1 >> 1, s3 = e3[i3];
              if (r3(n3, s3) >= 0)
                break;
              e3[t3] = s3, t3 = i3;
            }
            e3[t3] = n3;
          }
          _down(t3) {
            const { data: e3, compare: r3 } = this, n3 = this.length >> 1, i3 = e3[t3];
            for (; t3 < n3; ) {
              let n4 = 1 + (t3 << 1), s3 = e3[n4];
              const a3 = n4 + 1;
              if (a3 < this.length && r3(e3[a3], s3) < 0 && (n4 = a3, s3 = e3[a3]), r3(s3, i3) >= 0)
                break;
              e3[t3] = s3, t3 = n4;
            }
            e3[t3] = i3;
          }
        }
        function hd(t3, e3) {
          return t3 < e3 ? -1 : t3 > e3 ? 1 : 0;
        }
        function pd(t3, e3 = 1, r3 = false) {
          let n3 = 1 / 0, i3 = 1 / 0, s3 = -1 / 0, a3 = -1 / 0;
          const o3 = t3[0];
          for (let t4 = 0; t4 < o3.length; t4++) {
            const e4 = o3[t4];
            (!t4 || e4.x < n3) && (n3 = e4.x), (!t4 || e4.y < i3) && (i3 = e4.y), (!t4 || e4.x > s3) && (s3 = e4.x), (!t4 || e4.y > a3) && (a3 = e4.y);
          }
          const l2 = Math.min(s3 - n3, a3 - i3);
          let u3 = l2 / 2;
          const c3 = new cd([], dd);
          if (0 === l2)
            return new x2(n3, i3);
          for (let e4 = n3; e4 < s3; e4 += l2)
            for (let r4 = i3; r4 < a3; r4 += l2)
              c3.push(new fd(e4 + u3, r4 + u3, u3, t3));
          let h3 = function(t4) {
            let e4 = 0, r4 = 0, n4 = 0;
            const i4 = t4[0];
            for (let t5 = 0, s4 = i4.length, a4 = s4 - 1; t5 < s4; a4 = t5++) {
              const s5 = i4[t5], o4 = i4[a4], l3 = s5.x * o4.y - o4.x * s5.y;
              r4 += (s5.x + o4.x) * l3, n4 += (s5.y + o4.y) * l3, e4 += 3 * l3;
            }
            return new fd(r4 / e4, n4 / e4, 0, t4);
          }(t3), p3 = c3.length;
          for (; c3.length; ) {
            const n4 = c3.pop();
            (n4.d > h3.d || !h3.d) && (h3 = n4, r3 && console.log("found best %d after %d probes", Math.round(1e4 * n4.d) / 1e4, p3)), n4.max - h3.d <= e3 || (u3 = n4.h / 2, c3.push(new fd(n4.p.x - u3, n4.p.y - u3, u3, t3)), c3.push(new fd(n4.p.x + u3, n4.p.y - u3, u3, t3)), c3.push(new fd(n4.p.x - u3, n4.p.y + u3, u3, t3)), c3.push(new fd(n4.p.x + u3, n4.p.y + u3, u3, t3)), p3 += 4);
          }
          return r3 && (console.log(`num probes: ${p3}`), console.log(`best distance: ${h3.d}`)), h3.p;
        }
        function dd(t3, e3) {
          return e3.max - t3.max;
        }
        class fd {
          constructor(t3, e3, r3, n3) {
            this.p = new x2(t3, e3), this.h = r3, this.d = function(t4, e4) {
              let r4 = false, n4 = 1 / 0;
              for (let i3 = 0; i3 < e4.length; i3++) {
                const s3 = e4[i3];
                for (let e5 = 0, i4 = s3.length, a3 = i4 - 1; e5 < i4; a3 = e5++) {
                  const i5 = s3[e5], o3 = s3[a3];
                  i5.y > t4.y != o3.y > t4.y && t4.x < (o3.x - i5.x) * (t4.y - i5.y) / (o3.y - i5.y) + i5.x && (r4 = !r4), n4 = Math.min(n4, xu(t4, i5, o3));
                }
              }
              return (r4 ? 1 : -1) * Math.sqrt(n4);
            }(this.p, n3), this.max = this.d + this.h * Math.SQRT2;
          }
        }
        const yd = 7, md = Number.POSITIVE_INFINITY, gd = Math.sqrt(2);
        function xd(t3, [e3, r3]) {
          let n3 = 0, i3 = 0;
          if (r3 === md) {
            e3 < 0 && (e3 = 0);
            const r4 = e3 / gd;
            switch (t3) {
              case "top-right":
              case "top-left":
                i3 = r4 - yd;
                break;
              case "bottom-right":
              case "bottom-left":
                i3 = -r4 + yd;
                break;
              case "bottom":
                i3 = -e3 + yd;
                break;
              case "top":
                i3 = e3 - yd;
            }
            switch (t3) {
              case "top-right":
              case "bottom-right":
                n3 = -r4;
                break;
              case "top-left":
              case "bottom-left":
                n3 = r4;
                break;
              case "left":
                n3 = e3;
                break;
              case "right":
                n3 = -e3;
            }
          } else {
            switch (e3 = Math.abs(e3), r3 = Math.abs(r3), t3) {
              case "top-right":
              case "top-left":
              case "top":
                i3 = r3 - yd;
                break;
              case "bottom-right":
              case "bottom-left":
              case "bottom":
                i3 = -r3 + yd;
            }
            switch (t3) {
              case "top-right":
              case "bottom-right":
              case "right":
                n3 = -e3;
                break;
              case "top-left":
              case "bottom-left":
              case "left":
                n3 = e3;
            }
          }
          return [n3, i3];
        }
        function vd(t3, e3, r3, n3, i3, s3, a3, o3, l2, u3) {
          t3.createArrays(), t3.tilePixelRatio = ao / (512 * t3.overscaling), t3.compareText = {}, t3.iconsNeedLinear = false;
          const c3 = t3.layers[0].layout, h3 = t3.layers[0]._unevaluatedLayout._values, p3 = {};
          if ("composite" === t3.textSizeData.kind) {
            const { minZoom: e4, maxZoom: r4 } = t3.textSizeData;
            p3.compositeTextSizes = [h3["text-size"].possiblyEvaluate(new ws(e4), o3), h3["text-size"].possiblyEvaluate(new ws(r4), o3)];
          }
          if ("composite" === t3.iconSizeData.kind) {
            const { minZoom: e4, maxZoom: r4 } = t3.iconSizeData;
            p3.compositeIconSizes = [h3["icon-size"].possiblyEvaluate(new ws(e4), o3), h3["icon-size"].possiblyEvaluate(new ws(r4), o3)];
          }
          p3.layoutTextSize = h3["text-size"].possiblyEvaluate(new ws(l2 + 1), o3), p3.layoutIconSize = h3["icon-size"].possiblyEvaluate(new ws(l2 + 1), o3), p3.textMaxSize = h3["text-size"].possiblyEvaluate(new ws(18), o3);
          const d3 = "map" === c3.get("text-rotation-alignment") && "point" !== c3.get("symbol-placement"), f3 = c3.get("text-size");
          for (const s4 of t3.features) {
            const l3 = c3.get("text-font").evaluate(s4, {}, o3).join(","), h4 = f3.evaluate(s4, {}, o3), y3 = p3.layoutTextSize.evaluate(s4, {}, o3), m3 = (p3.layoutIconSize.evaluate(s4, {}, o3), { horizontal: {}, vertical: void 0 }), g3 = s4.text;
            let x3, v3 = [0, 0];
            if (g3) {
              const n4 = g3.toString(), a4 = c3.get("text-letter-spacing").evaluate(s4, {}, o3) * Rh, u4 = c3.get("text-line-height").evaluate(s4, {}, o3) * Rh, p4 = rs(n4) ? a4 : 0, f4 = c3.get("text-anchor").evaluate(s4, {}, o3), x4 = c3.get("text-variable-anchor");
              if (!x4) {
                const t4 = c3.get("text-radial-offset").evaluate(s4, {}, o3);
                v3 = t4 ? xd(f4, [t4 * Rh, md]) : c3.get("text-offset").evaluate(s4, {}, o3).map((t5) => t5 * Rh);
              }
              let b3 = d3 ? "center" : c3.get("text-justify").evaluate(s4, {}, o3);
              const w3 = "point" === c3.get("symbol-placement"), _2 = w3 ? c3.get("text-max-width").evaluate(s4, {}, o3) * Rh : 1 / 0, A2 = (s5) => {
                t3.allowVerticalPlacement && es(n4) && (m3.vertical = Bp(g3, e3, r3, i3, l3, _2, u4, f4, s5, p4, v3, Ip.vertical, true, y3, h4));
              };
              if (!d3 && x4) {
                const t4 = "auto" === b3 ? x4.map((t5) => bd(t5)) : [b3];
                let n5 = false;
                for (let s5 = 0; s5 < t4.length; s5++) {
                  const a5 = t4[s5];
                  if (!m3.horizontal[a5])
                    if (n5)
                      m3.horizontal[a5] = m3.horizontal[0];
                    else {
                      const t5 = Bp(g3, e3, r3, i3, l3, _2, u4, "center", a5, p4, v3, Ip.horizontal, false, y3, h4);
                      t5 && (m3.horizontal[a5] = t5, n5 = 1 === t5.positionedLines.length);
                    }
                }
                A2("left");
              } else {
                if ("auto" === b3 && (b3 = bd(f4)), w3 || c3.get("text-writing-mode").indexOf("horizontal") >= 0 || !es(n4)) {
                  const t4 = Bp(g3, e3, r3, i3, l3, _2, u4, f4, b3, p4, v3, Ip.horizontal, false, y3, h4);
                  t4 && (m3.horizontal[b3] = t4);
                }
                A2(w3 ? "left" : b3);
              }
            }
            let b2 = false;
            if (s4.icon && s4.icon.name) {
              const e4 = n3[s4.icon.name];
              e4 && (x3 = $p(i3[s4.icon.name], c3.get("icon-offset").evaluate(s4, {}, o3), c3.get("icon-anchor").evaluate(s4, {}, o3)), b2 = e4.sdf, void 0 === t3.sdfIcons ? t3.sdfIcons = e4.sdf : t3.sdfIcons !== e4.sdf && N("Style sheet warning: Cannot mix SDF and non-SDF icons in one buffer"), (e4.pixelRatio !== t3.pixelRatio || 0 !== c3.get("icon-rotate").constantOr(1)) && (t3.iconsNeedLinear = true));
            }
            const w2 = kd(m3.horizontal) || m3.vertical;
            t3.iconsInText || (t3.iconsInText = !!w2 && w2.iconsInText), (w2 || x3) && wd(t3, s4, m3, x3, n3, p3, y3, 0, v3, b2, a3, o3, u3);
          }
          s3 && t3.generateCollisionDebugBuffers(l2, t3.collisionBoxArray);
        }
        function bd(t3) {
          switch (t3) {
            case "right":
            case "top-right":
            case "bottom-right":
              return "right";
            case "left":
            case "top-left":
            case "bottom-left":
              return "left";
          }
          return "center";
        }
        function wd(t3, e3, r3, n3, i3, s3, a3, o3, l2, u3, c3, h3, p3) {
          let d3 = s3.textMaxSize.evaluate(e3, {}, h3);
          void 0 === d3 && (d3 = a3);
          const f3 = t3.layers[0].layout, y3 = f3.get("icon-offset").evaluate(e3, {}, h3), m3 = kd(r3.horizontal) || r3.vertical, g3 = "globe" === p3.name, x3 = Rh, v3 = a3 / x3, b2 = t3.tilePixelRatio * d3 / x3, _2 = (B2 = t3.overscaling, t3.zoom > 18 && B2 > 2 && (B2 >>= 1), Math.max(ao / (512 * B2), 1) * f3.get("symbol-spacing")), A2 = f3.get("text-padding") * t3.tilePixelRatio, S2 = f3.get("icon-padding") * t3.tilePixelRatio, k2 = w(f3.get("text-max-angle")), I2 = "map" === f3.get("text-rotation-alignment") && "point" !== f3.get("symbol-placement"), M2 = "map" === f3.get("icon-rotation-alignment") && "point" !== f3.get("symbol-placement"), T2 = f3.get("symbol-placement"), z2 = _2 / 2;
          var B2;
          const E3 = f3.get("icon-text-fit");
          let C2;
          n3 && "none" !== E3 && (t3.allowVerticalPlacement && r3.vertical && (C2 = jp(n3, r3.vertical, E3, f3.get("icon-text-fit-padding"), y3, v3)), m3 && (n3 = jp(n3, m3, E3, f3.get("icon-text-fit-padding"), y3, v3)));
          const P2 = (a4, o4, d4) => {
            if (o4.x < 0 || o4.x >= ao || o4.y < 0 || o4.y >= ao)
              return;
            let f4 = null;
            if (g3) {
              const { x: t4, y: e4, z: r4 } = p3.projectTilePoint(o4.x, o4.y, d4);
              f4 = { anchor: new Op(t4, e4, r4, 0, void 0), up: p3.upVector(d4, o4.x, o4.y) };
            }
            !function(t4, e4, r4, n4, i4, s4, a5, o5, l3, u4, c4, h4, p4, d5, f5, y4, m4, g4, x4, v4, b3, w2, _3, A3, S3) {
              const k3 = t4.addToLineVertexArray(e4, n4);
              let I3, M3, T3, z3, B3, E4, C3, P3 = 0, D2 = 0, V2 = 0, L2 = 0, F2 = -1, R2 = -1;
              const U2 = {};
              let $2 = Ba("");
              const j2 = r4 ? r4.anchor : e4;
              let O2 = 0, q2 = 0;
              if (void 0 === l3._unevaluatedLayout.getValue("text-radial-offset") ? [O2, q2] = l3.layout.get("text-offset").evaluate(b3, {}, S3).map((t5) => t5 * Rh) : (O2 = l3.layout.get("text-radial-offset").evaluate(b3, {}, S3) * Rh, q2 = md), t4.allowVerticalPlacement && i4.vertical) {
                const t5 = i4.vertical;
                if (f5)
                  E4 = Md(t5), o5 && (C3 = Md(o5));
                else {
                  const r5 = l3.layout.get("text-rotate").evaluate(b3, {}, S3) + 90;
                  T3 = Id(u4, j2, e4, c4, h4, p4, t5, d5, r5, y4), o5 && (z3 = Id(u4, j2, e4, c4, h4, p4, o5, g4, r5));
                }
              }
              if (s4) {
                const n5 = l3.layout.get("icon-rotate").evaluate(b3, {}, S3), i5 = "none" !== l3.layout.get("icon-text-fit"), a6 = id2(s4, n5, _3, i5), d6 = o5 ? id2(o5, n5, _3, i5) : void 0;
                M3 = Id(u4, j2, e4, c4, h4, p4, s4, g4, n5), P3 = 4 * a6.length;
                const f6 = t4.iconSizeData;
                let y5 = null;
                "source" === f6.kind ? (y5 = [Uh * l3.layout.get("icon-size").evaluate(b3, {}, S3)], y5[0] > Ad && N(`${t4.layerIds[0]}: Value for "icon-size" is >= ${_d}. Reduce your "icon-size".`)) : "composite" === f6.kind && (y5 = [Uh * w2.compositeIconSizes[0].evaluate(b3, {}, S3), Uh * w2.compositeIconSizes[1].evaluate(b3, {}, S3)], (y5[0] > Ad || y5[1] > Ad) && N(`${t4.layerIds[0]}: Value for "icon-size" is >= ${_d}. Reduce your "icon-size".`)), t4.addSymbols(t4.icon, a6, y5, v4, x4, b3, false, r4, e4, k3.lineStartIndex, k3.lineLength, -1, A3, S3), F2 = t4.icon.placedSymbolArray.length - 1, d6 && (D2 = 4 * d6.length, t4.addSymbols(t4.icon, d6, y5, v4, x4, b3, Ip.vertical, r4, e4, k3.lineStartIndex, k3.lineLength, -1, A3, S3), R2 = t4.icon.placedSymbolArray.length - 1);
              }
              for (const n5 in i4.horizontal) {
                const s5 = i4.horizontal[n5];
                I3 || ($2 = Ba(s5.text), f5 ? B3 = Md(s5) : I3 = Id(u4, j2, e4, c4, h4, p4, s5, d5, l3.layout.get("text-rotate").evaluate(b3, {}, S3), y4));
                const o6 = 1 === s5.positionedLines.length;
                if (V2 += Sd(t4, r4, e4, s5, a5, l3, f5, b3, y4, k3, i4.vertical ? Ip.horizontal : Ip.horizontalOnly, o6 ? Object.keys(i4.horizontal) : [n5], U2, F2, w2, A3, S3), o6)
                  break;
              }
              i4.vertical && (L2 += Sd(t4, r4, e4, i4.vertical, a5, l3, f5, b3, y4, k3, Ip.vertical, ["vertical"], U2, R2, w2, A3, S3));
              let G2 = -1;
              const Z2 = (t5, e5) => t5 ? Math.max(t5, e5) : e5;
              G2 = Z2(B3, G2), G2 = Z2(E4, G2), G2 = Z2(C3, G2);
              const K2 = G2 > -1 ? 1 : 0;
              t4.glyphOffsetArray.length >= of.MAX_GLYPHS && N("Too many glyphs being rendered in a tile. See https://github.com/mapbox/mapbox-gl-js/issues/2907"), void 0 !== b3.sortKey && t4.addToSortKeyRanges(t4.symbolInstances.length, b3.sortKey), t4.symbolInstances.emplaceBack(j2.x, j2.y, j2.z, e4.x, e4.y, U2.right >= 0 ? U2.right : -1, U2.center >= 0 ? U2.center : -1, U2.left >= 0 ? U2.left : -1, U2.vertical >= 0 ? U2.vertical : -1, F2, R2, $2, void 0 !== I3 ? I3 : t4.collisionBoxArray.length, void 0 !== I3 ? I3 + 1 : t4.collisionBoxArray.length, void 0 !== T3 ? T3 : t4.collisionBoxArray.length, void 0 !== T3 ? T3 + 1 : t4.collisionBoxArray.length, void 0 !== M3 ? M3 : t4.collisionBoxArray.length, void 0 !== M3 ? M3 + 1 : t4.collisionBoxArray.length, z3 || t4.collisionBoxArray.length, z3 ? z3 + 1 : t4.collisionBoxArray.length, c4, V2, L2, P3, D2, K2, 0, O2, q2, G2);
            }(t3, o4, f4, a4, r3, n3, i3, C2, t3.layers[0], t3.collisionBoxArray, e3.index, e3.sourceLayerIndex, t3.index, A2, I2, l2, 0, S2, M2, y3, e3, s3, u3, c3, h3);
          };
          if ("line" === T2)
            for (const i4 of Hp(e3.geometry, 0, 0, ao, ao)) {
              const e4 = Xp(i4, _2, k2, r3.vertical || m3, n3, x3, b2, t3.overscaling, ao);
              for (const r4 of e4)
                m3 && Td(t3, m3.text, z2, r4) || P2(i4, r4, h3);
            }
          else if ("line-center" === T2) {
            for (const t4 of e3.geometry)
              if (t4.length > 1) {
                const e4 = Kp(t4, k2, r3.vertical || m3, n3, x3, b2);
                e4 && P2(t4, e4, h3);
              }
          } else if ("Polygon" === e3.type)
            for (const t4 of Ac(e3.geometry, 0)) {
              const e4 = pd(t4, 16);
              P2(t4[0], new Op(e4.x, e4.y, 0, 0, void 0), h3);
            }
          else if ("LineString" === e3.type)
            for (const t4 of e3.geometry)
              P2(t4, new Op(t4[0].x, t4[0].y, 0, 0, void 0), h3);
          else if ("Point" === e3.type)
            for (const t4 of e3.geometry)
              for (const e4 of t4)
                P2([e4], new Op(e4.x, e4.y, 0, 0, void 0), h3);
        }
        const _d = 255, Ad = _d * Uh;
        function Sd(t3, e3, r3, n3, i3, s3, a3, o3, l2, u3, c3, h3, p3, d3, f3, y3, m3) {
          const g3 = function(t4, e4, r4, n4, i4, s4, a4, o4) {
            const l3 = [];
            if (0 === e4.positionedLines.length)
              return l3;
            const u4 = n4.layout.get("text-rotate").evaluate(s4, {}) * Math.PI / 180, c4 = function(t5) {
              const e5 = t5[0], r5 = t5[1], n5 = e5 * r5;
              return n5 > 0 ? [e5, -r5] : n5 < 0 ? [-e5, r5] : 0 === e5 ? [r5, e5] : [r5, -e5];
            }(r4);
            let h4 = Math.abs(e4.top - e4.bottom);
            for (const t5 of e4.positionedLines)
              h4 -= t5.lineOffset;
            const p4 = e4.positionedLines.length, d4 = h4 / p4;
            let f4 = e4.top - r4[1];
            for (let t5 = 0; t5 < p4; ++t5) {
              const n5 = e4.positionedLines[t5];
              f4 = ud(e4, d4, f4, t5);
              for (const t6 of n5.positionedGlyphs) {
                if (!t6.rect)
                  continue;
                const n6 = t6.rect || {};
                let s5 = wp + 1, h5 = true, p5 = 1, d5 = 0;
                if (t6.imageName) {
                  const e5 = a4[t6.imageName];
                  if (!e5)
                    continue;
                  if (e5.sdf) {
                    N("SDF images are not supported in formatted text and will be ignored.");
                    continue;
                  }
                  h5 = false, p5 = e5.pixelRatio, s5 = Ap / p5;
                }
                const y4 = (i4 || o4) && t6.vertical, m4 = t6.metrics.advance * t6.scale / 2, g4 = t6.metrics, v4 = t6.rect;
                if (null === v4)
                  continue;
                o4 && e4.verticalizable && (d5 = t6.imageName ? m4 - t6.metrics.width * t6.scale / 2 : 0);
                const b3 = i4 ? [t6.x + m4, t6.y] : [0, 0];
                let w2 = [0, 0], _2 = [0, 0], A2 = false;
                i4 || (y4 ? (_2 = [t6.x + m4 + c4[0], t6.y + c4[1] - d5], A2 = true) : w2 = [t6.x + m4 + r4[0], t6.y + r4[1] - d5]);
                const S2 = v4.w * t6.scale / (p5 * (t6.localGlyph ? td : 1)), k2 = v4.h * t6.scale / (p5 * (t6.localGlyph ? td : 1));
                let I2, M2, T2, z2;
                if (y4) {
                  const e5 = t6.y - f4, r5 = new x2(-m4, m4 - e5), n7 = -Math.PI / 2, i5 = new x2(..._2);
                  I2 = new x2(-m4 + w2[0], w2[1]), I2._rotateAround(n7, r5)._add(i5), I2.x += -e5 + m4, I2.y -= (g4.left - s5) * t6.scale;
                  const a5 = t6.imageName ? g4.advance * t6.scale : Rh * t6.scale, o5 = String.fromCharCode(t6.glyph);
                  Zh(o5) ? I2.x += (1 - s5) * t6.scale : Kh(o5) ? I2.x += a5 - g4.height * t6.scale + (-s5 - 1) * t6.scale : I2.x += t6.imageName || g4.width + 2 * s5 === v4.w && g4.height + 2 * s5 === v4.h ? (a5 - k2) / 2 : (a5 - (g4.height + 2 * s5) * t6.scale) / 2, M2 = new x2(I2.x, I2.y - S2), T2 = new x2(I2.x + k2, I2.y), z2 = new x2(I2.x + k2, I2.y - S2);
                } else {
                  const e5 = (g4.left - s5) * t6.scale - m4 + w2[0], r5 = (-g4.top - s5) * t6.scale + w2[1], n7 = e5 + S2, i5 = r5 + k2;
                  I2 = new x2(e5, r5), M2 = new x2(n7, r5), T2 = new x2(e5, i5), z2 = new x2(n7, i5);
                }
                if (u4) {
                  let t7;
                  t7 = i4 ? new x2(0, 0) : A2 ? new x2(c4[0], c4[1]) : new x2(r4[0], r4[1]), I2._rotateAround(u4, t7), M2._rotateAround(u4, t7), T2._rotateAround(u4, t7), z2._rotateAround(u4, t7);
                }
                const B2 = new x2(0, 0), E3 = new x2(0, 0);
                l3.push({ tl: I2, tr: M2, bl: T2, br: z2, tex: n6, writingMode: e4.writingMode, glyphOffset: b3, sectionIndex: t6.sectionIndex, isSDF: h5, pixelOffsetTL: B2, pixelOffsetBR: E3, minFontScaleX: 0, minFontScaleY: 0 });
              }
            }
            return l3;
          }(0, n3, l2, s3, a3, o3, i3, t3.allowVerticalPlacement), v3 = t3.textSizeData;
          let b2 = null;
          "source" === v3.kind ? (b2 = [Uh * s3.layout.get("text-size").evaluate(o3, {}, m3)], b2[0] > Ad && N(`${t3.layerIds[0]}: Value for "text-size" is >= ${_d}. Reduce your "text-size".`)) : "composite" === v3.kind && (b2 = [Uh * f3.compositeTextSizes[0].evaluate(o3, {}, m3), Uh * f3.compositeTextSizes[1].evaluate(o3, {}, m3)], (b2[0] > Ad || b2[1] > Ad) && N(`${t3.layerIds[0]}: Value for "text-size" is >= ${_d}. Reduce your "text-size".`)), t3.addSymbols(t3.text, g3, b2, l2, a3, o3, c3, e3, r3, u3.lineStartIndex, u3.lineLength, d3, y3, m3);
          for (const e4 of h3)
            p3[e4] = t3.text.placedSymbolArray.length - 1;
          return 4 * g3.length;
        }
        function kd(t3) {
          for (const e3 in t3)
            return t3[e3];
          return null;
        }
        function Id(t3, e3, r3, n3, i3, s3, a3, o3, l2, u3) {
          let c3 = a3.top, h3 = a3.bottom, p3 = a3.left, d3 = a3.right;
          const f3 = a3.collisionPadding;
          if (f3 && (p3 -= f3[0], c3 -= f3[1], d3 += f3[2], h3 += f3[3]), l2) {
            const t4 = new x2(p3, c3), e4 = new x2(d3, c3), r4 = new x2(p3, h3), n4 = new x2(d3, h3), i4 = w(l2);
            let s4 = new x2(0, 0);
            u3 && (s4 = new x2(u3[0], u3[1])), t4._rotateAround(i4, s4), e4._rotateAround(i4, s4), r4._rotateAround(i4, s4), n4._rotateAround(i4, s4), p3 = Math.min(t4.x, e4.x, r4.x, n4.x), d3 = Math.max(t4.x, e4.x, r4.x, n4.x), c3 = Math.min(t4.y, e4.y, r4.y, n4.y), h3 = Math.max(t4.y, e4.y, r4.y, n4.y);
          }
          return t3.emplaceBack(e3.x, e3.y, e3.z, r3.x, r3.y, p3, c3, d3, h3, o3, n3, i3, s3), t3.length - 1;
        }
        function Md(t3) {
          t3.collisionPadding && (t3.top -= t3.collisionPadding[1], t3.bottom += t3.collisionPadding[3]);
          const e3 = t3.bottom - t3.top;
          return e3 > 0 ? Math.max(10, e3) : null;
        }
        function Td(t3, e3, r3, n3) {
          const i3 = t3.compareText;
          if (e3 in i3) {
            const t4 = i3[e3];
            for (let e4 = t4.length - 1; e4 >= 0; e4--)
              if (n3.dist(t4[e4]) < r3)
                return true;
          } else
            i3[e3] = [];
          return i3[e3].push(n3), false;
        }
        function zd(t3, e3) {
          const r3 = t3.fovAboveCenter, n3 = t3.elevation ? t3.elevation.getMinElevationBelowMSL() * e3 : 0, i3 = (t3._camera.position[2] * t3.worldSize - n3) / Math.cos(t3._pitch), s3 = Math.sin(r3) * i3 / Math.sin(Math.max(Math.PI / 2 - t3._pitch - r3, 0.01)), a3 = Math.sin(t3._pitch) * s3 + i3;
          return Math.min(1.01 * a3, i3 * (1 / t3._horizonShift));
        }
        function Bd(t3, e3) {
          if (!e3.isReprojectedInTileSpace)
            return { scale: 1 << t3.z, x: t3.x, y: t3.y, x2: t3.x + 1, y2: t3.y + 1, projection: e3 };
          const r3 = Math.pow(2, -t3.z), n3 = t3.x * r3, i3 = (t3.x + 1) * r3, s3 = t3.y * r3, a3 = (t3.y + 1) * r3, o3 = Kl(n3), l2 = Kl(i3), u3 = Xl(s3), c3 = Xl(a3), h3 = e3.project(o3, u3), p3 = e3.project(l2, u3), d3 = e3.project(l2, c3), f3 = e3.project(o3, c3);
          let y3 = Math.min(h3.x, p3.x, d3.x, f3.x), m3 = Math.min(h3.y, p3.y, d3.y, f3.y), g3 = Math.max(h3.x, p3.x, d3.x, f3.x), x3 = Math.max(h3.y, p3.y, d3.y, f3.y);
          const v3 = r3 / 16;
          function b2(t4, r4, n4, i4, s4, a4) {
            const o4 = (n4 + s4) / 2, l3 = (i4 + a4) / 2, u4 = e3.project(Kl(o4), Xl(l3)), c4 = Math.max(0, y3 - u4.x, m3 - u4.y, u4.x - g3, u4.y - x3);
            y3 = Math.min(y3, u4.x), g3 = Math.max(g3, u4.x), m3 = Math.min(m3, u4.y), x3 = Math.max(x3, u4.y), c4 > v3 && (b2(t4, u4, n4, i4, o4, l3), b2(u4, r4, o4, l3, s4, a4));
          }
          b2(h3, p3, n3, s3, i3, s3), b2(p3, d3, i3, s3, i3, a3), b2(d3, f3, i3, a3, n3, a3), b2(f3, h3, n3, a3, n3, s3), y3 -= v3, m3 -= v3, g3 += v3, x3 += v3;
          const w2 = 1 / Math.max(g3 - y3, x3 - m3);
          return { scale: w2, x: y3 * w2, y: m3 * w2, x2: g3 * w2, y2: x3 * w2, projection: e3 };
        }
        const Ed = po(new Float32Array(16));
        class Cd {
          constructor(t3) {
            this.spec = t3, this.name = t3.name, this.wrap = false, this.requiresDraping = false, this.supportsWorldCopies = false, this.supportsTerrain = false, this.supportsFog = false, this.supportsFreeCamera = false, this.zAxisUnit = "meters", this.isReprojectedInTileSpace = true, this.unsupportedLayers = ["custom"], this.center = [0, 0], this.range = [3.5, 7];
          }
          project(t3, e3) {
            return { x: 0, y: 0, z: 0 };
          }
          unproject(t3, e3) {
            return new Ol(0, 0);
          }
          projectTilePoint(t3, e3, r3) {
            return { x: t3, y: e3, z: 0 };
          }
          locationPoint(t3, e3, r3 = true) {
            return t3._coordinatePoint(t3.locationCoordinate(e3), r3);
          }
          pixelsPerMeter(t3, e3) {
            return Zl(1, t3) * e3;
          }
          pixelSpaceConversion(t3, e3, r3) {
            return 1;
          }
          farthestPixelDistance(t3) {
            return zd(t3, t3.pixelsPerMeter);
          }
          pointCoordinate(t3, e3, r3, n3) {
            const i3 = t3.horizonLineFromTop(false), s3 = new x2(e3, Math.max(i3, r3));
            return t3.rayIntersectionCoordinate(t3.pointRayIntersection(s3, n3));
          }
          pointCoordinate3D(t3, e3, r3) {
            const n3 = new x2(e3, r3);
            if (t3.elevation)
              return t3.elevation.pointCoordinate(n3);
            {
              const e4 = this.pointCoordinate(t3, n3.x, n3.y, 0);
              return [e4.x, e4.y, e4.z];
            }
          }
          isPointAboveHorizon(t3, e3) {
            if (t3.elevation)
              return !this.pointCoordinate3D(t3, e3.x, e3.y);
            const r3 = t3.horizonLineFromTop();
            return e3.y < r3;
          }
          createInversionMatrix(t3, e3) {
            return Ed;
          }
          createTileMatrix(t3, e3, r3) {
            let n3, i3, s3;
            const a3 = r3.canonical, o3 = po(new Float64Array(16));
            if (this.isReprojectedInTileSpace) {
              const l2 = Bd(a3, this);
              n3 = 1, i3 = l2.x + r3.wrap * l2.scale, s3 = l2.y, go(o3, o3, [n3 / l2.scale, n3 / l2.scale, t3.pixelsPerMeter / e3]);
            } else
              n3 = e3 / t3.zoomScale(a3.z), i3 = (a3.x + Math.pow(2, a3.z) * r3.wrap) * n3, s3 = a3.y * n3;
            return mo(o3, o3, [i3, s3, 0]), go(o3, o3, [n3 / ao, n3 / ao, 1]), o3;
          }
          upVector(t3, e3, r3) {
            return [0, 0, 1];
          }
          upVectorScale(t3, e3, r3) {
            return { metersToTile: 1 };
          }
        }
        class Pd extends Cd {
          constructor(t3) {
            super(t3), this.range = [4, 7], this.center = t3.center || [-96, 37.5];
            const [e3, r3] = this.parallels = t3.parallels || [29.5, 45.5], n3 = Math.sin(w(e3));
            this.n = (n3 + Math.sin(w(r3))) / 2, this.c = 1 + n3 * (2 * this.n - n3), this.r0 = Math.sqrt(this.c) / this.n;
          }
          project(t3, e3) {
            const { n: r3, c: n3, r0: i3 } = this, s3 = w(t3 - this.center[0]), a3 = w(e3), o3 = Math.sqrt(n3 - 2 * r3 * Math.sin(a3)) / r3;
            return { x: o3 * Math.sin(s3 * r3), y: o3 * Math.cos(s3 * r3) - i3, z: 0 };
          }
          unproject(t3, e3) {
            const { n: r3, c: n3, r0: i3 } = this, s3 = i3 + e3;
            let a3 = Math.atan2(t3, Math.abs(s3)) * Math.sign(s3);
            s3 * r3 < 0 && (a3 -= Math.PI * Math.sign(t3) * Math.sign(s3));
            const o3 = w(this.center[0]) * r3;
            a3 = z(a3, -Math.PI - o3, Math.PI - o3);
            const l2 = M(_(a3 / r3) + this.center[0], -180, 180), u3 = Math.asin(M((n3 - (t3 * t3 + s3 * s3) * r3 * r3) / (2 * r3), -1, 1)), c3 = M(_(u3), -Hl, Hl);
            return new Ol(l2, c3);
          }
        }
        const Dd = 1.340264, Vd = -0.081106, Ld = 893e-6, Fd = 3796e-6, Rd = Math.sqrt(3) / 2;
        class Ud extends Cd {
          project(t3, e3) {
            e3 = e3 / 180 * Math.PI, t3 = t3 / 180 * Math.PI;
            const r3 = Math.asin(Rd * Math.sin(e3)), n3 = r3 * r3, i3 = n3 * n3 * n3;
            return { x: 0.5 * (t3 * Math.cos(r3) / (Rd * (Dd + 3 * Vd * n3 + i3 * (7 * Ld + 9 * Fd * n3))) / Math.PI + 0.5), y: 1 - 0.5 * (r3 * (Dd + Vd * n3 + i3 * (Ld + Fd * n3)) / Math.PI + 1), z: 0 };
          }
          unproject(t3, e3) {
            t3 = (2 * t3 - 0.5) * Math.PI;
            let r3 = e3 = (2 * (1 - e3) - 1) * Math.PI, n3 = r3 * r3, i3 = n3 * n3 * n3;
            for (let t4, s4, a4, o4 = 0; o4 < 12 && (s4 = r3 * (Dd + Vd * n3 + i3 * (Ld + Fd * n3)) - e3, a4 = Dd + 3 * Vd * n3 + i3 * (7 * Ld + 9 * Fd * n3), t4 = s4 / a4, r3 = M(r3 - t4, -Math.PI / 3, Math.PI / 3), n3 = r3 * r3, i3 = n3 * n3 * n3, !(Math.abs(t4) < 1e-12)); ++o4)
              ;
            const s3 = Rd * t3 * (Dd + 3 * Vd * n3 + i3 * (7 * Ld + 9 * Fd * n3)) / Math.cos(r3), a3 = Math.asin(Math.sin(r3) / Rd), o3 = M(180 * s3 / Math.PI, -180, 180), l2 = M(180 * a3 / Math.PI, -Hl, Hl);
            return new Ol(o3, l2);
          }
        }
        class $d extends Cd {
          constructor(t3) {
            super(t3), this.wrap = true, this.supportsWorldCopies = true;
          }
          project(t3, e3) {
            return { x: 0.5 + t3 / 360, y: 0.5 - e3 / 360, z: 0 };
          }
          unproject(t3, e3) {
            const r3 = 360 * (t3 - 0.5), n3 = M(360 * (0.5 - e3), -Hl, Hl);
            return new Ol(r3, n3);
          }
        }
        const jd = Math.PI / 2;
        function Od(t3) {
          return Math.tan((jd + t3) / 2);
        }
        class qd extends Cd {
          constructor(t3) {
            super(t3), this.center = t3.center || [0, 30];
            const [e3, r3] = this.parallels = t3.parallels || [30, 30];
            let n3 = w(e3), i3 = w(r3);
            this.southernCenter = n3 + i3 < 0, this.southernCenter && (n3 = -n3, i3 = -i3);
            const s3 = Math.cos(n3), a3 = Od(n3);
            this.n = n3 === i3 ? Math.sin(n3) : Math.log(s3 / Math.cos(i3)) / Math.log(Od(i3) / a3), this.f = s3 * Math.pow(Od(n3), this.n) / this.n;
          }
          project(t3, e3) {
            e3 = w(e3), this.southernCenter && (e3 = -e3), t3 = w(t3 - this.center[0]);
            const r3 = 1e-6, { n: n3, f: i3 } = this;
            i3 > 0 ? e3 < -jd + r3 && (e3 = -jd + r3) : e3 > jd - r3 && (e3 = jd - r3);
            const s3 = i3 / Math.pow(Od(e3), n3);
            let a3 = s3 * Math.sin(n3 * t3), o3 = i3 - s3 * Math.cos(n3 * t3);
            return a3 = 0.5 * (a3 / Math.PI + 0.5), o3 = 0.5 * (o3 / Math.PI + 0.5), { x: a3, y: this.southernCenter ? o3 : 1 - o3, z: 0 };
          }
          unproject(t3, e3) {
            t3 = (2 * t3 - 0.5) * Math.PI, this.southernCenter && (e3 = 1 - e3), e3 = (2 * (1 - e3) - 0.5) * Math.PI;
            const { n: r3, f: n3 } = this, i3 = n3 - e3, s3 = Math.sign(i3), a3 = Math.sign(r3) * Math.sqrt(t3 * t3 + i3 * i3);
            let o3 = Math.atan2(t3, Math.abs(i3)) * s3;
            i3 * r3 < 0 && (o3 -= Math.PI * Math.sign(t3) * s3);
            const l2 = M(_(o3 / r3) + this.center[0], -180, 180), u3 = M(_(2 * Math.atan(Math.pow(n3 / a3, 1 / r3)) - jd), -Hl, Hl);
            return new Ol(l2, this.southernCenter ? -u3 : u3);
          }
        }
        class Nd extends Cd {
          constructor(t3) {
            super(t3), this.wrap = true, this.supportsWorldCopies = true, this.supportsTerrain = true, this.supportsFog = true, this.supportsFreeCamera = true, this.isReprojectedInTileSpace = false, this.unsupportedLayers = [], this.range = null;
          }
          project(t3, e3) {
            return { x: Nl(t3), y: Gl(e3), z: 0 };
          }
          unproject(t3, e3) {
            const r3 = Kl(t3), n3 = Xl(e3);
            return new Ol(r3, n3);
          }
        }
        const Gd = w(Hl);
        class Zd extends Cd {
          project(t3, e3) {
            const r3 = (e3 = w(e3)) * e3, n3 = r3 * r3;
            return { x: 0.5 * ((t3 = w(t3)) * (0.8707 - 0.131979 * r3 + n3 * (n3 * (3971e-6 * r3 - 1529e-6 * n3) - 0.013791)) / Math.PI + 0.5), y: 1 - 0.5 * (e3 * (1.007226 + r3 * (0.015085 + n3 * (0.028874 * r3 - 0.044475 - 5916e-6 * n3))) / Math.PI + 1), z: 0 };
          }
          unproject(t3, e3) {
            t3 = (2 * t3 - 0.5) * Math.PI;
            let r3 = e3 = (2 * (1 - e3) - 1) * Math.PI, n3 = 25, i3 = 0, s3 = r3 * r3;
            do {
              s3 = r3 * r3;
              const t4 = s3 * s3;
              i3 = (r3 * (1.007226 + s3 * (0.015085 + t4 * (0.028874 * s3 - 0.044475 - 5916e-6 * t4))) - e3) / (1.007226 + s3 * (0.045255 + t4 * (0.259866 * s3 - 0.311325 - 5916e-6 * 11 * t4))), r3 = M(r3 - i3, -Gd, Gd);
            } while (Math.abs(i3) > 1e-6 && --n3 > 0);
            s3 = r3 * r3;
            const a3 = M(_(t3 / (0.8707 + s3 * (s3 * (s3 * s3 * s3 * (3971e-6 - 1529e-6 * s3) - 0.013791) - 0.131979))), -180, 180), o3 = _(r3);
            return new Ol(a3, o3);
          }
        }
        const Kd = w(Hl);
        class Xd extends Cd {
          project(t3, e3) {
            e3 = w(e3), t3 = w(t3);
            const r3 = Math.cos(e3), n3 = 2 / Math.PI, i3 = Math.acos(r3 * Math.cos(t3 / 2)), s3 = Math.sin(i3) / i3, a3 = 0.5 * (t3 * n3 + 2 * r3 * Math.sin(t3 / 2) / s3) || 0, o3 = 0.5 * (e3 + Math.sin(e3) / s3) || 0;
            return { x: 0.5 * (a3 / Math.PI + 0.5), y: 1 - 0.5 * (o3 / Math.PI + 1), z: 0 };
          }
          unproject(t3, e3) {
            let r3 = t3 = (2 * t3 - 0.5) * Math.PI, n3 = e3 = (2 * (1 - e3) - 1) * Math.PI, i3 = 25;
            const s3 = 1e-6;
            let a3 = 0, o3 = 0;
            do {
              const i4 = Math.cos(n3), s4 = Math.sin(n3), l2 = 2 * s4 * i4, u3 = s4 * s4, c3 = i4 * i4, h3 = Math.cos(r3 / 2), p3 = Math.sin(r3 / 2), d3 = 2 * h3 * p3, f3 = p3 * p3, y3 = 1 - c3 * h3 * h3, m3 = y3 ? 1 / y3 : 0, g3 = y3 ? Math.acos(i4 * h3) * Math.sqrt(1 / y3) : 0, x3 = 0.5 * (2 * g3 * i4 * p3 + 2 * r3 / Math.PI) - t3, v3 = 0.5 * (g3 * s4 + n3) - e3, b2 = 0.5 * m3 * (c3 * f3 + g3 * i4 * h3 * u3) + 1 / Math.PI, w2 = m3 * (d3 * l2 / 4 - g3 * s4 * p3), _2 = 0.125 * m3 * (l2 * p3 - g3 * s4 * c3 * d3), A2 = 0.5 * m3 * (u3 * h3 + g3 * f3 * i4) + 0.5, S2 = w2 * _2 - A2 * b2;
              a3 = (v3 * w2 - x3 * A2) / S2, o3 = (x3 * _2 - v3 * b2) / S2, r3 = M(r3 - a3, -Math.PI, Math.PI), n3 = M(n3 - o3, -Kd, Kd);
            } while ((Math.abs(a3) > s3 || Math.abs(o3) > s3) && --i3 > 0);
            return new Ol(_(r3), _(n3));
          }
        }
        class Jd extends Cd {
          constructor(t3) {
            super(t3), this.center = t3.center || [0, 0], this.parallels = t3.parallels || [0, 0], this.cosPhi = Math.max(0.01, Math.cos(w(this.parallels[0]))), this.scale = 1 / (2 * Math.max(Math.PI * this.cosPhi, 1 / this.cosPhi)), this.wrap = true, this.supportsWorldCopies = true;
          }
          project(t3, e3) {
            const { scale: r3, cosPhi: n3 } = this;
            return { x: w(t3) * n3 * r3 + 0.5, y: -Math.sin(w(e3)) / n3 * r3 + 0.5, z: 0 };
          }
          unproject(t3, e3) {
            const { scale: r3, cosPhi: n3 } = this, i3 = -(e3 - 0.5) / r3, s3 = M(_((t3 - 0.5) / r3) / n3, -180, 180), a3 = Math.asin(M(i3 * n3, -1, 1)), o3 = M(_(a3), -Hl, Hl);
            return new Ol(s3, o3);
          }
        }
        class Hd extends Nd {
          constructor(t3) {
            super(t3), this.requiresDraping = true, this.supportsWorldCopies = false, this.supportsFog = true, this.zAxisUnit = "pixels", this.unsupportedLayers = ["debug"], this.range = [3, 5];
          }
          projectTilePoint(t3, e3, r3) {
            const n3 = Ml(t3, e3, r3);
            return Fo(n3, n3, Bl(xl(r3))), { x: n3[0], y: n3[1], z: n3[2] };
          }
          locationPoint(t3, e3) {
            const r3 = Il(e3.lat, e3.lng), n3 = Do([], r3), i3 = t3.elevation ? t3.elevation.getAtPointOrZero(t3.locationCoordinate(e3), t3._centerAltitude) : t3._centerAltitude;
            Po(r3, r3, n3, Zl(1, 0) * ao * i3);
            const s3 = po(new Float64Array(16));
            return yo(s3, t3.pixelMatrix, t3.globeMatrix), Fo(r3, r3, s3), new x2(r3[0], r3[1]);
          }
          pixelsPerMeter(t3, e3) {
            return Zl(1, 0) * e3;
          }
          pixelSpaceConversion(t3, e3, r3) {
            const n3 = Zl(1, t3) * e3, i3 = Er(Zl(1, 45) * e3, n3, r3);
            return this.pixelsPerMeter(t3, e3) / i3;
          }
          createTileMatrix(t3, e3, r3) {
            const n3 = El(xl(r3.canonical));
            return yo(new Float64Array(16), t3.globeMatrix, n3);
          }
          createInversionMatrix(t3, e3) {
            const { center: r3 } = t3, n3 = Bl(xl(e3));
            return vo(n3, n3, w(r3.lng)), xo(n3, n3, w(r3.lat)), go(n3, n3, [t3._pixelsPerMercatorPixel, t3._pixelsPerMercatorPixel, 1]), Float32Array.from(n3);
          }
          pointCoordinate(t3, e3, r3, n3) {
            return yl(t3, e3, r3, true) || new Wl(0, 0);
          }
          pointCoordinate3D(t3, e3, r3) {
            const n3 = this.pointCoordinate(t3, e3, r3, 0);
            return [n3.x, n3.y, n3.z];
          }
          isPointAboveHorizon(t3, e3) {
            return !yl(t3, e3.x, e3.y, false);
          }
          farthestPixelDistance(t3) {
            const e3 = function(t4, e4) {
              const r4 = t4.cameraToCenterDistance, n3 = t4._centerAltitude * e4, i3 = t4._camera, s3 = t4._camera.forward(), a3 = Mo([], Co([], s3, -r4), [0, 0, n3]), o3 = t4.worldSize / (2 * Math.PI), l2 = [0, 0, -o3], u3 = t4.width / t4.height, c3 = Math.tan(t4.fovAboveCenter), h3 = Co([], i3.up(), c3), p3 = Co([], i3.right(), c3 * u3), d3 = Do([], Mo([], Mo([], s3, h3), p3)), f3 = [];
              let y3;
              if (new el(a3, d3).closestPointOnSphere(l2, o3, f3)) {
                const e5 = Mo([], f3, l2), r5 = $o([], e5, a3);
                y3 = Math.cos(t4.fovAboveCenter) * ko(r5);
              } else {
                const t5 = $o([], a3, l2), e5 = $o([], l2, a3);
                Do(e5, e5);
                const r5 = ko(t5) - o3;
                y3 = Math.sqrt(r5 * (r5 + 2 * o3));
                const n4 = Math.acos(y3 / (o3 + r5)) - Math.acos(Vo(s3, e5));
                y3 *= Math.cos(n4);
              }
              return 1.01 * y3;
            }(t3, this.pixelsPerMeter(t3.center.lat, t3.worldSize)), r3 = Pl(t3.zoom);
            if (r3 > 0) {
              const n3 = zd(t3, Zl(1, t3.center.lat) * t3.worldSize), i3 = t3.worldSize / (2 * Math.PI), s3 = Math.max(t3.width, t3.height) / t3.worldSize * Math.PI;
              return Er(e3, n3 + i3 * (1 - Math.cos(s3)), Math.pow(r3, 10));
            }
            return e3;
          }
          upVector(t3, e3, r3) {
            return Ml(e3, r3, t3, 1);
          }
          upVectorScale(t3) {
            return { metersToTile: fl(Tl(xl(t3))) };
          }
        }
        function Yd(t3) {
          const e3 = t3.parallels, r3 = !!e3 && Math.abs(e3[0] + e3[1]) < 0.01;
          switch (t3.name) {
            case "mercator":
              return new Nd(t3);
            case "equirectangular":
              return new $d(t3);
            case "naturalEarth":
              return new Zd(t3);
            case "equalEarth":
              return new Ud(t3);
            case "winkelTripel":
              return new Xd(t3);
            case "albers":
              return r3 ? new Jd(t3) : new Pd(t3);
            case "lambertConformalConic":
              return r3 ? new Jd(t3) : new qd(t3);
            case "globe":
              return new Hd(t3);
          }
          throw new Error(`Invalid projection name: ${t3.name}`);
        }
        const Wd = Kc.types, Qd = [{ name: "a_fade_opacity", components: 1, type: "Uint8", offset: 0 }];
        function tf(t3, e3, r3, n3, i3, s3, a3, o3, l2, u3, c3, h3, p3) {
          const d3 = o3 ? Math.min(Ad, Math.round(o3[0])) : 0, f3 = o3 ? Math.min(Ad, Math.round(o3[1])) : 0;
          t3.emplaceBack(e3, r3, Math.round(32 * n3), Math.round(32 * i3), s3, a3, (d3 << 1) + (l2 ? 1 : 0), f3, 16 * u3, 16 * c3, 256 * h3, 256 * p3);
        }
        function ef(t3, e3, r3, n3, i3, s3, a3) {
          t3.emplaceBack(e3, r3, n3, i3, s3, a3);
        }
        function rf(t3, e3, r3, n3, i3) {
          t3.emplaceBack(e3, r3, n3, i3), t3.emplaceBack(e3, r3, n3, i3), t3.emplaceBack(e3, r3, n3, i3), t3.emplaceBack(e3, r3, n3, i3);
        }
        function nf(t3) {
          for (const e3 of t3.sections)
            if (ls(e3.text))
              return true;
          return false;
        }
        class sf {
          constructor(t3) {
            this.layoutVertexArray = new Xs(), this.indexArray = new ra(), this.programConfigurations = t3, this.segments = new so(), this.dynamicLayoutVertexArray = new Ns(), this.opacityVertexArray = new Hs(), this.placedSymbolArray = new fa(), this.globeExtVertexArray = new Js();
          }
          isEmpty() {
            return 0 === this.layoutVertexArray.length && 0 === this.indexArray.length && 0 === this.dynamicLayoutVertexArray.length && 0 === this.opacityVertexArray.length;
          }
          upload(t3, e3, r3, n3) {
            this.isEmpty() || (r3 && (this.layoutVertexBuffer = t3.createVertexBuffer(this.layoutVertexArray, Eh.members), this.indexBuffer = t3.createIndexBuffer(this.indexArray, e3), this.dynamicLayoutVertexBuffer = t3.createVertexBuffer(this.dynamicLayoutVertexArray, Ph.members, true), this.opacityVertexBuffer = t3.createVertexBuffer(this.opacityVertexArray, Qd, true), this.globeExtVertexArray.length > 0 && (this.globeExtVertexBuffer = t3.createVertexBuffer(this.globeExtVertexArray, Ch.members, true)), this.opacityVertexBuffer.itemSize = 1), (r3 || n3) && this.programConfigurations.upload(t3));
          }
          destroy() {
            this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy(), this.dynamicLayoutVertexBuffer.destroy(), this.opacityVertexBuffer.destroy(), this.globeExtVertexBuffer && this.globeExtVertexBuffer.destroy());
          }
        }
        Ji(sf, "SymbolBuffers");
        class af {
          constructor(t3, e3, r3) {
            this.layoutVertexArray = new t3(), this.layoutAttributes = e3, this.indexArray = new r3(), this.segments = new so(), this.collisionVertexArray = new ta(), this.collisionVertexArrayExt = new ea();
          }
          upload(t3) {
            this.layoutVertexBuffer = t3.createVertexBuffer(this.layoutVertexArray, this.layoutAttributes), this.indexBuffer = t3.createIndexBuffer(this.indexArray), this.collisionVertexBuffer = t3.createVertexBuffer(this.collisionVertexArray, Dh.members, true), this.collisionVertexBufferExt = t3.createVertexBuffer(this.collisionVertexArrayExt, Vh.members, true);
          }
          destroy() {
            this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.segments.destroy(), this.collisionVertexBuffer.destroy(), this.collisionVertexBufferExt.destroy());
          }
        }
        Ji(af, "CollisionBuffers");
        class of {
          constructor(t3) {
            this.collisionBoxArray = t3.collisionBoxArray, this.zoom = t3.zoom, this.overscaling = t3.overscaling, this.layers = t3.layers, this.layerIds = this.layers.map((t4) => t4.id), this.index = t3.index, this.pixelRatio = t3.pixelRatio, this.sourceLayerIndex = t3.sourceLayerIndex, this.hasPattern = false, this.hasRTLText = false, this.fullyClipped = false, this.sortKeyRanges = [], this.collisionCircleArray = [], this.placementInvProjMatrix = po([]), this.placementViewportMatrix = po([]);
            const e3 = this.layers[0]._unevaluatedLayout._values;
            this.textSizeData = $h(this.zoom, e3["text-size"]), this.iconSizeData = $h(this.zoom, e3["icon-size"]);
            const r3 = this.layers[0].layout, n3 = r3.get("symbol-sort-key"), i3 = r3.get("symbol-z-order");
            this.canOverlap = r3.get("text-allow-overlap") || r3.get("icon-allow-overlap") || r3.get("text-ignore-placement") || r3.get("icon-ignore-placement"), this.sortFeaturesByKey = "viewport-y" !== i3 && void 0 !== n3.constantOr(1), this.sortFeaturesByY = ("viewport-y" === i3 || "auto" === i3 && !this.sortFeaturesByKey) && this.canOverlap, this.writingModes = r3.get("text-writing-mode").map((t4) => Ip[t4]), this.stateDependentLayerIds = this.layers.filter((t4) => t4.isStateDependent()).map((t4) => t4.id), this.sourceID = t3.sourceID, this.projection = t3.projection;
          }
          createArrays() {
            this.text = new sf(new Ja(this.layers, this.zoom, (t3) => /^text/.test(t3))), this.icon = new sf(new Ja(this.layers, this.zoom, (t3) => /^icon/.test(t3))), this.glyphOffsetArray = new ga(), this.lineVertexArray = new xa(), this.symbolInstances = new ma();
          }
          calculateGlyphDependencies(t3, e3, r3, n3, i3) {
            for (let r4 = 0; r4 < t3.length; r4++)
              if (e3[t3.charCodeAt(r4)] = true, n3 && i3) {
                const n4 = Gh[t3.charAt(r4)];
                n4 && (e3[n4.charCodeAt(0)] = true);
              }
          }
          populate(t3, e3, r3, n3) {
            const i3 = this.layers[0], s3 = i3.layout, a3 = "globe" === this.projection.name, o3 = s3.get("text-font"), l2 = s3.get("text-field"), u3 = s3.get("icon-image"), c3 = ("constant" !== l2.value.kind || l2.value.value instanceof De && !l2.value.value.isEmpty() || l2.value.value.toString().length > 0) && ("constant" !== o3.value.kind || o3.value.value.length > 0), h3 = "constant" !== u3.value.kind || !!u3.value.value || Object.keys(u3.parameters).length > 0, p3 = s3.get("symbol-sort-key");
            if (this.features = [], !c3 && !h3)
              return;
            const d3 = e3.iconDependencies, f3 = e3.glyphDependencies, y3 = e3.availableImages, m3 = new ws(this.zoom);
            for (const { feature: e4, id: l3, index: u4, sourceLayerIndex: g3 } of t3) {
              const t4 = i3._featureFilter.needGeometry, x3 = ou(e4, t4);
              if (!i3._featureFilter.filter(m3, x3, r3))
                continue;
              if (t4 || (x3.geometry = au(e4, r3, n3)), a3 && 1 !== e4.type && r3.z <= 5) {
                const t5 = x3.geometry, e5 = 0.98078528056, n4 = (t6, n5) => Vo(Ml(t6.x, t6.y, r3, 1), Ml(n5.x, n5.y, r3, 1)) < e5;
                for (let e6 = 0; e6 < t5.length; e6++)
                  t5[e6] = ru(t5[e6], n4);
              }
              let v3, b2;
              if (c3) {
                const t5 = i3.getValueAndResolveTokens("text-field", x3, r3, y3), e5 = De.factory(t5);
                nf(e5) && (this.hasRTLText = true), (!this.hasRTLText || "unavailable" === xs() || this.hasRTLText && bs.isParsed()) && (v3 = Nh(e5, i3, x3));
              }
              if (h3) {
                const t5 = i3.getValueAndResolveTokens("icon-image", x3, r3, y3);
                b2 = t5 instanceof Ve ? t5 : Ve.fromString(t5);
              }
              if (!v3 && !b2)
                continue;
              const w2 = this.sortFeaturesByKey ? p3.evaluate(x3, {}, r3) : void 0;
              if (this.features.push({ id: l3, text: v3, icon: b2, index: u4, sourceLayerIndex: g3, geometry: x3.geometry, properties: e4.properties, type: Wd[e4.type], sortKey: w2 }), b2 && (d3[b2.name] = true), v3) {
                const t5 = o3.evaluate(x3, {}, r3).join(","), e5 = "map" === s3.get("text-rotation-alignment") && "point" !== s3.get("symbol-placement");
                this.allowVerticalPlacement = this.writingModes && this.writingModes.indexOf(Ip.vertical) >= 0;
                for (const r4 of v3.sections)
                  if (r4.image)
                    d3[r4.image.name] = true;
                  else {
                    const n4 = es(v3.toString()), i4 = r4.fontStack || t5, s4 = f3[i4] = f3[i4] || {};
                    this.calculateGlyphDependencies(r4.text, s4, e5, this.allowVerticalPlacement, n4);
                  }
              }
            }
            "line" === s3.get("symbol-placement") && (this.features = function(t4) {
              const e4 = {}, r4 = {}, n4 = [];
              let i4 = 0;
              function s4(e5) {
                n4.push(t4[e5]), i4++;
              }
              function a4(t5, e5, i5) {
                const s5 = r4[t5];
                return delete r4[t5], r4[e5] = s5, n4[s5].geometry[0].pop(), n4[s5].geometry[0] = n4[s5].geometry[0].concat(i5[0]), s5;
              }
              function o4(t5, r5, i5) {
                const s5 = e4[r5];
                return delete e4[r5], e4[t5] = s5, n4[s5].geometry[0].shift(), n4[s5].geometry[0] = i5[0].concat(n4[s5].geometry[0]), s5;
              }
              function l3(t5, e5, r5) {
                const n5 = r5 ? e5[0][e5[0].length - 1] : e5[0][0];
                return `${t5}:${n5.x}:${n5.y}`;
              }
              for (let u4 = 0; u4 < t4.length; u4++) {
                const c4 = t4[u4], h4 = c4.geometry, p4 = c4.text ? c4.text.toString() : null;
                if (!p4) {
                  s4(u4);
                  continue;
                }
                const d4 = l3(p4, h4), f4 = l3(p4, h4, true);
                if (d4 in r4 && f4 in e4 && r4[d4] !== e4[f4]) {
                  const t5 = o4(d4, f4, h4), i5 = a4(d4, f4, n4[t5].geometry);
                  delete e4[d4], delete r4[f4], r4[l3(p4, n4[i5].geometry, true)] = i5, n4[t5].geometry = null;
                } else
                  d4 in r4 ? a4(d4, f4, h4) : f4 in e4 ? o4(d4, f4, h4) : (s4(u4), e4[d4] = i4 - 1, r4[f4] = i4 - 1);
              }
              return n4.filter((t5) => t5.geometry);
            }(this.features)), this.sortFeaturesByKey && this.features.sort((t4, e4) => t4.sortKey - e4.sortKey);
          }
          update(t3, e3, r3, n3) {
            this.stateDependentLayers.length && (this.text.programConfigurations.updatePaintArrays(t3, e3, this.layers, r3, n3), this.icon.programConfigurations.updatePaintArrays(t3, e3, this.layers, r3, n3));
          }
          isEmpty() {
            return 0 === this.symbolInstances.length && !this.hasRTLText;
          }
          uploadPending() {
            return !this.uploaded || this.text.programConfigurations.needsUpload || this.icon.programConfigurations.needsUpload;
          }
          upload(t3) {
            !this.uploaded && this.hasDebugData() && (this.textCollisionBox.upload(t3), this.iconCollisionBox.upload(t3)), this.text.upload(t3, this.sortFeaturesByY, !this.uploaded, this.text.programConfigurations.needsUpload), this.icon.upload(t3, this.sortFeaturesByY, !this.uploaded, this.icon.programConfigurations.needsUpload), this.uploaded = true;
          }
          destroyDebugData() {
            this.textCollisionBox.destroy(), this.iconCollisionBox.destroy();
          }
          getProjection() {
            return this.projectionInstance || (this.projectionInstance = Yd(this.projection)), this.projectionInstance;
          }
          destroy() {
            this.text.destroy(), this.icon.destroy(), this.hasDebugData() && this.destroyDebugData();
          }
          addToLineVertexArray(t3, e3) {
            const r3 = this.lineVertexArray.length;
            if (void 0 !== t3.segment)
              for (const { x: t4, y: r4 } of e3)
                this.lineVertexArray.emplaceBack(t4, r4);
            return { lineStartIndex: r3, lineLength: this.lineVertexArray.length - r3 };
          }
          addSymbols(t3, e3, r3, n3, i3, s3, a3, o3, l2, u3, c3, h3, p3, d3) {
            const f3 = t3.indexArray, y3 = t3.layoutVertexArray, m3 = t3.globeExtVertexArray, g3 = t3.segments.prepareSegment(4 * e3.length, y3, f3, this.canOverlap ? s3.sortKey : void 0), x3 = this.glyphOffsetArray.length, v3 = g3.vertexLength, b2 = this.allowVerticalPlacement && a3 === Ip.vertical ? Math.PI / 2 : 0, w2 = s3.text && s3.text.sections;
            for (let n4 = 0; n4 < e3.length; n4++) {
              const { tl: i4, tr: a4, bl: u4, br: c4, tex: h4, pixelOffsetTL: x4, pixelOffsetBR: v4, minFontScaleX: _3, minFontScaleY: A2, glyphOffset: S2, isSDF: k2, sectionIndex: I2 } = e3[n4], M2 = g3.vertexLength, T2 = S2[1];
              if (tf(y3, l2.x, l2.y, i4.x, T2 + i4.y, h4.x, h4.y, r3, k2, x4.x, x4.y, _3, A2), tf(y3, l2.x, l2.y, a4.x, T2 + a4.y, h4.x + h4.w, h4.y, r3, k2, v4.x, x4.y, _3, A2), tf(y3, l2.x, l2.y, u4.x, T2 + u4.y, h4.x, h4.y + h4.h, r3, k2, x4.x, v4.y, _3, A2), tf(y3, l2.x, l2.y, c4.x, T2 + c4.y, h4.x + h4.w, h4.y + h4.h, r3, k2, v4.x, v4.y, _3, A2), o3) {
                const { x: e4, y: r4, z: n5 } = o3.anchor, [i5, s4, a5] = o3.up;
                ef(m3, e4, r4, n5, i5, s4, a5), ef(m3, e4, r4, n5, i5, s4, a5), ef(m3, e4, r4, n5, i5, s4, a5), ef(m3, e4, r4, n5, i5, s4, a5), rf(t3.dynamicLayoutVertexArray, e4, r4, n5, b2);
              } else
                rf(t3.dynamicLayoutVertexArray, l2.x, l2.y, l2.z, b2);
              f3.emplaceBack(M2, M2 + 1, M2 + 2), f3.emplaceBack(M2 + 1, M2 + 2, M2 + 3), g3.vertexLength += 4, g3.primitiveLength += 2, this.glyphOffsetArray.emplaceBack(S2[0]), n4 !== e3.length - 1 && I2 === e3[n4 + 1].sectionIndex || t3.programConfigurations.populatePaintArrays(y3.length, s3, s3.index, {}, p3, d3, w2 && w2[I2]);
            }
            const _2 = o3 ? o3.anchor : l2;
            t3.placedSymbolArray.emplaceBack(_2.x, _2.y, _2.z, l2.x, l2.y, x3, this.glyphOffsetArray.length - x3, v3, u3, c3, l2.segment, r3 ? r3[0] : 0, r3 ? r3[1] : 0, n3[0], n3[1], a3, 0, false, 0, h3, 0);
          }
          _commitLayoutVertex(t3, e3, r3, n3, i3, s3, a3) {
            t3.emplaceBack(e3, r3, n3, i3, s3, Math.round(a3.x), Math.round(a3.y));
          }
          _addCollisionDebugVertices(t3, e3, r3, n3, i3, s3, a3) {
            const o3 = r3.segments.prepareSegment(4, r3.layoutVertexArray, r3.indexArray), l2 = o3.vertexLength, u3 = a3.tileAnchorX, c3 = a3.tileAnchorY;
            for (let t4 = 0; t4 < 4; t4++)
              r3.collisionVertexArray.emplaceBack(0, 0, 0, 0);
            r3.collisionVertexArrayExt.emplaceBack(e3, -t3.padding, -t3.padding), r3.collisionVertexArrayExt.emplaceBack(e3, t3.padding, -t3.padding), r3.collisionVertexArrayExt.emplaceBack(e3, t3.padding, t3.padding), r3.collisionVertexArrayExt.emplaceBack(e3, -t3.padding, t3.padding), this._commitLayoutVertex(r3.layoutVertexArray, n3, i3, s3, u3, c3, new x2(t3.x1, t3.y1)), this._commitLayoutVertex(r3.layoutVertexArray, n3, i3, s3, u3, c3, new x2(t3.x2, t3.y1)), this._commitLayoutVertex(r3.layoutVertexArray, n3, i3, s3, u3, c3, new x2(t3.x2, t3.y2)), this._commitLayoutVertex(r3.layoutVertexArray, n3, i3, s3, u3, c3, new x2(t3.x1, t3.y2)), o3.vertexLength += 4;
            const h3 = r3.indexArray;
            h3.emplaceBack(l2, l2 + 1), h3.emplaceBack(l2 + 1, l2 + 2), h3.emplaceBack(l2 + 2, l2 + 3), h3.emplaceBack(l2 + 3, l2), o3.primitiveLength += 4;
          }
          _addTextDebugCollisionBoxes(t3, e3, r3, n3, i3, s3) {
            for (let a3 = n3; a3 < i3; a3++) {
              const n4 = r3.get(a3), i4 = this.getSymbolInstanceTextSize(t3, s3, e3, a3);
              this._addCollisionDebugVertices(n4, i4, this.textCollisionBox, n4.projectedAnchorX, n4.projectedAnchorY, n4.projectedAnchorZ, s3);
            }
          }
          _addIconDebugCollisionBoxes(t3, e3, r3, n3, i3, s3) {
            for (let a3 = n3; a3 < i3; a3++) {
              const n4 = r3.get(a3), i4 = this.getSymbolInstanceIconSize(t3, e3, s3.placedIconSymbolIndex);
              this._addCollisionDebugVertices(n4, i4, this.iconCollisionBox, n4.projectedAnchorX, n4.projectedAnchorY, n4.projectedAnchorZ, s3);
            }
          }
          generateCollisionDebugBuffers(t3, e3) {
            this.hasDebugData() && this.destroyDebugData(), this.textCollisionBox = new af(Ws, Lh.members, la), this.iconCollisionBox = new af(Ws, Lh.members, la);
            const r3 = Oh(this.iconSizeData, t3), n3 = Oh(this.textSizeData, t3);
            for (let i3 = 0; i3 < this.symbolInstances.length; i3++) {
              const s3 = this.symbolInstances.get(i3);
              this._addTextDebugCollisionBoxes(n3, t3, e3, s3.textBoxStartIndex, s3.textBoxEndIndex, s3), this._addTextDebugCollisionBoxes(n3, t3, e3, s3.verticalTextBoxStartIndex, s3.verticalTextBoxEndIndex, s3), this._addIconDebugCollisionBoxes(r3, t3, e3, s3.iconBoxStartIndex, s3.iconBoxEndIndex, s3), this._addIconDebugCollisionBoxes(r3, t3, e3, s3.verticalIconBoxStartIndex, s3.verticalIconBoxEndIndex, s3);
            }
          }
          getSymbolInstanceTextSize(t3, e3, r3, n3) {
            const i3 = this.text.placedSymbolArray.get(e3.rightJustifiedTextSymbolIndex >= 0 ? e3.rightJustifiedTextSymbolIndex : e3.centerJustifiedTextSymbolIndex >= 0 ? e3.centerJustifiedTextSymbolIndex : e3.leftJustifiedTextSymbolIndex >= 0 ? e3.leftJustifiedTextSymbolIndex : e3.verticalPlacedTextSymbolIndex >= 0 ? e3.verticalPlacedTextSymbolIndex : n3), s3 = jh(this.textSizeData, t3, i3) / Rh;
            return this.tilePixelRatio * s3;
          }
          getSymbolInstanceIconSize(t3, e3, r3) {
            const n3 = this.icon.placedSymbolArray.get(r3), i3 = jh(this.iconSizeData, t3, n3);
            return this.tilePixelRatio * i3;
          }
          _commitDebugCollisionVertexUpdate(t3, e3, r3) {
            t3.emplaceBack(e3, -r3, -r3), t3.emplaceBack(e3, r3, -r3), t3.emplaceBack(e3, r3, r3), t3.emplaceBack(e3, -r3, r3);
          }
          _updateTextDebugCollisionBoxes(t3, e3, r3, n3, i3, s3) {
            for (let a3 = n3; a3 < i3; a3++) {
              const n4 = r3.get(a3), i4 = this.getSymbolInstanceTextSize(t3, s3, e3, a3);
              this._commitDebugCollisionVertexUpdate(this.textCollisionBox.collisionVertexArrayExt, i4, n4.padding);
            }
          }
          _updateIconDebugCollisionBoxes(t3, e3, r3, n3, i3, s3) {
            for (let a3 = n3; a3 < i3; a3++) {
              const n4 = r3.get(a3), i4 = this.getSymbolInstanceIconSize(t3, e3, s3);
              this._commitDebugCollisionVertexUpdate(this.iconCollisionBox.collisionVertexArrayExt, i4, n4.padding);
            }
          }
          updateCollisionDebugBuffers(t3, e3) {
            if (!this.hasDebugData())
              return;
            this.hasTextCollisionBoxData() && this.textCollisionBox.collisionVertexArrayExt.clear(), this.hasIconCollisionBoxData() && this.iconCollisionBox.collisionVertexArrayExt.clear();
            const r3 = Oh(this.iconSizeData, t3), n3 = Oh(this.textSizeData, t3);
            for (let i3 = 0; i3 < this.symbolInstances.length; i3++) {
              const s3 = this.symbolInstances.get(i3);
              this._updateTextDebugCollisionBoxes(n3, t3, e3, s3.textBoxStartIndex, s3.textBoxEndIndex, s3), this._updateTextDebugCollisionBoxes(n3, t3, e3, s3.verticalTextBoxStartIndex, s3.verticalTextBoxEndIndex, s3), this._updateIconDebugCollisionBoxes(r3, t3, e3, s3.iconBoxStartIndex, s3.iconBoxEndIndex, s3.placedIconSymbolIndex), this._updateIconDebugCollisionBoxes(r3, t3, e3, s3.verticalIconBoxStartIndex, s3.verticalIconBoxEndIndex, s3.placedIconSymbolIndex);
            }
            this.hasTextCollisionBoxData() && this.textCollisionBox.collisionVertexBufferExt && this.textCollisionBox.collisionVertexBufferExt.updateData(this.textCollisionBox.collisionVertexArrayExt), this.hasIconCollisionBoxData() && this.iconCollisionBox.collisionVertexBufferExt && this.iconCollisionBox.collisionVertexBufferExt.updateData(this.iconCollisionBox.collisionVertexArrayExt);
          }
          _deserializeCollisionBoxesForSymbol(t3, e3, r3, n3, i3, s3, a3, o3, l2) {
            const u3 = {};
            if (e3 < r3) {
              const { x1: r4, y1: n4, x2: i4, y2: s4, padding: a4, projectedAnchorX: o4, projectedAnchorY: l3, projectedAnchorZ: c3, tileAnchorX: h3, tileAnchorY: p3, featureIndex: d3 } = t3.get(e3);
              u3.textBox = { x1: r4, y1: n4, x2: i4, y2: s4, padding: a4, projectedAnchorX: o4, projectedAnchorY: l3, projectedAnchorZ: c3, tileAnchorX: h3, tileAnchorY: p3 }, u3.textFeatureIndex = d3;
            }
            if (n3 < i3) {
              const { x1: e4, y1: r4, x2: i4, y2: s4, padding: a4, projectedAnchorX: o4, projectedAnchorY: l3, projectedAnchorZ: c3, tileAnchorX: h3, tileAnchorY: p3, featureIndex: d3 } = t3.get(n3);
              u3.verticalTextBox = { x1: e4, y1: r4, x2: i4, y2: s4, padding: a4, projectedAnchorX: o4, projectedAnchorY: l3, projectedAnchorZ: c3, tileAnchorX: h3, tileAnchorY: p3 }, u3.verticalTextFeatureIndex = d3;
            }
            if (s3 < a3) {
              const { x1: e4, y1: r4, x2: n4, y2: i4, padding: a4, projectedAnchorX: o4, projectedAnchorY: l3, projectedAnchorZ: c3, tileAnchorX: h3, tileAnchorY: p3, featureIndex: d3 } = t3.get(s3);
              u3.iconBox = { x1: e4, y1: r4, x2: n4, y2: i4, padding: a4, projectedAnchorX: o4, projectedAnchorY: l3, projectedAnchorZ: c3, tileAnchorX: h3, tileAnchorY: p3 }, u3.iconFeatureIndex = d3;
            }
            if (o3 < l2) {
              const { x1: e4, y1: r4, x2: n4, y2: i4, padding: s4, projectedAnchorX: a4, projectedAnchorY: l3, projectedAnchorZ: c3, tileAnchorX: h3, tileAnchorY: p3, featureIndex: d3 } = t3.get(o3);
              u3.verticalIconBox = { x1: e4, y1: r4, x2: n4, y2: i4, padding: s4, projectedAnchorX: a4, projectedAnchorY: l3, projectedAnchorZ: c3, tileAnchorX: h3, tileAnchorY: p3 }, u3.verticalIconFeatureIndex = d3;
            }
            return u3;
          }
          deserializeCollisionBoxes(t3) {
            this.collisionArrays = [];
            for (let e3 = 0; e3 < this.symbolInstances.length; e3++) {
              const r3 = this.symbolInstances.get(e3);
              this.collisionArrays.push(this._deserializeCollisionBoxesForSymbol(t3, r3.textBoxStartIndex, r3.textBoxEndIndex, r3.verticalTextBoxStartIndex, r3.verticalTextBoxEndIndex, r3.iconBoxStartIndex, r3.iconBoxEndIndex, r3.verticalIconBoxStartIndex, r3.verticalIconBoxEndIndex));
            }
          }
          hasTextData() {
            return this.text.segments.get().length > 0;
          }
          hasIconData() {
            return this.icon.segments.get().length > 0;
          }
          hasDebugData() {
            return this.textCollisionBox && this.iconCollisionBox;
          }
          hasTextCollisionBoxData() {
            return this.hasDebugData() && this.textCollisionBox.segments.get().length > 0;
          }
          hasIconCollisionBoxData() {
            return this.hasDebugData() && this.iconCollisionBox.segments.get().length > 0;
          }
          addIndicesForPlacedSymbol(t3, e3) {
            const r3 = t3.placedSymbolArray.get(e3), n3 = r3.vertexStartIndex + 4 * r3.numGlyphs;
            for (let e4 = r3.vertexStartIndex; e4 < n3; e4 += 4)
              t3.indexArray.emplaceBack(e4, e4 + 1, e4 + 2), t3.indexArray.emplaceBack(e4 + 1, e4 + 2, e4 + 3);
          }
          getSortedSymbolIndexes(t3) {
            if (this.sortedAngle === t3 && void 0 !== this.symbolInstanceIndexes)
              return this.symbolInstanceIndexes;
            const e3 = Math.sin(t3), r3 = Math.cos(t3), n3 = [], i3 = [], s3 = [];
            for (let t4 = 0; t4 < this.symbolInstances.length; ++t4) {
              s3.push(t4);
              const a3 = this.symbolInstances.get(t4);
              n3.push(0 | Math.round(e3 * a3.tileAnchorX + r3 * a3.tileAnchorY)), i3.push(a3.featureIndex);
            }
            return s3.sort((t4, e4) => n3[t4] - n3[e4] || i3[e4] - i3[t4]), s3;
          }
          addToSortKeyRanges(t3, e3) {
            const r3 = this.sortKeyRanges[this.sortKeyRanges.length - 1];
            r3 && r3.sortKey === e3 ? r3.symbolInstanceEnd = t3 + 1 : this.sortKeyRanges.push({ sortKey: e3, symbolInstanceStart: t3, symbolInstanceEnd: t3 + 1 });
          }
          sortFeatures(t3) {
            if (this.sortFeaturesByY && this.sortedAngle !== t3 && !(this.text.segments.get().length > 1 || this.icon.segments.get().length > 1)) {
              this.symbolInstanceIndexes = this.getSortedSymbolIndexes(t3), this.sortedAngle = t3, this.text.indexArray.clear(), this.icon.indexArray.clear(), this.featureSortOrder = [];
              for (const t4 of this.symbolInstanceIndexes) {
                const e3 = this.symbolInstances.get(t4);
                this.featureSortOrder.push(e3.featureIndex);
                const { rightJustifiedTextSymbolIndex: r3, centerJustifiedTextSymbolIndex: n3, leftJustifiedTextSymbolIndex: i3, verticalPlacedTextSymbolIndex: s3, placedIconSymbolIndex: a3, verticalPlacedIconSymbolIndex: o3 } = e3;
                r3 >= 0 && this.addIndicesForPlacedSymbol(this.text, r3), n3 >= 0 && n3 !== r3 && this.addIndicesForPlacedSymbol(this.text, n3), i3 >= 0 && i3 !== n3 && i3 !== r3 && this.addIndicesForPlacedSymbol(this.text, i3), s3 >= 0 && this.addIndicesForPlacedSymbol(this.text, s3), a3 >= 0 && this.addIndicesForPlacedSymbol(this.icon, a3), o3 >= 0 && this.addIndicesForPlacedSymbol(this.icon, o3);
              }
              this.text.indexBuffer && this.text.indexBuffer.updateData(this.text.indexArray), this.icon.indexBuffer && this.icon.indexBuffer.updateData(this.icon.indexArray);
            }
          }
        }
        Ji(of, "SymbolBucket", { omit: ["layers", "collisionBoxArray", "features", "compareText"] }), of.MAX_GLYPHS = 65535, of.addDynamicAttributes = rf;
        const lf = new Ps({ "symbol-placement": new Bs(te.layout_symbol["symbol-placement"]), "symbol-spacing": new Bs(te.layout_symbol["symbol-spacing"]), "symbol-avoid-edges": new Bs(te.layout_symbol["symbol-avoid-edges"]), "symbol-sort-key": new Es(te.layout_symbol["symbol-sort-key"]), "symbol-z-order": new Bs(te.layout_symbol["symbol-z-order"]), "icon-allow-overlap": new Bs(te.layout_symbol["icon-allow-overlap"]), "icon-ignore-placement": new Bs(te.layout_symbol["icon-ignore-placement"]), "icon-optional": new Bs(te.layout_symbol["icon-optional"]), "icon-rotation-alignment": new Bs(te.layout_symbol["icon-rotation-alignment"]), "icon-size": new Es(te.layout_symbol["icon-size"]), "icon-text-fit": new Bs(te.layout_symbol["icon-text-fit"]), "icon-text-fit-padding": new Bs(te.layout_symbol["icon-text-fit-padding"]), "icon-image": new Es(te.layout_symbol["icon-image"]), "icon-rotate": new Es(te.layout_symbol["icon-rotate"]), "icon-padding": new Bs(te.layout_symbol["icon-padding"]), "icon-keep-upright": new Bs(te.layout_symbol["icon-keep-upright"]), "icon-offset": new Es(te.layout_symbol["icon-offset"]), "icon-anchor": new Es(te.layout_symbol["icon-anchor"]), "icon-pitch-alignment": new Bs(te.layout_symbol["icon-pitch-alignment"]), "text-pitch-alignment": new Bs(te.layout_symbol["text-pitch-alignment"]), "text-rotation-alignment": new Bs(te.layout_symbol["text-rotation-alignment"]), "text-field": new Es(te.layout_symbol["text-field"]), "text-font": new Es(te.layout_symbol["text-font"]), "text-size": new Es(te.layout_symbol["text-size"]), "text-max-width": new Es(te.layout_symbol["text-max-width"]), "text-line-height": new Es(te.layout_symbol["text-line-height"]), "text-letter-spacing": new Es(te.layout_symbol["text-letter-spacing"]), "text-justify": new Es(te.layout_symbol["text-justify"]), "text-radial-offset": new Es(te.layout_symbol["text-radial-offset"]), "text-variable-anchor": new Bs(te.layout_symbol["text-variable-anchor"]), "text-anchor": new Es(te.layout_symbol["text-anchor"]), "text-max-angle": new Bs(te.layout_symbol["text-max-angle"]), "text-writing-mode": new Bs(te.layout_symbol["text-writing-mode"]), "text-rotate": new Es(te.layout_symbol["text-rotate"]), "text-padding": new Bs(te.layout_symbol["text-padding"]), "text-keep-upright": new Bs(te.layout_symbol["text-keep-upright"]), "text-transform": new Es(te.layout_symbol["text-transform"]), "text-offset": new Es(te.layout_symbol["text-offset"]), "text-allow-overlap": new Bs(te.layout_symbol["text-allow-overlap"]), "text-ignore-placement": new Bs(te.layout_symbol["text-ignore-placement"]), "text-optional": new Bs(te.layout_symbol["text-optional"]) });
        var uf = { paint: new Ps({ "icon-opacity": new Es(te.paint_symbol["icon-opacity"]), "icon-color": new Es(te.paint_symbol["icon-color"]), "icon-halo-color": new Es(te.paint_symbol["icon-halo-color"]), "icon-halo-width": new Es(te.paint_symbol["icon-halo-width"]), "icon-halo-blur": new Es(te.paint_symbol["icon-halo-blur"]), "icon-translate": new Bs(te.paint_symbol["icon-translate"]), "icon-translate-anchor": new Bs(te.paint_symbol["icon-translate-anchor"]), "text-opacity": new Es(te.paint_symbol["text-opacity"]), "text-color": new Es(te.paint_symbol["text-color"], { runtimeType: pe, getOverride: (t3) => t3.textColor, hasOverride: (t3) => !!t3.textColor }), "text-halo-color": new Es(te.paint_symbol["text-halo-color"]), "text-halo-width": new Es(te.paint_symbol["text-halo-width"]), "text-halo-blur": new Es(te.paint_symbol["text-halo-blur"]), "text-translate": new Bs(te.paint_symbol["text-translate"]), "text-translate-anchor": new Bs(te.paint_symbol["text-translate-anchor"]) }), layout: lf };
        class cf {
          constructor(t3) {
            this.type = t3.property.overrides ? t3.property.overrides.runtimeType : le, this.defaultValue = t3;
          }
          evaluate(t3) {
            if (t3.formattedSection) {
              const e3 = this.defaultValue.property.overrides;
              if (e3 && e3.hasOverride(t3.formattedSection))
                return e3.getOverride(t3.formattedSection);
            }
            return t3.feature && t3.featureState ? this.defaultValue.evaluate(t3.feature, t3.featureState) : this.defaultValue.property.specification.default;
          }
          eachChild(t3) {
            this.defaultValue.isConstant() || t3(this.defaultValue.value._styleExpression.expression);
          }
          outputDefined() {
            return false;
          }
          serialize() {
            return null;
          }
        }
        Ji(cf, "FormatSectionOverride", { omit: ["defaultValue"] });
        class hf extends ro {
          constructor(t3) {
            super(t3, uf);
          }
          recalculate(t3, e3) {
            super.recalculate(t3, e3), "auto" === this.layout.get("icon-rotation-alignment") && (this.layout._values["icon-rotation-alignment"] = "point" !== this.layout.get("symbol-placement") ? "map" : "viewport"), "auto" === this.layout.get("text-rotation-alignment") && (this.layout._values["text-rotation-alignment"] = "point" !== this.layout.get("symbol-placement") ? "map" : "viewport"), "auto" === this.layout.get("text-pitch-alignment") && (this.layout._values["text-pitch-alignment"] = this.layout.get("text-rotation-alignment")), "auto" === this.layout.get("icon-pitch-alignment") && (this.layout._values["icon-pitch-alignment"] = this.layout.get("icon-rotation-alignment"));
            const r3 = this.layout.get("text-writing-mode");
            if (r3) {
              const t4 = [];
              for (const e4 of r3)
                t4.indexOf(e4) < 0 && t4.push(e4);
              this.layout._values["text-writing-mode"] = t4;
            } else
              this.layout._values["text-writing-mode"] = "point" === this.layout.get("symbol-placement") ? ["horizontal"] : ["horizontal", "vertical"];
            this._setPaintOverrides();
          }
          getValueAndResolveTokens(t3, e3, r3, n3) {
            const i3 = this.layout.get(t3).evaluate(e3, {}, r3, n3), s3 = this._unevaluatedLayout._values[t3];
            return s3.isDataDriven() || Jn(s3.value) || !i3 ? i3 : function(t4, e4) {
              return e4.replace(/{([^{}]+)}/g, (e5, r4) => r4 in t4 ? String(t4[r4]) : "");
            }(e3.properties, i3);
          }
          createBucket(t3) {
            return new of(t3);
          }
          queryRadius() {
            return 0;
          }
          queryIntersectsFeature() {
            return false;
          }
          _setPaintOverrides() {
            for (const t3 of uf.paint.overridableProperties) {
              if (!hf.hasPaintOverride(this.layout, t3))
                continue;
              const e3 = this.paint.get(t3), r3 = new cf(e3), n3 = new Xn(r3, e3.property.specification);
              let i3 = null;
              i3 = "constant" === e3.value.kind || "source" === e3.value.kind ? new Yn("source", n3) : new Wn("composite", n3, e3.value.zoomStops, e3.value._interpolationType), this.paint._values[t3] = new Ts(e3.property, i3, e3.parameters);
            }
          }
          _handleOverridablePaintPropertyUpdate(t3, e3, r3) {
            return !(!this.layout || e3.isDataDriven() || r3.isDataDriven()) && hf.hasPaintOverride(this.layout, t3);
          }
          static hasPaintOverride(t3, e3) {
            const r3 = t3.get("text-field"), n3 = uf.paint.properties[e3];
            let i3 = false;
            const s3 = (t4) => {
              for (const e4 of t4)
                if (n3.overrides && n3.overrides.hasOverride(e4))
                  return void (i3 = true);
            };
            if ("constant" === r3.value.kind && r3.value.value instanceof De)
              s3(r3.value.value.sections);
            else if ("source" === r3.value.kind) {
              const t4 = (e5) => {
                i3 || (e5 instanceof je && Re(e5.value) === me ? s3(e5.value.sections) : e5 instanceof Ze ? s3(e5.sections) : e5.eachChild(t4));
              }, e4 = r3.value;
              e4._styleExpression && t4(e4._styleExpression.expression);
            }
            return i3;
          }
          getProgramConfiguration(t3) {
            return new Xa(this, t3);
          }
        }
        var pf = { paint: new Ps({ "background-color": new Bs(te.paint_background["background-color"]), "background-pattern": new Bs(te.paint_background["background-pattern"]), "background-opacity": new Bs(te.paint_background["background-opacity"]) }) }, df = { paint: new Ps({ "raster-opacity": new Bs(te.paint_raster["raster-opacity"]), "raster-hue-rotate": new Bs(te.paint_raster["raster-hue-rotate"]), "raster-brightness-min": new Bs(te.paint_raster["raster-brightness-min"]), "raster-brightness-max": new Bs(te.paint_raster["raster-brightness-max"]), "raster-saturation": new Bs(te.paint_raster["raster-saturation"]), "raster-contrast": new Bs(te.paint_raster["raster-contrast"]), "raster-resampling": new Bs(te.paint_raster["raster-resampling"]), "raster-fade-duration": new Bs(te.paint_raster["raster-fade-duration"]) }) };
        class ff extends ro {
          constructor(t3) {
            super(t3, {}), this.implementation = t3;
          }
          is3D() {
            return "3d" === this.implementation.renderingMode;
          }
          hasOffscreenPass() {
            return void 0 !== this.implementation.prerender;
          }
          isLayerDraped() {
            return void 0 !== this.implementation.renderToTile;
          }
          shouldRedrape() {
            return !!this.implementation.shouldRerenderTiles && this.implementation.shouldRerenderTiles();
          }
          recalculate() {
          }
          updateTransitions() {
          }
          hasTransition() {
            return false;
          }
          serialize() {
          }
          onAdd(t3) {
            this.implementation.onAdd && this.implementation.onAdd(t3, t3.painter.context.gl);
          }
          onRemove(t3) {
            this.implementation.onRemove && this.implementation.onRemove(t3, t3.painter.context.gl);
          }
        }
        var yf = { paint: new Ps({ "sky-type": new Bs(te.paint_sky["sky-type"]), "sky-atmosphere-sun": new Bs(te.paint_sky["sky-atmosphere-sun"]), "sky-atmosphere-sun-intensity": new Bs(te.paint_sky["sky-atmosphere-sun-intensity"]), "sky-gradient-center": new Bs(te.paint_sky["sky-gradient-center"]), "sky-gradient-radius": new Bs(te.paint_sky["sky-gradient-radius"]), "sky-gradient": new Cs(te.paint_sky["sky-gradient"]), "sky-atmosphere-halo-color": new Bs(te.paint_sky["sky-atmosphere-halo-color"]), "sky-atmosphere-color": new Bs(te.paint_sky["sky-atmosphere-color"]), "sky-opacity": new Bs(te.paint_sky["sky-opacity"]) }) };
        function mf(t3, e3, r3) {
          const n3 = [0, 0, 1], i3 = Ko([]);
          return Jo(i3, i3, r3 ? -w(t3) + Math.PI : w(t3)), Xo(i3, i3, -w(e3)), Ro(n3, n3, i3), Do(n3, n3);
        }
        const gf = { circle: class extends ro {
          constructor(t3) {
            super(t3, Tu);
          }
          createBucket(t3) {
            return new cu(t3);
          }
          queryRadius(t3) {
            const e3 = t3;
            return Au("circle-radius", this, e3) + Au("circle-stroke-width", this, e3) + Su(this.paint.get("circle-translate"));
          }
          queryIntersectsFeature(t3, e3, r3, n3, i3, s3, a3, o3) {
            const l2 = Iu(this.paint.get("circle-translate"), this.paint.get("circle-translate-anchor"), s3.angle, t3.pixelToTileUnitsFactor), u3 = this.paint.get("circle-radius").evaluate(e3, r3) + this.paint.get("circle-stroke-width").evaluate(e3, r3);
            return zu(t3, n3, s3, a3, o3, "map" === this.paint.get("circle-pitch-alignment"), "map" === this.paint.get("circle-pitch-scale"), l2, u3);
          }
          getProgramIds() {
            return ["circle"];
          }
          getProgramConfiguration(t3) {
            return new Xa(this, t3);
          }
        }, heatmap: class extends ro {
          createBucket(t3) {
            return new Du(t3);
          }
          constructor(t3) {
            super(t3, $u), this._updateColorRamp();
          }
          _handleSpecialPaintPropertyUpdate(t3) {
            "heatmap-color" === t3 && this._updateColorRamp();
          }
          _updateColorRamp() {
            this.colorRamp = ju({ expression: this._transitionablePaint._values["heatmap-color"].value.expression, evaluationKey: "heatmapDensity", image: this.colorRamp }), this.colorRampTexture = null;
          }
          resize() {
            this.heatmapFbo && (this.heatmapFbo.destroy(), this.heatmapFbo = null);
          }
          queryRadius(t3) {
            return Au("heatmap-radius", this, t3);
          }
          queryIntersectsFeature(t3, e3, r3, n3, i3, s3, a3, o3) {
            const l2 = this.paint.get("heatmap-radius").evaluate(e3, r3);
            return zu(t3, n3, s3, a3, o3, true, true, new x2(0, 0), l2);
          }
          hasOffscreenPass() {
            return 0 !== this.paint.get("heatmap-opacity") && "none" !== this.visibility;
          }
          getProgramIds() {
            return ["heatmap", "heatmapTexture"];
          }
          getProgramConfiguration(t3) {
            return new Xa(this, t3);
          }
        }, hillshade: class extends ro {
          constructor(t3) {
            super(t3, Ou);
          }
          hasOffscreenPass() {
            return 0 !== this.paint.get("hillshade-exaggeration") && "none" !== this.visibility;
          }
          getProgramIds() {
            return ["hillshade", "hillshadePrepare"];
          }
        }, fill: class extends ro {
          constructor(t3) {
            super(t3, zc);
          }
          getProgramIds() {
            const t3 = this.paint.get("fill-pattern"), e3 = t3 && t3.constantOr(1), r3 = [e3 ? "fillPattern" : "fill"];
            return this.paint.get("fill-antialias") && r3.push(e3 && !this.getPaintProperty("fill-outline-color") ? "fillOutlinePattern" : "fillOutline"), r3;
          }
          getProgramConfiguration(t3) {
            return new Xa(this, t3);
          }
          recalculate(t3, e3) {
            super.recalculate(t3, e3);
            const r3 = this.paint._values["fill-outline-color"];
            "constant" === r3.value.kind && void 0 === r3.value.value && (this.paint._values["fill-outline-color"] = this.paint._values["fill-color"]);
          }
          createBucket(t3) {
            return new Mc(t3);
          }
          queryRadius() {
            return Su(this.paint.get("fill-translate"));
          }
          queryIntersectsFeature(t3, e3, r3, n3, i3, s3) {
            return !t3.queryGeometry.isAboveHorizon && du(ku(t3.tilespaceGeometry, this.paint.get("fill-translate"), this.paint.get("fill-translate-anchor"), s3.angle, t3.pixelToTileUnitsFactor), n3);
          }
          isTileClipped() {
            return true;
          }
        }, "fill-extrusion": class extends ro {
          constructor(t3) {
            super(t3, ch);
          }
          createBucket(t3) {
            return new th(t3);
          }
          queryRadius() {
            return Su(this.paint.get("fill-extrusion-translate"));
          }
          is3D() {
            return true;
          }
          getProgramIds() {
            return [this.paint.get("fill-extrusion-pattern").constantOr(1) ? "fillExtrusionPattern" : "fillExtrusion"];
          }
          getProgramConfiguration(t3) {
            return new Xa(this, t3);
          }
          queryIntersectsFeature(t3, e3, r3, n3, i3, s3, a3, o3, l2) {
            const u3 = Iu(this.paint.get("fill-extrusion-translate"), this.paint.get("fill-extrusion-translate-anchor"), s3.angle, t3.pixelToTileUnitsFactor), c3 = this.paint.get("fill-extrusion-height").evaluate(e3, r3), h3 = this.paint.get("fill-extrusion-base").evaluate(e3, r3), p3 = [0, 0], d3 = o3 && s3.elevation, f3 = s3.elevation ? s3.elevation.exaggeration() : 1, y3 = t3.tile.getBucket(this);
            if (d3 && y3 instanceof th) {
              const t4 = y3.centroidVertexArray, e4 = l2 + 1;
              e4 < t4.length && (p3[0] = t4.geta_centroid_pos0(e4), p3[1] = t4.geta_centroid_pos1(e4));
            }
            if (0 === p3[0] && 1 === p3[1])
              return false;
            "globe" === s3.projection.name && (n3 = lh([n3], [new x2(0, 0), new x2(ao, ao)], t3.tileID.canonical).map((t4) => t4.polygon).flat());
            const m3 = d3 ? o3 : null, [g3, v3] = function(t4, e4, r4, n4, i4, s4, a4, o4, l3, u4, c4) {
              return "globe" === t4.projection.name ? function(t5, e5, r5, n5, i5, s5, a5, o5, l4, u5, c5) {
                const h4 = [], p4 = [], d4 = t5.projection.upVectorScale(c5, t5.center.lat, t5.worldSize).metersToTile, f4 = [0, 0, 0, 1], y4 = [0, 0, 0, 1], m4 = (t6, e6, r6, n6) => {
                  t6[0] = e6, t6[1] = r6, t6[2] = n6, t6[3] = 1;
                }, g4 = oh();
                r5 > 0 && (r5 += g4), n5 += g4;
                for (const g5 of e5) {
                  const e6 = [], x3 = [];
                  for (const h5 of g5) {
                    const p5 = h5.x + i5.x, g6 = h5.y + i5.y, v4 = t5.projection.projectTilePoint(p5, g6, c5), b3 = t5.projection.upVector(c5, h5.x, h5.y);
                    let w2 = r5, _2 = n5;
                    if (a5) {
                      const t6 = vh(p5, g6, r5, n5, a5, o5, l4, u5);
                      w2 += t6.base, _2 += t6.top;
                    }
                    0 !== r5 ? m4(f4, v4.x + b3[0] * d4 * w2, v4.y + b3[1] * d4 * w2, v4.z + b3[2] * d4 * w2) : m4(f4, v4.x, v4.y, v4.z), m4(y4, v4.x + b3[0] * d4 * _2, v4.y + b3[1] * d4 * _2, v4.z + b3[2] * d4 * _2), Fo(f4, f4, s5), Fo(y4, y4, s5), e6.push(new mh(f4[0], f4[1], f4[2])), x3.push(new mh(y4[0], y4[1], y4[2]));
                  }
                  h4.push(e6), p4.push(x3);
                }
                return [h4, p4];
              }(t4, e4, r4, n4, i4, s4, a4, o4, l3, u4, c4) : a4 ? function(t5, e5, r5, n5, i5, s5, a5, o5, l4) {
                const u5 = [], c5 = [], h4 = [0, 0, 0, 1];
                for (const p4 of t5) {
                  const t6 = [], d4 = [];
                  for (const u6 of p4) {
                    const c6 = u6.x + n5.x, p5 = u6.y + n5.y, f4 = vh(c6, p5, e5, r5, s5, a5, o5, l4);
                    h4[0] = c6, h4[1] = p5, h4[2] = f4.base, h4[3] = 1, Go(h4, h4, i5), h4[3] = Math.max(h4[3], 1e-5);
                    const y4 = new mh(h4[0] / h4[3], h4[1] / h4[3], h4[2] / h4[3]);
                    h4[0] = c6, h4[1] = p5, h4[2] = f4.top, h4[3] = 1, Go(h4, h4, i5), h4[3] = Math.max(h4[3], 1e-5);
                    const m4 = new mh(h4[0] / h4[3], h4[1] / h4[3], h4[2] / h4[3]);
                    t6.push(y4), d4.push(m4);
                  }
                  u5.push(t6), c5.push(d4);
                }
                return [u5, c5];
              }(e4, r4, n4, i4, s4, a4, o4, l3, u4) : function(t5, e5, r5, n5, i5) {
                const s5 = [], a5 = [], o5 = i5[8] * e5, l4 = i5[9] * e5, u5 = i5[10] * e5, c5 = i5[11] * e5, h4 = i5[8] * r5, p4 = i5[9] * r5, d4 = i5[10] * r5, f4 = i5[11] * r5;
                for (const e6 of t5) {
                  const t6 = [], r6 = [];
                  for (const s6 of e6) {
                    const e7 = s6.x + n5.x, a6 = s6.y + n5.y, y4 = i5[0] * e7 + i5[4] * a6 + i5[12], m4 = i5[1] * e7 + i5[5] * a6 + i5[13], g4 = i5[2] * e7 + i5[6] * a6 + i5[14], x3 = i5[3] * e7 + i5[7] * a6 + i5[15], v4 = y4 + o5, b3 = m4 + l4, w2 = g4 + u5, _2 = Math.max(x3 + c5, 1e-5), A2 = y4 + h4, S2 = m4 + p4, k2 = g4 + d4, I2 = Math.max(x3 + f4, 1e-5);
                    t6.push(new mh(v4 / _2, b3 / _2, w2 / _2)), r6.push(new mh(A2 / I2, S2 / I2, k2 / I2));
                  }
                  s5.push(t6), a5.push(r6);
                }
                return [s5, a5];
              }(e4, r4, n4, i4, s4);
            }(s3, n3, h3, c3, u3, a3, m3, p3, f3, s3.center.lat, t3.tileID.canonical), b2 = t3.queryGeometry;
            return function(t4, e4, r4) {
              let n4 = 1 / 0;
              du(r4, e4) && (n4 = xh(r4, e4[0]));
              for (let i4 = 0; i4 < e4.length; i4++) {
                const s4 = e4[i4], a4 = t4[i4];
                for (let t5 = 0; t5 < s4.length - 1; t5++) {
                  const e5 = s4[t5], i5 = [e5, s4[t5 + 1], a4[t5 + 1], a4[t5], e5];
                  hu(r4, i5) && (n4 = Math.min(n4, xh(r4, i5)));
                }
              }
              return n4 !== 1 / 0 && n4;
            }(g3, v3, b2.isPointQuery() ? b2.screenBounds : b2.screenGeometry);
          }
        }, line: class extends ro {
          constructor(t3) {
            super(t3, Th), this.gradientVersion = 0;
          }
          _handleSpecialPaintPropertyUpdate(t3) {
            if ("line-gradient" === t3) {
              const t4 = this._transitionablePaint._values["line-gradient"].value.expression;
              this.stepInterpolant = t4._styleExpression && t4._styleExpression.expression instanceof Br, this.gradientVersion = (this.gradientVersion + 1) % Number.MAX_SAFE_INTEGER;
            }
          }
          gradientExpression() {
            return this._transitionablePaint._values["line-gradient"].value.expression;
          }
          widthExpression() {
            return this._transitionablePaint._values["line-width"].value.expression;
          }
          recalculate(t3, e3) {
            super.recalculate(t3, e3), this.paint._values["line-floorwidth"] = zh.possiblyEvaluate(this._transitioningPaint._values["line-width"].value, t3);
          }
          createBucket(t3) {
            return new Ih(t3);
          }
          getProgramIds() {
            return [this.paint.get("line-pattern").constantOr(1) ? "linePattern" : "line"];
          }
          getProgramConfiguration(t3) {
            return new Xa(this, t3);
          }
          queryRadius(t3) {
            const e3 = t3, r3 = Bh(Au("line-width", this, e3), Au("line-gap-width", this, e3)), n3 = Au("line-offset", this, e3);
            return r3 / 2 + Math.abs(n3) + Su(this.paint.get("line-translate"));
          }
          queryIntersectsFeature(t3, e3, r3, n3, i3, s3) {
            if (t3.queryGeometry.isAboveHorizon)
              return false;
            const a3 = ku(t3.tilespaceGeometry, this.paint.get("line-translate"), this.paint.get("line-translate-anchor"), s3.angle, t3.pixelToTileUnitsFactor), o3 = t3.pixelToTileUnitsFactor / 2 * Bh(this.paint.get("line-width").evaluate(e3, r3), this.paint.get("line-gap-width").evaluate(e3, r3)), l2 = this.paint.get("line-offset").evaluate(e3, r3);
            return l2 && (n3 = function(t4, e4) {
              const r4 = [], n4 = new x2(0, 0);
              for (let i4 = 0; i4 < t4.length; i4++) {
                const s4 = t4[i4], a4 = [];
                for (let t5 = 0; t5 < s4.length; t5++) {
                  const r5 = s4[t5], i5 = s4[t5 + 1], o4 = 0 === t5 ? n4 : r5.sub(s4[t5 - 1])._unit()._perp(), l3 = t5 === s4.length - 1 ? n4 : i5.sub(r5)._unit()._perp(), u3 = o4._add(l3)._unit();
                  u3._mult(1 / (u3.x * l3.x + u3.y * l3.y)), a4.push(u3._mult(e4)._add(r5));
                }
                r4.push(a4);
              }
              return r4;
            }(n3, l2 * t3.pixelToTileUnitsFactor)), function(t4, e4, r4) {
              for (let n4 = 0; n4 < e4.length; n4++) {
                const i4 = e4[n4];
                if (t4.length >= 3) {
                  for (let e5 = 0; e5 < i4.length; e5++)
                    if (bu(t4, i4[e5]))
                      return true;
                }
                if (fu(t4, i4, r4))
                  return true;
              }
              return false;
            }(a3, n3, o3);
          }
          isTileClipped() {
            return true;
          }
        }, symbol: hf, background: class extends ro {
          constructor(t3) {
            super(t3, pf);
          }
          getProgramIds() {
            return [this.paint.get("background-pattern") ? "backgroundPattern" : "background"];
          }
        }, raster: class extends ro {
          constructor(t3) {
            super(t3, df);
          }
          getProgramIds() {
            return ["raster"];
          }
        }, sky: class extends ro {
          constructor(t3) {
            super(t3, yf), this._updateColorRamp();
          }
          _handleSpecialPaintPropertyUpdate(t3) {
            "sky-gradient" === t3 ? this._updateColorRamp() : "sky-atmosphere-sun" !== t3 && "sky-atmosphere-halo-color" !== t3 && "sky-atmosphere-color" !== t3 && "sky-atmosphere-sun-intensity" !== t3 || (this._skyboxInvalidated = true);
          }
          _updateColorRamp() {
            this.colorRamp = ju({ expression: this._transitionablePaint._values["sky-gradient"].value.expression, evaluationKey: "skyRadialProgress" }), this.colorRampTexture && (this.colorRampTexture.destroy(), this.colorRampTexture = null);
          }
          needsSkyboxCapture(t3) {
            if (this._skyboxInvalidated || !this.skyboxTexture || !this.skyboxGeometry)
              return true;
            if (!this.paint.get("sky-atmosphere-sun")) {
              const e3 = t3.style.light.properties.get("position");
              return this._lightPosition.azimuthal !== e3.azimuthal || this._lightPosition.polar !== e3.polar;
            }
            return false;
          }
          getCenter(t3, e3) {
            if ("atmosphere" === this.paint.get("sky-type")) {
              const r4 = this.paint.get("sky-atmosphere-sun"), n3 = !r4, i3 = t3.style.light, s3 = i3.properties.get("position");
              return n3 && "viewport" === i3.properties.get("anchor") && N("The sun direction is attached to a light with viewport anchor, lighting may behave unexpectedly."), n3 ? mf(s3.azimuthal, 90 - s3.polar, e3) : mf(r4[0], 90 - r4[1], e3);
            }
            const r3 = this.paint.get("sky-gradient-center");
            return mf(r3[0], 90 - r3[1], e3);
          }
          is3D() {
            return false;
          }
          isSky() {
            return true;
          }
          markSkyboxValid(t3) {
            this._skyboxInvalidated = false, this._lightPosition = t3.style.light.properties.get("position");
          }
          hasOffscreenPass() {
            return true;
          }
          getProgramIds() {
            const t3 = this.paint.get("sky-type");
            return "atmosphere" === t3 ? ["skyboxCapture", "skybox"] : "gradient" === t3 ? ["skyboxGradient"] : null;
          }
        } };
        class xf {
          constructor(t3, e3, r3, n3) {
            this.context = t3, this.format = r3, this.texture = t3.gl.createTexture(), this.update(e3, n3);
          }
          update(t3, r3, n3) {
            const { width: i3, height: s3 } = t3, { context: a3 } = this, { gl: o3 } = a3, { HTMLImageElement: l2, HTMLCanvasElement: u3, HTMLVideoElement: c3, ImageData: h3, ImageBitmap: p3 } = e2;
            if (o3.bindTexture(o3.TEXTURE_2D, this.texture), a3.pixelStoreUnpackFlipY.set(false), a3.pixelStoreUnpack.set(1), a3.pixelStoreUnpackPremultiplyAlpha.set(this.format === o3.RGBA && (!r3 || false !== r3.premultiply)), n3 || this.size && this.size[0] === i3 && this.size[1] === s3) {
              const { x: e3, y: r4 } = n3 || { x: 0, y: 0 };
              t3 instanceof l2 || t3 instanceof u3 || t3 instanceof c3 || t3 instanceof h3 || p3 && t3 instanceof p3 ? o3.texSubImage2D(o3.TEXTURE_2D, 0, e3, r4, o3.RGBA, o3.UNSIGNED_BYTE, t3) : o3.texSubImage2D(o3.TEXTURE_2D, 0, e3, r4, i3, s3, o3.RGBA, o3.UNSIGNED_BYTE, t3.data);
            } else
              this.size = [i3, s3], t3 instanceof l2 || t3 instanceof u3 || t3 instanceof c3 || t3 instanceof h3 || p3 && t3 instanceof p3 ? o3.texImage2D(o3.TEXTURE_2D, 0, this.format, this.format, o3.UNSIGNED_BYTE, t3) : o3.texImage2D(o3.TEXTURE_2D, 0, this.format, i3, s3, 0, this.format, o3.UNSIGNED_BYTE, t3.data);
            this.useMipmap = Boolean(r3 && r3.useMipmap && this.isSizePowerOfTwo()), this.useMipmap && o3.generateMipmap(o3.TEXTURE_2D);
          }
          bind(t3, e3) {
            const { context: r3 } = this, { gl: n3 } = r3;
            n3.bindTexture(n3.TEXTURE_2D, this.texture), t3 !== this.filter && (n3.texParameteri(n3.TEXTURE_2D, n3.TEXTURE_MAG_FILTER, t3), n3.texParameteri(n3.TEXTURE_2D, n3.TEXTURE_MIN_FILTER, this.useMipmap ? t3 === n3.NEAREST ? n3.NEAREST_MIPMAP_NEAREST : n3.LINEAR_MIPMAP_NEAREST : t3), this.filter = t3), e3 !== this.wrap && (n3.texParameteri(n3.TEXTURE_2D, n3.TEXTURE_WRAP_S, e3), n3.texParameteri(n3.TEXTURE_2D, n3.TEXTURE_WRAP_T, e3), this.wrap = e3);
          }
          isSizePowerOfTwo() {
            return this.size[0] === this.size[1] && Math.log(this.size[0]) / Math.LN2 % 1 == 0;
          }
          destroy() {
            const { gl: t3 } = this.context;
            t3.deleteTexture(this.texture), this.texture = null;
          }
        }
        class vf {
          constructor(t3) {
            this._callback = t3, this._triggered = false, "undefined" != typeof MessageChannel && (this._channel = new MessageChannel(), this._channel.port2.onmessage = () => {
              this._triggered = false, this._callback();
            });
          }
          trigger() {
            this._triggered || (this._triggered = true, this._channel ? this._channel.port1.postMessage(true) : setTimeout(() => {
              this._triggered = false, this._callback();
            }, 0));
          }
          remove() {
            this._channel = void 0, this._callback = () => {
            };
          }
        }
        class bf {
          constructor() {
            this.tasks = {}, this.taskQueue = [], R(["process"], this), this.invoker = new vf(this.process), this.nextId = 0;
          }
          add(t3, e3) {
            const r3 = this.nextId++, n3 = function({ type: t4, isSymbolTile: e4, zoom: r4 }) {
              return r4 = r4 || 0, "message" === t4 ? 0 : "maybePrepare" !== t4 || e4 ? "parseTile" !== t4 || e4 ? "parseTile" === t4 && e4 ? 300 - r4 : "maybePrepare" === t4 && e4 ? 400 - r4 : 500 : 200 - r4 : 100 - r4;
            }(e3);
            if (0 === n3) {
              K();
              try {
                t3();
              } finally {
              }
              return { cancel: () => {
              } };
            }
            return this.tasks[r3] = { fn: t3, metadata: e3, priority: n3, id: r3 }, this.taskQueue.push(r3), this.invoker.trigger(), { cancel: () => {
              delete this.tasks[r3];
            } };
          }
          process() {
            K();
            try {
              if (this.taskQueue = this.taskQueue.filter((t4) => !!this.tasks[t4]), !this.taskQueue.length)
                return;
              const t3 = this.pick();
              if (null === t3)
                return;
              const e3 = this.tasks[t3];
              if (delete this.tasks[t3], this.taskQueue.length && this.invoker.trigger(), !e3)
                return;
              e3.fn();
            } finally {
            }
          }
          pick() {
            let t3 = null, e3 = 1 / 0;
            for (let r4 = 0; r4 < this.taskQueue.length; r4++) {
              const n3 = this.tasks[this.taskQueue[r4]];
              n3.priority < e3 && (e3 = n3.priority, t3 = r4);
            }
            if (null === t3)
              return null;
            const r3 = this.taskQueue[t3];
            return this.taskQueue.splice(t3, 1), r3;
          }
          remove() {
            this.invoker.remove();
          }
        }
        class wf {
          constructor(t3) {
            this._stringToNumber = {}, this._numberToString = [];
            for (let e3 = 0; e3 < t3.length; e3++) {
              const r3 = t3[e3];
              this._stringToNumber[r3] = e3, this._numberToString[e3] = r3;
            }
          }
          encode(t3) {
            return this._stringToNumber[t3];
          }
          decode(t3) {
            return this._numberToString[t3];
          }
        }
        const _f = ["tile", "layer", "source", "sourceLayer", "state"];
        class Af {
          constructor(t3, e3, r3, n3, i3) {
            this.type = "Feature", this._vectorTileFeature = t3, this._z = e3, this._x = r3, this._y = n3, this.properties = t3.properties, this.id = i3;
          }
          get geometry() {
            return void 0 === this._geometry && (this._geometry = this._vectorTileFeature.toGeoJSON(this._x, this._y, this._z).geometry), this._geometry;
          }
          set geometry(t3) {
            this._geometry = t3;
          }
          toJSON() {
            const t3 = { type: "Feature", state: void 0, geometry: this.geometry, properties: this.properties };
            void 0 !== this.id && (t3.id = this.id);
            for (const e3 of _f)
              void 0 !== this[e3] && (t3[e3] = this[e3]);
            return t3;
          }
        }
        const Sf = 32, kf = 33, If = new Uint16Array(8184);
        for (let t3 = 0; t3 < 2046; t3++) {
          let e3 = t3 + 2, r3 = 0, n3 = 0, i3 = 0, s3 = 0, a3 = 0, o3 = 0;
          for (1 & e3 ? i3 = s3 = a3 = Sf : r3 = n3 = o3 = Sf; (e3 >>= 1) > 1; ) {
            const t4 = r3 + i3 >> 1, l3 = n3 + s3 >> 1;
            1 & e3 ? (i3 = r3, s3 = n3, r3 = a3, n3 = o3) : (r3 = i3, n3 = s3, i3 = a3, s3 = o3), a3 = t4, o3 = l3;
          }
          const l2 = 4 * t3;
          If[l2 + 0] = r3, If[l2 + 1] = n3, If[l2 + 2] = i3, If[l2 + 3] = s3;
        }
        const Mf = new Uint16Array(2178), Tf = new Uint8Array(1089), zf = new Uint16Array(1089);
        function Bf(t3) {
          return 0 === t3 ? -0.03125 : 32 === t3 ? 0.03125 : 0;
        }
        var Ef = Rs([{ name: "a_pos", type: "Int16", components: 2 }, { name: "a_texture_pos", type: "Int16", components: 2 }]);
        const Cf = { type: 2, extent: ao, loadGeometry: () => [[new x2(0, 0), new x2(ao + 1, 0), new x2(ao + 1, ao + 1), new x2(0, ao + 1), new x2(0, 0)]] };
        class Pf {
          constructor(t3, e3, r3, n3, i3) {
            this.tileID = t3, this.uid = D(), this.uses = 0, this.tileSize = e3, this.tileZoom = r3, this.buckets = {}, this.expirationTime = null, this.queryPadding = 0, this.hasSymbolBuckets = false, this.hasRTLText = false, this.dependencies = {}, this.isRaster = i3, this.expiredRequestCount = 0, this.state = "loading", n3 && n3.transform && (this.projection = n3.transform.projection);
          }
          registerFadeDuration(t3) {
            const e3 = t3 + this.timeAdded;
            e3 < Xt.now() || this.fadeEndTime && e3 < this.fadeEndTime || (this.fadeEndTime = e3);
          }
          wasRequested() {
            return "errored" === this.state || "loaded" === this.state || "reloading" === this.state;
          }
          get tileTransform() {
            return this._tileTransform || (this._tileTransform = Bd(this.tileID.canonical, this.projection)), this._tileTransform;
          }
          loadVectorData(t3, e3, r3) {
            if (this.unloadVectorData(), this.state = "loaded", t3) {
              t3.featureIndex && (this.latestFeatureIndex = t3.featureIndex, t3.rawTileData ? (this.latestRawTileData = t3.rawTileData, this.latestFeatureIndex.rawTileData = t3.rawTileData) : this.latestRawTileData && (this.latestFeatureIndex.rawTileData = this.latestRawTileData)), this.collisionBoxArray = t3.collisionBoxArray, this.buckets = function(t4, e4) {
                const r4 = {};
                if (!e4)
                  return r4;
                for (const n3 of t4) {
                  const t5 = n3.layerIds.map((t6) => e4.getLayer(t6)).filter(Boolean);
                  if (0 !== t5.length) {
                    n3.layers = t5, n3.stateDependentLayerIds && (n3.stateDependentLayers = n3.stateDependentLayerIds.map((e5) => t5.filter((t6) => t6.id === e5)[0]));
                    for (const e5 of t5)
                      r4[e5.id] = n3;
                  }
                }
                return r4;
              }(t3.buckets, e3.style), this.hasSymbolBuckets = false;
              for (const t4 in this.buckets) {
                const e4 = this.buckets[t4];
                if (e4 instanceof of) {
                  if (this.hasSymbolBuckets = true, !r3)
                    break;
                  e4.justReloaded = true;
                }
              }
              if (this.hasRTLText = false, this.hasSymbolBuckets)
                for (const t4 in this.buckets) {
                  const e4 = this.buckets[t4];
                  if (e4 instanceof of && e4.hasRTLText) {
                    this.hasRTLText = true, bs.isLoading() || bs.isLoaded() || "deferred" !== xs() || vs();
                    break;
                  }
                }
              this.queryPadding = 0;
              for (const t4 in this.buckets) {
                const r4 = this.buckets[t4];
                this.queryPadding = Math.max(this.queryPadding, e3.style.getLayer(t4).queryRadius(r4));
              }
              t3.imageAtlas && (this.imageAtlas = t3.imageAtlas), t3.glyphAtlasImage && (this.glyphAtlasImage = t3.glyphAtlasImage), t3.lineAtlas && (this.lineAtlas = t3.lineAtlas);
            } else
              this.collisionBoxArray = new pa();
          }
          unloadVectorData() {
            if (this.hasData()) {
              for (const t3 in this.buckets)
                this.buckets[t3].destroy();
              this.buckets = {}, this.imageAtlas && (this.imageAtlas = null), this.lineAtlas && (this.lineAtlas = null), this.imageAtlasTexture && this.imageAtlasTexture.destroy(), this.glyphAtlasTexture && this.glyphAtlasTexture.destroy(), this.lineAtlasTexture && this.lineAtlasTexture.destroy(), this._tileBoundsBuffer && (this._tileBoundsBuffer.destroy(), this._tileBoundsIndexBuffer.destroy(), this._tileBoundsSegments.destroy(), this._tileBoundsBuffer = null), this._tileDebugBuffer && (this._tileDebugBuffer.destroy(), this._tileDebugSegments.destroy(), this._tileDebugBuffer = null), this._tileDebugIndexBuffer && (this._tileDebugIndexBuffer.destroy(), this._tileDebugIndexBuffer = null), this._globeTileDebugBorderBuffer && (this._globeTileDebugBorderBuffer.destroy(), this._globeTileDebugBorderBuffer = null), this._tileDebugTextBuffer && (this._tileDebugTextBuffer.destroy(), this._tileDebugTextSegments.destroy(), this._tileDebugTextIndexBuffer.destroy(), this._tileDebugTextBuffer = null), this._globeTileDebugTextBuffer && (this._globeTileDebugTextBuffer.destroy(), this._globeTileDebugTextBuffer = null), this.latestFeatureIndex = null, this.state = "unloaded";
            }
          }
          getBucket(t3) {
            return this.buckets[t3.id];
          }
          upload(t3) {
            for (const e4 in this.buckets) {
              const r3 = this.buckets[e4];
              r3.uploadPending() && r3.upload(t3);
            }
            const e3 = t3.gl;
            this.imageAtlas && !this.imageAtlas.uploaded && (this.imageAtlasTexture = new xf(t3, this.imageAtlas.image, e3.RGBA), this.imageAtlas.uploaded = true), this.glyphAtlasImage && (this.glyphAtlasTexture = new xf(t3, this.glyphAtlasImage, e3.ALPHA), this.glyphAtlasImage = null), this.lineAtlas && !this.lineAtlas.uploaded && (this.lineAtlasTexture = new xf(t3, this.lineAtlas.image, e3.ALPHA), this.lineAtlas.uploaded = true);
          }
          prepare(t3) {
            this.imageAtlas && this.imageAtlas.patchUpdatedImages(t3, this.imageAtlasTexture);
          }
          queryRenderedFeatures(t3, e3, r3, n3, i3, s3, a3, o3) {
            return this.latestFeatureIndex && this.latestFeatureIndex.rawTileData ? this.latestFeatureIndex.query({ tileResult: n3, pixelPosMatrix: a3, transform: s3, params: i3, tileTransform: this.tileTransform }, t3, e3, r3) : {};
          }
          querySourceFeatures(t3, e3) {
            const r3 = this.latestFeatureIndex;
            if (!r3 || !r3.rawTileData)
              return;
            const n3 = r3.loadVTLayers(), i3 = e3 ? e3.sourceLayer : "", s3 = n3._geojsonTileLayer || n3[i3];
            if (!s3)
              return;
            const a3 = hi(e3 && e3.filter), { z: o3, x: l2, y: u3 } = this.tileID.canonical, c3 = { z: o3, x: l2, y: u3 };
            for (let e4 = 0; e4 < s3.length; e4++) {
              const n4 = s3.feature(e4);
              if (a3.needGeometry) {
                const t4 = ou(n4, true);
                if (!a3.filter(new ws(this.tileID.overscaledZ), t4, this.tileID.canonical))
                  continue;
              } else if (!a3.filter(new ws(this.tileID.overscaledZ), n4))
                continue;
              const h3 = r3.getId(n4, i3), p3 = new Af(n4, o3, l2, u3, h3);
              p3.tile = c3, t3.push(p3);
            }
          }
          hasData() {
            return "loaded" === this.state || "reloading" === this.state || "expired" === this.state;
          }
          patternsLoaded() {
            return !!this.imageAtlas && !!Object.keys(this.imageAtlas.patternPositions).length;
          }
          setExpiryData(t3) {
            const e3 = this.expirationTime;
            if (t3.cacheControl) {
              const e4 = X(t3.cacheControl);
              e4["max-age"] && (this.expirationTime = Date.now() + 1e3 * e4["max-age"]);
            } else
              t3.expires && (this.expirationTime = new Date(t3.expires).getTime());
            if (this.expirationTime) {
              const t4 = Date.now();
              let r3 = false;
              if (this.expirationTime > t4)
                r3 = false;
              else if (e3)
                if (this.expirationTime < e3)
                  r3 = true;
                else {
                  const n3 = this.expirationTime - e3;
                  n3 ? this.expirationTime = t4 + Math.max(n3, 3e4) : r3 = true;
                }
              else
                r3 = true;
              r3 ? (this.expiredRequestCount++, this.state = "expired") : this.expiredRequestCount = 0;
            }
          }
          getExpiryTimeout() {
            if (this.expirationTime)
              return this.expiredRequestCount ? 1e3 * (1 << Math.min(this.expiredRequestCount - 1, 31)) : Math.min(this.expirationTime - new Date().getTime(), Math.pow(2, 31) - 1);
          }
          setFeatureState(t3, e3) {
            if (!this.latestFeatureIndex || !this.latestFeatureIndex.rawTileData || 0 === Object.keys(t3).length || !e3)
              return;
            const r3 = this.latestFeatureIndex.loadVTLayers(), n3 = e3.style.listImages();
            for (const i3 in this.buckets) {
              if (!e3.style.hasLayer(i3))
                continue;
              const s3 = this.buckets[i3], a3 = s3.layers[0].sourceLayer || "_geojsonTileLayer", o3 = r3[a3], l2 = t3[a3];
              if (!o3 || !l2 || 0 === Object.keys(l2).length)
                continue;
              if (s3.update(l2, o3, n3, this.imageAtlas && this.imageAtlas.patternPositions || {}), s3 instanceof Ih || s3 instanceof Mc) {
                const t4 = e3.style._getSourceCache(s3.layers[0].source);
                e3._terrain && e3._terrain.enabled && t4 && s3.programConfigurations.needsUpload && e3._terrain._clearRenderCacheForTile(t4.id, this.tileID);
              }
              const u3 = e3 && e3.style && e3.style.getLayer(i3);
              u3 && (this.queryPadding = Math.max(this.queryPadding, u3.queryRadius(s3)));
            }
          }
          holdingForFade() {
            return void 0 !== this.symbolFadeHoldUntil;
          }
          symbolFadeFinished() {
            return !this.symbolFadeHoldUntil || this.symbolFadeHoldUntil < Xt.now();
          }
          clearFadeHold() {
            this.symbolFadeHoldUntil = void 0;
          }
          setHoldDuration(t3) {
            this.symbolFadeHoldUntil = Xt.now() + t3;
          }
          setTexture(t3, e3) {
            const r3 = e3.context, n3 = r3.gl;
            this.texture = this.texture || e3.getTileTexture(t3.width), this.texture ? this.texture.update(t3, { useMipmap: true }) : (this.texture = new xf(r3, t3, n3.RGBA, { useMipmap: true }), this.texture.bind(n3.LINEAR, n3.CLAMP_TO_EDGE));
          }
          setDependencies(t3, e3) {
            const r3 = {};
            for (const t4 of e3)
              r3[t4] = true;
            this.dependencies[t3] = r3;
          }
          hasDependency(t3, e3) {
            for (const r3 of t3) {
              const t4 = this.dependencies[r3];
              if (t4) {
                for (const r4 of e3)
                  if (t4[r4])
                    return true;
              }
            }
            return false;
          }
          clearQueryDebugViz() {
          }
          _makeDebugTileBoundsBuffers(t3, e3) {
            if (!e3 || "mercator" === e3.name || this._tileDebugBuffer)
              return;
            const r3 = au(Cf, this.tileID.canonical, this.tileTransform)[0], n3 = new $s(), i3 = new ua();
            for (let t4 = 0; t4 < r3.length; t4++) {
              const { x: e4, y: s3 } = r3[t4];
              n3.emplaceBack(e4, s3), i3.emplaceBack(t4);
            }
            i3.emplaceBack(0), this._tileDebugIndexBuffer = t3.createIndexBuffer(i3), this._tileDebugBuffer = t3.createVertexBuffer(n3, tl.members), this._tileDebugSegments = so.simpleSegment(0, 0, n3.length, i3.length);
          }
          _makeTileBoundsBuffers(t3, e3) {
            if (this._tileBoundsBuffer || !e3 || "mercator" === e3.name)
              return;
            const r3 = au(Cf, this.tileID.canonical, this.tileTransform)[0];
            let n3, i3;
            if (this.isRaster) {
              const t4 = function(t5, e4) {
                const r4 = Bd(t5, e4), n4 = Math.pow(2, t5.z);
                for (let i5 = 0; i5 < kf; i5++)
                  for (let s4 = 0; s4 < kf; s4++) {
                    const a4 = Kl((t5.x + (s4 + Bf(s4)) / Sf) / n4), o4 = Xl((t5.y + (i5 + Bf(i5)) / Sf) / n4), l3 = e4.project(a4, o4), u3 = i5 * kf + s4;
                    Mf[2 * u3 + 0] = Math.round((l3.x * r4.scale - r4.x) * ao), Mf[2 * u3 + 1] = Math.round((l3.y * r4.scale - r4.y) * ao);
                  }
                Tf.fill(0), zf.fill(0);
                for (let t6 = 2045; t6 >= 0; t6--) {
                  const e5 = 4 * t6, r5 = If[e5 + 0], n5 = If[e5 + 1], i5 = If[e5 + 2], s4 = If[e5 + 3], a4 = r5 + i5 >> 1, o4 = n5 + s4 >> 1, l3 = a4 + o4 - n5, u3 = o4 + r5 - a4, c3 = n5 * kf + r5, h3 = s4 * kf + i5, p3 = o4 * kf + a4, d3 = Math.hypot((Mf[2 * c3 + 0] + Mf[2 * h3 + 0]) / 2 - Mf[2 * p3 + 0], (Mf[2 * c3 + 1] + Mf[2 * h3 + 1]) / 2 - Mf[2 * p3 + 1]) >= 16;
                  Tf[p3] = Tf[p3] || (d3 ? 1 : 0), t6 < 1022 && (Tf[p3] = Tf[p3] || Tf[(n5 + u3 >> 1) * kf + (r5 + l3 >> 1)] || Tf[(s4 + u3 >> 1) * kf + (i5 + l3 >> 1)]);
                }
                const i4 = new Os(), s3 = new ra();
                let a3 = 0;
                function o3(t6, e5) {
                  const r5 = e5 * kf + t6;
                  return 0 === zf[r5] && (i4.emplaceBack(Mf[2 * r5 + 0], Mf[2 * r5 + 1], t6 * ao / Sf, e5 * ao / Sf), zf[r5] = ++a3), zf[r5] - 1;
                }
                function l2(t6, e5, r5, n5, i5, a4) {
                  const u3 = t6 + r5 >> 1, c3 = e5 + n5 >> 1;
                  if (Math.abs(t6 - i5) + Math.abs(e5 - a4) > 1 && Tf[c3 * kf + u3])
                    l2(i5, a4, t6, e5, u3, c3), l2(r5, n5, i5, a4, u3, c3);
                  else {
                    const l3 = o3(t6, e5), u4 = o3(r5, n5), c4 = o3(i5, a4);
                    s3.emplaceBack(l3, u4, c4);
                  }
                }
                return l2(0, 0, Sf, Sf, Sf, 0), l2(Sf, Sf, 0, 0, 0, Sf), { vertices: i4, indices: s3 };
              }(this.tileID.canonical, e3);
              n3 = t4.vertices, i3 = t4.indices;
            } else {
              n3 = new Os(), i3 = new ra();
              for (const { x: t5, y: e4 } of r3)
                n3.emplaceBack(t5, e4, 0, 0);
              const t4 = xc(n3.int16, void 0, 4);
              for (let e4 = 0; e4 < t4.length; e4 += 3)
                i3.emplaceBack(t4[e4], t4[e4 + 1], t4[e4 + 2]);
            }
            this._tileBoundsBuffer = t3.createVertexBuffer(n3, Ef.members), this._tileBoundsIndexBuffer = t3.createIndexBuffer(i3), this._tileBoundsSegments = so.simpleSegment(0, 0, n3.length, i3.length);
          }
          _makeGlobeTileDebugBuffers(t3, e3) {
            const r3 = e3.projection;
            if (!r3 || "globe" !== r3.name || e3.freezeTileCoverage)
              return;
            const n3 = this.tileID.canonical, i3 = Bl(bl(n3, e3)), s3 = Pl(e3.zoom);
            let a3;
            s3 > 0 && (a3 = fo(new Float64Array(16), e3.globeMatrix)), this._makeGlobeTileDebugBorderBuffer(t3, n3, e3, i3, a3, s3), this._makeGlobeTileDebugTextBuffer(t3, n3, e3, i3, a3, s3);
          }
          _globePoint(t3, e3, r3, n3, i3, s3, a3) {
            let o3 = Ml(t3, e3, r3);
            if (s3) {
              const i4 = 1 << r3.z, l2 = Nl(n3.center.lng), u3 = Gl(n3.center.lat), c3 = (r3.x + 0.5) / i4 - l2;
              let h3 = 0;
              c3 > 0.5 ? h3 = -1 : c3 < -0.5 && (h3 = 1);
              let p3 = (t3 / ao + r3.x) / i4 + h3, d3 = (e3 / ao + r3.y) / i4;
              p3 = (p3 - l2) * n3._pixelsPerMercatorPixel + l2, d3 = (d3 - u3) * n3._pixelsPerMercatorPixel + u3;
              const f3 = [p3 * n3.worldSize, d3 * n3.worldSize, 0];
              Fo(f3, f3, s3), o3 = vl(o3, f3, a3);
            }
            return Fo(o3, o3, i3);
          }
          _makeGlobeTileDebugBorderBuffer(t3, e3, r3, n3, i3, s3) {
            const a3 = new $s(), o3 = new ua(), l2 = new js(), u3 = (t4, u4, c4, h3, p3) => {
              const d3 = (c4 - t4) / (p3 - 1), f3 = (h3 - u4) / (p3 - 1), y3 = a3.length;
              for (let c5 = 0; c5 < p3; c5++) {
                const h4 = t4 + c5 * d3, p4 = u4 + c5 * f3;
                a3.emplaceBack(h4, p4);
                const m3 = this._globePoint(h4, p4, e3, r3, n3, i3, s3);
                l2.emplaceBack(m3[0], m3[1], m3[2]), o3.emplaceBack(y3 + c5);
              }
            }, c3 = ao;
            u3(0, 0, c3, 0, 16), u3(c3, 0, c3, c3, 16), u3(c3, c3, 0, c3, 16), u3(0, c3, 0, 0, 16), this._tileDebugIndexBuffer = t3.createIndexBuffer(o3), this._tileDebugBuffer = t3.createVertexBuffer(a3, tl.members), this._globeTileDebugBorderBuffer = t3.createVertexBuffer(l2, Qo.members), this._tileDebugSegments = so.simpleSegment(0, 0, a3.length, o3.length);
          }
          _makeGlobeTileDebugTextBuffer(t3, e3, r3, n3, i3, s3) {
            const a3 = ao / 4, o3 = new $s(), l2 = new ra(), u3 = new js(), c3 = 25;
            l2.reserve(32), o3.reserve(c3), u3.reserve(c3);
            const h3 = (t4, e4) => c3 * t4 + e4;
            for (let t4 = 0; t4 < c3; t4++) {
              const l3 = t4 * a3;
              for (let t5 = 0; t5 < c3; t5++) {
                const c4 = t5 * a3;
                o3.emplaceBack(c4, l3);
                const h4 = this._globePoint(c4, l3, e3, r3, n3, i3, s3);
                u3.emplaceBack(h4[0], h4[1], h4[2]);
              }
            }
            for (let t4 = 0; t4 < 4; t4++)
              for (let e4 = 0; e4 < 4; e4++) {
                const r4 = h3(t4, e4), n4 = h3(t4, e4 + 1), i4 = h3(t4 + 1, e4), s4 = h3(t4 + 1, e4 + 1);
                l2.emplaceBack(r4, n4, i4), l2.emplaceBack(i4, n4, s4);
              }
            this._tileDebugTextIndexBuffer = t3.createIndexBuffer(l2), this._tileDebugTextBuffer = t3.createVertexBuffer(o3, tl.members), this._globeTileDebugTextBuffer = t3.createVertexBuffer(u3, Qo.members), this._tileDebugTextSegments = so.simpleSegment(0, 0, c3, 32);
          }
        }
        class Df {
          constructor() {
            this.state = {}, this.stateChanges = {}, this.deletedStates = {};
          }
          updateState(t3, e3, r3) {
            const n3 = String(e3);
            if (this.stateChanges[t3] = this.stateChanges[t3] || {}, this.stateChanges[t3][n3] = this.stateChanges[t3][n3] || {}, C(this.stateChanges[t3][n3], r3), null === this.deletedStates[t3]) {
              this.deletedStates[t3] = {};
              for (const e4 in this.state[t3])
                e4 !== n3 && (this.deletedStates[t3][e4] = null);
            } else if (this.deletedStates[t3] && null === this.deletedStates[t3][n3]) {
              this.deletedStates[t3][n3] = {};
              for (const e4 in this.state[t3][n3])
                r3[e4] || (this.deletedStates[t3][n3][e4] = null);
            } else
              for (const e4 in r3)
                this.deletedStates[t3] && this.deletedStates[t3][n3] && null === this.deletedStates[t3][n3][e4] && delete this.deletedStates[t3][n3][e4];
          }
          removeFeatureState(t3, e3, r3) {
            if (null === this.deletedStates[t3])
              return;
            const n3 = String(e3);
            if (this.deletedStates[t3] = this.deletedStates[t3] || {}, r3 && void 0 !== e3)
              null !== this.deletedStates[t3][n3] && (this.deletedStates[t3][n3] = this.deletedStates[t3][n3] || {}, this.deletedStates[t3][n3][r3] = null);
            else if (void 0 !== e3)
              if (this.stateChanges[t3] && this.stateChanges[t3][n3])
                for (r3 in this.deletedStates[t3][n3] = {}, this.stateChanges[t3][n3])
                  this.deletedStates[t3][n3][r3] = null;
              else
                this.deletedStates[t3][n3] = null;
            else
              this.deletedStates[t3] = null;
          }
          getState(t3, e3) {
            const r3 = String(e3), n3 = C({}, (this.state[t3] || {})[r3], (this.stateChanges[t3] || {})[r3]);
            if (null === this.deletedStates[t3])
              return {};
            if (this.deletedStates[t3]) {
              const r4 = this.deletedStates[t3][e3];
              if (null === r4)
                return {};
              for (const t4 in r4)
                delete n3[t4];
            }
            return n3;
          }
          initializeTileState(t3, e3) {
            t3.setFeatureState(this.state, e3);
          }
          coalesceChanges(t3, e3) {
            const r3 = {};
            for (const t4 in this.stateChanges) {
              this.state[t4] = this.state[t4] || {};
              const e4 = {};
              for (const r4 in this.stateChanges[t4])
                this.state[t4][r4] || (this.state[t4][r4] = {}), C(this.state[t4][r4], this.stateChanges[t4][r4]), e4[r4] = this.state[t4][r4];
              r3[t4] = e4;
            }
            for (const t4 in this.deletedStates) {
              this.state[t4] = this.state[t4] || {};
              const e4 = {};
              if (null === this.deletedStates[t4])
                for (const r4 in this.state[t4])
                  e4[r4] = {}, this.state[t4][r4] = {};
              else
                for (const r4 in this.deletedStates[t4]) {
                  if (null === this.deletedStates[t4][r4])
                    this.state[t4][r4] = {};
                  else if (this.state[t4][r4])
                    for (const e5 of Object.keys(this.deletedStates[t4][r4]))
                      delete this.state[t4][r4][e5];
                  e4[r4] = this.state[t4][r4];
                }
              r3[t4] = r3[t4] || {}, C(r3[t4], e4);
            }
            if (this.stateChanges = {}, this.deletedStates = {}, 0 !== Object.keys(r3).length)
              for (const n3 in t3)
                t3[n3].setFeatureState(r3, e3);
          }
        }
        class Vf {
          constructor(t3) {
            this.size = t3, this.minimums = [], this.maximums = [], this.leaves = [];
          }
          getElevation(t3, e3) {
            const r3 = this.toIdx(t3, e3);
            return { min: this.minimums[r3], max: this.maximums[r3] };
          }
          isLeaf(t3, e3) {
            return this.leaves[this.toIdx(t3, e3)];
          }
          toIdx(t3, e3) {
            return e3 * this.size + t3;
          }
        }
        function Lf(t3, e3, r3, n3) {
          let i3 = 0, s3 = Number.MAX_VALUE;
          for (let a3 = 0; a3 < 3; a3++)
            if (Math.abs(n3[a3]) < 1e-15) {
              if (r3[a3] < t3[a3] || r3[a3] > e3[a3])
                return null;
            } else {
              const o3 = 1 / n3[a3];
              let l2 = (t3[a3] - r3[a3]) * o3, u3 = (e3[a3] - r3[a3]) * o3;
              if (l2 > u3) {
                const t4 = l2;
                l2 = u3, u3 = t4;
              }
              if (l2 > i3 && (i3 = l2), u3 < s3 && (s3 = u3), i3 > s3)
                return null;
            }
          return i3;
        }
        function Ff(t3, e3, r3, n3, i3, s3, a3, o3, l2, u3, c3) {
          const h3 = n3 - t3, p3 = i3 - e3, d3 = s3 - r3, f3 = a3 - t3, y3 = o3 - e3, m3 = l2 - r3, g3 = c3[1] * m3 - c3[2] * y3, x3 = c3[2] * f3 - c3[0] * m3, v3 = c3[0] * y3 - c3[1] * f3, b2 = h3 * g3 + p3 * x3 + d3 * v3;
          if (Math.abs(b2) < 1e-15)
            return null;
          const w2 = 1 / b2, _2 = u3[0] - t3, A2 = u3[1] - e3, S2 = u3[2] - r3, k2 = (_2 * g3 + A2 * x3 + S2 * v3) * w2;
          if (k2 < 0 || k2 > 1)
            return null;
          const I2 = A2 * d3 - S2 * p3, M2 = S2 * h3 - _2 * d3, T2 = _2 * p3 - A2 * h3, z2 = (c3[0] * I2 + c3[1] * M2 + c3[2] * T2) * w2;
          return z2 < 0 || k2 + z2 > 1 ? null : (f3 * I2 + y3 * M2 + m3 * T2) * w2;
        }
        function Rf(t3, e3, r3) {
          return (t3 - e3) / (r3 - e3);
        }
        function Uf(t3, e3, r3, n3, i3, s3, a3, o3, l2) {
          const u3 = 1 << r3, c3 = s3 - n3, h3 = a3 - i3, p3 = (t3 + 1) / u3 * c3 + n3, d3 = (e3 + 0) / u3 * h3 + i3, f3 = (e3 + 1) / u3 * h3 + i3;
          o3[0] = (t3 + 0) / u3 * c3 + n3, o3[1] = d3, l2[0] = p3, l2[1] = f3;
        }
        class $f {
          constructor(t3) {
            if (this.maximums = [], this.minimums = [], this.leaves = [], this.childOffsets = [], this.nodeCount = 0, this.dem = t3, this._siblingOffset = [[0, 0], [1, 0], [0, 1], [1, 1]], !this.dem)
              return;
            const e3 = function(t4) {
              const e4 = Math.ceil(Math.log2(t4.dim / 8)), r4 = [];
              let n4 = Math.ceil(Math.pow(2, e4));
              const i3 = 1 / n4, s3 = (t5, e5, r5, n5, i4) => {
                const s4 = n5 ? 1 : 0, a4 = (t5 + 1) * r5 - s4, o4 = e5 * r5, l2 = (e5 + 1) * r5 - s4;
                i4[0] = t5 * r5, i4[1] = o4, i4[2] = a4, i4[3] = l2;
              };
              let a3 = new Vf(n4);
              const o3 = [];
              for (let e5 = 0; e5 < n4 * n4; e5++) {
                s3(e5 % n4, Math.floor(e5 / n4), i3, false, o3);
                const r5 = Of(o3[0], o3[1], t4), l2 = Of(o3[2], o3[1], t4), u3 = Of(o3[2], o3[3], t4), c3 = Of(o3[0], o3[3], t4);
                a3.minimums.push(Math.min(r5, l2, u3, c3)), a3.maximums.push(Math.max(r5, l2, u3, c3)), a3.leaves.push(1);
              }
              for (r4.push(a3), n4 /= 2; n4 >= 1; n4 /= 2) {
                const t5 = r4[r4.length - 1];
                a3 = new Vf(n4);
                for (let e5 = 0; e5 < n4 * n4; e5++) {
                  s3(e5 % n4, Math.floor(e5 / n4), 2, true, o3);
                  const r5 = t5.getElevation(o3[0], o3[1]), i4 = t5.getElevation(o3[2], o3[1]), l2 = t5.getElevation(o3[2], o3[3]), u3 = t5.getElevation(o3[0], o3[3]), c3 = t5.isLeaf(o3[0], o3[1]), h3 = t5.isLeaf(o3[2], o3[1]), p3 = t5.isLeaf(o3[2], o3[3]), d3 = t5.isLeaf(o3[0], o3[3]), f3 = Math.min(r5.min, i4.min, l2.min, u3.min), y3 = Math.max(r5.max, i4.max, l2.max, u3.max), m3 = c3 && h3 && p3 && d3;
                  a3.maximums.push(y3), a3.minimums.push(f3), a3.leaves.push(y3 - f3 <= 5 && m3 ? 1 : 0);
                }
                r4.push(a3);
              }
              return r4;
            }(this.dem), r3 = e3.length - 1, n3 = e3[r3];
            this._addNode(n3.minimums[0], n3.maximums[0], n3.leaves[0]), this._construct(e3, 0, 0, r3, 0);
          }
          raycastRoot(t3, e3, r3, n3, i3, s3, a3 = 1) {
            return Lf([t3, e3, -100], [r3, n3, this.maximums[0] * a3], i3, s3);
          }
          raycast(t3, e3, r3, n3, i3, s3, a3 = 1) {
            if (!this.nodeCount)
              return null;
            const o3 = this.raycastRoot(t3, e3, r3, n3, i3, s3, a3);
            if (null == o3)
              return null;
            const l2 = [], u3 = [], c3 = [], h3 = [], p3 = [{ idx: 0, t: o3, nodex: 0, nodey: 0, depth: 0 }];
            for (; p3.length > 0; ) {
              const { idx: o4, t: d3, nodex: f3, nodey: y3, depth: m3 } = p3.pop();
              if (this.leaves[o4]) {
                Uf(f3, y3, m3, t3, e3, r3, n3, c3, h3);
                const o5 = 1 << m3, l3 = (f3 + 0) / o5, u4 = (f3 + 1) / o5, p4 = (y3 + 0) / o5, g4 = (y3 + 1) / o5, x3 = Of(l3, p4, this.dem) * a3, v3 = Of(u4, p4, this.dem) * a3, b2 = Of(u4, g4, this.dem) * a3, w2 = Of(l3, g4, this.dem) * a3, _2 = Ff(c3[0], c3[1], x3, h3[0], c3[1], v3, h3[0], h3[1], b2, i3, s3), A2 = Ff(h3[0], h3[1], b2, c3[0], h3[1], w2, c3[0], c3[1], x3, i3, s3), S2 = Math.min(null !== _2 ? _2 : Number.MAX_VALUE, null !== A2 ? A2 : Number.MAX_VALUE);
                if (S2 !== Number.MAX_VALUE)
                  return S2;
                {
                  const t4 = Po([], i3, s3, d3);
                  if (jf(x3, v3, w2, b2, Rf(t4[0], c3[0], h3[0]), Rf(t4[1], c3[1], h3[1])) >= t4[2])
                    return d3;
                }
                continue;
              }
              let g3 = 0;
              for (let p4 = 0; p4 < this._siblingOffset.length; p4++) {
                Uf((f3 << 1) + this._siblingOffset[p4][0], (y3 << 1) + this._siblingOffset[p4][1], m3 + 1, t3, e3, r3, n3, c3, h3), c3[2] = -100, h3[2] = this.maximums[this.childOffsets[o4] + p4] * a3;
                const d4 = Lf(c3, h3, i3, s3);
                if (null != d4) {
                  const t4 = d4;
                  l2[p4] = t4;
                  let e4 = false;
                  for (let r4 = 0; r4 < g3 && !e4; r4++)
                    t4 >= l2[u3[r4]] && (u3.splice(r4, 0, p4), e4 = true);
                  e4 || (u3[g3] = p4), g3++;
                }
              }
              for (let t4 = 0; t4 < g3; t4++) {
                const e4 = u3[t4];
                p3.push({ idx: this.childOffsets[o4] + e4, t: l2[e4], nodex: (f3 << 1) + this._siblingOffset[e4][0], nodey: (y3 << 1) + this._siblingOffset[e4][1], depth: m3 + 1 });
              }
            }
            return null;
          }
          _addNode(t3, e3, r3) {
            return this.minimums.push(t3), this.maximums.push(e3), this.leaves.push(r3), this.childOffsets.push(0), this.nodeCount++;
          }
          _construct(t3, e3, r3, n3, i3) {
            if (1 === t3[n3].isLeaf(e3, r3))
              return;
            this.childOffsets[i3] || (this.childOffsets[i3] = this.nodeCount);
            const s3 = n3 - 1, a3 = t3[s3];
            let o3 = 0, l2 = 0;
            for (let t4 = 0; t4 < this._siblingOffset.length; t4++) {
              const n4 = 2 * e3 + this._siblingOffset[t4][0], i4 = 2 * r3 + this._siblingOffset[t4][1], s4 = a3.getElevation(n4, i4), u3 = a3.isLeaf(n4, i4), c3 = this._addNode(s4.min, s4.max, u3);
              u3 && (o3 |= 1 << t4), l2 || (l2 = c3);
            }
            for (let n4 = 0; n4 < this._siblingOffset.length; n4++)
              o3 & 1 << n4 || this._construct(t3, 2 * e3 + this._siblingOffset[n4][0], 2 * r3 + this._siblingOffset[n4][1], s3, l2 + n4);
          }
        }
        function jf(t3, e3, r3, n3, i3, s3) {
          return Er(Er(t3, r3, s3), Er(e3, n3, s3), i3);
        }
        function Of(t3, e3, r3) {
          const n3 = r3.dim, i3 = M(t3 * n3 - 0.5, 0, n3 - 1), s3 = M(e3 * n3 - 0.5, 0, n3 - 1), a3 = Math.floor(i3), o3 = Math.floor(s3), l2 = Math.min(a3 + 1, n3 - 1), u3 = Math.min(o3 + 1, n3 - 1);
          return jf(r3.get(a3, o3), r3.get(l2, o3), r3.get(a3, u3), r3.get(l2, u3), i3 - a3, s3 - o3);
        }
        const qf = { mapbox: [6553.6, 25.6, 0.1, 1e4], terrarium: [256, 1, 1 / 256, 32768] };
        function Nf(t3, e3, r3) {
          return (256 * t3 * 256 + 256 * e3 + r3) / 10 - 1e4;
        }
        function Gf(t3, e3, r3) {
          return 256 * t3 + e3 + r3 / 256 - 32768;
        }
        class Zf {
          get tree() {
            return this._tree || this._buildQuadTree(), this._tree;
          }
          constructor(t3, e3, r3, n3 = false, i3 = false) {
            if (this.uid = t3, e3.height !== e3.width)
              throw new RangeError("DEM tiles must be square");
            if (r3 && "mapbox" !== r3 && "terrarium" !== r3)
              return N(`"${r3}" is not a valid encoding type. Valid types include "mapbox" and "terrarium".`);
            this.stride = e3.height;
            const s3 = this.dim = e3.height - 2, a3 = new Uint32Array(e3.data.buffer);
            if (this.pixels = new Uint8Array(e3.data.buffer), this.encoding = r3 || "mapbox", this.borderReady = n3, !n3) {
              for (let t4 = 0; t4 < s3; t4++)
                a3[this._idx(-1, t4)] = a3[this._idx(0, t4)], a3[this._idx(s3, t4)] = a3[this._idx(s3 - 1, t4)], a3[this._idx(t4, -1)] = a3[this._idx(t4, 0)], a3[this._idx(t4, s3)] = a3[this._idx(t4, s3 - 1)];
              a3[this._idx(-1, -1)] = a3[this._idx(0, 0)], a3[this._idx(s3, -1)] = a3[this._idx(s3 - 1, 0)], a3[this._idx(-1, s3)] = a3[this._idx(0, s3 - 1)], a3[this._idx(s3, s3)] = a3[this._idx(s3 - 1, s3 - 1)], i3 && this._buildQuadTree();
            }
          }
          _buildQuadTree() {
            this._tree = new $f(this);
          }
          get(t3, e3, r3 = false) {
            r3 && (t3 = M(t3, -1, this.dim), e3 = M(e3, -1, this.dim));
            const n3 = 4 * this._idx(t3, e3);
            return ("terrarium" === this.encoding ? Gf : Nf)(this.pixels[n3], this.pixels[n3 + 1], this.pixels[n3 + 2]);
          }
          static getUnpackVector(t3) {
            return qf[t3];
          }
          get unpackVector() {
            return qf[this.encoding];
          }
          _idx(t3, e3) {
            if (t3 < -1 || t3 >= this.dim + 1 || e3 < -1 || e3 >= this.dim + 1)
              throw new RangeError("out of range source coordinates for DEM data");
            return (e3 + 1) * this.stride + (t3 + 1);
          }
          static pack(t3, e3) {
            const r3 = [0, 0, 0, 0], n3 = Zf.getUnpackVector(e3);
            let i3 = Math.floor((t3 + n3[3]) / n3[2]);
            return r3[2] = i3 % 256, i3 = Math.floor(i3 / 256), r3[1] = i3 % 256, i3 = Math.floor(i3 / 256), r3[0] = i3, r3;
          }
          getPixels() {
            return new Uu({ width: this.stride, height: this.stride }, this.pixels);
          }
          backfillBorder(t3, e3, r3) {
            if (this.dim !== t3.dim)
              throw new Error("dem dimension mismatch");
            let n3 = e3 * this.dim, i3 = e3 * this.dim + this.dim, s3 = r3 * this.dim, a3 = r3 * this.dim + this.dim;
            switch (e3) {
              case -1:
                n3 = i3 - 1;
                break;
              case 1:
                i3 = n3 + 1;
            }
            switch (r3) {
              case -1:
                s3 = a3 - 1;
                break;
              case 1:
                a3 = s3 + 1;
            }
            const o3 = -e3 * this.dim, l2 = -r3 * this.dim;
            for (let e4 = s3; e4 < a3; e4++)
              for (let r4 = n3; r4 < i3; r4++) {
                const n4 = 4 * this._idx(r4, e4), i4 = 4 * this._idx(r4 + o3, e4 + l2);
                this.pixels[n4 + 0] = t3.pixels[i4 + 0], this.pixels[n4 + 1] = t3.pixels[i4 + 1], this.pixels[n4 + 2] = t3.pixels[i4 + 2], this.pixels[n4 + 3] = t3.pixels[i4 + 3];
              }
          }
          onDeserialize() {
            this._tree && (this._tree.dem = this);
          }
        }
        Ji(Zf, "DEMData"), Ji($f, "DemMinMaxQuadTree", { omit: ["dem"] });
        class Kf {
          constructor(t3, e3) {
            this.max = t3, this.onRemove = e3, this.reset();
          }
          reset() {
            for (const t3 in this.data)
              for (const e3 of this.data[t3])
                e3.timeout && clearTimeout(e3.timeout), this.onRemove(e3.value);
            return this.data = {}, this.order = [], this;
          }
          add(t3, e3, r3) {
            const n3 = t3.wrapped().key;
            void 0 === this.data[n3] && (this.data[n3] = []);
            const i3 = { value: e3, timeout: void 0 };
            if (void 0 !== r3 && (i3.timeout = setTimeout(() => {
              this.remove(t3, i3);
            }, r3)), this.data[n3].push(i3), this.order.push(n3), this.order.length > this.max) {
              const t4 = this._getAndRemoveByKey(this.order[0]);
              t4 && this.onRemove(t4);
            }
            return this;
          }
          has(t3) {
            return t3.wrapped().key in this.data;
          }
          getAndRemove(t3) {
            return this.has(t3) ? this._getAndRemoveByKey(t3.wrapped().key) : null;
          }
          _getAndRemoveByKey(t3) {
            const e3 = this.data[t3].shift();
            return e3.timeout && clearTimeout(e3.timeout), 0 === this.data[t3].length && delete this.data[t3], this.order.splice(this.order.indexOf(t3), 1), e3.value;
          }
          getByKey(t3) {
            const e3 = this.data[t3];
            return e3 ? e3[0].value : null;
          }
          get(t3) {
            return this.has(t3) ? this.data[t3.wrapped().key][0].value : null;
          }
          remove(t3, e3) {
            if (!this.has(t3))
              return this;
            const r3 = t3.wrapped().key, n3 = void 0 === e3 ? 0 : this.data[r3].indexOf(e3), i3 = this.data[r3][n3];
            return this.data[r3].splice(n3, 1), i3.timeout && clearTimeout(i3.timeout), 0 === this.data[r3].length && delete this.data[r3], this.onRemove(i3.value), this.order.splice(this.order.indexOf(r3), 1), this;
          }
          setMaxSize(t3) {
            for (this.max = t3; this.order.length > this.max; ) {
              const t4 = this._getAndRemoveByKey(this.order[0]);
              t4 && this.onRemove(t4);
            }
            return this;
          }
          filter(t3) {
            const e3 = [];
            for (const r3 in this.data)
              for (const n3 of this.data[r3])
                t3(n3.value) || e3.push(n3);
            for (const t4 of e3)
              this.remove(t4.value.tileID, t4);
          }
        }
        class Xf {
          constructor(t3, e3, r3) {
            this.func = t3, this.mask = e3, this.range = r3;
          }
        }
        Xf.ReadOnly = false, Xf.ReadWrite = true, Xf.disabled = new Xf(519, Xf.ReadOnly, [0, 1]);
        const Jf = 7680;
        class Hf {
          constructor(t3, e3, r3, n3, i3, s3) {
            this.test = t3, this.ref = e3, this.mask = r3, this.fail = n3, this.depthFail = i3, this.pass = s3;
          }
        }
        Hf.disabled = new Hf({ func: 519, mask: 0 }, 0, 0, Jf, Jf, Jf);
        class Yf {
          constructor(t3, e3, r3) {
            this.blendFunction = t3, this.blendColor = e3, this.mask = r3;
          }
        }
        Yf.Replace = [1, 0], Yf.disabled = new Yf(Yf.Replace, Ee.transparent, [false, false, false, false]), Yf.unblended = new Yf(Yf.Replace, Ee.transparent, [true, true, true, true]), Yf.alphaBlended = new Yf([1, 771], Ee.transparent, [true, true, true, true]);
        const Wf = 1029, Qf = 2305;
        class ty {
          constructor(t3, e3, r3) {
            this.enable = t3, this.mode = e3, this.frontFace = r3;
          }
        }
        ty.disabled = new ty(false, Wf, Qf), ty.backCCW = new ty(true, Wf, Qf), ty.backCW = new ty(true, Wf, 2304), ty.frontCW = new ty(true, 1028, 2304), ty.frontCCW = new ty(true, 1028, Qf);
        class ey extends Qt {
          constructor(t3, e3, r3) {
            super(), this.id = t3, this._onlySymbols = r3, e3.on("data", (t4) => {
              "source" === t4.dataType && "metadata" === t4.sourceDataType && (this._sourceLoaded = true), this._sourceLoaded && !this._paused && "source" === t4.dataType && "content" === t4.sourceDataType && (this.reload(), this.transform && this.update(this.transform));
            }), e3.on("error", () => {
              this._sourceErrored = true;
            }), this._source = e3, this._tiles = {}, this._cache = new Kf(0, this._unloadTile.bind(this)), this._timers = {}, this._cacheTimers = {}, this._minTileCacheSize = e3.minTileCacheSize, this._maxTileCacheSize = e3.maxTileCacheSize, this._loadedParentTiles = {}, this._coveredTiles = {}, this._state = new Df(), this._isRaster = "raster" === this._source.type || "raster-dem" === this._source.type || "custom" === this._source.type && "raster" === this._source._dataType;
          }
          onAdd(t3) {
            this.map = t3, this._minTileCacheSize = void 0 === this._minTileCacheSize && t3 ? t3._minTileCacheSize : this._minTileCacheSize, this._maxTileCacheSize = void 0 === this._maxTileCacheSize && t3 ? t3._maxTileCacheSize : this._maxTileCacheSize;
          }
          loaded() {
            if (this._sourceErrored)
              return true;
            if (!this._sourceLoaded)
              return false;
            if (!this._source.loaded())
              return false;
            for (const t3 in this._tiles) {
              const e3 = this._tiles[t3];
              if ("loaded" !== e3.state && "errored" !== e3.state)
                return false;
            }
            return true;
          }
          getSource() {
            return this._source;
          }
          pause() {
            this._paused = true;
          }
          resume() {
            if (!this._paused)
              return;
            const t3 = this._shouldReloadOnResume;
            this._paused = false, this._shouldReloadOnResume = false, t3 && this.reload(), this.transform && this.update(this.transform);
          }
          _loadTile(t3, e3) {
            return t3.isSymbolTile = this._onlySymbols, this._source.loadTile(t3, e3);
          }
          _unloadTile(t3) {
            if (this._source.unloadTile)
              return this._source.unloadTile(t3, () => {
              });
          }
          _abortTile(t3) {
            if (this._source.abortTile)
              return this._source.abortTile(t3, () => {
              });
          }
          serialize() {
            return this._source.serialize();
          }
          prepare(t3) {
            this._source.prepare && this._source.prepare(), this._state.coalesceChanges(this._tiles, this.map ? this.map.painter : null);
            for (const e3 in this._tiles) {
              const r3 = this._tiles[e3];
              r3.upload(t3), r3.prepare(this.map.style.imageManager);
            }
          }
          getIds() {
            return E2(this._tiles).map((t3) => t3.tileID).sort(ry).map((t3) => t3.key);
          }
          getRenderableIds(t3) {
            const e3 = [];
            for (const r3 in this._tiles)
              this._isIdRenderable(+r3, t3) && e3.push(this._tiles[r3]);
            return t3 ? e3.sort((t4, e4) => {
              const r3 = t4.tileID, n3 = e4.tileID, i3 = new x2(r3.canonical.x, r3.canonical.y)._rotate(this.transform.angle), s3 = new x2(n3.canonical.x, n3.canonical.y)._rotate(this.transform.angle);
              return r3.overscaledZ - n3.overscaledZ || s3.y - i3.y || s3.x - i3.x;
            }).map((t4) => t4.tileID.key) : e3.map((t4) => t4.tileID).sort(ry).map((t4) => t4.key);
          }
          hasRenderableParent(t3) {
            const e3 = this.findLoadedParent(t3, 0);
            return !!e3 && this._isIdRenderable(e3.tileID.key);
          }
          _isIdRenderable(t3, e3) {
            return this._tiles[t3] && this._tiles[t3].hasData() && !this._coveredTiles[t3] && (e3 || !this._tiles[t3].holdingForFade());
          }
          reload() {
            if (this._paused)
              this._shouldReloadOnResume = true;
            else {
              this._cache.reset();
              for (const t3 in this._tiles)
                "errored" !== this._tiles[t3].state && this._reloadTile(+t3, "reloading");
            }
          }
          _reloadTile(t3, e3) {
            const r3 = this._tiles[t3];
            r3 && ("loading" !== r3.state && (r3.state = e3), this._loadTile(r3, this._tileLoaded.bind(this, r3, t3, e3)));
          }
          _tileLoaded(t3, e3, r3, n3) {
            if (n3)
              if (t3.state = "errored", 404 !== n3.status)
                this._source.fire(new Wt(n3, { tile: t3 }));
              else if ("raster-dem" === this._source.type && this.usedForTerrain && this.map.painter.terrain) {
                const t4 = this.map.painter.terrain;
                this.update(this.transform, t4.getScaledDemTileSize(), true), t4.resetTileLookupCache(this.id);
              } else
                this.update(this.transform);
            else
              t3.timeAdded = Xt.now(), "expired" === r3 && (t3.refreshedUponExpiration = true), this._setTileReloadTimer(e3, t3), "raster-dem" === this._source.type && t3.dem && this._backfillDEM(t3), this._state.initializeTileState(t3, this.map ? this.map.painter : null), this._source.fire(new Yt("data", { dataType: "source", tile: t3, coord: t3.tileID, sourceCacheId: this.id }));
          }
          _backfillDEM(t3) {
            const e3 = this.getRenderableIds();
            for (let n3 = 0; n3 < e3.length; n3++) {
              const i3 = e3[n3];
              if (t3.neighboringTiles && t3.neighboringTiles[i3]) {
                const e4 = this.getTileByID(i3);
                r3(t3, e4), r3(e4, t3);
              }
            }
            function r3(t4, e4) {
              if (!t4.dem || t4.dem.borderReady)
                return;
              t4.needsHillshadePrepare = true, t4.needsDEMTextureUpload = true;
              let r4 = e4.tileID.canonical.x - t4.tileID.canonical.x;
              const n3 = e4.tileID.canonical.y - t4.tileID.canonical.y, i3 = Math.pow(2, t4.tileID.canonical.z), s3 = e4.tileID.key;
              0 === r4 && 0 === n3 || Math.abs(n3) > 1 || (Math.abs(r4) > 1 && (1 === Math.abs(r4 + i3) ? r4 += i3 : 1 === Math.abs(r4 - i3) && (r4 -= i3)), e4.dem && t4.dem && (t4.dem.backfillBorder(e4.dem, r4, n3), t4.neighboringTiles && t4.neighboringTiles[s3] && (t4.neighboringTiles[s3].backfilled = true)));
            }
          }
          getTile(t3) {
            return this.getTileByID(t3.key);
          }
          getTileByID(t3) {
            return this._tiles[t3];
          }
          _retainLoadedChildren(t3, e3, r3, n3) {
            for (const i3 in this._tiles) {
              let s3 = this._tiles[i3];
              if (n3[i3] || !s3.hasData() || s3.tileID.overscaledZ <= e3 || s3.tileID.overscaledZ > r3)
                continue;
              let a3 = s3.tileID;
              for (; s3 && s3.tileID.overscaledZ > e3 + 1; ) {
                const t4 = s3.tileID.scaledTo(s3.tileID.overscaledZ - 1);
                s3 = this._tiles[t4.key], s3 && s3.hasData() && (a3 = t4);
              }
              let o3 = a3;
              for (; o3.overscaledZ > e3; )
                if (o3 = o3.scaledTo(o3.overscaledZ - 1), t3[o3.key]) {
                  n3[a3.key] = a3;
                  break;
                }
            }
          }
          findLoadedParent(t3, e3) {
            if (t3.key in this._loadedParentTiles) {
              const r3 = this._loadedParentTiles[t3.key];
              return r3 && r3.tileID.overscaledZ >= e3 ? r3 : null;
            }
            for (let r3 = t3.overscaledZ - 1; r3 >= e3; r3--) {
              const e4 = t3.scaledTo(r3), n3 = this._getLoadedTile(e4);
              if (n3)
                return n3;
            }
          }
          _getLoadedTile(t3) {
            const e3 = this._tiles[t3.key];
            return e3 && e3.hasData() ? e3 : this._cache.getByKey(this._source.reparseOverscaled ? t3.wrapped().key : t3.canonical.key);
          }
          updateCacheSize(t3, e3) {
            e3 = e3 || this._source.tileSize;
            const r3 = Math.ceil(t3.width / e3) + 1, n3 = Math.ceil(t3.height / e3) + 1, i3 = Math.floor(r3 * n3 * 5), s3 = "number" == typeof this._minTileCacheSize ? Math.max(this._minTileCacheSize, i3) : i3, a3 = "number" == typeof this._maxTileCacheSize ? Math.min(this._maxTileCacheSize, s3) : s3;
            this._cache.setMaxSize(a3);
          }
          handleWrapJump(t3) {
            const e3 = Math.round((t3 - (void 0 === this._prevLng ? t3 : this._prevLng)) / 360);
            if (this._prevLng = t3, e3) {
              const t4 = {};
              for (const r3 in this._tiles) {
                const n3 = this._tiles[r3];
                n3.tileID = n3.tileID.unwrapTo(n3.tileID.wrap + e3), t4[n3.tileID.key] = n3;
              }
              this._tiles = t4;
              for (const t5 in this._timers)
                clearTimeout(this._timers[t5]), delete this._timers[t5];
              for (const t5 in this._tiles)
                this._setTileReloadTimer(+t5, this._tiles[t5]);
            }
          }
          update(t3, e3, r3) {
            if (this.transform = t3, !this._sourceLoaded || this._paused || this.transform.freezeTileCoverage)
              return;
            if (this.usedForTerrain && !r3)
              return;
            let n3;
            this.updateCacheSize(t3, e3), "globe" !== this.transform.projection.name && this.handleWrapJump(this.transform.center.lng), this._coveredTiles = {}, this.used || this.usedForTerrain ? this._source.tileID ? n3 = t3.getVisibleUnwrappedCoordinates(this._source.tileID).map((t4) => new fh(t4.canonical.z, t4.wrap, t4.canonical.z, t4.canonical.x, t4.canonical.y)) : (n3 = t3.coveringTiles({ tileSize: e3 || this._source.tileSize, minzoom: this._source.minzoom, maxzoom: this._source.maxzoom, roundZoom: this._source.roundZoom && !r3, reparseOverscaled: this._source.reparseOverscaled, isTerrainDEM: this.usedForTerrain }), this._source.hasTile && (n3 = n3.filter((t4) => this._source.hasTile(t4)))) : n3 = [];
            const i3 = this._updateRetainedTiles(n3);
            if (ny(this._source.type) && 0 !== n3.length) {
              const t4 = {}, e4 = {}, r4 = Object.keys(i3);
              for (const n4 of r4) {
                const r5 = i3[n4], s5 = this._tiles[n4];
                if (!s5 || s5.fadeEndTime && s5.fadeEndTime <= Xt.now())
                  continue;
                const a3 = this.findLoadedParent(r5, Math.max(r5.overscaledZ - ey.maxOverzooming, this._source.minzoom));
                a3 && (this._addTile(a3.tileID), t4[a3.tileID.key] = a3.tileID), e4[n4] = r5;
              }
              const s4 = n3[n3.length - 1].overscaledZ;
              for (const t5 in this._tiles) {
                const r5 = this._tiles[t5];
                if (i3[t5] || !r5.hasData())
                  continue;
                let n4 = r5.tileID;
                for (; n4.overscaledZ > s4; ) {
                  n4 = n4.scaledTo(n4.overscaledZ - 1);
                  const s5 = this._tiles[n4.key];
                  if (s5 && s5.hasData() && e4[n4.key]) {
                    i3[t5] = r5.tileID;
                    break;
                  }
                }
              }
              for (const e5 in t4)
                i3[e5] || (this._coveredTiles[e5] = true, i3[e5] = t4[e5]);
            }
            for (const t4 in i3)
              this._tiles[t4].clearFadeHold();
            const s3 = function(t4, e4) {
              const r4 = [];
              for (const n4 in t4)
                n4 in e4 || r4.push(n4);
              return r4;
            }(this._tiles, i3);
            for (const t4 of s3) {
              const e4 = this._tiles[t4];
              e4.hasSymbolBuckets && !e4.holdingForFade() ? e4.setHoldDuration(this.map._fadeDuration) : e4.hasSymbolBuckets && !e4.symbolFadeFinished() || this._removeTile(+t4);
            }
            this._updateLoadedParentTileCache(), this._onlySymbols && this._source.afterUpdate && this._source.afterUpdate();
          }
          releaseSymbolFadeTiles() {
            for (const t3 in this._tiles)
              this._tiles[t3].holdingForFade() && this._removeTile(+t3);
          }
          _updateRetainedTiles(t3) {
            const e3 = {};
            if (0 === t3.length)
              return e3;
            const r3 = {}, n3 = t3.reduce((t4, e4) => Math.min(t4, e4.overscaledZ), 1 / 0), i3 = t3[0].overscaledZ, s3 = Math.max(i3 - ey.maxOverzooming, this._source.minzoom), a3 = Math.max(i3 + ey.maxUnderzooming, this._source.minzoom), o3 = {};
            for (const r4 of t3) {
              const t4 = this._addTile(r4);
              e3[r4.key] = r4, t4.hasData() || n3 < this._source.maxzoom && (o3[r4.key] = r4);
            }
            this._retainLoadedChildren(o3, n3, a3, e3);
            for (const n4 of t3) {
              let t4 = this._tiles[n4.key];
              if (t4.hasData())
                continue;
              if (n4.canonical.z >= this._source.maxzoom) {
                const t5 = n4.children(this._source.maxzoom)[0], r4 = this.getTile(t5);
                if (r4 && r4.hasData()) {
                  e3[t5.key] = t5;
                  continue;
                }
              } else {
                const t5 = n4.children(this._source.maxzoom);
                if (e3[t5[0].key] && e3[t5[1].key] && e3[t5[2].key] && e3[t5[3].key])
                  continue;
              }
              let i4 = t4.wasRequested();
              for (let a4 = n4.overscaledZ - 1; a4 >= s3; --a4) {
                const s4 = n4.scaledTo(a4);
                if (r3[s4.key])
                  break;
                if (r3[s4.key] = true, t4 = this.getTile(s4), !t4 && i4 && (t4 = this._addTile(s4)), t4 && (e3[s4.key] = s4, i4 = t4.wasRequested(), t4.hasData()))
                  break;
              }
            }
            return e3;
          }
          _updateLoadedParentTileCache() {
            this._loadedParentTiles = {};
            for (const t3 in this._tiles) {
              const e3 = [];
              let r3, n3 = this._tiles[t3].tileID;
              for (; n3.overscaledZ > 0; ) {
                if (n3.key in this._loadedParentTiles) {
                  r3 = this._loadedParentTiles[n3.key];
                  break;
                }
                e3.push(n3.key);
                const t4 = n3.scaledTo(n3.overscaledZ - 1);
                if (r3 = this._getLoadedTile(t4), r3)
                  break;
                n3 = t4;
              }
              for (const t4 of e3)
                this._loadedParentTiles[t4] = r3;
            }
          }
          _addTile(t3) {
            let e3 = this._tiles[t3.key];
            if (e3)
              return e3;
            e3 = this._cache.getAndRemove(t3), e3 && (this._setTileReloadTimer(t3.key, e3), e3.tileID = t3, this._state.initializeTileState(e3, this.map ? this.map.painter : null), this._cacheTimers[t3.key] && (clearTimeout(this._cacheTimers[t3.key]), delete this._cacheTimers[t3.key], this._setTileReloadTimer(t3.key, e3)));
            const r3 = Boolean(e3);
            if (!r3) {
              const r4 = this.map ? this.map.painter : null;
              e3 = new Pf(t3, this._source.tileSize * t3.overscaleFactor(), this.transform.tileZoom, r4, this._isRaster), this._loadTile(e3, this._tileLoaded.bind(this, e3, t3.key, e3.state));
            }
            return e3 ? (e3.uses++, this._tiles[t3.key] = e3, r3 || this._source.fire(new Yt("dataloading", { tile: e3, coord: e3.tileID, dataType: "source" })), e3) : null;
          }
          _setTileReloadTimer(t3, e3) {
            t3 in this._timers && (clearTimeout(this._timers[t3]), delete this._timers[t3]);
            const r3 = e3.getExpiryTimeout();
            r3 && (this._timers[t3] = setTimeout(() => {
              this._reloadTile(t3, "expired"), delete this._timers[t3];
            }, r3));
          }
          _removeTile(t3) {
            const e3 = this._tiles[t3];
            e3 && (e3.uses--, delete this._tiles[t3], this._timers[t3] && (clearTimeout(this._timers[t3]), delete this._timers[t3]), e3.uses > 0 || (e3.hasData() && "reloading" !== e3.state ? this._cache.add(e3.tileID, e3, e3.getExpiryTimeout()) : (e3.aborted = true, this._abortTile(e3), this._unloadTile(e3))));
          }
          clearTiles() {
            this._shouldReloadOnResume = false, this._paused = false;
            for (const t3 in this._tiles)
              this._removeTile(+t3);
            this._source._clear && this._source._clear(), this._cache.reset(), this.map && this.usedForTerrain && this.map.painter.terrain && this.map.painter.terrain.resetTileLookupCache(this.id);
          }
          tilesIn(t3, e3, r3) {
            const n3 = [], i3 = this.transform;
            if (!i3)
              return n3;
            const s3 = "globe" === i3.projection.name, a3 = Nl(i3.center.lng);
            for (const o3 in this._tiles) {
              const l2 = this._tiles[o3];
              if (r3 && l2.clearQueryDebugViz(), l2.holdingForFade())
                continue;
              let u3;
              if (s3) {
                const t4 = l2.tileID.canonical;
                if (0 === t4.z) {
                  const e4 = [Math.abs(M(a3, ...iy(t4, -1)) - a3), Math.abs(M(a3, ...iy(t4, 1)) - a3)];
                  u3 = [0, 2 * e4.indexOf(Math.min(...e4)) - 1];
                } else {
                  const e4 = [Math.abs(M(a3, ...iy(t4, -1)) - a3), Math.abs(M(a3, ...iy(t4, 0)) - a3), Math.abs(M(a3, ...iy(t4, 1)) - a3)];
                  u3 = [e4.indexOf(Math.min(...e4)) - 1];
                }
              } else
                u3 = [0];
              for (const r4 of u3) {
                const s4 = t3.containsTile(l2, i3, e3, r4);
                s4 && n3.push(s4);
              }
            }
            return n3;
          }
          getVisibleCoordinates(t3) {
            const e3 = this.getRenderableIds(t3).map((t4) => this._tiles[t4].tileID);
            for (const t4 of e3)
              t4.projMatrix = this.transform.calculateProjMatrix(t4.toUnwrapped());
            return e3;
          }
          hasTransition() {
            if (this._source.hasTransition())
              return true;
            if (ny(this._source.type))
              for (const t3 in this._tiles) {
                const e3 = this._tiles[t3];
                if (void 0 !== e3.fadeEndTime && e3.fadeEndTime >= Xt.now())
                  return true;
              }
            return false;
          }
          setFeatureState(t3, e3, r3) {
            this._state.updateState(t3 = t3 || "_geojsonTileLayer", e3, r3);
          }
          removeFeatureState(t3, e3, r3) {
            this._state.removeFeatureState(t3 = t3 || "_geojsonTileLayer", e3, r3);
          }
          getFeatureState(t3, e3) {
            return this._state.getState(t3 = t3 || "_geojsonTileLayer", e3);
          }
          setDependencies(t3, e3, r3) {
            const n3 = this._tiles[t3];
            n3 && n3.setDependencies(e3, r3);
          }
          reloadTilesForDependencies(t3, e3) {
            for (const r3 in this._tiles)
              this._tiles[r3].hasDependency(t3, e3) && this._reloadTile(+r3, "reloading");
            this._cache.filter((r3) => !r3.hasDependency(t3, e3));
          }
          _preloadTiles(t3, e3) {
            if (!this._sourceLoaded) {
              const r4 = () => {
                this._sourceLoaded && (this._source.off("data", r4), this._preloadTiles(t3, e3));
              };
              return void this._source.on("data", r4);
            }
            const r3 = /* @__PURE__ */ new Map(), n3 = Array.isArray(t3) ? t3 : [t3], i3 = this.map.painter.terrain, s3 = this.usedForTerrain && i3 ? i3.getScaledDemTileSize() : this._source.tileSize;
            for (const t4 of n3) {
              const e4 = t4.coveringTiles({ tileSize: s3, minzoom: this._source.minzoom, maxzoom: this._source.maxzoom, roundZoom: this._source.roundZoom && !this.usedForTerrain, reparseOverscaled: this._source.reparseOverscaled, isTerrainDEM: this.usedForTerrain });
              for (const t5 of e4)
                r3.set(t5.key, t5);
              this.usedForTerrain && t4.updateElevation(false);
            }
            B(Array.from(r3.values()), (t4, e4) => {
              const r4 = new Pf(t4, this._source.tileSize * t4.overscaleFactor(), this.transform.tileZoom, this.map.painter, this._isRaster);
              this._loadTile(r4, (t5) => {
                "raster-dem" === this._source.type && r4.dem && this._backfillDEM(r4), e4(t5, r4);
              });
            }, e3);
          }
        }
        function ry(t3, e3) {
          const r3 = Math.abs(2 * t3.wrap) - +(t3.wrap < 0), n3 = Math.abs(2 * e3.wrap) - +(e3.wrap < 0);
          return t3.overscaledZ - e3.overscaledZ || n3 - r3 || e3.canonical.y - t3.canonical.y || e3.canonical.x - t3.canonical.x;
        }
        function ny(t3) {
          return "raster" === t3 || "image" === t3 || "video" === t3 || "custom" === t3;
        }
        function iy(t3, e3) {
          const r3 = 1 << t3.z;
          return [t3.x / r3 + e3, (t3.x + 1) / r3 + e3];
        }
        ey.maxOverzooming = 10, ey.maxUnderzooming = 3;
        class sy {
          constructor(t3, e3, r3) {
            this._demTile = t3, this._dem = this._demTile.dem, this._scale = e3, this._offset = r3;
          }
          static create(t3, e3, r3) {
            const n3 = r3 || t3.findDEMTileFor(e3);
            if (!n3 || !n3.dem)
              return;
            const i3 = n3.dem, s3 = n3.tileID, a3 = 1 << e3.canonical.z - s3.canonical.z;
            return new sy(n3, n3.tileSize / ao / a3, [(e3.canonical.x / a3 - s3.canonical.x) * i3.dim, (e3.canonical.y / a3 - s3.canonical.y) * i3.dim]);
          }
          tileCoordToPixel(t3, e3) {
            const r3 = e3 * this._scale + this._offset[1], n3 = Math.floor(t3 * this._scale + this._offset[0]), i3 = Math.floor(r3);
            return new x2(n3, i3);
          }
          getElevationAt(t3, e3, r3, n3) {
            const i3 = t3 * this._scale + this._offset[0], s3 = e3 * this._scale + this._offset[1], a3 = Math.floor(i3), o3 = Math.floor(s3), l2 = this._dem;
            return n3 = !!n3, r3 ? Er(Er(l2.get(a3, o3, n3), l2.get(a3, o3 + 1, n3), s3 - o3), Er(l2.get(a3 + 1, o3, n3), l2.get(a3 + 1, o3 + 1, n3), s3 - o3), i3 - a3) : l2.get(a3, o3, n3);
          }
          getElevationAtPixel(t3, e3, r3) {
            return this._dem.get(t3, e3, !!r3);
          }
          getMeterToDEM(t3) {
            return (1 << this._demTile.tileID.canonical.z) * Zl(1, t3) * this._dem.stride;
          }
        }
        class ay {
          constructor(t3, e3) {
            this.tileID = t3, this.x = t3.canonical.x, this.y = t3.canonical.y, this.z = t3.canonical.z, this.grid = new Ki(ao, 16, 0), this.featureIndexArray = new ba(), this.promoteId = e3;
          }
          insert(t3, e3, r3, n3, i3, s3 = 0) {
            const a3 = this.featureIndexArray.length;
            this.featureIndexArray.emplaceBack(r3, n3, i3, s3);
            const o3 = this.grid;
            for (let t4 = 0; t4 < e3.length; t4++) {
              const r4 = e3[t4], n4 = [1 / 0, 1 / 0, -1 / 0, -1 / 0];
              for (let t5 = 0; t5 < r4.length; t5++) {
                const e4 = r4[t5];
                n4[0] = Math.min(n4[0], e4.x), n4[1] = Math.min(n4[1], e4.y), n4[2] = Math.max(n4[2], e4.x), n4[3] = Math.max(n4[3], e4.y);
              }
              n4[0] < ao && n4[1] < ao && n4[2] >= 0 && n4[3] >= 0 && o3.insert(a3, n4[0], n4[1], n4[2], n4[3]);
            }
          }
          loadVTLayers() {
            if (!this.vtLayers) {
              this.vtLayers = new Zc(new mp(this.rawTileData)).layers, this.sourceLayerCoder = new wf(this.vtLayers ? Object.keys(this.vtLayers).sort() : ["_geojsonTileLayer"]), this.vtFeatures = {};
              for (const t3 in this.vtLayers)
                this.vtFeatures[t3] = [];
            }
            return this.vtLayers;
          }
          query(t3, e3, r3, n3) {
            this.loadVTLayers();
            const i3 = t3.params || {}, s3 = hi(i3.filter), a3 = t3.tileResult, o3 = t3.transform, l2 = a3.bufferedTilespaceBounds, u3 = this.grid.query(l2.min.x, l2.min.y, l2.max.x, l2.max.y, (t4, e4, r4, n4) => wu(a3.bufferedTilespaceGeometry, t4, e4, r4, n4));
            u3.sort(ly);
            let c3 = null;
            o3.elevation && u3.length > 0 && (c3 = sy.create(o3.elevation, this.tileID));
            const h3 = {};
            let p3;
            for (let o4 = 0; o4 < u3.length; o4++) {
              const l3 = u3[o4];
              if (l3 === p3)
                continue;
              p3 = l3;
              const d3 = this.featureIndexArray.get(l3);
              let f3 = null;
              this.loadMatchingFeature(h3, d3, s3, i3.layers, i3.availableImages, e3, r3, n3, (e4, r4, n4, i4 = 0) => (f3 || (f3 = au(e4, this.tileID.canonical, t3.tileTransform)), r4.queryIntersectsFeature(a3, e4, n4, f3, this.z, t3.transform, t3.pixelPosMatrix, c3, i4)));
            }
            return h3;
          }
          loadMatchingFeature(t3, e3, r3, n3, i3, s3, a3, o3, l2) {
            const { featureIndex: u3, bucketIndex: c3, sourceLayerIndex: h3, layoutVertexArrayOffset: p3 } = e3, d3 = this.bucketLayerIDs[c3];
            if (n3 && !function(t4, e4) {
              for (let r4 = 0; r4 < t4.length; r4++)
                if (e4.indexOf(t4[r4]) >= 0)
                  return true;
              return false;
            }(n3, d3))
              return;
            const f3 = this.sourceLayerCoder.decode(h3), y3 = this.vtLayers[f3].feature(u3);
            if (r3.needGeometry) {
              const t4 = ou(y3, true);
              if (!r3.filter(new ws(this.tileID.overscaledZ), t4, this.tileID.canonical))
                return;
            } else if (!r3.filter(new ws(this.tileID.overscaledZ), y3))
              return;
            const m3 = this.getId(y3, f3);
            for (let e4 = 0; e4 < d3.length; e4++) {
              const r4 = d3[e4];
              if (n3 && n3.indexOf(r4) < 0)
                continue;
              const c4 = s3[r4];
              if (!c4)
                continue;
              let h4 = {};
              void 0 !== m3 && o3 && (h4 = o3.getState(c4.sourceLayer || "_geojsonTileLayer", m3));
              const f4 = C({}, a3[r4]);
              f4.paint = oy(f4.paint, c4.paint, y3, h4, i3), f4.layout = oy(f4.layout, c4.layout, y3, h4, i3);
              const g3 = !l2 || l2(y3, c4, h4, p3);
              if (!g3)
                continue;
              const x3 = new Af(y3, this.z, this.x, this.y, m3);
              x3.layer = f4;
              let v3 = t3[r4];
              void 0 === v3 && (v3 = t3[r4] = []), v3.push({ featureIndex: u3, feature: x3, intersectionZ: g3 });
            }
          }
          lookupSymbolFeatures(t3, e3, r3, n3, i3, s3, a3, o3) {
            const l2 = {};
            this.loadVTLayers();
            const u3 = hi(i3);
            for (const i4 of t3)
              this.loadMatchingFeature(l2, { bucketIndex: r3, sourceLayerIndex: n3, featureIndex: i4, layoutVertexArrayOffset: 0 }, u3, s3, a3, o3, e3);
            return l2;
          }
          loadFeature(t3) {
            const { featureIndex: e3, sourceLayerIndex: r3 } = t3;
            this.loadVTLayers();
            const n3 = this.sourceLayerCoder.decode(r3), i3 = this.vtFeatures[n3];
            if (i3[e3])
              return i3[e3];
            const s3 = this.vtLayers[n3].feature(e3);
            return i3[e3] = s3, s3;
          }
          hasLayer(t3) {
            for (const e3 of this.bucketLayerIDs)
              for (const r3 of e3)
                if (t3 === r3)
                  return true;
            return false;
          }
          getId(t3, e3) {
            let r3 = t3.id;
            if (this.promoteId) {
              const n3 = "string" == typeof this.promoteId ? this.promoteId : this.promoteId[e3];
              null != n3 && (r3 = t3.properties[n3]), "boolean" == typeof r3 && (r3 = Number(r3));
            }
            return r3;
          }
        }
        function oy(t3, e3, r3, n3, i3) {
          return $(t3, (t4, s3) => {
            const a3 = e3 instanceof zs ? e3.get(s3) : null;
            return a3 && a3.evaluate ? a3.evaluate(r3, n3, i3) : a3;
          });
        }
        function ly(t3, e3) {
          return e3 - t3;
        }
        Ji(ay, "FeatureIndex", { omit: ["rawTileData", "sourceLayerCoder"] });
        class uy {
          constructor(t3, e3) {
            this.width = t3, this.height = e3, this.nextRow = 0, this.image = new Ru({ width: t3, height: e3 }), this.positions = {}, this.uploaded = false;
          }
          getDash(t3, e3) {
            const r3 = this.getKey(t3, e3);
            return this.positions[r3];
          }
          trim() {
            const t3 = this.width, e3 = this.height = L(this.nextRow);
            this.image.resize({ width: t3, height: e3 });
          }
          getKey(t3, e3) {
            return t3.join(",") + e3;
          }
          getDashRanges(t3, e3, r3) {
            const n3 = [];
            let i3 = t3.length % 2 == 1 ? -t3[t3.length - 1] * r3 : 0, s3 = t3[0] * r3, a3 = true;
            n3.push({ left: i3, right: s3, isDash: a3, zeroLength: 0 === t3[0] });
            let o3 = t3[0];
            for (let e4 = 1; e4 < t3.length; e4++) {
              a3 = !a3;
              const l2 = t3[e4];
              i3 = o3 * r3, o3 += l2, s3 = o3 * r3, n3.push({ left: i3, right: s3, isDash: a3, zeroLength: 0 === l2 });
            }
            return n3;
          }
          addRoundDash(t3, e3, r3) {
            const n3 = e3 / 2;
            for (let e4 = -r3; e4 <= r3; e4++) {
              const i3 = this.width * (this.nextRow + r3 + e4);
              let s3 = 0, a3 = t3[s3];
              for (let o3 = 0; o3 < this.width; o3++) {
                o3 / a3.right > 1 && (a3 = t3[++s3]);
                const l2 = Math.abs(o3 - a3.left), u3 = Math.abs(o3 - a3.right), c3 = Math.min(l2, u3);
                let h3;
                const p3 = e4 / r3 * (n3 + 1);
                if (a3.isDash) {
                  const t4 = n3 - Math.abs(p3);
                  h3 = Math.sqrt(c3 * c3 + t4 * t4);
                } else
                  h3 = n3 - Math.sqrt(c3 * c3 + p3 * p3);
                this.image.data[i3 + o3] = Math.max(0, Math.min(255, h3 + 128));
              }
            }
          }
          addRegularDash(t3, e3) {
            for (let e4 = t3.length - 1; e4 >= 0; --e4) {
              const r4 = t3[e4], n4 = t3[e4 + 1];
              r4.zeroLength ? t3.splice(e4, 1) : n4 && n4.isDash === r4.isDash && (n4.left = r4.left, t3.splice(e4, 1));
            }
            const r3 = t3[0], n3 = t3[t3.length - 1];
            r3.isDash === n3.isDash && (r3.left = n3.left - this.width, n3.right = r3.right + this.width);
            const i3 = this.width * this.nextRow;
            let s3 = 0, a3 = t3[s3];
            for (let r4 = 0; r4 < this.width; r4++) {
              r4 / a3.right > 1 && (a3 = t3[++s3]);
              const n4 = Math.abs(r4 - a3.left), o3 = Math.abs(r4 - a3.right), l2 = Math.min(n4, o3);
              this.image.data[i3 + r4] = Math.max(0, Math.min(255, (a3.isDash ? l2 : -l2) + e3 + 128));
            }
          }
          addDash(t3, e3) {
            const r3 = this.getKey(t3, e3);
            if (this.positions[r3])
              return this.positions[r3];
            const n3 = "round" === e3, i3 = n3 ? 7 : 0, s3 = 2 * i3 + 1;
            if (this.nextRow + s3 > this.height)
              return N("LineAtlas out of space"), null;
            0 === t3.length && t3.push(1);
            let a3 = 0;
            for (let e4 = 0; e4 < t3.length; e4++)
              t3[e4] < 0 && (N("Negative value is found in line dasharray, replacing values with 0"), t3[e4] = 0), a3 += t3[e4];
            if (0 !== a3) {
              const r4 = this.width / a3, s4 = this.getDashRanges(t3, this.width, r4);
              n3 ? this.addRoundDash(s4, r4, i3) : this.addRegularDash(s4, "square" === e3 ? 0.5 * r4 : 0);
            }
            const o3 = this.nextRow + i3;
            this.nextRow += s3;
            const l2 = { tl: [o3, i3], br: [a3, 0] };
            return this.positions[r3] = l2, l2;
          }
        }
        Ji(uy, "LineAtlas");
        const cy = 1 * td;
        class hy {
          constructor(t3) {
            const e3 = {}, r3 = [];
            for (const n4 in t3) {
              const i4 = t3[n4], s4 = e3[n4] = {};
              for (const t4 in i4.glyphs) {
                const e4 = i4.glyphs[+t4];
                if (!e4 || 0 === e4.bitmap.width || 0 === e4.bitmap.height)
                  continue;
                const n5 = e4.metrics.localGlyph ? cy : 1, a3 = { x: 0, y: 0, w: e4.bitmap.width + 2 * n5, h: e4.bitmap.height + 2 * n5 };
                r3.push(a3), s4[t4] = a3;
              }
            }
            const { w: n3, h: i3 } = _p(r3), s3 = new Ru({ width: n3 || 1, height: i3 || 1 });
            for (const r4 in t3) {
              const n4 = t3[r4];
              for (const t4 in n4.glyphs) {
                const i4 = n4.glyphs[+t4];
                if (!i4 || 0 === i4.bitmap.width || 0 === i4.bitmap.height)
                  continue;
                const a3 = e3[r4][t4], o3 = i4.metrics.localGlyph ? cy : 1;
                Ru.copy(i4.bitmap, s3, { x: 0, y: 0 }, { x: a3.x + o3, y: a3.y + o3 }, i4.bitmap);
              }
            }
            this.image = s3, this.positions = e3;
          }
        }
        Ji(hy, "GlyphAtlas");
        class py {
          constructor(t3) {
            this.tileID = new fh(t3.tileID.overscaledZ, t3.tileID.wrap, t3.tileID.canonical.z, t3.tileID.canonical.x, t3.tileID.canonical.y), this.tileZoom = t3.tileZoom, this.uid = t3.uid, this.zoom = t3.zoom, this.canonical = t3.tileID.canonical, this.pixelRatio = t3.pixelRatio, this.tileSize = t3.tileSize, this.source = t3.source, this.overscaling = this.tileID.overscaleFactor(), this.showCollisionBoxes = t3.showCollisionBoxes, this.collectResourceTiming = !!t3.collectResourceTiming, this.returnDependencies = !!t3.returnDependencies, this.promoteId = t3.promoteId, this.enableTerrain = !!t3.enableTerrain, this.isSymbolTile = t3.isSymbolTile, this.tileTransform = Bd(t3.tileID.canonical, t3.projection), this.projection = t3.projection;
          }
          parse(t3, e3, r3, n3, i3) {
            this.status = "parsing", this.data = t3, this.collisionBoxArray = new pa();
            const s3 = new wf(Object.keys(t3.layers).sort()), a3 = new ay(this.tileID, this.promoteId);
            a3.bucketLayerIDs = [];
            const o3 = {}, l2 = new uy(256, 256), u3 = { featureIndex: a3, iconDependencies: {}, patternDependencies: {}, glyphDependencies: {}, lineAtlas: l2, availableImages: r3 }, c3 = e3.familiesBySource[this.source];
            for (const e4 in c3) {
              const n4 = t3.layers[e4];
              if (!n4)
                continue;
              let i4 = false, l3 = false;
              for (const t4 of c3[e4])
                "symbol" === t4[0].type ? i4 = true : l3 = true;
              if (true === this.isSymbolTile && !i4)
                continue;
              if (false === this.isSymbolTile && !l3)
                continue;
              1 === n4.version && N(`Vector tile source "${this.source}" layer "${e4}" does not use vector tile spec v2 and therefore may have some rendering errors.`);
              const h4 = s3.encode(e4), p4 = [];
              for (let t4 = 0; t4 < n4.length; t4++) {
                const r4 = n4.feature(t4), i5 = a3.getId(r4, e4);
                p4.push({ feature: r4, id: i5, index: t4, sourceLayerIndex: h4 });
              }
              for (const t4 of c3[e4]) {
                const e5 = t4[0];
                void 0 !== this.isSymbolTile && "symbol" === e5.type !== this.isSymbolTile || e5.minzoom && this.zoom < Math.floor(e5.minzoom) || e5.maxzoom && this.zoom >= e5.maxzoom || "none" !== e5.visibility && (dy(t4, this.zoom, r3), (o3[e5.id] = e5.createBucket({ index: a3.bucketLayerIDs.length, layers: t4, zoom: this.zoom, canonical: this.canonical, pixelRatio: this.pixelRatio, overscaling: this.overscaling, collisionBoxArray: this.collisionBoxArray, sourceLayerIndex: h4, sourceID: this.source, enableTerrain: this.enableTerrain, projection: this.projection.spec, availableImages: r3 })).populate(p4, u3, this.tileID.canonical, this.tileTransform), a3.bucketLayerIDs.push(t4.map((t5) => t5.id)));
              }
            }
            let h3, p3, d3, f3;
            l2.trim();
            const y3 = { type: "maybePrepare", isSymbolTile: this.isSymbolTile, zoom: this.zoom }, m3 = () => {
              if (h3)
                return i3(h3);
              if (p3 && d3 && f3) {
                const t4 = new hy(p3), e4 = new kp(d3, f3);
                for (const n4 in o3) {
                  const i4 = o3[n4];
                  i4 instanceof of ? (dy(i4.layers, this.zoom, r3), vd(i4, p3, t4.positions, d3, e4.iconPositions, this.showCollisionBoxes, r3, this.tileID.canonical, this.tileZoom, this.projection)) : i4.hasPattern && (i4 instanceof Ih || i4 instanceof Mc || i4 instanceof th) && (dy(i4.layers, this.zoom, r3), i4.addFeatures(u3, this.tileID.canonical, e4.patternPositions, r3, this.tileTransform));
                }
                this.status = "done", i3(null, { buckets: E2(o3).filter((t5) => !t5.isEmpty()), featureIndex: a3, collisionBoxArray: this.collisionBoxArray, glyphAtlasImage: t4.image, lineAtlas: l2, imageAtlas: e4, glyphMap: this.returnDependencies ? p3 : null, iconMap: this.returnDependencies ? d3 : null, glyphPositions: this.returnDependencies ? t4.positions : null });
              }
            }, g3 = $(u3.glyphDependencies, (t4) => Object.keys(t4).map(Number));
            Object.keys(g3).length ? n3.send("getGlyphs", { uid: this.uid, stacks: g3 }, (t4, e4) => {
              h3 || (h3 = t4, p3 = e4, m3());
            }, void 0, false, y3) : p3 = {};
            const x3 = Object.keys(u3.iconDependencies);
            x3.length ? n3.send("getImages", { icons: x3, source: this.source, tileID: this.tileID, type: "icons" }, (t4, e4) => {
              h3 || (h3 = t4, d3 = e4, m3());
            }, void 0, false, y3) : d3 = {};
            const v3 = Object.keys(u3.patternDependencies);
            v3.length ? n3.send("getImages", { icons: v3, source: this.source, tileID: this.tileID, type: "patterns" }, (t4, e4) => {
              h3 || (h3 = t4, f3 = e4, m3());
            }, void 0, false, y3) : f3 = {}, m3();
          }
        }
        function dy(t3, e3, r3) {
          const n3 = new ws(e3);
          for (const e4 of t3)
            e4.recalculate(n3, r3);
        }
        class fy {
          constructor(t3) {
            this.entries = {}, this.scheduler = t3;
          }
          request(t3, e3, r3, n3) {
            const i3 = this.entries[t3] = this.entries[t3] || { callbacks: [] };
            if (i3.result) {
              const [t4, r4] = i3.result;
              return this.scheduler ? this.scheduler.add(() => {
                n3(t4, r4);
              }, e3) : n3(t4, r4), () => {
              };
            }
            return i3.callbacks.push(n3), i3.cancel || (i3.cancel = r3((r4, n4) => {
              i3.result = [r4, n4];
              for (const t4 of i3.callbacks)
                this.scheduler ? this.scheduler.add(() => {
                  t4(r4, n4);
                }, e3) : t4(r4, n4);
              setTimeout(() => delete this.entries[t3], 3e3);
            })), () => {
              i3.result || (i3.callbacks = i3.callbacks.filter((t4) => t4 !== n3), i3.callbacks.length || (i3.cancel(), delete this.entries[t3]));
            };
          }
        }
        function yy(t3, e3, r3) {
          const n3 = JSON.stringify(t3.request);
          return t3.data && (this.deduped.entries[n3] = { result: [null, t3.data] }), this.deduped.request(n3, { type: "parseTile", isSymbolTile: t3.isSymbolTile, zoom: t3.tileZoom }, (e4) => {
            const n4 = pt(t3.request, (t4, n5, i3, s3) => {
              t4 ? e4(t4) : n5 && e4(null, { vectorTile: r3 ? void 0 : new Zc(new mp(n5)), rawData: n5, cacheControl: i3, expires: s3 });
            });
            return () => {
              n4.cancel(), e4();
            };
          }, e3);
        }
        const my = [Int8Array, Uint8Array, Uint8ClampedArray, Int16Array, Uint16Array, Int32Array, Uint32Array, Float32Array, Float64Array];
        class gy {
          static from(t3) {
            if (!(t3 instanceof ArrayBuffer))
              throw new Error("Data must be an instance of ArrayBuffer.");
            const [e3, r3] = new Uint8Array(t3, 0, 2);
            if (219 !== e3)
              throw new Error("Data does not appear to be in a KDBush format.");
            const n3 = r3 >> 4;
            if (1 !== n3)
              throw new Error(`Got v${n3} data when expected v1.`);
            const i3 = my[15 & r3];
            if (!i3)
              throw new Error("Unrecognized array type.");
            const [s3] = new Uint16Array(t3, 2, 1), [a3] = new Uint32Array(t3, 4, 1);
            return new gy(a3, s3, i3, t3);
          }
          constructor(t3, e3 = 64, r3 = Float64Array, n3) {
            if (isNaN(t3) || t3 < 0)
              throw new Error(`Unpexpected numItems value: ${t3}.`);
            this.numItems = +t3, this.nodeSize = Math.min(Math.max(+e3, 2), 65535), this.ArrayType = r3, this.IndexArrayType = t3 < 65536 ? Uint16Array : Uint32Array;
            const i3 = my.indexOf(this.ArrayType), s3 = 2 * t3 * this.ArrayType.BYTES_PER_ELEMENT, a3 = t3 * this.IndexArrayType.BYTES_PER_ELEMENT, o3 = (8 - a3 % 8) % 8;
            if (i3 < 0)
              throw new Error(`Unexpected typed array class: ${r3}.`);
            n3 && n3 instanceof ArrayBuffer ? (this.data = n3, this.ids = new this.IndexArrayType(this.data, 8, t3), this.coords = new this.ArrayType(this.data, 8 + a3 + o3, 2 * t3), this._pos = 2 * t3, this._finished = true) : (this.data = new ArrayBuffer(8 + s3 + a3 + o3), this.ids = new this.IndexArrayType(this.data, 8, t3), this.coords = new this.ArrayType(this.data, 8 + a3 + o3, 2 * t3), this._pos = 0, this._finished = false, new Uint8Array(this.data, 0, 2).set([219, 16 + i3]), new Uint16Array(this.data, 2, 1)[0] = e3, new Uint32Array(this.data, 4, 1)[0] = t3);
          }
          add(t3, e3) {
            const r3 = this._pos >> 1;
            return this.ids[r3] = r3, this.coords[this._pos++] = t3, this.coords[this._pos++] = e3, r3;
          }
          finish() {
            const t3 = this._pos >> 1;
            if (t3 !== this.numItems)
              throw new Error(`Added ${t3} items when expected ${this.numItems}.`);
            return xy(this.ids, this.coords, this.nodeSize, 0, this.numItems - 1, 0), this._finished = true, this;
          }
          range(t3, e3, r3, n3) {
            if (!this._finished)
              throw new Error("Data not yet indexed - call index.finish().");
            const { ids: i3, coords: s3, nodeSize: a3 } = this, o3 = [0, i3.length - 1, 0], l2 = [];
            for (; o3.length; ) {
              const u3 = o3.pop() || 0, c3 = o3.pop() || 0, h3 = o3.pop() || 0;
              if (c3 - h3 <= a3) {
                for (let a4 = h3; a4 <= c3; a4++) {
                  const o4 = s3[2 * a4], u4 = s3[2 * a4 + 1];
                  o4 >= t3 && o4 <= r3 && u4 >= e3 && u4 <= n3 && l2.push(i3[a4]);
                }
                continue;
              }
              const p3 = h3 + c3 >> 1, d3 = s3[2 * p3], f3 = s3[2 * p3 + 1];
              d3 >= t3 && d3 <= r3 && f3 >= e3 && f3 <= n3 && l2.push(i3[p3]), (0 === u3 ? t3 <= d3 : e3 <= f3) && (o3.push(h3), o3.push(p3 - 1), o3.push(1 - u3)), (0 === u3 ? r3 >= d3 : n3 >= f3) && (o3.push(p3 + 1), o3.push(c3), o3.push(1 - u3));
            }
            return l2;
          }
          within(t3, e3, r3) {
            if (!this._finished)
              throw new Error("Data not yet indexed - call index.finish().");
            const { ids: n3, coords: i3, nodeSize: s3 } = this, a3 = [0, n3.length - 1, 0], o3 = [], l2 = r3 * r3;
            for (; a3.length; ) {
              const u3 = a3.pop() || 0, c3 = a3.pop() || 0, h3 = a3.pop() || 0;
              if (c3 - h3 <= s3) {
                for (let r4 = h3; r4 <= c3; r4++)
                  _y(i3[2 * r4], i3[2 * r4 + 1], t3, e3) <= l2 && o3.push(n3[r4]);
                continue;
              }
              const p3 = h3 + c3 >> 1, d3 = i3[2 * p3], f3 = i3[2 * p3 + 1];
              _y(d3, f3, t3, e3) <= l2 && o3.push(n3[p3]), (0 === u3 ? t3 - r3 <= d3 : e3 - r3 <= f3) && (a3.push(h3), a3.push(p3 - 1), a3.push(1 - u3)), (0 === u3 ? t3 + r3 >= d3 : e3 + r3 >= f3) && (a3.push(p3 + 1), a3.push(c3), a3.push(1 - u3));
            }
            return o3;
          }
        }
        function xy(t3, e3, r3, n3, i3, s3) {
          if (i3 - n3 <= r3)
            return;
          const a3 = n3 + i3 >> 1;
          vy(t3, e3, a3, n3, i3, s3), xy(t3, e3, r3, n3, a3 - 1, 1 - s3), xy(t3, e3, r3, a3 + 1, i3, 1 - s3);
        }
        function vy(t3, e3, r3, n3, i3, s3) {
          for (; i3 > n3; ) {
            if (i3 - n3 > 600) {
              const a4 = i3 - n3 + 1, o4 = r3 - n3 + 1, l3 = Math.log(a4), u3 = 0.5 * Math.exp(2 * l3 / 3), c3 = 0.5 * Math.sqrt(l3 * u3 * (a4 - u3) / a4) * (o4 - a4 / 2 < 0 ? -1 : 1);
              vy(t3, e3, r3, Math.max(n3, Math.floor(r3 - o4 * u3 / a4 + c3)), Math.min(i3, Math.floor(r3 + (a4 - o4) * u3 / a4 + c3)), s3);
            }
            const a3 = e3[2 * r3 + s3];
            let o3 = n3, l2 = i3;
            for (by(t3, e3, n3, r3), e3[2 * i3 + s3] > a3 && by(t3, e3, n3, i3); o3 < l2; ) {
              for (by(t3, e3, o3, l2), o3++, l2--; e3[2 * o3 + s3] < a3; )
                o3++;
              for (; e3[2 * l2 + s3] > a3; )
                l2--;
            }
            e3[2 * n3 + s3] === a3 ? by(t3, e3, n3, l2) : (l2++, by(t3, e3, l2, i3)), l2 <= r3 && (n3 = l2 + 1), r3 <= l2 && (i3 = l2 - 1);
          }
        }
        function by(t3, e3, r3, n3) {
          wy(t3, r3, n3), wy(e3, 2 * r3, 2 * n3), wy(e3, 2 * r3 + 1, 2 * n3 + 1);
        }
        function wy(t3, e3, r3) {
          const n3 = t3[e3];
          t3[e3] = t3[r3], t3[r3] = n3;
        }
        function _y(t3, e3, r3, n3) {
          const i3 = t3 - r3, s3 = e3 - n3;
          return i3 * i3 + s3 * s3;
        }
        t2.ARRAY_TYPE = uo, t2.AUTH_ERR_MSG = xt, t2.Aabb = il, t2.Actor = class {
          constructor(t3, r3, n3) {
            this.target = t3, this.parent = r3, this.mapId = n3, this.callbacks = {}, this.cancelCallbacks = {}, R(["receive"], this), this.target.addEventListener("message", this.receive, false), this.globalScope = K() ? t3 : e2, this.scheduler = new bf();
          }
          send(t3, e3, r3, n3, i3 = false, s3) {
            const a3 = Math.round(1e18 * Math.random()).toString(36).substring(0, 10);
            r3 && (r3.metadata = s3, this.callbacks[a3] = r3);
            const o3 = H(this.globalScope) ? void 0 : [];
            return this.target.postMessage({ id: a3, type: t3, hasCallback: !!r3, targetMapId: n3, mustQueue: i3, sourceMapId: this.mapId, data: Wi(e3, o3) }, o3), { cancel: () => {
              r3 && delete this.callbacks[a3], this.target.postMessage({ id: a3, type: "<cancel>", targetMapId: n3, sourceMapId: this.mapId });
            } };
          }
          receive(t3) {
            const e3 = t3.data, r3 = e3.id;
            if (r3 && (!e3.targetMapId || this.mapId === e3.targetMapId))
              if ("<cancel>" === e3.type) {
                const t4 = this.cancelCallbacks[r3];
                delete this.cancelCallbacks[r3], t4 && t4.cancel();
              } else if (e3.mustQueue || K()) {
                const t4 = this.callbacks[r3];
                this.cancelCallbacks[r3] = this.scheduler.add(() => this.processTask(r3, e3), t4 && t4.metadata || { type: "message" });
              } else
                this.processTask(r3, e3);
          }
          processTask(t3, e3) {
            if ("<response>" === e3.type) {
              const r3 = this.callbacks[t3];
              delete this.callbacks[t3], r3 && (e3.error ? r3(Qi(e3.error)) : r3(null, Qi(e3.data)));
            } else {
              const r3 = H(this.globalScope) ? void 0 : [], n3 = e3.hasCallback ? (e4, n4) => {
                delete this.cancelCallbacks[t3], this.target.postMessage({ id: t3, type: "<response>", sourceMapId: this.mapId, error: e4 ? Wi(e4) : null, data: Wi(n4, r3) }, r3);
              } : (t4) => {
              }, i3 = Qi(e3.data);
              if (this.parent[e3.type])
                this.parent[e3.type](e3.sourceMapId, i3, n3);
              else if (this.parent.getWorkerSource) {
                const t4 = e3.type.split(".");
                this.parent.getWorkerSource(e3.sourceMapId, t4[0], i3.source)[t4[1]](i3, n3);
              } else
                n3(new Error(`Could not find function ${e3.type}`));
            }
          }
          remove() {
            this.scheduler.remove(), this.target.removeEventListener("message", this.receive, false);
          }
        }, t2.CanonicalTileID = ph, t2.Color = Ee, t2.ColorMode = Yf, t2.CullFaceMode = ty, t2.DEMData = Zf, t2.DataConstantProperty = Bs, t2.DedupedRequest = fy, t2.DepthMode = Xf, t2.EXTENT = ao, t2.Elevation = class {
          isDataAvailableAtPoint(t3) {
            const e3 = this._source();
            if (this.isUsingMockSource() || !e3 || t3.y < 0 || t3.y > 1)
              return false;
            const r3 = e3.getSource().maxzoom, n3 = 1 << r3, i3 = Math.floor(t3.x), s3 = Math.floor((t3.x - i3) * n3), a3 = Math.floor(t3.y * n3), o3 = this.findDEMTileFor(new fh(r3, i3, r3, s3, a3));
            return !(!o3 || !o3.dem);
          }
          getAtPointOrZero(t3, e3 = 0) {
            return this.getAtPoint(t3, e3) || 0;
          }
          getAtPoint(t3, e3, r3 = true) {
            if (this.isUsingMockSource())
              return null;
            null == e3 && (e3 = null);
            const n3 = this._source();
            if (!n3)
              return e3;
            if (t3.y < 0 || t3.y > 1)
              return e3;
            const i3 = n3.getSource().maxzoom, s3 = 1 << i3, a3 = Math.floor(t3.x), o3 = t3.x - a3, l2 = new fh(i3, a3, i3, Math.floor(o3 * s3), Math.floor(t3.y * s3)), u3 = this.findDEMTileFor(l2);
            if (!u3 || !u3.dem)
              return e3;
            const c3 = u3.dem, h3 = 1 << u3.tileID.canonical.z, p3 = (o3 * h3 - u3.tileID.canonical.x) * c3.dim, d3 = (t3.y * h3 - u3.tileID.canonical.y) * c3.dim, f3 = Math.floor(p3), y3 = Math.floor(d3);
            return (r3 ? this.exaggeration() : 1) * Er(Er(c3.get(f3, y3), c3.get(f3, y3 + 1), d3 - y3), Er(c3.get(f3 + 1, y3), c3.get(f3 + 1, y3 + 1), d3 - y3), p3 - f3);
          }
          getAtTileOffset(t3, e3, r3) {
            const n3 = 1 << t3.canonical.z;
            return this.getAtPointOrZero(new Wl(t3.wrap + (t3.canonical.x + e3 / ao) / n3, (t3.canonical.y + r3 / ao) / n3));
          }
          getAtTileOffsetFunc(t3, e3, r3, n3) {
            return (i3) => {
              const s3 = this.getAtTileOffset(t3, i3.x, i3.y), a3 = n3.upVector(t3.canonical, i3.x, i3.y);
              return Co(a3, a3, s3 * n3.upVectorScale(t3.canonical, e3, r3).metersToTile), a3;
            };
          }
          getForTilePoints(t3, e3, r3, n3) {
            if (this.isUsingMockSource())
              return false;
            const i3 = sy.create(this, t3, n3);
            return !!i3 && (e3.forEach((t4) => {
              t4[2] = this.exaggeration() * i3.getElevationAt(t4[0], t4[1], r3);
            }), true);
          }
          getMinMaxForTile(t3) {
            if (this.isUsingMockSource())
              return null;
            const e3 = this.findDEMTileFor(t3);
            if (!e3 || !e3.dem)
              return null;
            const r3 = e3.dem.tree, n3 = e3.tileID, i3 = 1 << t3.canonical.z - n3.canonical.z;
            let s3 = t3.canonical.x / i3 - n3.canonical.x, a3 = t3.canonical.y / i3 - n3.canonical.y, o3 = 0;
            for (let e4 = 0; e4 < t3.canonical.z - n3.canonical.z && !r3.leaves[o3]; e4++) {
              s3 *= 2, a3 *= 2;
              const t4 = 2 * Math.floor(a3) + Math.floor(s3);
              o3 = r3.childOffsets[o3] + t4, s3 %= 1, a3 %= 1;
            }
            return { min: this.exaggeration() * r3.minimums[o3], max: this.exaggeration() * r3.maximums[o3] };
          }
          getMinElevationBelowMSL() {
            throw new Error("Pure virtual method called.");
          }
          raycast(t3, e3, r3) {
            throw new Error("Pure virtual method called.");
          }
          pointCoordinate(t3) {
            throw new Error("Pure virtual method called.");
          }
          _source() {
            throw new Error("Pure virtual method called.");
          }
          isUsingMockSource() {
            throw new Error("Pure virtual method called.");
          }
          exaggeration() {
            throw new Error("Pure virtual method called.");
          }
          findDEMTileFor(t3) {
            throw new Error("Pure virtual method called.");
          }
          get visibleDemTiles() {
            throw new Error("Getter must be implemented in subclass.");
          }
        }, t2.ErrorEvent = Wt, t2.EvaluationParameters = ws, t2.Event = Yt, t2.Evented = Qt, t2.FillExtrusionBucket = th, t2.Frustum = nl, t2.FrustumCorners = rl, t2.GLOBE_RADIUS = ol, t2.GLOBE_SCALE_MATCH_LATITUDE = 45, t2.GLOBE_ZOOM_THRESHOLD_MAX = al, t2.GLOBE_ZOOM_THRESHOLD_MIN = sl, t2.GlobeSharedBuffers = class {
          constructor(t3) {
            this._createGrid(t3), this._createPoles(t3);
          }
          destroy() {
            this._poleIndexBuffer.destroy(), this._gridBuffer.destroy(), this._gridIndexBuffer.destroy(), this._poleNorthVertexBuffer.destroy(), this._poleSouthVertexBuffer.destroy();
            for (const t3 of this._poleSegments)
              t3.destroy();
            for (const t3 of this._gridSegments)
              t3.withSkirts.destroy(), t3.withoutSkirts.destroy();
            if (this._wireframeIndexBuffer) {
              this._wireframeIndexBuffer.destroy();
              for (const t3 of this._wireframeSegments)
                t3.destroy();
            }
          }
          _fillGridMeshWithLods(t3, e3) {
            const r3 = new $s(), n3 = new ra(), i3 = [], s3 = t3 + 1 + 2, a3 = e3[0] + 1, o3 = e3[0] + 1 + (1 + e3.length), l2 = (t4, e4, r4) => {
              let n4 = t4 === s3 - 1 ? t4 - 2 : 0 === t4 ? t4 : t4 - 1;
              return n4 += r4 ? 24575 : 0, [n4, e4];
            };
            for (let t4 = 0; t4 < s3; ++t4)
              r3.emplaceBack(...l2(t4, 0, true));
            for (let t4 = 0; t4 < a3; ++t4)
              for (let e4 = 0; e4 < s3; ++e4)
                r3.emplaceBack(...l2(e4, t4, (0 === e4 || e4 === s3 - 1) && true));
            for (let t4 = 0; t4 < e3.length; ++t4) {
              const n4 = e3[t4];
              for (let t5 = 0; t5 < s3; ++t5)
                r3.emplaceBack(...l2(t5, n4, true));
            }
            for (let t4 = 0; t4 < e3.length; ++t4) {
              const a4 = n3.length, l3 = e3[t4] + 1 + 2, u3 = new ra();
              for (let r4 = 0; r4 < l3 - 1; r4++) {
                const i4 = r4 === l3 - 2, a5 = i4 ? s3 * (o3 - e3.length + t4 - r4) : s3;
                for (let t5 = 0; t5 < s3 - 1; t5++) {
                  const e4 = r4 * s3 + t5;
                  0 === r4 || i4 || 0 === t5 || t5 === s3 - 2 ? (u3.emplaceBack(e4 + 1, e4, e4 + a5), u3.emplaceBack(e4 + a5, e4 + a5 + 1, e4 + 1)) : (n3.emplaceBack(e4 + 1, e4, e4 + a5), n3.emplaceBack(e4 + a5, e4 + a5 + 1, e4 + 1));
                }
              }
              const c3 = so.simpleSegment(0, a4, r3.length, n3.length - a4);
              for (let t5 = 0; t5 < u3.uint16.length; t5 += 3)
                n3.emplaceBack(u3.uint16[t5], u3.uint16[t5 + 1], u3.uint16[t5 + 2]);
              const h3 = so.simpleSegment(0, a4, r3.length, n3.length - a4);
              i3.push({ withoutSkirts: c3, withSkirts: h3 });
            }
            return { vertices: r3, indices: n3, segments: i3 };
          }
          _createGrid(t3) {
            const e3 = this._fillGridMeshWithLods(ul, cl);
            this._gridSegments = e3.segments, this._gridBuffer = t3.createVertexBuffer(e3.vertices, tl.members), this._gridIndexBuffer = t3.createIndexBuffer(e3.indices, true);
          }
          _createPoles(t3) {
            const e3 = new ra();
            for (let t4 = 0; t4 <= ul; t4++)
              e3.emplaceBack(0, t4 + 1, t4 + 2);
            this._poleIndexBuffer = t3.createIndexBuffer(e3, true);
            const r3 = new aa(), n3 = new aa();
            this._poleSegments = [];
            for (let t4 = 0, e4 = 0; t4 < sl; t4++) {
              const i3 = 360 / (1 << t4);
              r3.emplaceBack(0, -ol, 0, 0.5, 0), n3.emplaceBack(0, -ol, 0, 0.5, 1);
              for (let t5 = 0; t5 <= ul; t5++) {
                const e5 = t5 / ul, s3 = Er(0, i3, e5), [a3, o3, l2] = kl(Fl, Rl, s3, ol);
                r3.emplaceBack(a3, o3, l2, e5, 0), n3.emplaceBack(a3, o3, l2, e5, 1);
              }
              this._poleSegments.push(so.simpleSegment(e4, 0, 66, 64)), e4 += 66;
            }
            this._poleNorthVertexBuffer = t3.createVertexBuffer(r3, Wo, false), this._poleSouthVertexBuffer = t3.createVertexBuffer(n3, Wo, false);
          }
          getGridBuffers(t3, e3) {
            return [this._gridBuffer, this._gridIndexBuffer, e3 ? this._gridSegments[t3].withSkirts : this._gridSegments[t3].withoutSkirts];
          }
          getPoleBuffers(t3) {
            return [this._poleNorthVertexBuffer, this._poleSouthVertexBuffer, this._poleIndexBuffer, this._poleSegments[t3]];
          }
          getWirefameBuffers(t3, e3) {
            if (!this._wireframeSegments) {
              const e4 = new la(), r3 = ul, n3 = r3 + 1 + 2, i3 = 1;
              this._wireframeSegments = [];
              for (let t4 = 0, s3 = 0; t4 < cl.length; t4++) {
                const a3 = cl[t4];
                for (let t5 = i3; t5 < a3 + i3; t5++)
                  for (let s4 = i3; s4 < r3 + i3; s4++) {
                    const r4 = t5 * n3 + s4;
                    e4.emplaceBack(r4, r4 + 1), e4.emplaceBack(r4, r4 + n3), e4.emplaceBack(r4, r4 + n3 + 1);
                  }
                const o3 = a3 * r3 * 3;
                this._wireframeSegments.push(so.simpleSegment(0, s3, (a3 + 1) * n3, o3)), s3 += o3;
              }
              this._wireframeIndexBuffer = t3.createIndexBuffer(e4);
            }
            return [this._gridBuffer, this._wireframeIndexBuffer, this._wireframeSegments[e3]];
          }
        }, t2.GlyphManager = rd, t2.ImagePosition = Sp, t2.KDBush = gy, t2.LivePerformanceUtils = $t, t2.LngLat = Ol, t2.LngLatBounds = oo, t2.LocalGlyphMode = ed, t2.MAX_MERCATOR_LATITUDE = Hl, t2.MercatorCoordinate = Wl, t2.ONE_EM = Rh, t2.OverscaledTileID = fh, t2.PerformanceMarkers = Ut, t2.Point = x2, t2.Properties = Ps, t2.RGBAImage = Uu, t2.Ray = el, t2.RequestManager = class {
          constructor(t3, e3, r3) {
            this._transformRequestFn = t3, this._customAccessToken = e3, this._silenceAuthErrors = !!r3, this._createSkuToken();
          }
          _createSkuToken() {
            const t3 = function() {
              let t4 = "";
              for (let e3 = 0; e3 < 10; e3++)
                t4 += "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ"[Math.floor(62 * Math.random())];
              return { token: ["1", h2, t4].join(""), tokenExpiresAt: Date.now() + 432e5 };
            }();
            this._skuToken = t3.token, this._skuTokenExpiresAt = t3.tokenExpiresAt;
          }
          _isSkuTokenExpired() {
            return Date.now() > this._skuTokenExpiresAt;
          }
          transformRequest(t3, e3) {
            return this._transformRequestFn && this._transformRequestFn(t3, e3) || { url: t3 };
          }
          normalizeStyleURL(t3, e3) {
            if (!vt(t3))
              return t3;
            const r3 = kt(t3);
            return r3.path = `/styles/v1${r3.path}`, this._makeAPIURL(r3, this._customAccessToken || e3);
          }
          normalizeGlyphsURL(t3, e3) {
            if (!vt(t3))
              return t3;
            const r3 = kt(t3);
            return r3.path = `/fonts/v1${r3.path}`, this._makeAPIURL(r3, this._customAccessToken || e3);
          }
          normalizeSourceURL(t3, e3, r3, n3) {
            if (!vt(t3))
              return t3;
            const i3 = kt(t3);
            return i3.path = `/v4/${i3.authority}.json`, i3.params.push("secure"), r3 && i3.params.push(`language=${r3}`), n3 && i3.params.push(`worldview=${n3}`), this._makeAPIURL(i3, this._customAccessToken || e3);
          }
          normalizeSpriteURL(t3, e3, r3, n3) {
            const i3 = kt(t3);
            return vt(t3) ? (i3.path = `/styles/v1${i3.path}/sprite${e3}${r3}`, this._makeAPIURL(i3, this._customAccessToken || n3)) : (i3.path += `${e3}${r3}`, It(i3));
          }
          normalizeTileURL(t3, e3, r3) {
            if (this._isSkuTokenExpired() && this._createSkuToken(), t3 && !vt(t3))
              return t3;
            const n3 = kt(t3);
            n3.path = n3.path.replace(/(\.(png|jpg)\d*)(?=$)/, `${e3 || r3 && "raster" !== n3.authority && 512 === r3 ? "@2x" : ""}${s2.supported ? ".webp" : "$1"}`), "raster" === n3.authority ? n3.path = `/${i2.RASTER_URL_PREFIX}${n3.path}` : (n3.path = n3.path.replace(/^.+\/v4\//, "/"), n3.path = `/${i2.TILE_URL_VERSION}${n3.path}`);
            const a3 = this._customAccessToken || function(t4) {
              for (const e4 of t4) {
                const t5 = e4.match(/^access_token=(.*)$/);
                if (t5)
                  return t5[1];
              }
              return null;
            }(n3.params) || i2.ACCESS_TOKEN;
            return i2.REQUIRE_ACCESS_TOKEN && a3 && this._skuToken && n3.params.push(`sku=${this._skuToken}`), this._makeAPIURL(n3, a3);
          }
          canonicalizeTileURL(t3, e3) {
            const r3 = kt(t3);
            if (!r3.path.match(/^(\/v4\/|\/raster\/v1\/)/) || !r3.path.match(/\.[\w]+$/))
              return t3;
            let n3 = "mapbox://";
            r3.path.match(/^\/raster\/v1\//) ? n3 += `raster/${r3.path.replace(`/${i2.RASTER_URL_PREFIX}/`, "")}` : n3 += `tiles/${r3.path.replace(`/${i2.TILE_URL_VERSION}/`, "")}`;
            let s3 = r3.params;
            return e3 && (s3 = s3.filter((t4) => !t4.match(/^access_token=/))), s3.length && (n3 += `?${s3.join("&")}`), n3;
          }
          canonicalizeTileset(t3, e3) {
            const r3 = !!e3 && vt(e3), n3 = [];
            for (const e4 of t3.tiles || [])
              bt(e4) ? n3.push(this.canonicalizeTileURL(e4, r3)) : n3.push(e4);
            return n3;
          }
          _makeAPIURL(t3, e3) {
            const r3 = "See https://docs.mapbox.com/api/overview/#access-tokens-and-token-scopes", n3 = kt(i2.API_URL);
            if (t3.protocol = n3.protocol, t3.authority = n3.authority, "http" === t3.protocol) {
              const e4 = t3.params.indexOf("secure");
              e4 >= 0 && t3.params.splice(e4, 1);
            }
            if ("/" !== n3.path && (t3.path = `${n3.path}${t3.path}`), !i2.REQUIRE_ACCESS_TOKEN)
              return It(t3);
            if (e3 = e3 || i2.ACCESS_TOKEN, !this._silenceAuthErrors) {
              if (!e3)
                throw new Error(`An API access token is required to use Mapbox GL. ${r3}`);
              if ("s" === e3[0])
                throw new Error(`Use a public access token (pk.*) with Mapbox GL, not a secret access token (sk.*). ${r3}`);
            }
            return t3.params = t3.params.filter((t4) => -1 === t4.indexOf("access_token")), t3.params.push(`access_token=${e3 || ""}`), It(t3);
          }
        }, t2.ResourceType = lt, t2.SegmentVector = so, t2.SourceCache = ey, t2.StencilMode = Hf, t2.StructArrayLayout1ui2 = ua, t2.StructArrayLayout2f1f2i16 = Qs, t2.StructArrayLayout2i4 = $s, t2.StructArrayLayout2ui4 = la, t2.StructArrayLayout3f12 = ea, t2.StructArrayLayout3ui6 = ra, t2.StructArrayLayout4i8 = Os, t2.StructArrayLayout5f20 = aa, t2.Texture = xf, t2.Tile = Pf, t2.Transitionable = Ss, t2.Uniform1f = La, t2.Uniform1i = class extends Va {
          constructor(t3) {
            super(t3), this.current = 0;
          }
          set(t3, e3, r3) {
            this.fetchUniformLocation(t3, e3) && this.current !== r3 && (this.current = r3, this.gl.uniform1i(this.location, r3));
          }
        }, t2.Uniform2f = class extends Va {
          constructor(t3) {
            super(t3), this.current = [0, 0];
          }
          set(t3, e3, r3) {
            this.fetchUniformLocation(t3, e3) && (r3[0] === this.current[0] && r3[1] === this.current[1] || (this.current = r3, this.gl.uniform2f(this.location, r3[0], r3[1])));
          }
        }, t2.Uniform3f = class extends Va {
          constructor(t3) {
            super(t3), this.current = [0, 0, 0];
          }
          set(t3, e3, r3) {
            this.fetchUniformLocation(t3, e3) && (r3[0] === this.current[0] && r3[1] === this.current[1] && r3[2] === this.current[2] || (this.current = r3, this.gl.uniform3f(this.location, r3[0], r3[1], r3[2])));
          }
        }, t2.Uniform4f = Fa, t2.UniformColor = Ra, t2.UniformMatrix2f = class extends Va {
          constructor(t3) {
            super(t3), this.current = ja;
          }
          set(t3, e3, r3) {
            if (this.fetchUniformLocation(t3, e3)) {
              for (let t4 = 0; t4 < 4; t4++)
                if (r3[t4] !== this.current[t4]) {
                  this.current = r3, this.gl.uniformMatrix2fv(this.location, false, r3);
                  break;
                }
            }
          }
        }, t2.UniformMatrix3f = class extends Va {
          constructor(t3) {
            super(t3), this.current = $a;
          }
          set(t3, e3, r3) {
            if (this.fetchUniformLocation(t3, e3)) {
              for (let t4 = 0; t4 < 9; t4++)
                if (r3[t4] !== this.current[t4]) {
                  this.current = r3, this.gl.uniformMatrix3fv(this.location, false, r3);
                  break;
                }
            }
          }
        }, t2.UniformMatrix4f = class extends Va {
          constructor(t3) {
            super(t3), this.current = Ua;
          }
          set(t3, e3, r3) {
            if (this.fetchUniformLocation(t3, e3)) {
              if (r3[12] !== this.current[12] || r3[0] !== this.current[0])
                return this.current = r3, void this.gl.uniformMatrix4fv(this.location, false, r3);
              for (let t4 = 1; t4 < 16; t4++)
                if (r3[t4] !== this.current[t4]) {
                  this.current = r3, this.gl.uniformMatrix4fv(this.location, false, r3);
                  break;
                }
            }
          }
        }, t2.UnwrappedTileID = dh, t2.ValidationError = ri, t2.VectorTileFeature = Kc, t2.VectorTileWorkerSource = class extends Qt {
          constructor(t3, e3, r3, n3, i3) {
            super(), this.actor = t3, this.layerIndex = e3, this.availableImages = r3, this.loadVectorData = i3 || yy, this.loading = {}, this.loaded = {}, this.deduped = new fy(t3.scheduler), this.isSpriteLoaded = n3, this.scheduler = t3.scheduler;
          }
          loadTile(t3, e3) {
            const r3 = t3.uid, n3 = t3 && t3.request, i3 = n3 && n3.collectResourceTiming, s3 = this.loading[r3] = new py(t3);
            s3.abort = this.loadVectorData(t3, (a3, o3) => {
              const l2 = !this.loading[r3];
              if (delete this.loading[r3], l2 || a3 || !o3)
                return s3.status = "done", l2 || (this.loaded[r3] = s3), e3(a3);
              const u3 = o3.rawData, c3 = {};
              o3.expires && (c3.expires = o3.expires), o3.cacheControl && (c3.cacheControl = o3.cacheControl), s3.vectorTile = o3.vectorTile || new Zc(new mp(u3));
              const h3 = () => {
                s3.parse(s3.vectorTile, this.layerIndex, this.availableImages, this.actor, (t4, r4) => {
                  if (t4 || !r4)
                    return e3(t4);
                  const s4 = {};
                  if (i3) {
                    const t5 = qt(n3);
                    t5.length > 0 && (s4.resourceTiming = JSON.parse(JSON.stringify(t5)));
                  }
                  e3(null, C({ rawTileData: u3.slice(0) }, r4, c3, s4));
                });
              };
              this.isSpriteLoaded ? h3() : this.once("isSpriteLoaded", () => {
                this.scheduler ? this.scheduler.add(h3, { type: "parseTile", isSymbolTile: t3.isSymbolTile, zoom: t3.tileZoom }) : h3();
              }), this.loaded = this.loaded || {}, this.loaded[r3] = s3;
            });
          }
          reloadTile(t3, e3) {
            const r3 = this.loaded, n3 = t3.uid, i3 = this;
            if (r3 && r3[n3]) {
              const s3 = r3[n3];
              s3.showCollisionBoxes = t3.showCollisionBoxes, s3.enableTerrain = !!t3.enableTerrain, s3.projection = t3.projection, s3.tileTransform = Bd(t3.tileID.canonical, t3.projection);
              const a3 = (t4, r4) => {
                const n4 = s3.reloadCallback;
                n4 && (delete s3.reloadCallback, s3.parse(s3.vectorTile, i3.layerIndex, this.availableImages, i3.actor, n4)), e3(t4, r4);
              };
              "parsing" === s3.status ? s3.reloadCallback = a3 : "done" === s3.status && (s3.vectorTile ? s3.parse(s3.vectorTile, this.layerIndex, this.availableImages, this.actor, a3) : a3());
            }
          }
          abortTile(t3, e3) {
            const r3 = t3.uid, n3 = this.loading[r3];
            n3 && (n3.abort && n3.abort(), delete this.loading[r3]), e3();
          }
          removeTile(t3, e3) {
            const r3 = this.loaded, n3 = t3.uid;
            r3 && r3[n3] && delete r3[n3], e3();
          }
        }, t2.WritingMode = Ip, t2.ZoomDependentExpression = Wn, t2.add = Mo, t2.addDynamicAttributes = rf, t2.adjoint = function(t3, e3) {
          var r3 = e3[0], n3 = e3[1], i3 = e3[2], s3 = e3[3], a3 = e3[4], o3 = e3[5], l2 = e3[6], u3 = e3[7], c3 = e3[8];
          return t3[0] = a3 * c3 - o3 * u3, t3[1] = i3 * u3 - n3 * c3, t3[2] = n3 * o3 - i3 * a3, t3[3] = o3 * l2 - s3 * c3, t3[4] = r3 * c3 - i3 * l2, t3[5] = i3 * s3 - r3 * o3, t3[6] = s3 * u3 - a3 * l2, t3[7] = n3 * l2 - r3 * u3, t3[8] = r3 * a3 - n3 * s3, t3;
        }, t2.asyncAll = B, t2.bezier = k, t2.bindAll = R, t2.boundsAttributes = Ef, t2.bufferConvexPolygon = function(t3, e3) {
          const r3 = [];
          for (let n3 = 0; n3 < t3.length; n3++) {
            const i3 = z(n3 - 1, -1, t3.length - 1), s3 = z(n3 + 1, -1, t3.length - 1), a3 = t3[n3], o3 = t3[s3], l2 = t3[i3].sub(a3).unit(), u3 = o3.sub(a3).unit(), c3 = u3.angleWithSep(l2.x, l2.y), h3 = l2.add(u3).unit().mult(-1 * e3 / Math.sin(c3 / 2));
            r3.push(a3.add(h3));
          }
          return r3;
        }, t2.cacheEntryPossiblyAdded = function(t3) {
          ot++, ot > et && (t3.getActor().send("enforceCacheSizeLimit", tt), ot = 0);
        }, t2.calculateGlobeLabelMatrix = function(t3, e3) {
          const { x: r3, y: n3 } = t3.point, i3 = Cl(r3, n3, t3.worldSize / t3._pixelsPerMercatorPixel, 0, 0);
          return yo(i3, i3, El(xl(e3)));
        }, t2.calculateGlobeMatrix = function(t3) {
          const { x: e3, y: r3 } = t3.point, { lng: n3, lat: i3 } = t3._center;
          return Cl(e3, r3, t3.worldSize, n3, i3);
        }, t2.calculateGlobeMercatorMatrix = function(t3) {
          const e3 = t3.pixelsPerMeter, r3 = e3 / Zl(1, t3.center.lat), n3 = po(new Float64Array(16));
          return mo(n3, n3, [t3.point.x, t3.point.y, 0]), go(n3, n3, [r3, r3, e3]), Float32Array.from(n3);
        }, t2.circumferenceAtLatitude = ql, t2.clamp = M, t2.clearTileCache = function(t3) {
          if (!it())
            return;
          const r3 = e2.caches.delete(Q);
          t3 && r3.catch(t3).then(() => t3());
        }, t2.clipLine = Hp, t2.clone = function(t3) {
          var e3 = new uo(16);
          return e3[0] = t3[0], e3[1] = t3[1], e3[2] = t3[2], e3[3] = t3[3], e3[4] = t3[4], e3[5] = t3[5], e3[6] = t3[6], e3[7] = t3[7], e3[8] = t3[8], e3[9] = t3[9], e3[10] = t3[10], e3[11] = t3[11], e3[12] = t3[12], e3[13] = t3[13], e3[14] = t3[14], e3[15] = t3[15], e3;
        }, t2.clone$1 = O, t2.collisionCircleLayout = Fh, t2.config = i2, t2.conjugate = function(t3, e3) {
          return t3[0] = -e3[0], t3[1] = -e3[1], t3[2] = -e3[2], t3[3] = e3[3], t3;
        }, t2.create = function() {
          var t3 = new uo(16);
          return uo != Float32Array && (t3[1] = 0, t3[2] = 0, t3[3] = 0, t3[4] = 0, t3[6] = 0, t3[7] = 0, t3[8] = 0, t3[9] = 0, t3[11] = 0, t3[12] = 0, t3[13] = 0, t3[14] = 0), t3[0] = 1, t3[5] = 1, t3[10] = 1, t3[15] = 1, t3;
        }, t2.create$1 = co, t2.createExpression = Hn, t2.createLayout = Rs, t2.createStyleLayer = function(t3) {
          return "custom" === t3.type ? new ff(t3) : new gf[t3.type](t3);
        }, t2.cross = Lo, t2.degToRad = w, t2.distance = function(t3, e3) {
          return Math.hypot(e3[0] - t3[0], e3[1] - t3[1], e3[2] - t3[2]);
        }, t2.div = function(t3, e3, r3) {
          return t3[0] = e3[0] / r3[0], t3[1] = e3[1] / r3[1], t3[2] = e3[2] / r3[2], t3;
        }, t2.dot = Vo, t2.earthRadius = Ul, t2.ease = I, t2.easeCubicInOut = S, t2.ecefToLatLng = function([t3, e3, r3]) {
          const n3 = Math.hypot(t3, e3, r3), i3 = Math.atan2(t3, r3), s3 = 0.5 * Math.PI - Math.acos(-e3 / n3);
          return new Ol(_(i3), _(s3));
        }, t2.emitValidationErrors = qi, t2.endsWith = U, t2.enforceCacheSizeLimit = function(t3) {
          st(), rt && rt.then((e3) => {
            e3.keys().then((r3) => {
              for (let n3 = 0; n3 < r3.length - t3; n3++)
                e3.delete(r3[n3]);
            });
          });
        }, t2.evaluateSizeForFeature = jh, t2.evaluateSizeForZoom = Oh, t2.evaluateVariableOffset = xd, t2.evented = gs, t2.exactEquals = function(t3, e3) {
          return t3[0] === e3[0] && t3[1] === e3[1] && t3[2] === e3[2] && t3[3] === e3[3];
        }, t2.exactEquals$1 = function(t3, e3) {
          return t3[0] === e3[0] && t3[1] === e3[1] && t3[2] === e3[2];
        }, t2.exported = Xt, t2.exported$1 = s2, t2.extend = C, t2.extend$1 = ee, t2.fillExtrusionHeightLift = oh, t2.filterObject = j, t2.fromMat4 = function(t3, e3) {
          return t3[0] = e3[0], t3[1] = e3[1], t3[2] = e3[2], t3[3] = e3[4], t3[4] = e3[5], t3[5] = e3[6], t3[6] = e3[8], t3[7] = e3[9], t3[8] = e3[10], t3;
        }, t2.fromQuat = function(t3, e3) {
          var r3 = e3[0], n3 = e3[1], i3 = e3[2], s3 = e3[3], a3 = r3 + r3, o3 = n3 + n3, l2 = i3 + i3, u3 = r3 * a3, c3 = n3 * a3, h3 = n3 * o3, p3 = i3 * a3, d3 = i3 * o3, f3 = i3 * l2, y3 = s3 * a3, m3 = s3 * o3, g3 = s3 * l2;
          return t3[0] = 1 - h3 - f3, t3[1] = c3 + g3, t3[2] = p3 - m3, t3[3] = 0, t3[4] = c3 - g3, t3[5] = 1 - u3 - f3, t3[6] = d3 + y3, t3[7] = 0, t3[8] = p3 + m3, t3[9] = d3 - y3, t3[10] = 1 - u3 - h3, t3[11] = 0, t3[12] = 0, t3[13] = 0, t3[14] = 0, t3[15] = 1, t3;
        }, t2.fromRotation = function(t3, e3) {
          var r3 = Math.sin(e3), n3 = Math.cos(e3);
          return t3[0] = n3, t3[1] = r3, t3[2] = 0, t3[3] = -r3, t3[4] = n3, t3[5] = 0, t3[6] = 0, t3[7] = 0, t3[8] = 1, t3;
        }, t2.fromScaling = bo, t2.furthestTileCorner = function(t3) {
          const e3 = Math.round((t3 + 45 + 360) % 360 / 90) % 4;
          return A[e3];
        }, t2.getAABBPointSquareDist = function(t3, e3, r3) {
          let n3 = 0;
          for (let i3 = 0; i3 < 2; ++i3) {
            const s3 = r3 ? r3[i3] : 0;
            t3[i3] > s3 && (n3 += (t3[i3] - s3) * (t3[i3] - s3)), e3[i3] < s3 && (n3 += (s3 - e3[i3]) * (s3 - e3[i3]));
          }
          return n3;
        }, t2.getAnchorAlignment = Rp, t2.getAnchorJustification = bd, t2.getBounds = function(t3) {
          let e3 = 1 / 0, r3 = 1 / 0, n3 = -1 / 0, i3 = -1 / 0;
          for (const s3 of t3)
            e3 = Math.min(e3, s3.x), r3 = Math.min(r3, s3.y), n3 = Math.max(n3, s3.x), i3 = Math.max(i3, s3.y);
          return { min: new x2(e3, r3), max: new x2(n3, i3) };
        }, t2.getColumn = W, t2.getDefaultExportFromCjs = p2, t2.getGridMatrix = function(t3, e3, r3, n3) {
          const i3 = e3.getNorth(), s3 = e3.getSouth(), a3 = e3.getWest(), o3 = e3.getEast(), l2 = 1 << t3.z, u3 = o3 - a3, c3 = i3 - s3, h3 = u3 / ul, p3 = -c3 / cl[r3], d3 = [0, h3, 0, p3, 0, 0, i3, a3, 0];
          if (t3.z > 0) {
            const t4 = 180 / n3;
            ho(d3, d3, [t4 / u3 + 1, 0, 0, 0, t4 / c3 + 1, 0, -0.5 * t4 / h3, 0.5 * t4 / p3, 1]);
          }
          return d3[2] = l2, d3[5] = t3.x, d3[8] = t3.y, d3;
        }, t2.getImage = gt, t2.getJSON = function(t3, e3) {
          return ht(C(t3, { type: "json" }), e3);
        }, t2.getLatitudinalLod = function(t3) {
          const e3 = Hl - 5;
          t3 = M(t3, -e3, e3) / e3 * 90;
          const r3 = Math.pow(Math.abs(Math.sin(w(t3))), 3);
          return Math.round(r3 * (cl.length - 1));
        }, t2.getMapSessionAPI = Ft, t2.getPerformanceMeasurement = qt, t2.getProjection = Yd, t2.getRTLTextPluginStatus = xs, t2.getReferrer = ct, t2.getTilePoint = function(t3, { x: e3, y: r3 }, n3 = 0) {
          return new x2(((e3 - n3) * t3.scale - t3.x) * ao, (r3 * t3.scale - t3.y) * ao);
        }, t2.getTileVec3 = function(t3, e3, r3 = 0) {
          return Io(((e3.x - r3) * t3.scale - t3.x) * ao, (e3.y * t3.scale - t3.y) * ao, Jl(e3.z, e3.y));
        }, t2.getVideo = function(t3, r3) {
          const n3 = e2.document.createElement("video");
          n3.muted = true, n3.onloadstart = function() {
            r3(null, n3);
          };
          for (let r4 = 0; r4 < t3.length; r4++) {
            const i3 = e2.document.createElement("source");
            dt(t3[r4]) || (n3.crossOrigin = "Anonymous"), i3.src = t3[r4], n3.appendChild(i3);
          }
          return { cancel: () => {
          } };
        }, t2.globeCenterToScreenPoint = function(t3) {
          const e3 = [0, 0, 0], r3 = po(new Float64Array(16));
          return yo(r3, t3.pixelMatrix, t3.globeMatrix), Fo(e3, e3, r3), new x2(e3[0], e3[1]);
        }, t2.globeDenormalizeECEF = El, t2.globeECEFOrigin = function(t3, e3) {
          const r3 = [0, 0, 0];
          return Fo(r3, r3, Bl(xl(e3.canonical))), Fo(r3, r3, t3), r3;
        }, t2.globeMetersToEcef = fl, t2.globeNormalizeECEF = Bl, t2.globePixelsToTileUnits = function(t3, e3) {
          return ao / (512 * Math.pow(2, t3)) * Tl(xl(e3));
        }, t2.globePoleMatrixForTile = function(t3, e3, r3) {
          const n3 = po(new Float64Array(16)), i3 = (e3 / (1 << t3) - 0.5) * Math.PI * 2;
          return vo(n3, r3.globeMatrix, i3), Float32Array.from(n3);
        }, t2.globeTileBounds = xl, t2.globeTiltAtLngLat = Dl, t2.globeToMercatorTransition = Pl, t2.globeUseCustomAntiAliasing = function(t3, e3, r3) {
          const n3 = Pl(r3.zoom), i3 = t3.style.map._antialias, s3 = !!e3.extStandardDerivatives, a3 = e3.extStandardDerivativesForceOff || t3.terrain && t3.terrain.exaggeration() > 0;
          return 0 === n3 && !i3 && !a3 && s3;
        }, t2.identity = po, t2.identity$1 = Ko, t2.invert = fo, t2.isFullscreen = function() {
          return !!e2.document.fullscreenElement || !!e2.document.webkitFullscreenElement;
        }, t2.isLngLatBehindGlobe = Vl, t2.isMapAuthenticated = function(t3) {
          return Rt.has(t3);
        }, t2.isMapboxURL = vt, t2.isSafariWithAntialiasingBug = function(t3) {
          const e3 = t3.navigator ? t3.navigator.userAgent : null;
          return !!H(t3) && e3 && (e3.match("Version/15.4") || e3.match("Version/15.5") || e3.match(/CPU (OS|iPhone OS) (15_4|15_5) like Mac OS X/));
        }, t2.latFromMercatorY = Xl, t2.latLngToECEF = Il, t2.len = Oo, t2.length = ko, t2.length$1 = function(t3) {
          return Math.hypot(t3[0], t3[1], t3[2], t3[3]);
        }, t2.lngFromMercatorX = Kl, t2.loadVectorTile = yy, t2.makeRequest = ht, t2.mapValue = function(t3, e3, r3, n3, i3) {
          return M((t3 - e3) / (r3 - e3) * (i3 - n3) + n3, n3, i3);
        }, t2.mercatorScale = Yl, t2.mercatorXfromLng = Nl, t2.mercatorYfromLat = Gl, t2.mercatorZfromAltitude = Zl, t2.mul = _o, t2.mul$1 = jo, t2.multiply = yo, t2.multiply$1 = ho, t2.multiply$2 = zo, t2.nextPowerOfTwo = L, t2.normalize = Do, t2.normalize$1 = Ho, t2.normalize$2 = No, t2.number = Er, t2.ortho = function(t3, e3, r3, n3, i3, s3, a3) {
          var o3 = 1 / (e3 - r3), l2 = 1 / (n3 - i3), u3 = 1 / (s3 - a3);
          return t3[0] = -2 * o3, t3[1] = 0, t3[2] = 0, t3[3] = 0, t3[4] = 0, t3[5] = -2 * l2, t3[6] = 0, t3[7] = 0, t3[8] = 0, t3[9] = 0, t3[10] = 2 * u3, t3[11] = 0, t3[12] = (e3 + r3) * o3, t3[13] = (i3 + n3) * l2, t3[14] = (a3 + s3) * u3, t3[15] = 1, t3;
        }, t2.pbf = Xh, t2.perspective = function(t3, e3, r3, n3, i3) {
          var s3, a3 = 1 / Math.tan(e3 / 2);
          return t3[0] = a3 / r3, t3[1] = 0, t3[2] = 0, t3[3] = 0, t3[4] = 0, t3[5] = a3, t3[6] = 0, t3[7] = 0, t3[8] = 0, t3[9] = 0, t3[11] = -1, t3[12] = 0, t3[13] = 0, t3[15] = 0, null != i3 && i3 !== 1 / 0 ? (t3[10] = (i3 + n3) * (s3 = 1 / (n3 - i3)), t3[14] = 2 * i3 * n3 * s3) : (t3[10] = -1, t3[14] = -2 * n3), t3;
        }, t2.pick = function(t3, e3) {
          const r3 = {};
          for (let n3 = 0; n3 < e3.length; n3++) {
            const i3 = e3[n3];
            i3 in t3 && (r3[i3] = t3[i3]);
          }
          return r3;
        }, t2.plugin = bs, t2.pointGeometry = m2, t2.polesInViewport = function(t3) {
          const e3 = po(new Float64Array(16));
          yo(e3, t3.pixelMatrix, t3.globeMatrix);
          const r3 = [0, hl, 0], n3 = [0, pl, 0];
          return Fo(r3, r3, e3), Fo(n3, n3, e3), [r3[0] > 0 && r3[0] <= t3.width && r3[1] > 0 && r3[1] <= t3.height && !Vl(t3, new Ol(t3.center.lat, 90)), n3[0] > 0 && n3[0] <= t3.width && n3[1] > 0 && n3[1] <= t3.height && !Vl(t3, new Ol(t3.center.lat, -90))];
        }, t2.polygonContainsPoint = bu, t2.polygonIntersectsBox = wu, t2.polygonIntersectsPolygon = hu, t2.polygonizeBounds = function(t3, e3, r3 = 0, n3 = true) {
          const i3 = new x2(r3, r3), s3 = t3.sub(i3), a3 = e3.add(i3), o3 = [s3, new x2(a3.x, s3.y), a3, new x2(s3.x, a3.y)];
          return n3 && o3.push(s3.clone()), o3;
        }, t2.posAttributes = tl, t2.postMapLoadEvent = Pt, t2.postPerformanceEvent = Vt, t2.postTurnstileEvent = Et, t2.potpack = _p, t2.prevPowerOfTwo = function(t3) {
          return t3 <= 1 ? 1 : Math.pow(2, Math.floor(Math.log(t3) / Math.LN2));
        }, t2.radToDeg = _, t2.refProperties = ["type", "source", "source-layer", "minzoom", "maxzoom", "filter", "layout"], t2.registerForPluginStateChange = function(t3) {
          return t3({ pluginStatus: ds, pluginURL: fs }), gs.on("pluginStateChange", t3), t3;
        }, t2.removeAuthState = function(t3) {
          Rt.delete(t3);
        }, t2.renderColorRamp = ju, t2.resample = tu, t2.rotateX = xo, t2.rotateX$1 = Xo, t2.rotateY = vo, t2.rotateY$1 = Jo, t2.rotateZ = function(t3, e3, r3) {
          var n3 = Math.sin(r3), i3 = Math.cos(r3), s3 = e3[0], a3 = e3[1], o3 = e3[2], l2 = e3[3], u3 = e3[4], c3 = e3[5], h3 = e3[6], p3 = e3[7];
          return e3 !== t3 && (t3[8] = e3[8], t3[9] = e3[9], t3[10] = e3[10], t3[11] = e3[11], t3[12] = e3[12], t3[13] = e3[13], t3[14] = e3[14], t3[15] = e3[15]), t3[0] = s3 * i3 + u3 * n3, t3[1] = a3 * i3 + c3 * n3, t3[2] = o3 * i3 + h3 * n3, t3[3] = l2 * i3 + p3 * n3, t3[4] = u3 * i3 - s3 * n3, t3[5] = c3 * i3 - a3 * n3, t3[6] = h3 * i3 - o3 * n3, t3[7] = p3 * i3 - l2 * n3, t3;
        }, t2.rotateZ$1 = function(t3, e3, r3) {
          r3 *= 0.5;
          var n3 = e3[0], i3 = e3[1], s3 = e3[2], a3 = e3[3], o3 = Math.sin(r3), l2 = Math.cos(r3);
          return t3[0] = n3 * l2 + i3 * o3, t3[1] = i3 * l2 - n3 * o3, t3[2] = s3 * l2 + a3 * o3, t3[3] = a3 * l2 - s3 * o3, t3;
        }, t2.scale = go, t2.scale$1 = qo, t2.scale$2 = Co, t2.scaleAndAdd = Po, t2.set = function(t3, e3, r3, n3) {
          return t3[0] = e3, t3[1] = r3, t3[2] = n3, t3;
        }, t2.setCacheLimits = function(t3, e3) {
          tt = t3, et = e3;
        }, t2.setColumn = function(t3, e3, r3) {
          t3[4 * e3 + 0] = r3[0], t3[4 * e3 + 1] = r3[1], t3[4 * e3 + 2] = r3[2], t3[4 * e3 + 3] = r3[3];
        }, t2.setRTLTextPlugin = function(t3, e3, r3 = false) {
          if (ds === us || ds === cs || ds === hs)
            throw new Error("setRTLTextPlugin cannot be called multiple times.");
          fs = Xt.resolveURL(t3), ds = us, ps = e3, ms(), r3 || vs();
        }, t2.smoothstep = T, t2.spec = te, t2.squaredLength = function(t3) {
          var e3 = t3[0], r3 = t3[1], n3 = t3[2];
          return e3 * e3 + r3 * r3 + n3 * n3;
        }, t2.storeAuthState = function(t3, e3) {
          e3 ? Rt.add(t3) : Rt.delete(t3);
        }, t2.sub = $o, t2.subtract = To, t2.symbolSize = qh, t2.tileAABB = function(t3, e3, r3, n3, i3, s3, a3, o3, l2) {
          if ("globe" === l2.name)
            return _l(t3, e3, new ph(r3, n3, i3));
          const u3 = Bd({ z: r3, x: n3, y: i3 }, l2);
          return new il([(s3 + u3.x / u3.scale) * e3, e3 * (u3.y / u3.scale), a3], [(s3 + u3.x2 / u3.scale) * e3, e3 * (u3.y2 / u3.scale), o3]);
        }, t2.tileCornersToBounds = Al, t2.tileTransform = Bd, t2.transformMat3 = function(t3, e3, r3) {
          var n3 = e3[0], i3 = e3[1], s3 = e3[2];
          return t3[0] = n3 * r3[0] + i3 * r3[3] + s3 * r3[6], t3[1] = n3 * r3[1] + i3 * r3[4] + s3 * r3[7], t3[2] = n3 * r3[2] + i3 * r3[5] + s3 * r3[8], t3;
        }, t2.transformMat4 = Fo, t2.transformMat4$1 = Go, t2.transformQuat = Ro, t2.transitionTileAABBinECEF = bl, t2.translate = mo, t2.transpose = function(t3, e3) {
          if (t3 === e3) {
            var r3 = e3[1], n3 = e3[2], i3 = e3[5];
            t3[1] = e3[3], t3[2] = e3[6], t3[3] = r3, t3[5] = e3[7], t3[6] = n3, t3[7] = i3;
          } else
            t3[0] = e3[0], t3[1] = e3[3], t3[2] = e3[6], t3[3] = e3[1], t3[4] = e3[4], t3[5] = e3[7], t3[6] = e3[2], t3[7] = e3[5], t3[8] = e3[8];
          return t3;
        }, t2.triggerPluginCompletionEvent = ys, t2.uniqueId = D, t2.updateGlobeVertexNormal = function(t3, e3, r3, n3, i3) {
          const s3 = 5 * e3 + 2;
          t3.float32[s3 + 0] = r3, t3.float32[s3 + 1] = n3, t3.float32[s3 + 2] = i3;
        }, t2.validateCustomStyleLayer = function(t3) {
          const e3 = [], r3 = t3.id;
          return void 0 === r3 && e3.push({ message: `layers.${r3}: missing required property "id"` }), void 0 === t3.render && e3.push({ message: `layers.${r3}: missing required method "render"` }), t3.renderingMode && "2d" !== t3.renderingMode && "3d" !== t3.renderingMode && e3.push({ message: `layers.${r3}: property "renderingMode" must be either "2d" or "3d"` }), e3;
        }, t2.validateFilter = (t3) => Oi(Ai(t3)), t2.validateFog = (t3) => Oi(Vi(t3)), t2.validateLayer = (t3) => Oi(Ti(t3)), t2.validateLight = (t3) => Oi(Pi(t3)), t2.validateSource = (t3) => Oi(Ei(t3)), t2.validateStyle = Ui, t2.validateTerrain = (t3) => Oi(Di(t3)), t2.values = E2, t2.vectorTile = Dc, t2.version = r2, t2.warnOnce = N, t2.window = e2, t2.wrap = z;
      });
      define2(["./shared"], function(e2) {
        "use strict";
        function t2(e3) {
          if ("number" == typeof e3 || "boolean" == typeof e3 || "string" == typeof e3 || null == e3)
            return JSON.stringify(e3);
          if (Array.isArray(e3)) {
            let r4 = "[";
            for (const o3 of e3)
              r4 += `${t2(o3)},`;
            return `${r4}]`;
          }
          let r3 = "{";
          for (const o3 of Object.keys(e3).sort())
            r3 += `${o3}:${t2(e3[o3])},`;
          return `${r3}}`;
        }
        function r2(r3) {
          let o3 = "";
          for (const i3 of e2.refProperties)
            o3 += `/${t2(r3[i3])}`;
          return o3;
        }
        class o2 {
          constructor(e3) {
            this.keyCache = {}, e3 && this.replace(e3);
          }
          replace(e3) {
            this._layerConfigs = {}, this._layers = {}, this.update(e3, []);
          }
          update(t3, o3) {
            for (const r3 of t3)
              this._layerConfigs[r3.id] = r3, (this._layers[r3.id] = e2.createStyleLayer(r3)).compileFilter(), this.keyCache[r3.id] && delete this.keyCache[r3.id];
            for (const e3 of o3)
              delete this.keyCache[e3], delete this._layerConfigs[e3], delete this._layers[e3];
            this.familiesBySource = {};
            const i3 = function(e3, t4) {
              const o4 = {};
              for (let i5 = 0; i5 < e3.length; i5++) {
                const n3 = t4 && t4[e3[i5].id] || r2(e3[i5]);
                t4 && (t4[e3[i5].id] = n3);
                let s3 = o4[n3];
                s3 || (s3 = o4[n3] = []), s3.push(e3[i5]);
              }
              const i4 = [];
              for (const e4 in o4)
                i4.push(o4[e4]);
              return i4;
            }(e2.values(this._layerConfigs), this.keyCache);
            for (const e3 of i3) {
              const t4 = e3.map((e4) => this._layers[e4.id]), r3 = t4[0];
              if ("none" === r3.visibility)
                continue;
              const o4 = r3.source || "";
              let i4 = this.familiesBySource[o4];
              i4 || (i4 = this.familiesBySource[o4] = {});
              const n3 = r3.sourceLayer || "_geojsonTileLayer";
              let s3 = i4[n3];
              s3 || (s3 = i4[n3] = []), s3.push(t4);
            }
          }
        }
        class i2 {
          loadTile(t3, r3) {
            const { uid: o3, encoding: i3, rawImageData: n3, padding: s3, buildQuadTree: a3 } = t3, l2 = e2.window.ImageBitmap && n3 instanceof e2.window.ImageBitmap ? this.getImageData(n3, s3) : n3;
            r3(null, new e2.DEMData(o3, l2, i3, s3 < 1, a3));
          }
          getImageData(e3, t3) {
            this.offscreenCanvas && this.offscreenCanvasContext || (this.offscreenCanvas = new OffscreenCanvas(e3.width, e3.height), this.offscreenCanvasContext = this.offscreenCanvas.getContext("2d", { willReadFrequently: true })), this.offscreenCanvas.width = e3.width, this.offscreenCanvas.height = e3.height, this.offscreenCanvasContext.drawImage(e3, 0, 0, e3.width, e3.height);
            const r3 = this.offscreenCanvasContext.getImageData(-t3, -t3, e3.width + 2 * t3, e3.height + 2 * t3);
            return this.offscreenCanvasContext.clearRect(0, 0, this.offscreenCanvas.width, this.offscreenCanvas.height), r3;
          }
        }
        function n2(e3, t3) {
          if (0 !== e3.length) {
            s2(e3[0], t3);
            for (var r3 = 1; r3 < e3.length; r3++)
              s2(e3[r3], !t3);
          }
        }
        function s2(e3, t3) {
          for (var r3 = 0, o3 = 0, i3 = 0, n3 = e3.length, s3 = n3 - 1; i3 < n3; s3 = i3++) {
            var a3 = (e3[i3][0] - e3[s3][0]) * (e3[s3][1] + e3[i3][1]), l2 = r3 + a3;
            o3 += Math.abs(r3) >= Math.abs(a3) ? r3 - l2 + a3 : a3 - l2 + r3, r3 = l2;
          }
          r3 + o3 >= 0 != !!t3 && e3.reverse();
        }
        var a2 = e2.getDefaultExportFromCjs(function e3(t3, r3) {
          var o3, i3 = t3 && t3.type;
          if ("FeatureCollection" === i3)
            for (o3 = 0; o3 < t3.features.length; o3++)
              e3(t3.features[o3], r3);
          else if ("GeometryCollection" === i3)
            for (o3 = 0; o3 < t3.geometries.length; o3++)
              e3(t3.geometries[o3], r3);
          else if ("Feature" === i3)
            e3(t3.geometry, r3);
          else if ("Polygon" === i3)
            n2(t3.coordinates, r3);
          else if ("MultiPolygon" === i3)
            for (o3 = 0; o3 < t3.coordinates.length; o3++)
              n2(t3.coordinates[o3], r3);
          return t3;
        });
        const l = e2.VectorTileFeature.prototype.toGeoJSON;
        var u2 = { exports: {} }, h2 = e2.pointGeometry, c2 = e2.vectorTile.VectorTileFeature, f2 = p2;
        function p2(e3, t3) {
          this.options = t3 || {}, this.features = e3, this.length = e3.length;
        }
        function g2(e3, t3) {
          this.id = "number" == typeof e3.id ? e3.id : void 0, this.type = e3.type, this.rawGeometry = 1 === e3.type ? [e3.geometry] : e3.geometry, this.properties = e3.tags, this.extent = t3 || 4096;
        }
        p2.prototype.feature = function(e3) {
          return new g2(this.features[e3], this.options.extent);
        }, g2.prototype.loadGeometry = function() {
          var e3 = this.rawGeometry;
          this.geometry = [];
          for (var t3 = 0; t3 < e3.length; t3++) {
            for (var r3 = e3[t3], o3 = [], i3 = 0; i3 < r3.length; i3++)
              o3.push(new h2(r3[i3][0], r3[i3][1]));
            this.geometry.push(o3);
          }
          return this.geometry;
        }, g2.prototype.bbox = function() {
          this.geometry || this.loadGeometry();
          for (var e3 = this.geometry, t3 = 1 / 0, r3 = -1 / 0, o3 = 1 / 0, i3 = -1 / 0, n3 = 0; n3 < e3.length; n3++)
            for (var s3 = e3[n3], a3 = 0; a3 < s3.length; a3++) {
              var l2 = s3[a3];
              t3 = Math.min(t3, l2.x), r3 = Math.max(r3, l2.x), o3 = Math.min(o3, l2.y), i3 = Math.max(i3, l2.y);
            }
          return [t3, o3, r3, i3];
        }, g2.prototype.toGeoJSON = c2.prototype.toGeoJSON;
        var d2 = e2.pbf, m2 = f2;
        function y2(e3) {
          var t3 = new d2();
          return function(e4, t4) {
            for (var r3 in e4.layers)
              t4.writeMessage(3, v2, e4.layers[r3]);
          }(e3, t3), t3.finish();
        }
        function v2(e3, t3) {
          var r3;
          t3.writeVarintField(15, e3.version || 1), t3.writeStringField(1, e3.name || ""), t3.writeVarintField(5, e3.extent || 4096);
          var o3 = { keys: [], values: [], keycache: {}, valuecache: {} };
          for (r3 = 0; r3 < e3.length; r3++)
            o3.feature = e3.feature(r3), t3.writeMessage(2, x2, o3);
          var i3 = o3.keys;
          for (r3 = 0; r3 < i3.length; r3++)
            t3.writeStringField(3, i3[r3]);
          var n3 = o3.values;
          for (r3 = 0; r3 < n3.length; r3++)
            t3.writeMessage(4, b, n3[r3]);
        }
        function x2(e3, t3) {
          var r3 = e3.feature;
          void 0 !== r3.id && t3.writeVarintField(1, r3.id), t3.writeMessage(2, w, e3), t3.writeVarintField(3, r3.type), t3.writeMessage(4, P, r3);
        }
        function w(e3, t3) {
          var r3 = e3.feature, o3 = e3.keys, i3 = e3.values, n3 = e3.keycache, s3 = e3.valuecache;
          for (var a3 in r3.properties) {
            var l2 = r3.properties[a3], u3 = n3[a3];
            if (null !== l2) {
              void 0 === u3 && (o3.push(a3), n3[a3] = u3 = o3.length - 1), t3.writeVarint(u3);
              var h3 = typeof l2;
              "string" !== h3 && "boolean" !== h3 && "number" !== h3 && (l2 = JSON.stringify(l2));
              var c3 = h3 + ":" + l2, f3 = s3[c3];
              void 0 === f3 && (i3.push(l2), s3[c3] = f3 = i3.length - 1), t3.writeVarint(f3);
            }
          }
        }
        function S(e3, t3) {
          return (t3 << 3) + (7 & e3);
        }
        function M(e3) {
          return e3 << 1 ^ e3 >> 31;
        }
        function P(e3, t3) {
          for (var r3 = e3.loadGeometry(), o3 = e3.type, i3 = 0, n3 = 0, s3 = r3.length, a3 = 0; a3 < s3; a3++) {
            var l2 = r3[a3], u3 = 1;
            1 === o3 && (u3 = l2.length), t3.writeVarint(S(1, u3));
            for (var h3 = 3 === o3 ? l2.length - 1 : l2.length, c3 = 0; c3 < h3; c3++) {
              1 === c3 && 1 !== o3 && t3.writeVarint(S(2, h3 - 1));
              var f3 = l2[c3].x - i3, p3 = l2[c3].y - n3;
              t3.writeVarint(M(f3)), t3.writeVarint(M(p3)), i3 += f3, n3 += p3;
            }
            3 === o3 && t3.writeVarint(S(7, 1));
          }
        }
        function b(e3, t3) {
          var r3 = typeof e3;
          "string" === r3 ? t3.writeStringField(1, e3) : "boolean" === r3 ? t3.writeBooleanField(7, e3) : "number" === r3 && (e3 % 1 != 0 ? t3.writeDoubleField(3, e3) : e3 < 0 ? t3.writeSVarintField(6, e3) : t3.writeVarintField(5, e3));
        }
        u2.exports = y2, u2.exports.fromVectorTileJs = y2, u2.exports.fromGeojsonVt = function(e3, t3) {
          t3 = t3 || {};
          var r3 = {};
          for (var o3 in e3)
            r3[o3] = new m2(e3[o3].features, t3), r3[o3].name = o3, r3[o3].version = t3.version, r3[o3].extent = t3.extent;
          return y2({ layers: r3 });
        }, u2.exports.GeoJSONWrapper = m2;
        var T = e2.getDefaultExportFromCjs(u2.exports);
        const k = { minZoom: 0, maxZoom: 16, minPoints: 2, radius: 40, extent: 512, nodeSize: 64, log: false, generateId: false, reduce: null, map: (e3) => e3 }, I = Math.fround || (_ = new Float32Array(1), (e3) => (_[0] = +e3, _[0]));
        var _;
        const C = 3, L = 5, O = 6;
        class E2 {
          constructor(e3) {
            this.options = Object.assign(Object.create(k), e3), this.trees = new Array(this.options.maxZoom + 1), this.stride = this.options.reduce ? 7 : 6, this.clusterProps = [];
          }
          load(e3) {
            const { log: t3, minZoom: r3, maxZoom: o3 } = this.options;
            t3 && console.time("total time");
            const i3 = `prepare ${e3.length} points`;
            t3 && console.time(i3), this.points = e3;
            const n3 = [];
            for (let t4 = 0; t4 < e3.length; t4++) {
              const r4 = e3[t4];
              if (!r4.geometry)
                continue;
              const [o4, i4] = r4.geometry.coordinates, s4 = I(N(o4)), a3 = I(Z(i4));
              n3.push(s4, a3, 1 / 0, t4, -1, 1), this.options.reduce && n3.push(0);
            }
            let s3 = this.trees[o3 + 1] = this._createTree(n3);
            t3 && console.timeEnd(i3);
            for (let e4 = o3; e4 >= r3; e4--) {
              const r4 = +Date.now();
              s3 = this.trees[e4] = this._createTree(this._cluster(s3, e4)), t3 && console.log("z%d: %d clusters in %dms", e4, s3.numItems, +Date.now() - r4);
            }
            return t3 && console.timeEnd("total time"), this;
          }
          getClusters(e3, t3) {
            let r3 = ((e3[0] + 180) % 360 + 360) % 360 - 180;
            const o3 = Math.max(-90, Math.min(90, e3[1]));
            let i3 = 180 === e3[2] ? 180 : ((e3[2] + 180) % 360 + 360) % 360 - 180;
            const n3 = Math.max(-90, Math.min(90, e3[3]));
            if (e3[2] - e3[0] >= 360)
              r3 = -180, i3 = 180;
            else if (r3 > i3) {
              const e4 = this.getClusters([r3, o3, 180, n3], t3), s4 = this.getClusters([-180, o3, i3, n3], t3);
              return e4.concat(s4);
            }
            const s3 = this.trees[this._limitZoom(t3)], a3 = s3.range(N(r3), Z(n3), N(i3), Z(o3)), l2 = s3.data, u3 = [];
            for (const e4 of a3) {
              const t4 = this.stride * e4;
              u3.push(l2[t4 + L] > 1 ? j(l2, t4, this.clusterProps) : this.points[l2[t4 + C]]);
            }
            return u3;
          }
          getChildren(e3) {
            const t3 = this._getOriginId(e3), r3 = this._getOriginZoom(e3), o3 = "No cluster with the specified id.", i3 = this.trees[r3];
            if (!i3)
              throw new Error(o3);
            const n3 = i3.data;
            if (t3 * this.stride >= n3.length)
              throw new Error(o3);
            const s3 = this.options.radius / (this.options.extent * Math.pow(2, r3 - 1)), a3 = i3.within(n3[t3 * this.stride], n3[t3 * this.stride + 1], s3), l2 = [];
            for (const t4 of a3) {
              const r4 = t4 * this.stride;
              n3[r4 + 4] === e3 && l2.push(n3[r4 + L] > 1 ? j(n3, r4, this.clusterProps) : this.points[n3[r4 + C]]);
            }
            if (0 === l2.length)
              throw new Error(o3);
            return l2;
          }
          getLeaves(e3, t3, r3) {
            const o3 = [];
            return this._appendLeaves(o3, e3, t3 = t3 || 10, r3 = r3 || 0, 0), o3;
          }
          getTile(e3, t3, r3) {
            const o3 = this.trees[this._limitZoom(e3)], i3 = Math.pow(2, e3), { extent: n3, radius: s3 } = this.options, a3 = s3 / n3, l2 = (r3 - a3) / i3, u3 = (r3 + 1 + a3) / i3, h3 = { features: [] };
            return this._addTileFeatures(o3.range((t3 - a3) / i3, l2, (t3 + 1 + a3) / i3, u3), o3.data, t3, r3, i3, h3), 0 === t3 && this._addTileFeatures(o3.range(1 - a3 / i3, l2, 1, u3), o3.data, i3, r3, i3, h3), t3 === i3 - 1 && this._addTileFeatures(o3.range(0, l2, a3 / i3, u3), o3.data, -1, r3, i3, h3), h3.features.length ? h3 : null;
          }
          getClusterExpansionZoom(e3) {
            let t3 = this._getOriginZoom(e3) - 1;
            for (; t3 <= this.options.maxZoom; ) {
              const r3 = this.getChildren(e3);
              if (t3++, 1 !== r3.length)
                break;
              e3 = r3[0].properties.cluster_id;
            }
            return t3;
          }
          _appendLeaves(e3, t3, r3, o3, i3) {
            const n3 = this.getChildren(t3);
            for (const t4 of n3) {
              const n4 = t4.properties;
              if (n4 && n4.cluster ? i3 + n4.point_count <= o3 ? i3 += n4.point_count : i3 = this._appendLeaves(e3, n4.cluster_id, r3, o3, i3) : i3 < o3 ? i3++ : e3.push(t4), e3.length === r3)
                break;
            }
            return i3;
          }
          _createTree(t3) {
            const r3 = new e2.KDBush(t3.length / this.stride | 0, this.options.nodeSize, Float32Array);
            for (let e3 = 0; e3 < t3.length; e3 += this.stride)
              r3.add(t3[e3], t3[e3 + 1]);
            return r3.finish(), r3.data = t3, r3;
          }
          _addTileFeatures(e3, t3, r3, o3, i3, n3) {
            for (const s3 of e3) {
              const e4 = s3 * this.stride, a3 = t3[e4 + L] > 1;
              let l2, u3, h3;
              if (a3)
                l2 = F(t3, e4, this.clusterProps), u3 = t3[e4], h3 = t3[e4 + 1];
              else {
                const r4 = this.points[t3[e4 + C]];
                l2 = r4.properties;
                const [o4, i4] = r4.geometry.coordinates;
                u3 = N(o4), h3 = Z(i4);
              }
              const c3 = { type: 1, geometry: [[Math.round(this.options.extent * (u3 * i3 - r3)), Math.round(this.options.extent * (h3 * i3 - o3))]], tags: l2 };
              let f3;
              f3 = a3 || this.options.generateId ? t3[e4 + C] : this.points[t3[e4 + C]].id, void 0 !== f3 && (c3.id = f3), n3.features.push(c3);
            }
          }
          _limitZoom(e3) {
            return Math.max(this.options.minZoom, Math.min(Math.floor(+e3), this.options.maxZoom + 1));
          }
          _cluster(e3, t3) {
            const { radius: r3, extent: o3, reduce: i3, minPoints: n3 } = this.options, s3 = r3 / (o3 * Math.pow(2, t3)), a3 = e3.data, l2 = [], u3 = this.stride;
            for (let r4 = 0; r4 < a3.length; r4 += u3) {
              if (a3[r4 + 2] <= t3)
                continue;
              a3[r4 + 2] = t3;
              const o4 = a3[r4], h3 = a3[r4 + 1], c3 = e3.within(a3[r4], a3[r4 + 1], s3), f3 = a3[r4 + L];
              let p3 = f3;
              for (const e4 of c3) {
                const r5 = e4 * u3;
                a3[r5 + 2] > t3 && (p3 += a3[r5 + L]);
              }
              if (p3 > f3 && p3 >= n3) {
                let e4, n4 = o4 * f3, s4 = h3 * f3, g3 = -1;
                const d3 = ((r4 / u3 | 0) << 5) + (t3 + 1) + this.points.length;
                for (const o5 of c3) {
                  const l3 = o5 * u3;
                  if (a3[l3 + 2] <= t3)
                    continue;
                  a3[l3 + 2] = t3;
                  const h4 = a3[l3 + L];
                  n4 += a3[l3] * h4, s4 += a3[l3 + 1] * h4, a3[l3 + 4] = d3, i3 && (e4 || (e4 = this._map(a3, r4, true), g3 = this.clusterProps.length, this.clusterProps.push(e4)), i3(e4, this._map(a3, l3)));
                }
                a3[r4 + 4] = d3, l2.push(n4 / p3, s4 / p3, 1 / 0, d3, -1, p3), i3 && l2.push(g3);
              } else {
                for (let e4 = 0; e4 < u3; e4++)
                  l2.push(a3[r4 + e4]);
                if (p3 > 1)
                  for (const e4 of c3) {
                    const r5 = e4 * u3;
                    if (!(a3[r5 + 2] <= t3)) {
                      a3[r5 + 2] = t3;
                      for (let e5 = 0; e5 < u3; e5++)
                        l2.push(a3[r5 + e5]);
                    }
                  }
              }
            }
            return l2;
          }
          _getOriginId(e3) {
            return e3 - this.points.length >> 5;
          }
          _getOriginZoom(e3) {
            return (e3 - this.points.length) % 32;
          }
          _map(e3, t3, r3) {
            if (e3[t3 + L] > 1) {
              const o4 = this.clusterProps[e3[t3 + O]];
              return r3 ? Object.assign({}, o4) : o4;
            }
            const o3 = this.points[e3[t3 + C]].properties, i3 = this.options.map(o3);
            return r3 && i3 === o3 ? Object.assign({}, i3) : i3;
          }
        }
        function j(e3, t3, r3) {
          return { type: "Feature", id: e3[t3 + C], properties: F(e3, t3, r3), geometry: { type: "Point", coordinates: [(o3 = e3[t3], 360 * (o3 - 0.5)), J(e3[t3 + 1])] } };
          var o3;
        }
        function F(e3, t3, r3) {
          const o3 = e3[t3 + L], i3 = o3 >= 1e4 ? `${Math.round(o3 / 1e3)}k` : o3 >= 1e3 ? Math.round(o3 / 100) / 10 + "k" : o3, n3 = e3[t3 + O], s3 = -1 === n3 ? {} : Object.assign({}, r3[n3]);
          return Object.assign(s3, { cluster: true, cluster_id: e3[t3 + C], point_count: o3, point_count_abbreviated: i3 });
        }
        function N(e3) {
          return e3 / 360 + 0.5;
        }
        function Z(e3) {
          const t3 = Math.sin(e3 * Math.PI / 180), r3 = 0.5 - 0.25 * Math.log((1 + t3) / (1 - t3)) / Math.PI;
          return r3 < 0 ? 0 : r3 > 1 ? 1 : r3;
        }
        function J(e3) {
          const t3 = (180 - 360 * e3) * Math.PI / 180;
          return 360 * Math.atan(Math.exp(t3)) / Math.PI - 90;
        }
        function z(e3, t3, r3, o3) {
          for (var i3, n3 = o3, s3 = r3 - t3 >> 1, a3 = r3 - t3, l2 = e3[t3], u3 = e3[t3 + 1], h3 = e3[r3], c3 = e3[r3 + 1], f3 = t3 + 3; f3 < r3; f3 += 3) {
            var p3 = G(e3[f3], e3[f3 + 1], l2, u3, h3, c3);
            if (p3 > n3)
              i3 = f3, n3 = p3;
            else if (p3 === n3) {
              var g3 = Math.abs(f3 - s3);
              g3 < a3 && (i3 = f3, a3 = g3);
            }
          }
          n3 > o3 && (i3 - t3 > 3 && z(e3, t3, i3, o3), e3[i3 + 2] = n3, r3 - i3 > 3 && z(e3, i3, r3, o3));
        }
        function G(e3, t3, r3, o3, i3, n3) {
          var s3 = i3 - r3, a3 = n3 - o3;
          if (0 !== s3 || 0 !== a3) {
            var l2 = ((e3 - r3) * s3 + (t3 - o3) * a3) / (s3 * s3 + a3 * a3);
            l2 > 1 ? (r3 = i3, o3 = n3) : l2 > 0 && (r3 += s3 * l2, o3 += a3 * l2);
          }
          return (s3 = e3 - r3) * s3 + (a3 = t3 - o3) * a3;
        }
        function W(e3, t3, r3, o3) {
          var i3 = { id: void 0 === e3 ? null : e3, type: t3, geometry: r3, tags: o3, minX: 1 / 0, minY: 1 / 0, maxX: -1 / 0, maxY: -1 / 0 };
          return function(e4) {
            var t4 = e4.geometry, r4 = e4.type;
            if ("Point" === r4 || "MultiPoint" === r4 || "LineString" === r4)
              Y(e4, t4);
            else if ("Polygon" === r4 || "MultiLineString" === r4)
              for (var o4 = 0; o4 < t4.length; o4++)
                Y(e4, t4[o4]);
            else if ("MultiPolygon" === r4)
              for (o4 = 0; o4 < t4.length; o4++)
                for (var i4 = 0; i4 < t4[o4].length; i4++)
                  Y(e4, t4[o4][i4]);
          }(i3), i3;
        }
        function Y(e3, t3) {
          for (var r3 = 0; r3 < t3.length; r3 += 3)
            e3.minX = Math.min(e3.minX, t3[r3]), e3.minY = Math.min(e3.minY, t3[r3 + 1]), e3.maxX = Math.max(e3.maxX, t3[r3]), e3.maxY = Math.max(e3.maxY, t3[r3 + 1]);
        }
        function X(e3, t3, r3, o3) {
          if (t3.geometry) {
            var i3 = t3.geometry.coordinates, n3 = t3.geometry.type, s3 = Math.pow(r3.tolerance / ((1 << r3.maxZoom) * r3.extent), 2), a3 = [], l2 = t3.id;
            if (r3.promoteId ? l2 = t3.properties[r3.promoteId] : r3.generateId && (l2 = o3 || 0), "Point" === n3)
              V(i3, a3);
            else if ("MultiPoint" === n3)
              for (var u3 = 0; u3 < i3.length; u3++)
                V(i3[u3], a3);
            else if ("LineString" === n3)
              D(i3, a3, s3, false);
            else if ("MultiLineString" === n3) {
              if (r3.lineMetrics) {
                for (u3 = 0; u3 < i3.length; u3++)
                  D(i3[u3], a3 = [], s3, false), e3.push(W(l2, "LineString", a3, t3.properties));
                return;
              }
              $(i3, a3, s3, false);
            } else if ("Polygon" === n3)
              $(i3, a3, s3, true);
            else {
              if ("MultiPolygon" !== n3) {
                if ("GeometryCollection" === n3) {
                  for (u3 = 0; u3 < t3.geometry.geometries.length; u3++)
                    X(e3, { id: l2, geometry: t3.geometry.geometries[u3], properties: t3.properties }, r3, o3);
                  return;
                }
                throw new Error("Input data is not a valid GeoJSON object.");
              }
              for (u3 = 0; u3 < i3.length; u3++) {
                var h3 = [];
                $(i3[u3], h3, s3, true), a3.push(h3);
              }
            }
            e3.push(W(l2, n3, a3, t3.properties));
          }
        }
        function V(e3, t3) {
          t3.push(A(e3[0])), t3.push(B(e3[1])), t3.push(0);
        }
        function D(e3, t3, r3, o3) {
          for (var i3, n3, s3 = 0, a3 = 0; a3 < e3.length; a3++) {
            var l2 = A(e3[a3][0]), u3 = B(e3[a3][1]);
            t3.push(l2), t3.push(u3), t3.push(0), a3 > 0 && (s3 += o3 ? (i3 * u3 - l2 * n3) / 2 : Math.sqrt(Math.pow(l2 - i3, 2) + Math.pow(u3 - n3, 2))), i3 = l2, n3 = u3;
          }
          var h3 = t3.length - 3;
          t3[2] = 1, z(t3, 0, h3, r3), t3[h3 + 2] = 1, t3.size = Math.abs(s3), t3.start = 0, t3.end = t3.size;
        }
        function $(e3, t3, r3, o3) {
          for (var i3 = 0; i3 < e3.length; i3++) {
            var n3 = [];
            D(e3[i3], n3, r3, o3), t3.push(n3);
          }
        }
        function A(e3) {
          return e3 / 360 + 0.5;
        }
        function B(e3) {
          var t3 = Math.sin(e3 * Math.PI / 180), r3 = 0.5 - 0.25 * Math.log((1 + t3) / (1 - t3)) / Math.PI;
          return r3 < 0 ? 0 : r3 > 1 ? 1 : r3;
        }
        function R(e3, t3, r3, o3, i3, n3, s3, a3) {
          if (o3 /= t3, n3 >= (r3 /= t3) && s3 < o3)
            return e3;
          if (s3 < r3 || n3 >= o3)
            return null;
          for (var l2 = [], u3 = 0; u3 < e3.length; u3++) {
            var h3 = e3[u3], c3 = h3.geometry, f3 = h3.type, p3 = 0 === i3 ? h3.minX : h3.minY, g3 = 0 === i3 ? h3.maxX : h3.maxY;
            if (p3 >= r3 && g3 < o3)
              l2.push(h3);
            else if (!(g3 < r3 || p3 >= o3)) {
              var d3 = [];
              if ("Point" === f3 || "MultiPoint" === f3)
                q(c3, d3, r3, o3, i3);
              else if ("LineString" === f3)
                Q(c3, d3, r3, o3, i3, false, a3.lineMetrics);
              else if ("MultiLineString" === f3)
                K(c3, d3, r3, o3, i3, false);
              else if ("Polygon" === f3)
                K(c3, d3, r3, o3, i3, true);
              else if ("MultiPolygon" === f3)
                for (var m3 = 0; m3 < c3.length; m3++) {
                  var y3 = [];
                  K(c3[m3], y3, r3, o3, i3, true), y3.length && d3.push(y3);
                }
              if (d3.length) {
                if (a3.lineMetrics && "LineString" === f3) {
                  for (m3 = 0; m3 < d3.length; m3++)
                    l2.push(W(h3.id, f3, d3[m3], h3.tags));
                  continue;
                }
                "LineString" !== f3 && "MultiLineString" !== f3 || (1 === d3.length ? (f3 = "LineString", d3 = d3[0]) : f3 = "MultiLineString"), "Point" !== f3 && "MultiPoint" !== f3 || (f3 = 3 === d3.length ? "Point" : "MultiPoint"), l2.push(W(h3.id, f3, d3, h3.tags));
              }
            }
          }
          return l2.length ? l2 : null;
        }
        function q(e3, t3, r3, o3, i3) {
          for (var n3 = 0; n3 < e3.length; n3 += 3) {
            var s3 = e3[n3 + i3];
            s3 >= r3 && s3 <= o3 && (t3.push(e3[n3]), t3.push(e3[n3 + 1]), t3.push(e3[n3 + 2]));
          }
        }
        function Q(e3, t3, r3, o3, i3, n3, s3) {
          for (var a3, l2, u3 = U(e3), h3 = 0 === i3 ? ee : te, c3 = e3.start, f3 = 0; f3 < e3.length - 3; f3 += 3) {
            var p3 = e3[f3], g3 = e3[f3 + 1], d3 = e3[f3 + 2], m3 = e3[f3 + 3], y3 = e3[f3 + 4], v3 = 0 === i3 ? p3 : g3, x3 = 0 === i3 ? m3 : y3, w2 = false;
            s3 && (a3 = Math.sqrt(Math.pow(p3 - m3, 2) + Math.pow(g3 - y3, 2))), v3 < r3 ? x3 > r3 && (l2 = h3(u3, p3, g3, m3, y3, r3), s3 && (u3.start = c3 + a3 * l2)) : v3 > o3 ? x3 < o3 && (l2 = h3(u3, p3, g3, m3, y3, o3), s3 && (u3.start = c3 + a3 * l2)) : H(u3, p3, g3, d3), x3 < r3 && v3 >= r3 && (l2 = h3(u3, p3, g3, m3, y3, r3), w2 = true), x3 > o3 && v3 <= o3 && (l2 = h3(u3, p3, g3, m3, y3, o3), w2 = true), !n3 && w2 && (s3 && (u3.end = c3 + a3 * l2), t3.push(u3), u3 = U(e3)), s3 && (c3 += a3);
          }
          var S2 = e3.length - 3;
          p3 = e3[S2], g3 = e3[S2 + 1], d3 = e3[S2 + 2], (v3 = 0 === i3 ? p3 : g3) >= r3 && v3 <= o3 && H(u3, p3, g3, d3), S2 = u3.length - 3, n3 && S2 >= 3 && (u3[S2] !== u3[0] || u3[S2 + 1] !== u3[1]) && H(u3, u3[0], u3[1], u3[2]), u3.length && t3.push(u3);
        }
        function U(e3) {
          var t3 = [];
          return t3.size = e3.size, t3.start = e3.start, t3.end = e3.end, t3;
        }
        function K(e3, t3, r3, o3, i3, n3) {
          for (var s3 = 0; s3 < e3.length; s3++)
            Q(e3[s3], t3, r3, o3, i3, n3, false);
        }
        function H(e3, t3, r3, o3) {
          e3.push(t3), e3.push(r3), e3.push(o3);
        }
        function ee(e3, t3, r3, o3, i3, n3) {
          var s3 = (n3 - t3) / (o3 - t3);
          return e3.push(n3), e3.push(r3 + (i3 - r3) * s3), e3.push(1), s3;
        }
        function te(e3, t3, r3, o3, i3, n3) {
          var s3 = (n3 - r3) / (i3 - r3);
          return e3.push(t3 + (o3 - t3) * s3), e3.push(n3), e3.push(1), s3;
        }
        function re(e3, t3) {
          for (var r3 = [], o3 = 0; o3 < e3.length; o3++) {
            var i3, n3 = e3[o3], s3 = n3.type;
            if ("Point" === s3 || "MultiPoint" === s3 || "LineString" === s3)
              i3 = oe(n3.geometry, t3);
            else if ("MultiLineString" === s3 || "Polygon" === s3) {
              i3 = [];
              for (var a3 = 0; a3 < n3.geometry.length; a3++)
                i3.push(oe(n3.geometry[a3], t3));
            } else if ("MultiPolygon" === s3)
              for (i3 = [], a3 = 0; a3 < n3.geometry.length; a3++) {
                for (var l2 = [], u3 = 0; u3 < n3.geometry[a3].length; u3++)
                  l2.push(oe(n3.geometry[a3][u3], t3));
                i3.push(l2);
              }
            r3.push(W(n3.id, s3, i3, n3.tags));
          }
          return r3;
        }
        function oe(e3, t3) {
          var r3 = [];
          r3.size = e3.size, void 0 !== e3.start && (r3.start = e3.start, r3.end = e3.end);
          for (var o3 = 0; o3 < e3.length; o3 += 3)
            r3.push(e3[o3] + t3, e3[o3 + 1], e3[o3 + 2]);
          return r3;
        }
        function ie(e3, t3) {
          if (e3.transformed)
            return e3;
          var r3, o3, i3, n3 = 1 << e3.z, s3 = e3.x, a3 = e3.y;
          for (r3 = 0; r3 < e3.features.length; r3++) {
            var l2 = e3.features[r3], u3 = l2.geometry, h3 = l2.type;
            if (l2.geometry = [], 1 === h3)
              for (o3 = 0; o3 < u3.length; o3 += 2)
                l2.geometry.push(ne(u3[o3], u3[o3 + 1], t3, n3, s3, a3));
            else
              for (o3 = 0; o3 < u3.length; o3++) {
                var c3 = [];
                for (i3 = 0; i3 < u3[o3].length; i3 += 2)
                  c3.push(ne(u3[o3][i3], u3[o3][i3 + 1], t3, n3, s3, a3));
                l2.geometry.push(c3);
              }
          }
          return e3.transformed = true, e3;
        }
        function ne(e3, t3, r3, o3, i3, n3) {
          return [Math.round(r3 * (e3 * o3 - i3)), Math.round(r3 * (t3 * o3 - n3))];
        }
        function se(e3, t3, r3, o3, i3) {
          for (var n3 = t3 === i3.maxZoom ? 0 : i3.tolerance / ((1 << t3) * i3.extent), s3 = { features: [], numPoints: 0, numSimplified: 0, numFeatures: 0, source: null, x: r3, y: o3, z: t3, transformed: false, minX: 2, minY: 1, maxX: -1, maxY: 0 }, a3 = 0; a3 < e3.length; a3++) {
            s3.numFeatures++, ae(s3, e3[a3], n3, i3);
            var l2 = e3[a3].minX, u3 = e3[a3].minY, h3 = e3[a3].maxX, c3 = e3[a3].maxY;
            l2 < s3.minX && (s3.minX = l2), u3 < s3.minY && (s3.minY = u3), h3 > s3.maxX && (s3.maxX = h3), c3 > s3.maxY && (s3.maxY = c3);
          }
          return s3;
        }
        function ae(e3, t3, r3, o3) {
          var i3 = t3.geometry, n3 = t3.type, s3 = [];
          if ("Point" === n3 || "MultiPoint" === n3)
            for (var a3 = 0; a3 < i3.length; a3 += 3)
              s3.push(i3[a3]), s3.push(i3[a3 + 1]), e3.numPoints++, e3.numSimplified++;
          else if ("LineString" === n3)
            le(s3, i3, e3, r3, false, false);
          else if ("MultiLineString" === n3 || "Polygon" === n3)
            for (a3 = 0; a3 < i3.length; a3++)
              le(s3, i3[a3], e3, r3, "Polygon" === n3, 0 === a3);
          else if ("MultiPolygon" === n3)
            for (var l2 = 0; l2 < i3.length; l2++) {
              var u3 = i3[l2];
              for (a3 = 0; a3 < u3.length; a3++)
                le(s3, u3[a3], e3, r3, true, 0 === a3);
            }
          if (s3.length) {
            var h3 = t3.tags || null;
            if ("LineString" === n3 && o3.lineMetrics) {
              for (var c3 in h3 = {}, t3.tags)
                h3[c3] = t3.tags[c3];
              h3.mapbox_clip_start = i3.start / i3.size, h3.mapbox_clip_end = i3.end / i3.size;
            }
            var f3 = { geometry: s3, type: "Polygon" === n3 || "MultiPolygon" === n3 ? 3 : "LineString" === n3 || "MultiLineString" === n3 ? 2 : 1, tags: h3 };
            null !== t3.id && (f3.id = t3.id), e3.features.push(f3);
          }
        }
        function le(e3, t3, r3, o3, i3, n3) {
          var s3 = o3 * o3;
          if (o3 > 0 && t3.size < (i3 ? s3 : o3))
            r3.numPoints += t3.length / 3;
          else {
            for (var a3 = [], l2 = 0; l2 < t3.length; l2 += 3)
              (0 === o3 || t3[l2 + 2] > s3) && (r3.numSimplified++, a3.push(t3[l2]), a3.push(t3[l2 + 1])), r3.numPoints++;
            i3 && function(e4, t4) {
              for (var r4 = 0, o4 = 0, i4 = e4.length, n4 = i4 - 2; o4 < i4; n4 = o4, o4 += 2)
                r4 += (e4[o4] - e4[n4]) * (e4[o4 + 1] + e4[n4 + 1]);
              if (r4 > 0 === t4)
                for (o4 = 0, i4 = e4.length; o4 < i4 / 2; o4 += 2) {
                  var s4 = e4[o4], a4 = e4[o4 + 1];
                  e4[o4] = e4[i4 - 2 - o4], e4[o4 + 1] = e4[i4 - 1 - o4], e4[i4 - 2 - o4] = s4, e4[i4 - 1 - o4] = a4;
                }
            }(a3, n3), e3.push(a3);
          }
        }
        function ue(e3, t3) {
          var r3 = (t3 = this.options = function(e4, t4) {
            for (var r4 in t4)
              e4[r4] = t4[r4];
            return e4;
          }(Object.create(this.options), t3)).debug;
          if (r3 && console.time("preprocess data"), t3.maxZoom < 0 || t3.maxZoom > 24)
            throw new Error("maxZoom should be in the 0-24 range");
          if (t3.promoteId && t3.generateId)
            throw new Error("promoteId and generateId cannot be used together.");
          var o3 = function(e4, t4) {
            var r4 = [];
            if ("FeatureCollection" === e4.type)
              for (var o4 = 0; o4 < e4.features.length; o4++)
                X(r4, e4.features[o4], t4, o4);
            else
              X(r4, "Feature" === e4.type ? e4 : { geometry: e4 }, t4);
            return r4;
          }(e3, t3);
          this.tiles = {}, this.tileCoords = [], r3 && (console.timeEnd("preprocess data"), console.log("index: maxZoom: %d, maxPoints: %d", t3.indexMaxZoom, t3.indexMaxPoints), console.time("generate tiles"), this.stats = {}, this.total = 0), o3 = function(e4, t4) {
            var r4 = t4.buffer / t4.extent, o4 = e4, i3 = R(e4, 1, -1 - r4, r4, 0, -1, 2, t4), n3 = R(e4, 1, 1 - r4, 2 + r4, 0, -1, 2, t4);
            return (i3 || n3) && (o4 = R(e4, 1, -r4, 1 + r4, 0, -1, 2, t4) || [], i3 && (o4 = re(i3, 1).concat(o4)), n3 && (o4 = o4.concat(re(n3, -1)))), o4;
          }(o3, t3), o3.length && this.splitTile(o3, 0, 0, 0), r3 && (o3.length && console.log("features: %d, points: %d", this.tiles[0].numFeatures, this.tiles[0].numPoints), console.timeEnd("generate tiles"), console.log("tiles generated:", this.total, JSON.stringify(this.stats)));
        }
        function he(e3, t3, r3) {
          return 32 * ((1 << e3) * r3 + t3) + e3;
        }
        function ce(t3, r3) {
          const o3 = t3.tileID.canonical;
          if (!this._geoJSONIndex)
            return r3(null, null);
          const i3 = this._geoJSONIndex.getTile(o3.z, o3.x, o3.y);
          if (!i3)
            return r3(null, null);
          const n3 = new class {
            constructor(t4) {
              this.layers = { _geojsonTileLayer: this }, this.name = "_geojsonTileLayer", this.extent = e2.EXTENT, this.length = t4.length, this._features = t4;
            }
            feature(t4) {
              return new class {
                constructor(t5) {
                  this._feature = t5, this.extent = e2.EXTENT, this.type = t5.type, this.properties = t5.tags, "id" in t5 && !isNaN(t5.id) && (this.id = parseInt(t5.id, 10));
                }
                loadGeometry() {
                  if (1 === this._feature.type) {
                    const t5 = [];
                    for (const r4 of this._feature.geometry)
                      t5.push([new e2.Point(r4[0], r4[1])]);
                    return t5;
                  }
                  {
                    const t5 = [];
                    for (const r4 of this._feature.geometry) {
                      const o4 = [];
                      for (const t6 of r4)
                        o4.push(new e2.Point(t6[0], t6[1]));
                      t5.push(o4);
                    }
                    return t5;
                  }
                }
                toGeoJSON(e3, t5, r4) {
                  return l.call(this, e3, t5, r4);
                }
              }(this._features[t4]);
            }
          }(i3.features);
          let s3 = T(n3);
          0 === s3.byteOffset && s3.byteLength === s3.buffer.byteLength || (s3 = new Uint8Array(s3)), r3(null, { vectorTile: n3, rawData: s3.buffer });
        }
        ue.prototype.options = { maxZoom: 14, indexMaxZoom: 5, indexMaxPoints: 1e5, tolerance: 3, extent: 4096, buffer: 64, lineMetrics: false, promoteId: null, generateId: false, debug: 0 }, ue.prototype.splitTile = function(e3, t3, r3, o3, i3, n3, s3) {
          for (var a3 = [e3, t3, r3, o3], l2 = this.options, u3 = l2.debug; a3.length; ) {
            o3 = a3.pop(), r3 = a3.pop(), t3 = a3.pop(), e3 = a3.pop();
            var h3 = 1 << t3, c3 = he(t3, r3, o3), f3 = this.tiles[c3];
            if (!f3 && (u3 > 1 && console.time("creation"), f3 = this.tiles[c3] = se(e3, t3, r3, o3, l2), this.tileCoords.push({ z: t3, x: r3, y: o3 }), u3)) {
              u3 > 1 && (console.log("tile z%d-%d-%d (features: %d, points: %d, simplified: %d)", t3, r3, o3, f3.numFeatures, f3.numPoints, f3.numSimplified), console.timeEnd("creation"));
              var p3 = "z" + t3;
              this.stats[p3] = (this.stats[p3] || 0) + 1, this.total++;
            }
            if (f3.source = e3, i3) {
              if (t3 === l2.maxZoom || t3 === i3)
                continue;
              var g3 = 1 << i3 - t3;
              if (r3 !== Math.floor(n3 / g3) || o3 !== Math.floor(s3 / g3))
                continue;
            } else if (t3 === l2.indexMaxZoom || f3.numPoints <= l2.indexMaxPoints)
              continue;
            if (f3.source = null, 0 !== e3.length) {
              u3 > 1 && console.time("clipping");
              var d3, m3, y3, v3, x3, w2, S2 = 0.5 * l2.buffer / l2.extent, M2 = 0.5 - S2, P2 = 0.5 + S2, b2 = 1 + S2;
              d3 = m3 = y3 = v3 = null, x3 = R(e3, h3, r3 - S2, r3 + P2, 0, f3.minX, f3.maxX, l2), w2 = R(e3, h3, r3 + M2, r3 + b2, 0, f3.minX, f3.maxX, l2), e3 = null, x3 && (d3 = R(x3, h3, o3 - S2, o3 + P2, 1, f3.minY, f3.maxY, l2), m3 = R(x3, h3, o3 + M2, o3 + b2, 1, f3.minY, f3.maxY, l2), x3 = null), w2 && (y3 = R(w2, h3, o3 - S2, o3 + P2, 1, f3.minY, f3.maxY, l2), v3 = R(w2, h3, o3 + M2, o3 + b2, 1, f3.minY, f3.maxY, l2), w2 = null), u3 > 1 && console.timeEnd("clipping"), a3.push(d3 || [], t3 + 1, 2 * r3, 2 * o3), a3.push(m3 || [], t3 + 1, 2 * r3, 2 * o3 + 1), a3.push(y3 || [], t3 + 1, 2 * r3 + 1, 2 * o3), a3.push(v3 || [], t3 + 1, 2 * r3 + 1, 2 * o3 + 1);
            }
          }
        }, ue.prototype.getTile = function(e3, t3, r3) {
          var o3 = this.options, i3 = o3.extent, n3 = o3.debug;
          if (e3 < 0 || e3 > 24)
            return null;
          var s3 = 1 << e3, a3 = he(e3, t3 = (t3 % s3 + s3) % s3, r3);
          if (this.tiles[a3])
            return ie(this.tiles[a3], i3);
          n3 > 1 && console.log("drilling down to z%d-%d-%d", e3, t3, r3);
          for (var l2, u3 = e3, h3 = t3, c3 = r3; !l2 && u3 > 0; )
            u3--, h3 = Math.floor(h3 / 2), c3 = Math.floor(c3 / 2), l2 = this.tiles[he(u3, h3, c3)];
          return l2 && l2.source ? (n3 > 1 && console.log("found parent tile z%d-%d-%d", u3, h3, c3), n3 > 1 && console.time("drilling down"), this.splitTile(l2.source, u3, h3, c3, e3, t3, r3), n3 > 1 && console.timeEnd("drilling down"), this.tiles[a3] ? ie(this.tiles[a3], i3) : null) : null;
        };
        class fe extends e2.VectorTileWorkerSource {
          constructor(e3, t3, r3, o3, i3) {
            super(e3, t3, r3, o3, ce), i3 && (this.loadGeoJSON = i3);
          }
          loadData(t3, r3) {
            const o3 = t3 && t3.request, i3 = o3 && o3.collectResourceTiming;
            this.loadGeoJSON(t3, (n3, s3) => {
              if (n3 || !s3)
                return r3(n3);
              if ("object" != typeof s3)
                return r3(new Error(`Input data given to '${t3.source}' is not a valid GeoJSON object.`));
              {
                a2(s3, true);
                try {
                  if (t3.filter) {
                    const r4 = e2.createExpression(t3.filter, { type: "boolean", "property-type": "data-driven", overridable: false, transition: false });
                    if ("error" === r4.result)
                      throw new Error(r4.value.map((e3) => `${e3.key}: ${e3.message}`).join(", "));
                    const o4 = s3.features.filter((e3) => r4.value.evaluate({ zoom: 0 }, e3));
                    s3 = { type: "FeatureCollection", features: o4 };
                  }
                  this._geoJSONIndex = t3.cluster ? new E2(function({ superclusterOptions: t4, clusterProperties: r4 }) {
                    if (!r4 || !t4)
                      return t4;
                    const o4 = {}, i4 = {}, n4 = { accumulated: null, zoom: 0 }, s4 = { properties: null }, a3 = Object.keys(r4);
                    for (const t5 of a3) {
                      const [n5, s5] = r4[t5], a4 = e2.createExpression(s5), l3 = e2.createExpression("string" == typeof n5 ? [n5, ["accumulated"], ["get", t5]] : n5);
                      o4[t5] = a4.value, i4[t5] = l3.value;
                    }
                    return t4.map = (e3) => {
                      s4.properties = e3;
                      const t5 = {};
                      for (const e4 of a3)
                        t5[e4] = o4[e4].evaluate(n4, s4);
                      return t5;
                    }, t4.reduce = (e3, t5) => {
                      s4.properties = t5;
                      for (const t6 of a3)
                        n4.accumulated = e3[t6], e3[t6] = i4[t6].evaluate(n4, s4);
                    }, t4;
                  }(t3)).load(s3.features) : function(e3, t4) {
                    return new ue(e3, t4);
                  }(s3, t3.geojsonVtOptions);
                } catch (n4) {
                  return r3(n4);
                }
                this.loaded = {};
                const l2 = {};
                if (i3) {
                  const r4 = e2.getPerformanceMeasurement(o3);
                  r4 && (l2.resourceTiming = {}, l2.resourceTiming[t3.source] = JSON.parse(JSON.stringify(r4)));
                }
                r3(null, l2);
              }
            });
          }
          reloadTile(e3, t3) {
            const r3 = this.loaded;
            return r3 && r3[e3.uid] ? super.reloadTile(e3, t3) : this.loadTile(e3, t3);
          }
          loadGeoJSON(t3, r3) {
            if (t3.request)
              e2.getJSON(t3.request, r3);
            else {
              if ("string" != typeof t3.data)
                return r3(new Error(`Input data given to '${t3.source}' is not a valid GeoJSON object.`));
              try {
                return r3(null, JSON.parse(t3.data));
              } catch (e3) {
                return r3(new Error(`Input data given to '${t3.source}' is not a valid GeoJSON object.`));
              }
            }
          }
          getClusterExpansionZoom(e3, t3) {
            try {
              t3(null, this._geoJSONIndex.getClusterExpansionZoom(e3.clusterId));
            } catch (e4) {
              t3(e4);
            }
          }
          getClusterChildren(e3, t3) {
            try {
              t3(null, this._geoJSONIndex.getChildren(e3.clusterId));
            } catch (e4) {
              t3(e4);
            }
          }
          getClusterLeaves(e3, t3) {
            try {
              t3(null, this._geoJSONIndex.getLeaves(e3.clusterId, e3.limit, e3.offset));
            } catch (e4) {
              t3(e4);
            }
          }
        }
        class pe {
          constructor(t3) {
            this.self = t3, this.actor = new e2.Actor(t3, this), this.layerIndexes = {}, this.availableImages = {}, this.isSpriteLoaded = {}, this.projections = {}, this.defaultProjection = e2.getProjection({ name: "mercator" }), this.workerSourceTypes = { vector: e2.VectorTileWorkerSource, geojson: fe }, this.workerSources = {}, this.demWorkerSources = {}, this.self.registerWorkerSource = (e3, t4) => {
              if (this.workerSourceTypes[e3])
                throw new Error(`Worker source with name "${e3}" already registered.`);
              this.workerSourceTypes[e3] = t4;
            }, this.self.registerRTLTextPlugin = (t4) => {
              if (e2.plugin.isParsed())
                throw new Error("RTL text plugin already registered.");
              e2.plugin.applyArabicShaping = t4.applyArabicShaping, e2.plugin.processBidirectionalText = t4.processBidirectionalText, e2.plugin.processStyledBidirectionalText = t4.processStyledBidirectionalText;
            };
          }
          clearCaches(e3, t3, r3) {
            delete this.layerIndexes[e3], delete this.availableImages[e3], delete this.workerSources[e3], delete this.demWorkerSources[e3], r3();
          }
          checkIfReady(e3, t3, r3) {
            r3();
          }
          setReferrer(e3, t3) {
            this.referrer = t3;
          }
          spriteLoaded(t3, r3) {
            this.isSpriteLoaded[t3] = r3;
            for (const o3 in this.workerSources[t3]) {
              const i3 = this.workerSources[t3][o3];
              for (const t4 in i3)
                i3[t4] instanceof e2.VectorTileWorkerSource && (i3[t4].isSpriteLoaded = r3, i3[t4].fire(new e2.Event("isSpriteLoaded")));
            }
          }
          setImages(e3, t3, r3) {
            this.availableImages[e3] = t3;
            for (const r4 in this.workerSources[e3]) {
              const o3 = this.workerSources[e3][r4];
              for (const e4 in o3)
                o3[e4].availableImages = t3;
            }
            r3();
          }
          enableTerrain(e3, t3, r3) {
            this.terrain = t3, r3();
          }
          setProjection(t3, r3) {
            this.projections[t3] = e2.getProjection(r3);
          }
          setLayers(e3, t3, r3) {
            this.getLayerIndex(e3).replace(t3), r3();
          }
          updateLayers(e3, t3, r3) {
            this.getLayerIndex(e3).update(t3.layers, t3.removedIds), r3();
          }
          loadTile(t3, r3, o3) {
            const i3 = this.enableTerrain ? e2.extend({ enableTerrain: this.terrain }, r3) : r3;
            i3.projection = this.projections[t3] || this.defaultProjection, this.getWorkerSource(t3, r3.type, r3.source).loadTile(i3, o3);
          }
          loadDEMTile(t3, r3, o3) {
            const i3 = this.enableTerrain ? e2.extend({ buildQuadTree: this.terrain }, r3) : r3;
            this.getDEMWorkerSource(t3, r3.source).loadTile(i3, o3);
          }
          reloadTile(t3, r3, o3) {
            const i3 = this.enableTerrain ? e2.extend({ enableTerrain: this.terrain }, r3) : r3;
            i3.projection = this.projections[t3] || this.defaultProjection, this.getWorkerSource(t3, r3.type, r3.source).reloadTile(i3, o3);
          }
          abortTile(e3, t3, r3) {
            this.getWorkerSource(e3, t3.type, t3.source).abortTile(t3, r3);
          }
          removeTile(e3, t3, r3) {
            this.getWorkerSource(e3, t3.type, t3.source).removeTile(t3, r3);
          }
          removeSource(e3, t3, r3) {
            if (!this.workerSources[e3] || !this.workerSources[e3][t3.type] || !this.workerSources[e3][t3.type][t3.source])
              return;
            const o3 = this.workerSources[e3][t3.type][t3.source];
            delete this.workerSources[e3][t3.type][t3.source], void 0 !== o3.removeSource ? o3.removeSource(t3, r3) : r3();
          }
          loadWorkerSource(e3, t3, r3) {
            try {
              this.self.importScripts(t3.url), r3();
            } catch (e4) {
              r3(e4.toString());
            }
          }
          syncRTLPluginState(t3, r3, o3) {
            try {
              e2.plugin.setState(r3);
              const t4 = e2.plugin.getPluginURL();
              if (e2.plugin.isLoaded() && !e2.plugin.isParsed() && null != t4) {
                this.self.importScripts(t4);
                const r4 = e2.plugin.isParsed();
                o3(r4 ? void 0 : new Error(`RTL Text Plugin failed to import scripts from ${t4}`), r4);
              }
            } catch (e3) {
              o3(e3.toString());
            }
          }
          getAvailableImages(e3) {
            let t3 = this.availableImages[e3];
            return t3 || (t3 = []), t3;
          }
          getLayerIndex(e3) {
            let t3 = this.layerIndexes[e3];
            return t3 || (t3 = this.layerIndexes[e3] = new o2()), t3;
          }
          getWorkerSource(e3, t3, r3) {
            if (this.workerSources[e3] || (this.workerSources[e3] = {}), this.workerSources[e3][t3] || (this.workerSources[e3][t3] = {}), !this.workerSources[e3][t3][r3]) {
              const o3 = { send: (t4, r4, o4, i3, n3, s3) => {
                this.actor.send(t4, r4, o4, e3, n3, s3);
              }, scheduler: this.actor.scheduler };
              this.workerSources[e3][t3][r3] = new this.workerSourceTypes[t3](o3, this.getLayerIndex(e3), this.getAvailableImages(e3), this.isSpriteLoaded[e3]);
            }
            return this.workerSources[e3][t3][r3];
          }
          getDEMWorkerSource(e3, t3) {
            return this.demWorkerSources[e3] || (this.demWorkerSources[e3] = {}), this.demWorkerSources[e3][t3] || (this.demWorkerSources[e3][t3] = new i2()), this.demWorkerSources[e3][t3];
          }
          enforceCacheSizeLimit(t3, r3) {
            e2.enforceCacheSizeLimit(r3);
          }
          getWorkerPerformanceMetrics(e3, t3, r3) {
            r3(void 0, void 0);
          }
        }
        return "undefined" != typeof WorkerGlobalScope && "undefined" != typeof self && self instanceof WorkerGlobalScope && (self.worker = new pe(self)), pe;
      });
      define2(["./shared"], function(e2) {
        "use strict";
        function t2(e3, i3) {
          if (Array.isArray(e3)) {
            if (!Array.isArray(i3) || e3.length !== i3.length)
              return false;
            for (let o3 = 0; o3 < e3.length; o3++)
              if (!t2(e3[o3], i3[o3]))
                return false;
            return true;
          }
          if ("object" == typeof e3 && null !== e3 && null !== i3) {
            if ("object" != typeof i3)
              return false;
            if (Object.keys(e3).length !== Object.keys(i3).length)
              return false;
            for (const o3 in e3)
              if (!t2(e3[o3], i3[o3]))
                return false;
            return true;
          }
          return e3 === i3;
        }
        var i2 = o2;
        function o2(e3) {
          return !function(e4) {
            return "undefined" == typeof window || "undefined" == typeof document ? "not a browser" : Array.prototype && Array.prototype.every && Array.prototype.filter && Array.prototype.forEach && Array.prototype.indexOf && Array.prototype.lastIndexOf && Array.prototype.map && Array.prototype.some && Array.prototype.reduce && Array.prototype.reduceRight && Array.isArray ? Function.prototype && Function.prototype.bind ? Object.keys && Object.create && Object.getPrototypeOf && Object.getOwnPropertyNames && Object.isSealed && Object.isFrozen && Object.isExtensible && Object.getOwnPropertyDescriptor && Object.defineProperty && Object.defineProperties && Object.seal && Object.freeze && Object.preventExtensions ? "JSON" in window && "parse" in JSON && "stringify" in JSON ? function() {
              if (!("Worker" in window && "Blob" in window && "URL" in window))
                return false;
              var e5, t4, i3 = new Blob([""], { type: "text/javascript" }), o3 = URL.createObjectURL(i3);
              try {
                t4 = new Worker(o3), e5 = true;
              } catch (t5) {
                e5 = false;
              }
              return t4 && t4.terminate(), URL.revokeObjectURL(o3), e5;
            }() ? "Uint8ClampedArray" in window ? ArrayBuffer.isView ? function() {
              var e5 = document.createElement("canvas");
              e5.width = e5.height = 1;
              var t4 = e5.getContext("2d");
              if (!t4)
                return false;
              var i3 = t4.getImageData(0, 0, 1, 1);
              return i3 && i3.width === e5.width;
            }() ? (void 0 === r2[t3 = e4 && e4.failIfMajorPerformanceCaveat] && (r2[t3] = function(e5) {
              var t4, i3 = function(e6) {
                var t5 = document.createElement("canvas"), i4 = Object.create(o2.webGLContextAttributes);
                return i4.failIfMajorPerformanceCaveat = e6, t5.getContext("webgl", i4) || t5.getContext("experimental-webgl", i4);
              }(e5);
              if (!i3)
                return false;
              try {
                t4 = i3.createShader(i3.VERTEX_SHADER);
              } catch (e6) {
                return false;
              }
              return !(!t4 || i3.isContextLost()) && (i3.shaderSource(t4, "void main() {}"), i3.compileShader(t4), true === i3.getShaderParameter(t4, i3.COMPILE_STATUS));
            }(t3)), r2[t3] ? document.documentMode ? "insufficient ECMAScript 6 support" : void 0 : "insufficient WebGL support") : "insufficient Canvas/getImageData support" : "insufficient ArrayBuffer support" : "insufficient Uint8ClampedArray support" : "insufficient worker support" : "insufficient JSON support" : "insufficient Object support" : "insufficient Function support" : "insufficent Array support";
            var t3;
          }(e3);
        }
        var r2 = {};
        function n2(t3, i3, o3) {
          const r3 = e2.window.document.createElement(t3);
          return void 0 !== i3 && (r3.className = i3), o3 && o3.appendChild(r3), r3;
        }
        function s2(t3, i3, o3) {
          const r3 = e2.window.document.createElementNS("http://www.w3.org/2000/svg", t3);
          for (const e3 of Object.keys(i3))
            r3.setAttributeNS(null, e3, i3[e3]);
          return o3 && o3.appendChild(r3), r3;
        }
        o2.webGLContextAttributes = { antialias: false, alpha: true, stencil: true, depth: true };
        const a2 = e2.window.document && e2.window.document.documentElement.style, l = a2 && void 0 !== a2.userSelect ? "userSelect" : "WebkitUserSelect";
        let c2;
        function h2() {
          a2 && l && (c2 = a2[l], a2[l] = "none");
        }
        function u2() {
          a2 && l && (a2[l] = c2);
        }
        function _(t3) {
          t3.preventDefault(), t3.stopPropagation(), e2.window.removeEventListener("click", _, true);
        }
        function d2() {
          e2.window.addEventListener("click", _, true), e2.window.setTimeout(() => {
            e2.window.removeEventListener("click", _, true);
          }, 0);
        }
        function p2(e3, t3) {
          const i3 = e3.getBoundingClientRect();
          return g2(e3, i3, t3);
        }
        function m2(e3, t3) {
          const i3 = e3.getBoundingClientRect(), o3 = [];
          for (let r3 = 0; r3 < t3.length; r3++)
            o3.push(g2(e3, i3, t3[r3]));
          return o3;
        }
        function f2(t3) {
          return void 0 !== e2.window.InstallTrigger && 2 === t3.button && t3.ctrlKey && e2.window.navigator.platform.toUpperCase().indexOf("MAC") >= 0 ? 0 : t3.button;
        }
        function g2(t3, i3, o3) {
          const r3 = t3.offsetWidth === i3.width ? 1 : t3.offsetWidth / i3.width;
          return new e2.Point((o3.clientX - i3.left) * r3, (o3.clientY - i3.top) * r3);
        }
        function v2(e3, t3) {
          var i3 = t3[0], o3 = t3[1], r3 = t3[2], n3 = t3[3], s3 = i3 * n3 - r3 * o3;
          return s3 ? (e3[0] = n3 * (s3 = 1 / s3), e3[1] = -o3 * s3, e3[2] = -r3 * s3, e3[3] = i3 * s3, e3) : null;
        }
        function x2(e3) {
          const { userImage: t3 } = e3;
          return !!(t3 && t3.render && t3.render()) && (e3.data.replace(new Uint8Array(t3.data.buffer)), true);
        }
        class y2 extends e2.Evented {
          constructor() {
            super(), this.images = {}, this.updatedImages = {}, this.callbackDispatchedThisFrame = {}, this.loaded = false, this.requestors = [], this.patterns = {}, this.atlasImage = new e2.RGBAImage({ width: 1, height: 1 }), this.dirty = true;
          }
          isLoaded() {
            return this.loaded;
          }
          setLoaded(e3) {
            if (this.loaded !== e3 && (this.loaded = e3, e3)) {
              for (const { ids: e4, callback: t3 } of this.requestors)
                this._notify(e4, t3);
              this.requestors = [];
            }
          }
          hasImage(e3) {
            return !!this.getImage(e3);
          }
          getImage(e3) {
            return this.images[e3];
          }
          addImage(e3, t3) {
            this._validate(e3, t3) && (this.images[e3] = t3);
          }
          _validate(t3, i3) {
            let o3 = true;
            return this._validateStretch(i3.stretchX, i3.data && i3.data.width) || (this.fire(new e2.ErrorEvent(new Error(`Image "${t3}" has invalid "stretchX" value`))), o3 = false), this._validateStretch(i3.stretchY, i3.data && i3.data.height) || (this.fire(new e2.ErrorEvent(new Error(`Image "${t3}" has invalid "stretchY" value`))), o3 = false), this._validateContent(i3.content, i3) || (this.fire(new e2.ErrorEvent(new Error(`Image "${t3}" has invalid "content" value`))), o3 = false), o3;
          }
          _validateStretch(e3, t3) {
            if (!e3)
              return true;
            let i3 = 0;
            for (const o3 of e3) {
              if (o3[0] < i3 || o3[1] < o3[0] || t3 < o3[1])
                return false;
              i3 = o3[1];
            }
            return true;
          }
          _validateContent(e3, t3) {
            return !(e3 && (4 !== e3.length || e3[0] < 0 || t3.data.width < e3[0] || e3[1] < 0 || t3.data.height < e3[1] || e3[2] < 0 || t3.data.width < e3[2] || e3[3] < 0 || t3.data.height < e3[3] || e3[2] < e3[0] || e3[3] < e3[1]));
          }
          updateImage(e3, t3) {
            t3.version = this.images[e3].version + 1, this.images[e3] = t3, this.updatedImages[e3] = true;
          }
          removeImage(e3) {
            const t3 = this.images[e3];
            delete this.images[e3], delete this.patterns[e3], t3.userImage && t3.userImage.onRemove && t3.userImage.onRemove();
          }
          listImages() {
            return Object.keys(this.images);
          }
          getImages(e3, t3) {
            let i3 = true;
            if (!this.isLoaded())
              for (const t4 of e3)
                this.images[t4] || (i3 = false);
            this.isLoaded() || i3 ? this._notify(e3, t3) : this.requestors.push({ ids: e3, callback: t3 });
          }
          _notify(t3, i3) {
            const o3 = {};
            for (const i4 of t3) {
              this.images[i4] || this.fire(new e2.Event("styleimagemissing", { id: i4 }));
              const t4 = this.images[i4];
              t4 ? o3[i4] = { data: t4.data.clone(), pixelRatio: t4.pixelRatio, sdf: t4.sdf, version: t4.version, stretchX: t4.stretchX, stretchY: t4.stretchY, content: t4.content, hasRenderCallback: Boolean(t4.userImage && t4.userImage.render) } : e2.warnOnce(`Image "${i4}" could not be loaded. Please make sure you have added the image with map.addImage() or a "sprite" property in your style. You can provide missing images by listening for the "styleimagemissing" map event.`);
            }
            i3(null, o3);
          }
          getPixelSize() {
            const { width: e3, height: t3 } = this.atlasImage;
            return { width: e3, height: t3 };
          }
          getPattern(t3) {
            const i3 = this.patterns[t3], o3 = this.getImage(t3);
            if (!o3)
              return null;
            if (i3 && i3.position.version === o3.version)
              return i3.position;
            if (i3)
              i3.position.version = o3.version;
            else {
              const i4 = { w: o3.data.width + 2, h: o3.data.height + 2, x: 0, y: 0 }, r3 = new e2.ImagePosition(i4, o3);
              this.patterns[t3] = { bin: i4, position: r3 };
            }
            return this._updatePatternAtlas(), this.patterns[t3].position;
          }
          bind(t3) {
            const i3 = t3.gl;
            this.atlasTexture ? this.dirty && (this.atlasTexture.update(this.atlasImage), this.dirty = false) : this.atlasTexture = new e2.Texture(t3, this.atlasImage, i3.RGBA), this.atlasTexture && this.atlasTexture.bind(i3.LINEAR, i3.CLAMP_TO_EDGE);
          }
          _updatePatternAtlas() {
            const t3 = [];
            for (const e3 in this.patterns)
              t3.push(this.patterns[e3].bin);
            const { w: i3, h: o3 } = e2.potpack(t3), r3 = this.atlasImage;
            r3.resize({ width: i3 || 1, height: o3 || 1 });
            for (const t4 in this.patterns) {
              const { bin: i4 } = this.patterns[t4], o4 = i4.x + 1, n3 = i4.y + 1, s3 = this.images[t4].data, a3 = s3.width, l2 = s3.height;
              e2.RGBAImage.copy(s3, r3, { x: 0, y: 0 }, { x: o4, y: n3 }, { width: a3, height: l2 }), e2.RGBAImage.copy(s3, r3, { x: 0, y: l2 - 1 }, { x: o4, y: n3 - 1 }, { width: a3, height: 1 }), e2.RGBAImage.copy(s3, r3, { x: 0, y: 0 }, { x: o4, y: n3 + l2 }, { width: a3, height: 1 }), e2.RGBAImage.copy(s3, r3, { x: a3 - 1, y: 0 }, { x: o4 - 1, y: n3 }, { width: 1, height: l2 }), e2.RGBAImage.copy(s3, r3, { x: 0, y: 0 }, { x: o4 + a3, y: n3 }, { width: 1, height: l2 });
            }
            this.dirty = true;
          }
          beginFrame() {
            this.callbackDispatchedThisFrame = {};
          }
          dispatchRenderCallbacks(e3) {
            for (const t3 of e3) {
              if (this.callbackDispatchedThisFrame[t3])
                continue;
              this.callbackDispatchedThisFrame[t3] = true;
              const e4 = this.images[t3];
              x2(e4) && this.updateImage(t3, e4);
            }
          }
        }
        const b = new e2.Properties({ anchor: new e2.DataConstantProperty(e2.spec.light.anchor), position: new class {
          constructor() {
            this.specification = e2.spec.light.position;
          }
          possiblyEvaluate(t3, i3) {
            return function([t4, i4, o3]) {
              const r3 = e2.degToRad(i4 + 90), n3 = e2.degToRad(o3);
              return { x: t4 * Math.cos(r3) * Math.sin(n3), y: t4 * Math.sin(r3) * Math.sin(n3), z: t4 * Math.cos(n3), azimuthal: i4, polar: o3 };
            }(t3.expression.evaluate(i3));
          }
          interpolate(t3, i3, o3) {
            return { x: e2.number(t3.x, i3.x, o3), y: e2.number(t3.y, i3.y, o3), z: e2.number(t3.z, i3.z, o3), azimuthal: e2.number(t3.azimuthal, i3.azimuthal, o3), polar: e2.number(t3.polar, i3.polar, o3) };
          }
        }(), color: new e2.DataConstantProperty(e2.spec.light.color), intensity: new e2.DataConstantProperty(e2.spec.light.intensity) });
        class w extends e2.Evented {
          constructor(t3) {
            super(), this._transitionable = new e2.Transitionable(b), this.setLight(t3), this._transitioning = this._transitionable.untransitioned();
          }
          getLight() {
            return this._transitionable.serialize();
          }
          setLight(t3, i3 = {}) {
            if (!this._validate(e2.validateLight, t3, i3))
              for (const i4 in t3) {
                const o3 = t3[i4];
                e2.endsWith(i4, "-transition") ? this._transitionable.setTransition(i4.slice(0, -11), o3) : this._transitionable.setValue(i4, o3);
              }
          }
          updateTransitions(e3) {
            this._transitioning = this._transitionable.transitioned(e3, this._transitioning);
          }
          hasTransition() {
            return this._transitioning.hasTransition();
          }
          recalculate(e3) {
            this.properties = this._transitioning.possiblyEvaluate(e3);
          }
          _validate(t3, i3, o3) {
            return (!o3 || false !== o3.validate) && e2.emitValidationErrors(this, t3.call(e2.validateStyle, e2.extend({ value: i3, style: { glyphs: true, sprite: true }, styleSpec: e2.spec })));
          }
        }
        const T = new e2.Properties({ source: new e2.DataConstantProperty(e2.spec.terrain.source), exaggeration: new e2.DataConstantProperty(e2.spec.terrain.exaggeration) });
        let E2 = class extends e2.Evented {
          constructor(t3, i3) {
            super(), this._transitionable = new e2.Transitionable(T), this.set(t3), this._transitioning = this._transitionable.untransitioned(), this.drapeRenderMode = i3;
          }
          get() {
            return this._transitionable.serialize();
          }
          set(t3) {
            for (const i3 in t3) {
              const o3 = t3[i3];
              e2.endsWith(i3, "-transition") ? this._transitionable.setTransition(i3.slice(0, -11), o3) : this._transitionable.setValue(i3, o3);
            }
          }
          updateTransitions(e3) {
            this._transitioning = this._transitionable.transitioned(e3, this._transitioning);
          }
          hasTransition() {
            return this._transitioning.hasTransition();
          }
          recalculate(e3) {
            this.properties = this._transitioning.possiblyEvaluate(e3);
          }
        };
        function C(t3, i3, o3, r3) {
          const n3 = e2.smoothstep(45, 65, o3), [s3, a3] = M(t3, r3), l2 = e2.length(i3);
          let c3 = 1 - Math.min(1, Math.exp((l2 - s3) / (a3 - s3) * -6));
          return c3 *= c3 * c3, c3 = Math.min(1, 1.00747 * c3), c3 * n3 * t3.alpha;
        }
        function M(e3, t3) {
          const i3 = 0.5 / Math.tan(0.5 * t3);
          return [e3.range[0] + i3, e3.range[1] + i3];
        }
        const I = new e2.Properties({ range: new e2.DataConstantProperty(e2.spec.fog.range), color: new e2.DataConstantProperty(e2.spec.fog.color), "high-color": new e2.DataConstantProperty(e2.spec.fog["high-color"]), "space-color": new e2.DataConstantProperty(e2.spec.fog["space-color"]), "horizon-blend": new e2.DataConstantProperty(e2.spec.fog["horizon-blend"]), "star-intensity": new e2.DataConstantProperty(e2.spec.fog["star-intensity"]) });
        class P extends e2.Evented {
          constructor(t3, i3) {
            super(), this._transitionable = new e2.Transitionable(I), this.set(t3), this._transitioning = this._transitionable.untransitioned(), this._transform = i3;
          }
          get state() {
            const t3 = this._transform, i3 = "globe" === t3.projection.name, o3 = e2.globeToMercatorTransition(t3.zoom), r3 = this.properties.get("range"), n3 = [0.5, 3];
            return { range: i3 ? [e2.number(n3[0], r3[0], o3), e2.number(n3[1], r3[1], o3)] : r3, horizonBlend: this.properties.get("horizon-blend"), alpha: this.properties.get("color").a };
          }
          get() {
            return this._transitionable.serialize();
          }
          set(t3, i3 = {}) {
            if (!this._validate(e2.validateFog, t3, i3)) {
              for (const i4 of Object.keys(e2.spec.fog))
                t3 && void 0 === t3[i4] && (t3[i4] = e2.spec.fog[i4].default);
              for (const i4 in t3) {
                const o3 = t3[i4];
                e2.endsWith(i4, "-transition") ? this._transitionable.setTransition(i4.slice(0, -11), o3) : this._transitionable.setValue(i4, o3);
              }
            }
          }
          getOpacity(t3) {
            if (!this._transform.projection.supportsFog)
              return 0;
            const i3 = this.properties && this.properties.get("color") || 1;
            return ("globe" === this._transform.projection.name ? 1 : e2.smoothstep(45, 65, t3)) * i3.a;
          }
          getOpacityAtLatLng(t3, i3) {
            return this._transform.projection.supportsFog ? function(t4, i4, o3) {
              const r3 = e2.MercatorCoordinate.fromLngLat(i4), n3 = o3.elevation ? o3.elevation.getAtPointOrZero(r3) : 0, s3 = [r3.x, r3.y, n3];
              return e2.transformMat4(s3, s3, o3.mercatorFogMatrix), C(t4, s3, o3.pitch, o3._fov);
            }(this.state, t3, i3) : 0;
          }
          getFovAdjustedRange(e3) {
            return this._transform.projection.supportsFog ? M(this.state, e3) : [0, 1];
          }
          updateTransitions(e3) {
            this._transitioning = this._transitionable.transitioned(e3, this._transitioning);
          }
          hasTransition() {
            return this._transitioning.hasTransition();
          }
          recalculate(e3) {
            this.properties = this._transitioning.possiblyEvaluate(e3);
          }
          _validate(t3, i3, o3) {
            return (!o3 || false !== o3.validate) && e2.emitValidationErrors(this, t3.call(e2.validateStyle, e2.extend({ value: i3, style: { glyphs: true, sprite: true }, styleSpec: e2.spec })));
          }
        }
        class S {
          constructor(t3, i3) {
            this.workerPool = t3, this.actors = [], this.currentActor = 0, this.id = e2.uniqueId();
            const o3 = this.workerPool.acquire(this.id);
            for (let e3 = 0; e3 < o3.length; e3++) {
              const t4 = new S.Actor(o3[e3], i3, this.id);
              t4.name = `Worker ${e3}`, this.actors.push(t4);
            }
            this.ready = false, this.broadcast("checkIfReady", null, () => {
              this.ready = true;
            });
          }
          broadcast(t3, i3, o3) {
            e2.asyncAll(this.actors, (e3, o4) => {
              e3.send(t3, i3, o4);
            }, o3 = o3 || function() {
            });
          }
          getActor() {
            return this.currentActor = (this.currentActor + 1) % this.actors.length, this.actors[this.currentActor];
          }
          remove() {
            this.actors.forEach((e3) => {
              e3.remove();
            }), this.actors = [], this.workerPool.release(this.id);
          }
        }
        function D(t3, i3, o3) {
          return i3 * (e2.EXTENT / (t3.tileSize * Math.pow(2, o3 - t3.tileID.overscaledZ)));
        }
        S.Actor = e2.Actor;
        class L {
          constructor(e3, t3, i3, o3) {
            this.screenBounds = e3, this.cameraPoint = t3, this._screenRaycastCache = {}, this._cameraRaycastCache = {}, this.isAboveHorizon = i3, this.screenGeometry = this.bufferedScreenGeometry(0), this.screenGeometryMercator = this._bufferedScreenMercator(0, o3);
          }
          static createFromScreenPoints(t3, i3) {
            let o3, r3;
            if (t3 instanceof e2.Point || "number" == typeof t3[0]) {
              const n3 = e2.Point.convert(t3);
              o3 = [n3], r3 = i3.isPointAboveHorizon(n3);
            } else {
              const n3 = e2.Point.convert(t3[0]), s3 = e2.Point.convert(t3[1]);
              o3 = [n3, s3], r3 = e2.polygonizeBounds(n3, s3).every((e3) => i3.isPointAboveHorizon(e3));
            }
            return new L(o3, i3.getCameraPoint(), r3, i3);
          }
          isPointQuery() {
            return 1 === this.screenBounds.length;
          }
          bufferedScreenGeometry(t3) {
            return e2.polygonizeBounds(this.screenBounds[0], 1 === this.screenBounds.length ? this.screenBounds[0] : this.screenBounds[1], t3);
          }
          bufferedCameraGeometry(t3) {
            const i3 = this.screenBounds[0], o3 = 1 === this.screenBounds.length ? this.screenBounds[0].add(new e2.Point(1, 1)) : this.screenBounds[1], r3 = e2.polygonizeBounds(i3, o3, 0, false);
            return this.cameraPoint.y > o3.y && (this.cameraPoint.x > i3.x && this.cameraPoint.x < o3.x ? r3.splice(3, 0, this.cameraPoint) : this.cameraPoint.x >= o3.x ? r3[2] = this.cameraPoint : this.cameraPoint.x <= i3.x && (r3[3] = this.cameraPoint)), e2.bufferConvexPolygon(r3, t3);
          }
          bufferedCameraGeometryGlobe(t3) {
            const i3 = this.screenBounds[0], o3 = 1 === this.screenBounds.length ? this.screenBounds[0].add(new e2.Point(1, 1)) : this.screenBounds[1], r3 = e2.polygonizeBounds(i3, o3, t3), n3 = this.cameraPoint.clone();
            switch (3 * ((n3.y > i3.y) + (n3.y > o3.y)) + ((n3.x > i3.x) + (n3.x > o3.x))) {
              case 0:
                r3[0] = n3, r3[4] = n3.clone();
                break;
              case 1:
                r3.splice(1, 0, n3);
                break;
              case 2:
                r3[1] = n3;
                break;
              case 3:
                r3.splice(4, 0, n3);
                break;
              case 5:
                r3.splice(2, 0, n3);
                break;
              case 6:
                r3[3] = n3;
                break;
              case 7:
                r3.splice(3, 0, n3);
                break;
              case 8:
                r3[2] = n3;
            }
            return r3;
          }
          containsTile(t3, i3, o3, r3 = 0) {
            const n3 = t3.queryPadding / i3._pixelsPerMercatorPixel + 1, s3 = o3 ? this._bufferedCameraMercator(n3, i3) : this._bufferedScreenMercator(n3, i3);
            let a3 = t3.tileID.wrap + (s3.unwrapped ? r3 : 0);
            const l2 = s3.polygon.map((i4) => e2.getTilePoint(t3.tileTransform, i4, a3));
            if (!e2.polygonIntersectsBox(l2, 0, 0, e2.EXTENT, e2.EXTENT))
              return;
            a3 = t3.tileID.wrap + (this.screenGeometryMercator.unwrapped ? r3 : 0);
            const c3 = this.screenGeometryMercator.polygon.map((i4) => e2.getTileVec3(t3.tileTransform, i4, a3)), h3 = c3.map((t4) => new e2.Point(t4[0], t4[1])), u3 = i3.getFreeCameraOptions().position || new e2.MercatorCoordinate(0, 0, 0), _2 = e2.getTileVec3(t3.tileTransform, u3, a3), d3 = c3.map((t4) => {
              const i4 = e2.sub(t4, t4, _2);
              return e2.normalize(i4, i4), new e2.Ray(_2, i4);
            }), p3 = D(t3, 1, i3.zoom) * i3._pixelsPerMercatorPixel;
            return { queryGeometry: this, tilespaceGeometry: h3, tilespaceRays: d3, bufferedTilespaceGeometry: l2, bufferedTilespaceBounds: (m3 = e2.getBounds(l2), m3.min.x = e2.clamp(m3.min.x, 0, e2.EXTENT), m3.min.y = e2.clamp(m3.min.y, 0, e2.EXTENT), m3.max.x = e2.clamp(m3.max.x, 0, e2.EXTENT), m3.max.y = e2.clamp(m3.max.y, 0, e2.EXTENT), m3), tile: t3, tileID: t3.tileID, pixelToTileUnitsFactor: p3 };
            var m3;
          }
          _bufferedScreenMercator(e3, t3) {
            const i3 = R(e3);
            if (this._screenRaycastCache[i3])
              return this._screenRaycastCache[i3];
            {
              let o3;
              return o3 = "globe" === t3.projection.name ? this._projectAndResample(this.bufferedScreenGeometry(e3), t3) : { polygon: this.bufferedScreenGeometry(e3).map((e4) => t3.pointCoordinate3D(e4)), unwrapped: true }, this._screenRaycastCache[i3] = o3, o3;
            }
          }
          _bufferedCameraMercator(e3, t3) {
            const i3 = R(e3);
            if (this._cameraRaycastCache[i3])
              return this._cameraRaycastCache[i3];
            {
              let o3;
              return o3 = "globe" === t3.projection.name ? this._projectAndResample(this.bufferedCameraGeometryGlobe(e3), t3) : { polygon: this.bufferedCameraGeometry(e3).map((e4) => t3.pointCoordinate3D(e4)), unwrapped: true }, this._cameraRaycastCache[i3] = o3, o3;
            }
          }
          _projectAndResample(t3, i3) {
            const o3 = function(t4, i4) {
              const o4 = e2.multiply([], i4.pixelMatrix, i4.globeMatrix), r4 = [0, -e2.GLOBE_RADIUS, 0, 1], n3 = [0, e2.GLOBE_RADIUS, 0, 1], s3 = [0, 0, 0, 1];
              e2.transformMat4$1(r4, r4, o4), e2.transformMat4$1(n3, n3, o4), e2.transformMat4$1(s3, s3, o4);
              const a3 = new e2.Point(r4[0] / r4[3], r4[1] / r4[3]), l2 = new e2.Point(n3[0] / n3[3], n3[1] / n3[3]), c3 = e2.polygonContainsPoint(t4, a3) && r4[3] < s3[3], h3 = e2.polygonContainsPoint(t4, l2) && n3[3] < s3[3];
              if (!c3 && !h3)
                return null;
              const u3 = function(e3, t5, i5) {
                for (let o5 = 1; o5 < e3.length; o5++) {
                  const r5 = z(t5.pointCoordinate3D(e3[o5 - 1]).x), n4 = z(t5.pointCoordinate3D(e3[o5]).x);
                  if (i5 < 0) {
                    if (r5 < n4)
                      return { idx: o5, t: -r5 / (n4 - 1 - r5) };
                  } else if (n4 < r5)
                    return { idx: o5, t: (1 - r5) / (n4 + 1 - r5) };
                }
                return null;
              }(t4, i4, c3 ? -1 : 1);
              if (!u3)
                return null;
              const { idx: _2, t: d3 } = u3;
              let p3 = _2 > 1 ? A(t4.slice(0, _2), i4) : [], m3 = _2 < t4.length ? A(t4.slice(_2), i4) : [];
              p3 = p3.map((t5) => new e2.Point(z(t5.x), t5.y)), m3 = m3.map((t5) => new e2.Point(z(t5.x), t5.y));
              const f3 = [...p3];
              0 === f3.length && f3.push(m3[m3.length - 1]);
              const g3 = e2.number(f3[f3.length - 1].y, (0 === m3.length ? p3[0] : m3[0]).y, d3);
              let v3;
              return v3 = c3 ? [new e2.Point(0, g3), new e2.Point(0, 0), new e2.Point(1, 0), new e2.Point(1, g3)] : [new e2.Point(1, g3), new e2.Point(1, 1), new e2.Point(0, 1), new e2.Point(0, g3)], f3.push(...v3), 0 === m3.length ? f3.push(p3[0]) : f3.push(...m3), { polygon: f3.map((t5) => new e2.MercatorCoordinate(t5.x, t5.y)), unwrapped: false };
            }(t3, i3);
            if (o3)
              return o3;
            const r3 = function(t4, i4) {
              let o4 = false, r4 = -1 / 0, n3 = 0;
              for (let e3 = 0; e3 < t4.length - 1; e3++)
                t4[e3].x > r4 && (r4 = t4[e3].x, n3 = e3);
              for (let e3 = 0; e3 < t4.length - 1; e3++) {
                const i5 = (n3 + e3) % (t4.length - 1), r5 = t4[i5], s4 = t4[i5 + 1];
                Math.abs(r5.x - s4.x) > 0.5 && (r5.x < s4.x ? (r5.x += 1, 0 === i5 && (t4[t4.length - 1].x += 1)) : (s4.x += 1, i5 + 1 === t4.length - 1 && (t4[0].x += 1)), o4 = true);
              }
              const s3 = e2.mercatorXfromLng(i4.center.lng);
              return o4 && s3 < Math.abs(s3 - 1) && t4.forEach((e3) => {
                e3.x -= 1;
              }), { polygon: t4, unwrapped: o4 };
            }(A(t3, i3).map((t4) => new e2.Point(z(t4.x), t4.y)), i3);
            return { polygon: r3.polygon.map((t4) => new e2.MercatorCoordinate(t4.x, t4.y)), unwrapped: r3.unwrapped };
          }
        }
        function A(t3, i3) {
          return e2.resample(t3, (e3) => {
            const t4 = i3.pointCoordinate3D(e3);
            e3.x = t4.x, e3.y = t4.y;
          }, 1 / 256);
        }
        function z(e3) {
          return e3 < 0 ? 1 + e3 % 1 : e3 % 1;
        }
        function R(e3) {
          return 100 * e3 | 0;
        }
        function O(t3, i3, o3, r3, n3) {
          const s3 = function(o4, r4) {
            if (o4)
              return n3(o4);
            if (r4) {
              t3.url && r4.tiles && t3.tiles && delete t3.tiles;
              const o5 = e2.pick(e2.extend(r4, t3), ["tiles", "minzoom", "maxzoom", "attribution", "mapbox_logo", "bounds", "scheme", "tileSize", "encoding"]);
              r4.vector_layers && (o5.vectorLayers = r4.vector_layers, o5.vectorLayerIds = o5.vectorLayers.map((e3) => e3.id)), o5.tiles = i3.canonicalizeTileset(o5, t3.url), n3(null, o5);
            }
          };
          return t3.url ? e2.getJSON(i3.transformRequest(i3.normalizeSourceURL(t3.url, null, o3, r3), e2.ResourceType.Source), s3) : e2.exported.frame(() => s3(null, t3));
        }
        class B {
          constructor(t3, i3, o3) {
            this.bounds = e2.LngLatBounds.convert(this.validateBounds(t3)), this.minzoom = i3 || 0, this.maxzoom = o3 || 24;
          }
          validateBounds(e3) {
            return Array.isArray(e3) && 4 === e3.length ? [Math.max(-180, e3[0]), Math.max(-90, e3[1]), Math.min(180, e3[2]), Math.min(90, e3[3])] : [-180, -90, 180, 90];
          }
          contains(t3) {
            const i3 = Math.pow(2, t3.z), o3 = Math.floor(e2.mercatorXfromLng(this.bounds.getWest()) * i3), r3 = Math.floor(e2.mercatorYfromLat(this.bounds.getNorth()) * i3), n3 = Math.ceil(e2.mercatorXfromLng(this.bounds.getEast()) * i3), s3 = Math.ceil(e2.mercatorYfromLat(this.bounds.getSouth()) * i3);
            return t3.x >= o3 && t3.x < n3 && t3.y >= r3 && t3.y < s3;
          }
        }
        class k {
          constructor(e3, t3, i3) {
            this.context = e3;
            const o3 = e3.gl;
            this.buffer = o3.createBuffer(), this.dynamicDraw = Boolean(i3), this.context.unbindVAO(), e3.bindElementBuffer.set(this.buffer), o3.bufferData(o3.ELEMENT_ARRAY_BUFFER, t3.arrayBuffer, this.dynamicDraw ? o3.DYNAMIC_DRAW : o3.STATIC_DRAW), this.dynamicDraw || t3.destroy();
          }
          bind() {
            this.context.bindElementBuffer.set(this.buffer);
          }
          updateData(e3) {
            const t3 = this.context.gl;
            this.context.unbindVAO(), this.bind(), t3.bufferSubData(t3.ELEMENT_ARRAY_BUFFER, 0, e3.arrayBuffer);
          }
          destroy() {
            this.buffer && (this.context.gl.deleteBuffer(this.buffer), delete this.buffer);
          }
        }
        const F = { Int8: "BYTE", Uint8: "UNSIGNED_BYTE", Int16: "SHORT", Uint16: "UNSIGNED_SHORT", Int32: "INT", Uint32: "UNSIGNED_INT", Float32: "FLOAT" };
        class U {
          constructor(e3, t3, i3, o3) {
            this.length = t3.length, this.attributes = i3, this.itemSize = t3.bytesPerElement, this.dynamicDraw = o3, this.context = e3;
            const r3 = e3.gl;
            this.buffer = r3.createBuffer(), e3.bindVertexBuffer.set(this.buffer), r3.bufferData(r3.ARRAY_BUFFER, t3.arrayBuffer, this.dynamicDraw ? r3.DYNAMIC_DRAW : r3.STATIC_DRAW), this.dynamicDraw || t3.destroy();
          }
          bind() {
            this.context.bindVertexBuffer.set(this.buffer);
          }
          updateData(e3) {
            const t3 = this.context.gl;
            this.bind(), t3.bufferSubData(t3.ARRAY_BUFFER, 0, e3.arrayBuffer);
          }
          enableAttributes(e3, t3) {
            for (let i3 = 0; i3 < this.attributes.length; i3++) {
              const o3 = t3.attributes[this.attributes[i3].name];
              void 0 !== o3 && e3.enableVertexAttribArray(o3);
            }
          }
          setVertexAttribPointers(e3, t3, i3) {
            for (let o3 = 0; o3 < this.attributes.length; o3++) {
              const r3 = this.attributes[o3], n3 = t3.attributes[r3.name];
              void 0 !== n3 && e3.vertexAttribPointer(n3, r3.components, e3[F[r3.type]], false, this.itemSize, r3.offset + this.itemSize * (i3 || 0));
            }
          }
          destroy() {
            this.buffer && (this.context.gl.deleteBuffer(this.buffer), delete this.buffer);
          }
        }
        class N {
          constructor(e3) {
            this.gl = e3.gl, this.default = this.getDefault(), this.current = this.default, this.dirty = false;
          }
          get() {
            return this.current;
          }
          set(e3) {
          }
          getDefault() {
            return this.default;
          }
          setDefault() {
            this.set(this.default);
          }
        }
        class j extends N {
          getDefault() {
            return e2.Color.transparent;
          }
          set(e3) {
            const t3 = this.current;
            (e3.r !== t3.r || e3.g !== t3.g || e3.b !== t3.b || e3.a !== t3.a || this.dirty) && (this.gl.clearColor(e3.r, e3.g, e3.b, e3.a), this.current = e3, this.dirty = false);
          }
        }
        class G extends N {
          getDefault() {
            return 1;
          }
          set(e3) {
            (e3 !== this.current || this.dirty) && (this.gl.clearDepth(e3), this.current = e3, this.dirty = false);
          }
        }
        class Z extends N {
          getDefault() {
            return 0;
          }
          set(e3) {
            (e3 !== this.current || this.dirty) && (this.gl.clearStencil(e3), this.current = e3, this.dirty = false);
          }
        }
        class V extends N {
          getDefault() {
            return [true, true, true, true];
          }
          set(e3) {
            const t3 = this.current;
            (e3[0] !== t3[0] || e3[1] !== t3[1] || e3[2] !== t3[2] || e3[3] !== t3[3] || this.dirty) && (this.gl.colorMask(e3[0], e3[1], e3[2], e3[3]), this.current = e3, this.dirty = false);
          }
        }
        class W extends N {
          getDefault() {
            return true;
          }
          set(e3) {
            (e3 !== this.current || this.dirty) && (this.gl.depthMask(e3), this.current = e3, this.dirty = false);
          }
        }
        class X extends N {
          getDefault() {
            return 255;
          }
          set(e3) {
            (e3 !== this.current || this.dirty) && (this.gl.stencilMask(e3), this.current = e3, this.dirty = false);
          }
        }
        class q extends N {
          getDefault() {
            return { func: this.gl.ALWAYS, ref: 0, mask: 255 };
          }
          set(e3) {
            const t3 = this.current;
            (e3.func !== t3.func || e3.ref !== t3.ref || e3.mask !== t3.mask || this.dirty) && (this.gl.stencilFunc(e3.func, e3.ref, e3.mask), this.current = e3, this.dirty = false);
          }
        }
        class $ extends N {
          getDefault() {
            const e3 = this.gl;
            return [e3.KEEP, e3.KEEP, e3.KEEP];
          }
          set(e3) {
            const t3 = this.current;
            (e3[0] !== t3[0] || e3[1] !== t3[1] || e3[2] !== t3[2] || this.dirty) && (this.gl.stencilOp(e3[0], e3[1], e3[2]), this.current = e3, this.dirty = false);
          }
        }
        class H extends N {
          getDefault() {
            return false;
          }
          set(e3) {
            if (e3 === this.current && !this.dirty)
              return;
            const t3 = this.gl;
            e3 ? t3.enable(t3.STENCIL_TEST) : t3.disable(t3.STENCIL_TEST), this.current = e3, this.dirty = false;
          }
        }
        class Y extends N {
          getDefault() {
            return [0, 1];
          }
          set(e3) {
            const t3 = this.current;
            (e3[0] !== t3[0] || e3[1] !== t3[1] || this.dirty) && (this.gl.depthRange(e3[0], e3[1]), this.current = e3, this.dirty = false);
          }
        }
        class K extends N {
          getDefault() {
            return false;
          }
          set(e3) {
            if (e3 === this.current && !this.dirty)
              return;
            const t3 = this.gl;
            e3 ? t3.enable(t3.DEPTH_TEST) : t3.disable(t3.DEPTH_TEST), this.current = e3, this.dirty = false;
          }
        }
        class J extends N {
          getDefault() {
            return this.gl.LESS;
          }
          set(e3) {
            (e3 !== this.current || this.dirty) && (this.gl.depthFunc(e3), this.current = e3, this.dirty = false);
          }
        }
        class Q extends N {
          getDefault() {
            return false;
          }
          set(e3) {
            if (e3 === this.current && !this.dirty)
              return;
            const t3 = this.gl;
            e3 ? t3.enable(t3.BLEND) : t3.disable(t3.BLEND), this.current = e3, this.dirty = false;
          }
        }
        class ee extends N {
          getDefault() {
            const e3 = this.gl;
            return [e3.ONE, e3.ZERO];
          }
          set(e3) {
            const t3 = this.current;
            (e3[0] !== t3[0] || e3[1] !== t3[1] || this.dirty) && (this.gl.blendFunc(e3[0], e3[1]), this.current = e3, this.dirty = false);
          }
        }
        class te extends N {
          getDefault() {
            return e2.Color.transparent;
          }
          set(e3) {
            const t3 = this.current;
            (e3.r !== t3.r || e3.g !== t3.g || e3.b !== t3.b || e3.a !== t3.a || this.dirty) && (this.gl.blendColor(e3.r, e3.g, e3.b, e3.a), this.current = e3, this.dirty = false);
          }
        }
        class ie extends N {
          getDefault() {
            return this.gl.FUNC_ADD;
          }
          set(e3) {
            (e3 !== this.current || this.dirty) && (this.gl.blendEquation(e3), this.current = e3, this.dirty = false);
          }
        }
        class oe extends N {
          getDefault() {
            return false;
          }
          set(e3) {
            if (e3 === this.current && !this.dirty)
              return;
            const t3 = this.gl;
            e3 ? t3.enable(t3.CULL_FACE) : t3.disable(t3.CULL_FACE), this.current = e3, this.dirty = false;
          }
        }
        class re extends N {
          getDefault() {
            return this.gl.BACK;
          }
          set(e3) {
            (e3 !== this.current || this.dirty) && (this.gl.cullFace(e3), this.current = e3, this.dirty = false);
          }
        }
        class ne extends N {
          getDefault() {
            return this.gl.CCW;
          }
          set(e3) {
            (e3 !== this.current || this.dirty) && (this.gl.frontFace(e3), this.current = e3, this.dirty = false);
          }
        }
        let se, ae = class extends N {
          getDefault() {
            return null;
          }
          set(e3) {
            (e3 !== this.current || this.dirty) && (this.gl.useProgram(e3), this.current = e3, this.dirty = false);
          }
        };
        class le extends N {
          getDefault() {
            return this.gl.TEXTURE0;
          }
          set(e3) {
            (e3 !== this.current || this.dirty) && (this.gl.activeTexture(e3), this.current = e3, this.dirty = false);
          }
        }
        class ce extends N {
          getDefault() {
            const e3 = this.gl;
            return [0, 0, e3.drawingBufferWidth, e3.drawingBufferHeight];
          }
          set(e3) {
            const t3 = this.current;
            (e3[0] !== t3[0] || e3[1] !== t3[1] || e3[2] !== t3[2] || e3[3] !== t3[3] || this.dirty) && (this.gl.viewport(e3[0], e3[1], e3[2], e3[3]), this.current = e3, this.dirty = false);
          }
        }
        class he extends N {
          getDefault() {
            return null;
          }
          set(e3) {
            if (e3 === this.current && !this.dirty)
              return;
            const t3 = this.gl;
            t3.bindFramebuffer(t3.FRAMEBUFFER, e3), this.current = e3, this.dirty = false;
          }
        }
        class ue extends N {
          getDefault() {
            return null;
          }
          set(e3) {
            if (e3 === this.current && !this.dirty)
              return;
            const t3 = this.gl;
            t3.bindRenderbuffer(t3.RENDERBUFFER, e3), this.current = e3, this.dirty = false;
          }
        }
        class _e extends N {
          getDefault() {
            return null;
          }
          set(e3) {
            if (e3 === this.current && !this.dirty)
              return;
            const t3 = this.gl;
            t3.bindTexture(t3.TEXTURE_2D, e3), this.current = e3, this.dirty = false;
          }
        }
        class de extends N {
          getDefault() {
            return null;
          }
          set(e3) {
            if (e3 === this.current && !this.dirty)
              return;
            const t3 = this.gl;
            t3.bindBuffer(t3.ARRAY_BUFFER, e3), this.current = e3, this.dirty = false;
          }
        }
        class pe extends N {
          getDefault() {
            return null;
          }
          set(e3) {
            const t3 = this.gl;
            t3.bindBuffer(t3.ELEMENT_ARRAY_BUFFER, e3), this.current = e3, this.dirty = false;
          }
        }
        class me extends N {
          constructor(e3) {
            super(e3), this.vao = e3.extVertexArrayObject;
          }
          getDefault() {
            return null;
          }
          set(e3) {
            this.vao && (e3 !== this.current || this.dirty) && (this.vao.bindVertexArrayOES(e3), this.current = e3, this.dirty = false);
          }
        }
        class fe extends N {
          getDefault() {
            return 4;
          }
          set(e3) {
            if (e3 === this.current && !this.dirty)
              return;
            const t3 = this.gl;
            t3.pixelStorei(t3.UNPACK_ALIGNMENT, e3), this.current = e3, this.dirty = false;
          }
        }
        class ge extends N {
          getDefault() {
            return false;
          }
          set(e3) {
            if (e3 === this.current && !this.dirty)
              return;
            const t3 = this.gl;
            t3.pixelStorei(t3.UNPACK_PREMULTIPLY_ALPHA_WEBGL, e3), this.current = e3, this.dirty = false;
          }
        }
        class ve extends N {
          getDefault() {
            return false;
          }
          set(e3) {
            if (e3 === this.current && !this.dirty)
              return;
            const t3 = this.gl;
            t3.pixelStorei(t3.UNPACK_FLIP_Y_WEBGL, e3), this.current = e3, this.dirty = false;
          }
        }
        class xe extends N {
          constructor(e3, t3) {
            super(e3), this.context = e3, this.parent = t3;
          }
          getDefault() {
            return null;
          }
        }
        class ye extends xe {
          setDirty() {
            this.dirty = true;
          }
          set(e3) {
            if (e3 === this.current && !this.dirty)
              return;
            this.context.bindFramebuffer.set(this.parent);
            const t3 = this.gl;
            t3.framebufferTexture2D(t3.FRAMEBUFFER, t3.COLOR_ATTACHMENT0, t3.TEXTURE_2D, e3, 0), this.current = e3, this.dirty = false;
          }
        }
        class be extends xe {
          attachment() {
            return this.gl.DEPTH_ATTACHMENT;
          }
          set(e3) {
            if (e3 === this.current && !this.dirty)
              return;
            this.context.bindFramebuffer.set(this.parent);
            const t3 = this.gl;
            t3.framebufferRenderbuffer(t3.FRAMEBUFFER, this.attachment(), t3.RENDERBUFFER, e3), this.current = e3, this.dirty = false;
          }
        }
        class we extends be {
          attachment() {
            return this.gl.DEPTH_STENCIL_ATTACHMENT;
          }
        }
        class Te {
          constructor(e3, t3, i3, o3) {
            this.context = e3, this.width = t3, this.height = i3;
            const r3 = this.framebuffer = e3.gl.createFramebuffer();
            this.colorAttachment = new ye(e3, r3), o3 && (this.depthAttachment = new be(e3, r3));
          }
          destroy() {
            const e3 = this.context.gl, t3 = this.colorAttachment.get();
            if (t3 && e3.deleteTexture(t3), this.depthAttachment) {
              const t4 = this.depthAttachment.get();
              t4 && e3.deleteRenderbuffer(t4);
            }
            e3.deleteFramebuffer(this.framebuffer);
          }
        }
        class Ee {
          constructor(e3, t3 = false) {
            if (this.gl = e3, this.isWebGL2 = t3, this.extVertexArrayObject = this.gl.getExtension("OES_vertex_array_object"), t3) {
              const t4 = e3;
              this.extVertexArrayObject = { createVertexArrayOES: t4.createVertexArray.bind(e3), deleteVertexArrayOES: t4.deleteVertexArray.bind(e3), bindVertexArrayOES: t4.bindVertexArray.bind(e3) };
            }
            this.clearColor = new j(this), this.clearDepth = new G(this), this.clearStencil = new Z(this), this.colorMask = new V(this), this.depthMask = new W(this), this.stencilMask = new X(this), this.stencilFunc = new q(this), this.stencilOp = new $(this), this.stencilTest = new H(this), this.depthRange = new Y(this), this.depthTest = new K(this), this.depthFunc = new J(this), this.blend = new Q(this), this.blendFunc = new ee(this), this.blendColor = new te(this), this.blendEquation = new ie(this), this.cullFace = new oe(this), this.cullFaceSide = new re(this), this.frontFace = new ne(this), this.program = new ae(this), this.activeTexture = new le(this), this.viewport = new ce(this), this.bindFramebuffer = new he(this), this.bindRenderbuffer = new ue(this), this.bindTexture = new _e(this), this.bindVertexBuffer = new de(this), this.bindElementBuffer = new pe(this), this.bindVertexArrayOES = this.extVertexArrayObject && new me(this), this.pixelStoreUnpack = new fe(this), this.pixelStoreUnpackPremultiplyAlpha = new ge(this), this.pixelStoreUnpackFlipY = new ve(this), this.extTextureFilterAnisotropic = e3.getExtension("EXT_texture_filter_anisotropic") || e3.getExtension("MOZ_EXT_texture_filter_anisotropic") || e3.getExtension("WEBKIT_EXT_texture_filter_anisotropic"), this.extTextureFilterAnisotropic && (this.extTextureFilterAnisotropicMax = e3.getParameter(this.extTextureFilterAnisotropic.MAX_TEXTURE_MAX_ANISOTROPY_EXT)), this.extTextureFilterAnisotropicForceOff = false, this.extStandardDerivativesForceOff = false, this.extDebugRendererInfo = e3.getExtension("WEBGL_debug_renderer_info"), this.extDebugRendererInfo && (this.renderer = e3.getParameter(this.extDebugRendererInfo.UNMASKED_RENDERER_WEBGL), this.vendor = e3.getParameter(this.extDebugRendererInfo.UNMASKED_VENDOR_WEBGL)), t3 || (this.extTextureHalfFloat = e3.getExtension("OES_texture_half_float")), (t3 || this.extTextureHalfFloat && e3.getExtension("OES_texture_half_float_linear")) && (this.extRenderToTextureHalfFloat = e3.getExtension("EXT_color_buffer_half_float")), this.extStandardDerivatives = t3 || e3.getExtension("OES_standard_derivatives"), this.extTimerQuery = e3.getExtension("EXT_disjoint_timer_query"), this.maxTextureSize = e3.getParameter(e3.MAX_TEXTURE_SIZE);
          }
          setDefault() {
            this.unbindVAO(), this.clearColor.setDefault(), this.clearDepth.setDefault(), this.clearStencil.setDefault(), this.colorMask.setDefault(), this.depthMask.setDefault(), this.stencilMask.setDefault(), this.stencilFunc.setDefault(), this.stencilOp.setDefault(), this.stencilTest.setDefault(), this.depthRange.setDefault(), this.depthTest.setDefault(), this.depthFunc.setDefault(), this.blend.setDefault(), this.blendFunc.setDefault(), this.blendColor.setDefault(), this.blendEquation.setDefault(), this.cullFace.setDefault(), this.cullFaceSide.setDefault(), this.frontFace.setDefault(), this.program.setDefault(), this.activeTexture.setDefault(), this.bindFramebuffer.setDefault(), this.pixelStoreUnpack.setDefault(), this.pixelStoreUnpackPremultiplyAlpha.setDefault(), this.pixelStoreUnpackFlipY.setDefault();
          }
          setDirty() {
            this.clearColor.dirty = true, this.clearDepth.dirty = true, this.clearStencil.dirty = true, this.colorMask.dirty = true, this.depthMask.dirty = true, this.stencilMask.dirty = true, this.stencilFunc.dirty = true, this.stencilOp.dirty = true, this.stencilTest.dirty = true, this.depthRange.dirty = true, this.depthTest.dirty = true, this.depthFunc.dirty = true, this.blend.dirty = true, this.blendFunc.dirty = true, this.blendColor.dirty = true, this.blendEquation.dirty = true, this.cullFace.dirty = true, this.cullFaceSide.dirty = true, this.frontFace.dirty = true, this.program.dirty = true, this.activeTexture.dirty = true, this.viewport.dirty = true, this.bindFramebuffer.dirty = true, this.bindRenderbuffer.dirty = true, this.bindTexture.dirty = true, this.bindVertexBuffer.dirty = true, this.bindElementBuffer.dirty = true, this.extVertexArrayObject && (this.bindVertexArrayOES.dirty = true), this.pixelStoreUnpack.dirty = true, this.pixelStoreUnpackPremultiplyAlpha.dirty = true, this.pixelStoreUnpackFlipY.dirty = true;
          }
          createIndexBuffer(e3, t3) {
            return new k(this, e3, t3);
          }
          createVertexBuffer(e3, t3, i3) {
            return new U(this, e3, t3, i3);
          }
          createRenderbuffer(e3, t3, i3) {
            const o3 = this.gl, r3 = o3.createRenderbuffer();
            return this.bindRenderbuffer.set(r3), o3.renderbufferStorage(o3.RENDERBUFFER, e3, t3, i3), this.bindRenderbuffer.set(null), r3;
          }
          createFramebuffer(e3, t3, i3) {
            return new Te(this, e3, t3, i3);
          }
          clear({ color: e3, depth: t3, stencil: i3 }) {
            const o3 = this.gl;
            let r3 = 0;
            e3 && (r3 |= o3.COLOR_BUFFER_BIT, this.clearColor.set(e3), this.colorMask.set([true, true, true, true])), void 0 !== t3 && (r3 |= o3.DEPTH_BUFFER_BIT, this.depthRange.set([0, 1]), this.clearDepth.set(t3), this.depthMask.set(true)), void 0 !== i3 && (r3 |= o3.STENCIL_BUFFER_BIT, this.clearStencil.set(i3), this.stencilMask.set(255)), o3.clear(r3);
          }
          setCullFace(e3) {
            false === e3.enable ? this.cullFace.set(false) : (this.cullFace.set(true), this.cullFaceSide.set(e3.mode), this.frontFace.set(e3.frontFace));
          }
          setDepthMode(e3) {
            e3.func !== this.gl.ALWAYS || e3.mask ? (this.depthTest.set(true), this.depthFunc.set(e3.func), this.depthMask.set(e3.mask), this.depthRange.set(e3.range)) : this.depthTest.set(false);
          }
          setStencilMode(e3) {
            e3.test.func !== this.gl.ALWAYS || e3.mask ? (this.stencilTest.set(true), this.stencilMask.set(e3.mask), this.stencilOp.set([e3.fail, e3.depthFail, e3.pass]), this.stencilFunc.set({ func: e3.test.func, ref: e3.ref, mask: e3.test.mask })) : this.stencilTest.set(false);
          }
          setColorMode(i3) {
            t2(i3.blendFunction, e2.ColorMode.Replace) ? this.blend.set(false) : (this.blend.set(true), this.blendFunc.set(i3.blendFunction), this.blendColor.set(i3.blendColor)), this.colorMask.set(i3.mask);
          }
          unbindVAO() {
            this.extVertexArrayObject && this.bindVertexArrayOES.set(null);
          }
        }
        class Ce extends e2.Evented {
          constructor(t3, i3, o3, r3) {
            if (super(), this.id = t3, this.dispatcher = o3, this.type = "vector", this.minzoom = 0, this.maxzoom = 22, this.scheme = "xyz", this.tileSize = 512, this.reparseOverscaled = true, this.isTileClipped = true, this._loaded = false, e2.extend(this, e2.pick(i3, ["url", "scheme", "tileSize", "promoteId"])), this._options = e2.extend({ type: "vector" }, i3), this._collectResourceTiming = i3.collectResourceTiming, 512 !== this.tileSize)
              throw new Error("vector tile sources must have a tileSize of 512");
            this.setEventedParent(r3), this._tileWorkers = {}, this._deduped = new e2.DedupedRequest();
          }
          load(t3) {
            this._loaded = false, this.fire(new e2.Event("dataloading", { dataType: "source" }));
            const i3 = Array.isArray(this.map._language) ? this.map._language.join() : this.map._language, o3 = this.map._worldview;
            this._tileJSONRequest = O(this._options, this.map._requestManager, i3, o3, (r3, n3) => {
              this._tileJSONRequest = null, this._loaded = true, r3 ? (i3 && console.warn(`Ensure that your requested language string is a valid BCP-47 code or list of codes. Found: ${i3}`), o3 && 2 !== o3.length && console.warn(`Requested worldview strings must be a valid ISO alpha-2 code. Found: ${o3}`), this.fire(new e2.ErrorEvent(r3))) : n3 && (e2.extend(this, n3), n3.bounds && (this.tileBounds = new B(n3.bounds, this.minzoom, this.maxzoom)), e2.postTurnstileEvent(n3.tiles, this.map._requestManager._customAccessToken), this.fire(new e2.Event("data", { dataType: "source", sourceDataType: "metadata" })), this.fire(new e2.Event("data", { dataType: "source", sourceDataType: "content" }))), t3 && t3(r3);
            });
          }
          loaded() {
            return this._loaded;
          }
          hasTile(e3) {
            return !this.tileBounds || this.tileBounds.contains(e3.canonical);
          }
          onAdd(e3) {
            this.map = e3, this.load();
          }
          reload() {
            this.cancelTileJSONRequest(), this.load(() => this.map.style._clearSource(this.id));
          }
          setTiles(e3) {
            return this._options.tiles = e3, this.reload(), this;
          }
          setUrl(e3) {
            return this.url = e3, this._options.url = e3, this.reload(), this;
          }
          onRemove() {
            this.cancelTileJSONRequest();
          }
          serialize() {
            return e2.extend({}, this._options);
          }
          loadTile(t3, i3) {
            const o3 = this.map._requestManager.normalizeTileURL(t3.tileID.canonical.url(this.tiles, this.scheme)), r3 = { request: this.map._requestManager.transformRequest(o3, e2.ResourceType.Tile), data: void 0, uid: t3.uid, tileID: t3.tileID, tileZoom: t3.tileZoom, zoom: t3.tileID.overscaledZ, tileSize: this.tileSize * t3.tileID.overscaleFactor(), type: this.type, source: this.id, pixelRatio: e2.exported.devicePixelRatio, showCollisionBoxes: this.map.showCollisionBoxes, promoteId: this.promoteId, isSymbolTile: t3.isSymbolTile };
            if (r3.request.collectResourceTiming = this._collectResourceTiming, t3.actor && "expired" !== t3.state)
              "loading" === t3.state ? t3.reloadCallback = i3 : t3.request = t3.actor.send("reloadTile", r3, n3.bind(this));
            else if (t3.actor = this._tileWorkers[o3] = this._tileWorkers[o3] || this.dispatcher.getActor(), this.dispatcher.ready)
              t3.request = t3.actor.send("loadTile", r3, n3.bind(this), void 0, true);
            else {
              const i4 = e2.loadVectorTile.call({ deduped: this._deduped }, r3, (e3, i5) => {
                e3 || !i5 ? n3.call(this, e3) : (r3.data = { cacheControl: i5.cacheControl, expires: i5.expires, rawData: i5.rawData.slice(0) }, t3.actor && t3.actor.send("loadTile", r3, n3.bind(this), void 0, true));
              }, true);
              t3.request = { cancel: i4 };
            }
            function n3(o4, r4) {
              return delete t3.request, t3.aborted ? i3(null) : o4 && 404 !== o4.status ? i3(o4) : (r4 && r4.resourceTiming && (t3.resourceTiming = r4.resourceTiming), this.map._refreshExpiredTiles && r4 && t3.setExpiryData(r4), t3.loadVectorData(r4, this.map.painter), e2.cacheEntryPossiblyAdded(this.dispatcher), i3(null), void (t3.reloadCallback && (this.loadTile(t3, t3.reloadCallback), t3.reloadCallback = null)));
            }
          }
          abortTile(e3) {
            e3.request && (e3.request.cancel(), delete e3.request), e3.actor && e3.actor.send("abortTile", { uid: e3.uid, type: this.type, source: this.id });
          }
          unloadTile(e3) {
            e3.unloadVectorData(), e3.actor && e3.actor.send("removeTile", { uid: e3.uid, type: this.type, source: this.id });
          }
          hasTransition() {
            return false;
          }
          afterUpdate() {
            this._tileWorkers = {};
          }
          cancelTileJSONRequest() {
            this._tileJSONRequest && (this._tileJSONRequest.cancel(), this._tileJSONRequest = null);
          }
        }
        class Me extends e2.Evented {
          constructor(t3, i3, o3, r3) {
            super(), this.id = t3, this.dispatcher = o3, this.setEventedParent(r3), this.type = "raster", this.minzoom = 0, this.maxzoom = 22, this.roundZoom = true, this.scheme = "xyz", this.tileSize = 512, this._loaded = false, this._options = e2.extend({ type: "raster" }, i3), e2.extend(this, e2.pick(i3, ["url", "scheme", "tileSize"]));
          }
          load(t3) {
            this._loaded = false, this.fire(new e2.Event("dataloading", { dataType: "source" })), this._tileJSONRequest = O(this._options, this.map._requestManager, null, null, (i3, o3) => {
              this._tileJSONRequest = null, this._loaded = true, i3 ? this.fire(new e2.ErrorEvent(i3)) : o3 && (e2.extend(this, o3), o3.bounds && (this.tileBounds = new B(o3.bounds, this.minzoom, this.maxzoom)), e2.postTurnstileEvent(o3.tiles), this.fire(new e2.Event("data", { dataType: "source", sourceDataType: "metadata" })), this.fire(new e2.Event("data", { dataType: "source", sourceDataType: "content" }))), t3 && t3(i3);
            });
          }
          loaded() {
            return this._loaded;
          }
          onAdd(e3) {
            this.map = e3, this.load();
          }
          reload() {
            this.cancelTileJSONRequest(), this.load(() => this.map.style._clearSource(this.id));
          }
          setTiles(e3) {
            return this._options.tiles = e3, this.reload(), this;
          }
          setUrl(e3) {
            return this.url = e3, this._options.url = e3, this.reload(), this;
          }
          onRemove() {
            this.cancelTileJSONRequest();
          }
          serialize() {
            return e2.extend({}, this._options);
          }
          hasTile(e3) {
            return !this.tileBounds || this.tileBounds.contains(e3.canonical);
          }
          loadTile(t3, i3) {
            const o3 = e2.exported.devicePixelRatio >= 2, r3 = this.map._requestManager.normalizeTileURL(t3.tileID.canonical.url(this.tiles, this.scheme), o3, this.tileSize);
            t3.request = e2.getImage(this.map._requestManager.transformRequest(r3, e2.ResourceType.Tile), (o4, r4, n3, s3) => (delete t3.request, t3.aborted ? (t3.state = "unloaded", i3(null)) : o4 ? (t3.state = "errored", i3(o4)) : r4 ? (this.map._refreshExpiredTiles && t3.setExpiryData({ cacheControl: n3, expires: s3 }), t3.setTexture(r4, this.map.painter), t3.state = "loaded", e2.cacheEntryPossiblyAdded(this.dispatcher), void i3(null)) : i3(null)));
          }
          static loadTileData(e3, t3, i3) {
            e3.setTexture(t3, i3);
          }
          static unloadTileData(e3, t3) {
            e3.texture && t3.saveTileTexture(e3.texture);
          }
          abortTile(e3, t3) {
            e3.request && (e3.request.cancel(), delete e3.request), t3();
          }
          unloadTile(e3, t3) {
            e3.texture && this.map.painter.saveTileTexture(e3.texture), t3();
          }
          hasTransition() {
            return false;
          }
          cancelTileJSONRequest() {
            this._tileJSONRequest && (this._tileJSONRequest.cancel(), this._tileJSONRequest = null);
          }
        }
        function Ie(t3, i3, o3, r3, n3, s3, a3, l2) {
          const c3 = [t3, o3, n3, i3, r3, s3, 1, 1, 1], h3 = [a3, l2, 1], u3 = e2.adjoint([], c3), [_2, d3, p3] = e2.transformMat3(h3, h3, e2.transpose(u3, u3));
          return e2.multiply$1(c3, [_2, 0, 0, 0, d3, 0, 0, 0, p3], c3);
        }
        class Pe extends e2.Evented {
          constructor(e3, t3, i3, o3) {
            super(), this.id = e3, this.dispatcher = i3, this.coordinates = t3.coordinates, this.type = "image", this.minzoom = 0, this.maxzoom = 22, this.tileSize = 512, this.tiles = {}, this._loaded = false, this.setEventedParent(o3), this.options = t3, this._dirty = false;
          }
          load(t3, i3) {
            this._loaded = i3 || false, this.fire(new e2.Event("dataloading", { dataType: "source" })), this.url = this.options.url, this._imageRequest = e2.getImage(this.map._requestManager.transformRequest(this.url, e2.ResourceType.Image), (i4, o3) => {
              if (this._imageRequest = null, this._loaded = true, i4)
                this.fire(new e2.ErrorEvent(i4));
              else if (o3) {
                const { HTMLImageElement: i5 } = e2.window;
                this.image = o3 instanceof i5 ? e2.exported.getImageData(o3) : o3, this._dirty = true, this.width = this.image.width, this.height = this.image.height, t3 && (this.coordinates = t3), this._finishLoading();
              }
            });
          }
          loaded() {
            return this._loaded;
          }
          updateImage(e3) {
            return this.image && e3.url ? (this._imageRequest && e3.url !== this.options.url && (this._imageRequest.cancel(), this._imageRequest = null), this.options.url = e3.url, this.load(e3.coordinates, this._loaded), this) : this;
          }
          _finishLoading() {
            this.map && (this.setCoordinates(this.coordinates), this.fire(new e2.Event("data", { dataType: "source", sourceDataType: "metadata" })));
          }
          onAdd(e3) {
            this.map = e3, this.load();
          }
          onRemove() {
            this._imageRequest && (this._imageRequest.cancel(), this._imageRequest = null), this.texture && this.texture.destroy();
          }
          setCoordinates(t3) {
            this.coordinates = t3, this._boundsArray = void 0;
            const i3 = t3.map(e2.MercatorCoordinate.fromLngLat);
            return this.tileID = function(t4) {
              let i4 = 1 / 0, o3 = 1 / 0, r3 = -1 / 0, n3 = -1 / 0;
              for (const e3 of t4)
                i4 = Math.min(i4, e3.x), o3 = Math.min(o3, e3.y), r3 = Math.max(r3, e3.x), n3 = Math.max(n3, e3.y);
              const s3 = Math.max(r3 - i4, n3 - o3), a3 = Math.max(0, Math.floor(-Math.log(s3) / Math.LN2)), l2 = Math.pow(2, a3);
              return new e2.CanonicalTileID(a3, Math.floor((i4 + r3) / 2 * l2), Math.floor((o3 + n3) / 2 * l2));
            }(i3), this.minzoom = this.maxzoom = this.tileID.z, this.fire(new e2.Event("data", { dataType: "source", sourceDataType: "content" })), this;
          }
          _clear() {
            this._boundsArray = void 0;
          }
          _prepareData(t3) {
            for (const e3 in this.tiles) {
              const t4 = this.tiles[e3];
              "loaded" !== t4.state && (t4.state = "loaded", t4.texture = this.texture);
            }
            if (this._boundsArray)
              return;
            const i3 = e2.tileTransform(this.tileID, this.map.transform.projection), [o3, r3, n3, s3] = this.coordinates.map((t4) => {
              const o4 = i3.projection.project(t4[0], t4[1]);
              return e2.getTilePoint(i3, o4)._round();
            });
            this.perspectiveTransform = function(t4, i4, o4, r4, n4, s4, a4, l2, c3, h3) {
              const u3 = Ie(0, 0, t4, 0, 0, i4, t4, i4), _2 = Ie(o4, r4, n4, s4, a4, l2, c3, h3);
              return e2.multiply$1(_2, e2.adjoint(u3, u3), _2), [_2[6] / _2[8] * t4 / e2.EXTENT, _2[7] / _2[8] * i4 / e2.EXTENT];
            }(this.width, this.height, o3.x, o3.y, r3.x, r3.y, s3.x, s3.y, n3.x, n3.y);
            const a3 = this._boundsArray = new e2.StructArrayLayout4i8();
            a3.emplaceBack(o3.x, o3.y, 0, 0), a3.emplaceBack(r3.x, r3.y, e2.EXTENT, 0), a3.emplaceBack(s3.x, s3.y, 0, e2.EXTENT), a3.emplaceBack(n3.x, n3.y, e2.EXTENT, e2.EXTENT), this.boundsBuffer && this.boundsBuffer.destroy(), this.boundsBuffer = t3.createVertexBuffer(a3, e2.boundsAttributes.members), this.boundsSegments = e2.SegmentVector.simpleSegment(0, 0, 4, 2);
          }
          prepare() {
            if (0 === Object.keys(this.tiles).length || !this.image)
              return;
            const t3 = this.map.painter.context, i3 = t3.gl;
            this._dirty && (this.texture ? this.texture.update(this.image) : (this.texture = new e2.Texture(t3, this.image, i3.RGBA), this.texture.bind(i3.LINEAR, i3.CLAMP_TO_EDGE)), this._dirty = false), this._prepareData(t3);
          }
          loadTile(e3, t3) {
            this.tileID && this.tileID.equals(e3.tileID.canonical) ? (this.tiles[String(e3.tileID.wrap)] = e3, e3.buckets = {}, t3(null)) : (e3.state = "errored", t3(null));
          }
          serialize() {
            return { type: "image", url: this.options.url, coordinates: this.coordinates };
          }
          hasTransition() {
            return false;
          }
        }
        const Se = { vector: Ce, raster: Me, "raster-dem": class extends Me {
          constructor(t3, i3, o3, r3) {
            super(t3, i3, o3, r3), this.type = "raster-dem", this.maxzoom = 22, this._options = e2.extend({ type: "raster-dem" }, i3), this.encoding = i3.encoding || "mapbox";
          }
          loadTile(t3, i3) {
            const o3 = this.map._requestManager.normalizeTileURL(t3.tileID.canonical.url(this.tiles, this.scheme), false, this.tileSize);
            function r3(e3, o4) {
              e3 && (t3.state = "errored", i3(e3)), o4 && (t3.dem = o4, t3.dem.onDeserialize(), t3.needsHillshadePrepare = true, t3.needsDEMTextureUpload = true, t3.state = "loaded", i3(null));
            }
            t3.request = e2.getImage(this.map._requestManager.transformRequest(o3, e2.ResourceType.Tile), function(o4, n3, s3, a3) {
              if (delete t3.request, t3.aborted)
                t3.state = "unloaded", i3(null);
              else if (o4)
                t3.state = "errored", i3(o4);
              else if (n3) {
                this.map._refreshExpiredTiles && t3.setExpiryData({ cacheControl: s3, expires: a3 });
                const i4 = e2.window.ImageBitmap && n3 instanceof e2.window.ImageBitmap && (null == se && (se = e2.window.OffscreenCanvas && new e2.window.OffscreenCanvas(1, 1).getContext("2d") && "function" == typeof e2.window.createImageBitmap), se), o5 = 1 - (n3.width - e2.prevPowerOfTwo(n3.width)) / 2;
                o5 < 1 || t3.neighboringTiles || (t3.neighboringTiles = this._getNeighboringTiles(t3.tileID));
                const l2 = i4 ? n3 : e2.exported.getImageData(n3, o5), c3 = { uid: t3.uid, coord: t3.tileID, source: this.id, rawImageData: l2, encoding: this.encoding, padding: o5 };
                t3.actor && "expired" !== t3.state || (t3.actor = this.dispatcher.getActor(), t3.actor.send("loadDEMTile", c3, r3.bind(this), void 0, true));
              }
            }.bind(this));
          }
          _getNeighboringTiles(t3) {
            const i3 = t3.canonical, o3 = Math.pow(2, i3.z), r3 = (i3.x - 1 + o3) % o3, n3 = 0 === i3.x ? t3.wrap - 1 : t3.wrap, s3 = (i3.x + 1 + o3) % o3, a3 = i3.x + 1 === o3 ? t3.wrap + 1 : t3.wrap, l2 = {};
            return l2[new e2.OverscaledTileID(t3.overscaledZ, n3, i3.z, r3, i3.y).key] = { backfilled: false }, l2[new e2.OverscaledTileID(t3.overscaledZ, a3, i3.z, s3, i3.y).key] = { backfilled: false }, i3.y > 0 && (l2[new e2.OverscaledTileID(t3.overscaledZ, n3, i3.z, r3, i3.y - 1).key] = { backfilled: false }, l2[new e2.OverscaledTileID(t3.overscaledZ, t3.wrap, i3.z, i3.x, i3.y - 1).key] = { backfilled: false }, l2[new e2.OverscaledTileID(t3.overscaledZ, a3, i3.z, s3, i3.y - 1).key] = { backfilled: false }), i3.y + 1 < o3 && (l2[new e2.OverscaledTileID(t3.overscaledZ, n3, i3.z, r3, i3.y + 1).key] = { backfilled: false }, l2[new e2.OverscaledTileID(t3.overscaledZ, t3.wrap, i3.z, i3.x, i3.y + 1).key] = { backfilled: false }, l2[new e2.OverscaledTileID(t3.overscaledZ, a3, i3.z, s3, i3.y + 1).key] = { backfilled: false }), l2;
          }
          unloadTile(e3) {
            e3.demTexture && this.map.painter.saveTileTexture(e3.demTexture), e3.fbo && (e3.fbo.destroy(), delete e3.fbo), e3.dem && delete e3.dem, delete e3.neighboringTiles, e3.state = "unloaded";
          }
        }, geojson: class extends e2.Evented {
          constructor(t3, i3, o3, r3) {
            super(), this.id = t3, this.type = "geojson", this.minzoom = 0, this.maxzoom = 18, this.tileSize = 512, this.isTileClipped = true, this.reparseOverscaled = true, this._loaded = false, this.actor = o3.getActor(), this.setEventedParent(r3), this._data = i3.data, this._options = e2.extend({}, i3), this._collectResourceTiming = i3.collectResourceTiming, void 0 !== i3.maxzoom && (this.maxzoom = i3.maxzoom), i3.type && (this.type = i3.type), i3.attribution && (this.attribution = i3.attribution), this.promoteId = i3.promoteId;
            const n3 = e2.EXTENT / this.tileSize;
            this.workerOptions = e2.extend({ source: this.id, cluster: i3.cluster || false, geojsonVtOptions: { buffer: (void 0 !== i3.buffer ? i3.buffer : 128) * n3, tolerance: (void 0 !== i3.tolerance ? i3.tolerance : 0.375) * n3, extent: e2.EXTENT, maxZoom: this.maxzoom, lineMetrics: i3.lineMetrics || false, generateId: i3.generateId || false }, superclusterOptions: { maxZoom: void 0 !== i3.clusterMaxZoom ? i3.clusterMaxZoom : this.maxzoom - 1, minPoints: Math.max(2, i3.clusterMinPoints || 2), extent: e2.EXTENT, radius: (void 0 !== i3.clusterRadius ? i3.clusterRadius : 50) * n3, log: false, generateId: i3.generateId || false }, clusterProperties: i3.clusterProperties, filter: i3.filter }, i3.workerOptions);
          }
          onAdd(e3) {
            this.map = e3, this.setData(this._data);
          }
          setData(e3) {
            return this._data = e3, this._updateWorkerData(), this;
          }
          getClusterExpansionZoom(e3, t3) {
            return this.actor.send("geojson.getClusterExpansionZoom", { clusterId: e3, source: this.id }, t3), this;
          }
          getClusterChildren(e3, t3) {
            return this.actor.send("geojson.getClusterChildren", { clusterId: e3, source: this.id }, t3), this;
          }
          getClusterLeaves(e3, t3, i3, o3) {
            return this.actor.send("geojson.getClusterLeaves", { source: this.id, clusterId: e3, limit: t3, offset: i3 }, o3), this;
          }
          _updateWorkerData() {
            if (this._pendingLoad)
              return void (this._coalesce = true);
            this.fire(new e2.Event("dataloading", { dataType: "source" })), this._loaded = false;
            const t3 = e2.extend({}, this.workerOptions), i3 = this._data;
            "string" == typeof i3 ? (t3.request = this.map._requestManager.transformRequest(e2.exported.resolveURL(i3), e2.ResourceType.Source), t3.request.collectResourceTiming = this._collectResourceTiming) : t3.data = JSON.stringify(i3), this._pendingLoad = this.actor.send(`${this.type}.loadData`, t3, (t4, i4) => {
              if (this._loaded = true, this._pendingLoad = null, t4)
                this.fire(new e2.ErrorEvent(t4));
              else {
                const t5 = { dataType: "source", sourceDataType: this._metadataFired ? "content" : "metadata" };
                this._collectResourceTiming && i4 && i4.resourceTiming && i4.resourceTiming[this.id] && (t5.resourceTiming = i4.resourceTiming[this.id]), this.fire(new e2.Event("data", t5)), this._metadataFired = true;
              }
              this._coalesce && (this._updateWorkerData(), this._coalesce = false);
            });
          }
          loaded() {
            return this._loaded;
          }
          loadTile(t3, i3) {
            const o3 = t3.actor ? "reloadTile" : "loadTile";
            t3.actor = this.actor, t3.request = this.actor.send(o3, { type: this.type, uid: t3.uid, tileID: t3.tileID, tileZoom: t3.tileZoom, zoom: t3.tileID.overscaledZ, maxZoom: this.maxzoom, tileSize: this.tileSize, source: this.id, pixelRatio: e2.exported.devicePixelRatio, showCollisionBoxes: this.map.showCollisionBoxes, promoteId: this.promoteId }, (e3, r3) => (delete t3.request, t3.unloadVectorData(), t3.aborted ? i3(null) : e3 ? i3(e3) : (t3.loadVectorData(r3, this.map.painter, "reloadTile" === o3), i3(null))), void 0, "loadTile" === o3);
          }
          abortTile(e3) {
            e3.request && (e3.request.cancel(), delete e3.request), e3.aborted = true;
          }
          unloadTile(e3) {
            e3.unloadVectorData(), this.actor.send("removeTile", { uid: e3.uid, type: this.type, source: this.id });
          }
          onRemove() {
            this._pendingLoad && this._pendingLoad.cancel();
          }
          serialize() {
            return e2.extend({}, this._options, { type: this.type, data: this._data });
          }
          hasTransition() {
            return false;
          }
        }, video: class extends Pe {
          constructor(e3, t3, i3, o3) {
            super(e3, t3, i3, o3), this.roundZoom = true, this.type = "video", this.options = t3;
          }
          load() {
            this._loaded = false;
            const t3 = this.options;
            this.urls = [];
            for (const i3 of t3.urls)
              this.urls.push(this.map._requestManager.transformRequest(i3, e2.ResourceType.Source).url);
            e2.getVideo(this.urls, (t4, i3) => {
              this._loaded = true, t4 ? this.fire(new e2.ErrorEvent(t4)) : i3 && (this.video = i3, this.video.loop = true, this.video.setAttribute("playsinline", ""), this.video.addEventListener("playing", () => {
                this.map.triggerRepaint();
              }), this.map && this.video.play(), this._finishLoading());
            });
          }
          pause() {
            this.video && this.video.pause();
          }
          play() {
            this.video && this.video.play();
          }
          seek(t3) {
            if (this.video) {
              const i3 = this.video.seekable;
              t3 < i3.start(0) || t3 > i3.end(0) ? this.fire(new e2.ErrorEvent(new e2.ValidationError(`sources.${this.id}`, null, `Playback for this video can be set only between the ${i3.start(0)} and ${i3.end(0)}-second mark.`))) : this.video.currentTime = t3;
            }
          }
          getVideo() {
            return this.video;
          }
          onAdd(e3) {
            this.map || (this.map = e3, this.load(), this.video && (this.video.play(), this.setCoordinates(this.coordinates)));
          }
          prepare() {
            if (0 === Object.keys(this.tiles).length || this.video.readyState < 2)
              return;
            const t3 = this.map.painter.context, i3 = t3.gl;
            this.texture ? this.video.paused || (this.texture.bind(i3.LINEAR, i3.CLAMP_TO_EDGE), i3.texSubImage2D(i3.TEXTURE_2D, 0, 0, 0, i3.RGBA, i3.UNSIGNED_BYTE, this.video)) : (this.texture = new e2.Texture(t3, this.video, i3.RGBA), this.texture.bind(i3.LINEAR, i3.CLAMP_TO_EDGE), this.width = this.video.videoWidth, this.height = this.video.videoHeight), this._prepareData(t3);
          }
          serialize() {
            return { type: "video", urls: this.urls, coordinates: this.coordinates };
          }
          hasTransition() {
            return this.video && !this.video.paused;
          }
        }, image: Pe, canvas: class extends Pe {
          constructor(t3, i3, o3, r3) {
            super(t3, i3, o3, r3), i3.coordinates ? Array.isArray(i3.coordinates) && 4 === i3.coordinates.length && !i3.coordinates.some((e3) => !Array.isArray(e3) || 2 !== e3.length || e3.some((e4) => "number" != typeof e4)) || this.fire(new e2.ErrorEvent(new e2.ValidationError(`sources.${t3}`, null, '"coordinates" property must be an array of 4 longitude/latitude array pairs'))) : this.fire(new e2.ErrorEvent(new e2.ValidationError(`sources.${t3}`, null, 'missing required property "coordinates"'))), i3.animate && "boolean" != typeof i3.animate && this.fire(new e2.ErrorEvent(new e2.ValidationError(`sources.${t3}`, null, 'optional "animate" property must be a boolean value'))), i3.canvas ? "string" == typeof i3.canvas || i3.canvas instanceof e2.window.HTMLCanvasElement || this.fire(new e2.ErrorEvent(new e2.ValidationError(`sources.${t3}`, null, '"canvas" must be either a string representing the ID of the canvas element from which to read, or an HTMLCanvasElement instance'))) : this.fire(new e2.ErrorEvent(new e2.ValidationError(`sources.${t3}`, null, 'missing required property "canvas"'))), this.options = i3, this.animate = void 0 === i3.animate || i3.animate;
          }
          load() {
            this._loaded = true, this.canvas || (this.canvas = this.options.canvas instanceof e2.window.HTMLCanvasElement ? this.options.canvas : e2.window.document.getElementById(this.options.canvas)), this.width = this.canvas.width, this.height = this.canvas.height, this._hasInvalidDimensions() ? this.fire(new e2.ErrorEvent(new Error("Canvas dimensions cannot be less than or equal to zero."))) : (this.play = function() {
              this._playing = true, this.map.triggerRepaint();
            }, this.pause = function() {
              this._playing && (this.prepare(), this._playing = false);
            }, this._finishLoading());
          }
          getCanvas() {
            return this.canvas;
          }
          onAdd(e3) {
            this.map = e3, this.load(), this.canvas && this.animate && this.play();
          }
          onRemove() {
            this.pause();
          }
          prepare() {
            let t3 = false;
            if (this.canvas.width !== this.width && (this.width = this.canvas.width, t3 = true), this.canvas.height !== this.height && (this.height = this.canvas.height, t3 = true), this._hasInvalidDimensions())
              return;
            if (0 === Object.keys(this.tiles).length)
              return;
            const i3 = this.map.painter.context;
            this.texture ? (t3 || this._playing) && this.texture.update(this.canvas, { premultiply: true }) : this.texture = new e2.Texture(i3, this.canvas, i3.gl.RGBA, { premultiply: true }), this._prepareData(i3);
          }
          serialize() {
            return { type: "canvas", coordinates: this.coordinates };
          }
          hasTransition() {
            return this._playing;
          }
          _hasInvalidDimensions() {
            for (const e3 of [this.canvas.width, this.canvas.height])
              if (isNaN(e3) || e3 <= 0)
                return true;
            return false;
          }
        }, custom: class extends e2.Evented {
          constructor(t3, i3, o3, r3) {
            super(), this.id = t3, this.type = "custom", this._dataType = "raster", this._dispatcher = o3, this._implementation = i3, this.setEventedParent(r3), this.scheme = "xyz", this.minzoom = 0, this.maxzoom = 22, this.tileSize = 512, this._loaded = false, this.roundZoom = true, this._implementation || this.fire(new e2.ErrorEvent(new Error(`Missing implementation for ${this.id} custom source`))), this._implementation.loadTile || this.fire(new e2.ErrorEvent(new Error(`Missing loadTile implementation for ${this.id} custom source`))), this._implementation.bounds && (this.tileBounds = new B(this._implementation.bounds, this.minzoom, this.maxzoom)), i3.update = this._update.bind(this), i3.clearTiles = this._clearTiles.bind(this), i3.coveringTiles = this._coveringTiles.bind(this), e2.extend(this, e2.pick(i3, ["dataType", "scheme", "minzoom", "maxzoom", "tileSize", "attribution", "minTileCacheSize", "maxTileCacheSize"]));
          }
          serialize() {
            return e2.pick(this, ["type", "scheme", "minzoom", "maxzoom", "tileSize", "attribution"]);
          }
          load() {
            this._loaded = true, this.fire(new e2.Event("data", { dataType: "source", sourceDataType: "metadata" })), this.fire(new e2.Event("data", { dataType: "source", sourceDataType: "content" }));
          }
          loaded() {
            return this._loaded;
          }
          onAdd(t3) {
            this._map = t3, this._loaded = false, this.fire(new e2.Event("dataloading", { dataType: "source" })), this._implementation.onAdd && this._implementation.onAdd(t3), this.load();
          }
          onRemove(e3) {
            this._implementation.onRemove && this._implementation.onRemove(e3);
          }
          hasTile(e3) {
            if (this._implementation.hasTile) {
              const { x: t3, y: i3, z: o3 } = e3.canonical;
              return this._implementation.hasTile({ x: t3, y: i3, z: o3 });
            }
            return !this.tileBounds || this.tileBounds.contains(e3.canonical);
          }
          loadTile(t3, i3) {
            const { x: o3, y: r3, z: n3 } = t3.tileID.canonical, s3 = new e2.window.AbortController();
            t3.request = Promise.resolve(this._implementation.loadTile({ x: o3, y: r3, z: n3 }, { signal: s3.signal })).then(function(o4) {
              return delete t3.request, t3.aborted ? (t3.state = "unloaded", i3(null)) : void 0 === o4 ? (t3.state = "errored", i3(null)) : null === o4 ? (this.loadTileData(t3, { width: this.tileSize, height: this.tileSize, data: null }), t3.state = "loaded", i3(null)) : function(t4) {
                return t4 instanceof e2.window.ImageData || t4 instanceof e2.window.HTMLCanvasElement || t4 instanceof e2.window.ImageBitmap || t4 instanceof e2.window.HTMLImageElement;
              }(o4) ? (this.loadTileData(t3, o4), t3.state = "loaded", void i3(null)) : (t3.state = "errored", i3(new Error(`Can't infer data type for ${this.id}, only raster data supported at the moment`)));
            }.bind(this)).catch((e3) => {
              20 !== e3.code && (t3.state = "errored", i3(e3));
            }), t3.request.cancel = () => s3.abort();
          }
          loadTileData(e3, t3) {
            Me.loadTileData(e3, t3, this._map.painter);
          }
          unloadTileData(e3) {
            Me.unloadTileData(e3, this._map.painter);
          }
          unloadTile(e3, t3) {
            if (this.unloadTileData(e3), this._implementation.unloadTile) {
              const { x: t4, y: i3, z: o3 } = e3.tileID.canonical;
              this._implementation.unloadTile({ x: t4, y: i3, z: o3 });
            }
            t3();
          }
          abortTile(e3, t3) {
            e3.request && e3.request.cancel && (e3.request.cancel(), delete e3.request), t3();
          }
          hasTransition() {
            return false;
          }
          _coveringTiles() {
            return this._map.transform.coveringTiles({ tileSize: this.tileSize, minzoom: this.minzoom, maxzoom: this.maxzoom, roundZoom: this.roundZoom }).map((e3) => ({ x: e3.canonical.x, y: e3.canonical.y, z: e3.canonical.z }));
          }
          _clearTiles() {
            this._map.style._clearSource(this.id);
          }
          _update() {
            this.fire(new e2.Event("data", { dataType: "source", sourceDataType: "content" }));
          }
        } }, De = function(t3, i3, o3, r3) {
          const n3 = new Se[i3.type](t3, i3, o3, r3);
          if (n3.id !== t3)
            throw new Error(`Expected Source id to be ${t3} instead of ${n3.id}`);
          return e2.bindAll(["load", "abort", "unload", "serialize", "prepare"], n3), n3;
        };
        function Le(t3, i3) {
          const o3 = e2.identity([]);
          return e2.scale(o3, o3, [0.5 * t3.width, 0.5 * -t3.height, 1]), e2.translate(o3, o3, [1, -1, 0]), e2.multiply(o3, o3, t3.calculateProjMatrix(i3.toUnwrapped())), Float32Array.from(o3);
        }
        function Ae(e3, t3, i3, o3, r3, n3, s3, a3 = false) {
          const l2 = e3.tilesIn(o3, s3, a3);
          l2.sort(Re);
          const c3 = [];
          for (const o4 of l2)
            c3.push({ wrappedTileID: o4.tile.tileID.wrapped().key, queryResults: o4.tile.queryRenderedFeatures(t3, i3, e3._state, o4, r3, n3, Le(e3.transform, o4.tile.tileID), a3) });
          const h3 = function(e4) {
            const t4 = {}, i4 = {};
            for (const o4 of e4) {
              const e5 = o4.queryResults, r4 = o4.wrappedTileID, n4 = i4[r4] = i4[r4] || {};
              for (const i5 in e5) {
                const o5 = e5[i5], r5 = n4[i5] = n4[i5] || {}, s4 = t4[i5] = t4[i5] || [];
                for (const e6 of o5)
                  r5[e6.featureIndex] || (r5[e6.featureIndex] = true, s4.push(e6));
              }
            }
            return t4;
          }(c3);
          for (const t4 in h3)
            h3[t4].forEach((t5) => {
              const i4 = t5.feature, o4 = i4.layer;
              o4 && "background" !== o4.type && "sky" !== o4.type && (i4.source = o4.source, o4["source-layer"] && (i4.sourceLayer = o4["source-layer"]), i4.state = void 0 !== i4.id ? e3.getFeatureState(o4["source-layer"], i4.id) : {});
            });
          return h3;
        }
        function ze(e3, t3) {
          const i3 = e3.getRenderableIds().map((t4) => e3.getTileByID(t4)), o3 = [], r3 = {};
          for (let e4 = 0; e4 < i3.length; e4++) {
            const n3 = i3[e4], s3 = n3.tileID.canonical.key;
            r3[s3] || (r3[s3] = true, n3.querySourceFeatures(o3, t3));
          }
          return o3;
        }
        function Re(e3, t3) {
          const i3 = e3.tileID, o3 = t3.tileID;
          return i3.overscaledZ - o3.overscaledZ || i3.canonical.y - o3.canonical.y || i3.wrap - o3.wrap || i3.canonical.x - o3.canonical.x;
        }
        function Oe() {
          return null != dn.workerClass ? new dn.workerClass() : new e2.window.Worker(dn.workerUrl);
        }
        const Be = "mapboxgl_preloaded_worker_pool";
        class ke {
          constructor() {
            this.active = {};
          }
          acquire(e3) {
            if (!this.workers)
              for (this.workers = []; this.workers.length < ke.workerCount; )
                this.workers.push(new Oe());
            return this.active[e3] = true, this.workers.slice();
          }
          release(e3) {
            delete this.active[e3], 0 === this.numActive() && (this.workers.forEach((e4) => {
              e4.terminate();
            }), this.workers = null);
          }
          isPreloaded() {
            return !!this.active[Be];
          }
          numActive() {
            return Object.keys(this.active).length;
          }
        }
        let Fe;
        function Ue() {
          return Fe || (Fe = new ke()), Fe;
        }
        function Ne(t3, i3) {
          const o3 = {};
          for (const e3 in t3)
            "ref" !== e3 && (o3[e3] = t3[e3]);
          return e2.refProperties.forEach((e3) => {
            e3 in i3 && (o3[e3] = i3[e3]);
          }), o3;
        }
        function je(e3) {
          e3 = e3.slice();
          const t3 = /* @__PURE__ */ Object.create(null);
          for (let i3 = 0; i3 < e3.length; i3++)
            t3[e3[i3].id] = e3[i3];
          for (let i3 = 0; i3 < e3.length; i3++)
            "ref" in e3[i3] && (e3[i3] = Ne(e3[i3], t3[e3[i3].ref]));
          return e3;
        }
        ke.workerCount = 2;
        const Ge = { setStyle: "setStyle", addLayer: "addLayer", removeLayer: "removeLayer", setPaintProperty: "setPaintProperty", setLayoutProperty: "setLayoutProperty", setFilter: "setFilter", addSource: "addSource", removeSource: "removeSource", setGeoJSONSourceData: "setGeoJSONSourceData", setLayerZoomRange: "setLayerZoomRange", setLayerProperty: "setLayerProperty", setCenter: "setCenter", setZoom: "setZoom", setBearing: "setBearing", setPitch: "setPitch", setSprite: "setSprite", setGlyphs: "setGlyphs", setTransition: "setTransition", setLight: "setLight", setTerrain: "setTerrain", setFog: "setFog", setProjection: "setProjection" };
        function Ze(e3, t3, i3) {
          i3.push({ command: Ge.addSource, args: [e3, t3[e3]] });
        }
        function Ve(e3, t3, i3) {
          t3.push({ command: Ge.removeSource, args: [e3] }), i3[e3] = true;
        }
        function We(e3, t3, i3, o3) {
          Ve(e3, i3, o3), Ze(e3, t3, i3);
        }
        function Xe(e3, i3, o3) {
          let r3;
          for (r3 in e3[o3])
            if (e3[o3].hasOwnProperty(r3) && "data" !== r3 && !t2(e3[o3][r3], i3[o3][r3]))
              return false;
          for (r3 in i3[o3])
            if (i3[o3].hasOwnProperty(r3) && "data" !== r3 && !t2(e3[o3][r3], i3[o3][r3]))
              return false;
          return true;
        }
        function qe(e3, i3, o3, r3, n3, s3) {
          let a3;
          for (a3 in i3 = i3 || {}, e3 = e3 || {})
            e3.hasOwnProperty(a3) && (t2(e3[a3], i3[a3]) || o3.push({ command: s3, args: [r3, a3, i3[a3], n3] }));
          for (a3 in i3)
            i3.hasOwnProperty(a3) && !e3.hasOwnProperty(a3) && (t2(e3[a3], i3[a3]) || o3.push({ command: s3, args: [r3, a3, i3[a3], n3] }));
        }
        function $e(e3) {
          return e3.id;
        }
        function He(e3, t3) {
          return e3[t3.id] = t3, e3;
        }
        class Ye {
          constructor(e3, t3) {
            this.reset(e3, t3);
          }
          reset(e3, t3) {
            this.points = e3 || [], this._distances = [0];
            for (let e4 = 1; e4 < this.points.length; e4++)
              this._distances[e4] = this._distances[e4 - 1] + this.points[e4].dist(this.points[e4 - 1]);
            this.length = this._distances[this._distances.length - 1], this.padding = Math.min(t3 || 0, 0.5 * this.length), this.paddedLength = this.length - 2 * this.padding;
          }
          lerp(t3) {
            if (1 === this.points.length)
              return this.points[0];
            t3 = e2.clamp(t3, 0, 1);
            let i3 = 1, o3 = this._distances[i3];
            const r3 = t3 * this.paddedLength + this.padding;
            for (; o3 < r3 && i3 < this._distances.length; )
              o3 = this._distances[++i3];
            const n3 = i3 - 1, s3 = this._distances[n3], a3 = o3 - s3, l2 = a3 > 0 ? (r3 - s3) / a3 : 0;
            return this.points[n3].mult(1 - l2).add(this.points[i3].mult(l2));
          }
        }
        class Ke {
          constructor(e3, t3, i3) {
            const o3 = this.boxCells = [], r3 = this.circleCells = [];
            this.xCellCount = Math.ceil(e3 / i3), this.yCellCount = Math.ceil(t3 / i3);
            for (let e4 = 0; e4 < this.xCellCount * this.yCellCount; e4++)
              o3.push([]), r3.push([]);
            this.circleKeys = [], this.boxKeys = [], this.bboxes = [], this.circles = [], this.width = e3, this.height = t3, this.xScale = this.xCellCount / e3, this.yScale = this.yCellCount / t3, this.boxUid = 0, this.circleUid = 0;
          }
          keysLength() {
            return this.boxKeys.length + this.circleKeys.length;
          }
          insert(e3, t3, i3, o3, r3) {
            this._forEachCell(t3, i3, o3, r3, this._insertBoxCell, this.boxUid++), this.boxKeys.push(e3), this.bboxes.push(t3), this.bboxes.push(i3), this.bboxes.push(o3), this.bboxes.push(r3);
          }
          insertCircle(e3, t3, i3, o3) {
            this._forEachCell(t3 - o3, i3 - o3, t3 + o3, i3 + o3, this._insertCircleCell, this.circleUid++), this.circleKeys.push(e3), this.circles.push(t3), this.circles.push(i3), this.circles.push(o3);
          }
          _insertBoxCell(e3, t3, i3, o3, r3, n3) {
            this.boxCells[r3].push(n3);
          }
          _insertCircleCell(e3, t3, i3, o3, r3, n3) {
            this.circleCells[r3].push(n3);
          }
          _query(e3, t3, i3, o3, r3, n3) {
            if (i3 < 0 || e3 > this.width || o3 < 0 || t3 > this.height)
              return !r3 && [];
            const s3 = [];
            if (e3 <= 0 && t3 <= 0 && this.width <= i3 && this.height <= o3) {
              if (r3)
                return true;
              for (let e4 = 0; e4 < this.boxKeys.length; e4++)
                s3.push({ key: this.boxKeys[e4], x1: this.bboxes[4 * e4], y1: this.bboxes[4 * e4 + 1], x2: this.bboxes[4 * e4 + 2], y2: this.bboxes[4 * e4 + 3] });
              for (let e4 = 0; e4 < this.circleKeys.length; e4++) {
                const t4 = this.circles[3 * e4], i4 = this.circles[3 * e4 + 1], o4 = this.circles[3 * e4 + 2];
                s3.push({ key: this.circleKeys[e4], x1: t4 - o4, y1: i4 - o4, x2: t4 + o4, y2: i4 + o4 });
              }
              return n3 ? s3.filter(n3) : s3;
            }
            return this._forEachCell(e3, t3, i3, o3, this._queryCell, s3, { hitTest: r3, seenUids: { box: {}, circle: {} } }, n3), r3 ? s3.length > 0 : s3;
          }
          _queryCircle(e3, t3, i3, o3, r3) {
            const n3 = e3 - i3, s3 = e3 + i3, a3 = t3 - i3, l2 = t3 + i3;
            if (s3 < 0 || n3 > this.width || l2 < 0 || a3 > this.height)
              return !o3 && [];
            const c3 = [];
            return this._forEachCell(n3, a3, s3, l2, this._queryCellCircle, c3, { hitTest: o3, circle: { x: e3, y: t3, radius: i3 }, seenUids: { box: {}, circle: {} } }, r3), o3 ? c3.length > 0 : c3;
          }
          query(e3, t3, i3, o3, r3) {
            return this._query(e3, t3, i3, o3, false, r3);
          }
          hitTest(e3, t3, i3, o3, r3) {
            return this._query(e3, t3, i3, o3, true, r3);
          }
          hitTestCircle(e3, t3, i3, o3) {
            return this._queryCircle(e3, t3, i3, true, o3);
          }
          _queryCell(e3, t3, i3, o3, r3, n3, s3, a3) {
            const l2 = s3.seenUids, c3 = this.boxCells[r3];
            if (null !== c3) {
              const r4 = this.bboxes;
              for (const h4 of c3)
                if (!l2.box[h4]) {
                  l2.box[h4] = true;
                  const c4 = 4 * h4;
                  if (e3 <= r4[c4 + 2] && t3 <= r4[c4 + 3] && i3 >= r4[c4 + 0] && o3 >= r4[c4 + 1] && (!a3 || a3(this.boxKeys[h4]))) {
                    if (s3.hitTest)
                      return n3.push(true), true;
                    n3.push({ key: this.boxKeys[h4], x1: r4[c4], y1: r4[c4 + 1], x2: r4[c4 + 2], y2: r4[c4 + 3] });
                  }
                }
            }
            const h3 = this.circleCells[r3];
            if (null !== h3) {
              const r4 = this.circles;
              for (const c4 of h3)
                if (!l2.circle[c4]) {
                  l2.circle[c4] = true;
                  const h4 = 3 * c4;
                  if (this._circleAndRectCollide(r4[h4], r4[h4 + 1], r4[h4 + 2], e3, t3, i3, o3) && (!a3 || a3(this.circleKeys[c4]))) {
                    if (s3.hitTest)
                      return n3.push(true), true;
                    {
                      const e4 = r4[h4], t4 = r4[h4 + 1], i4 = r4[h4 + 2];
                      n3.push({ key: this.circleKeys[c4], x1: e4 - i4, y1: t4 - i4, x2: e4 + i4, y2: t4 + i4 });
                    }
                  }
                }
            }
          }
          _queryCellCircle(e3, t3, i3, o3, r3, n3, s3, a3) {
            const l2 = s3.circle, c3 = s3.seenUids, h3 = this.boxCells[r3];
            if (null !== h3) {
              const e4 = this.bboxes;
              for (const t4 of h3)
                if (!c3.box[t4]) {
                  c3.box[t4] = true;
                  const i4 = 4 * t4;
                  if (this._circleAndRectCollide(l2.x, l2.y, l2.radius, e4[i4 + 0], e4[i4 + 1], e4[i4 + 2], e4[i4 + 3]) && (!a3 || a3(this.boxKeys[t4])))
                    return n3.push(true), true;
                }
            }
            const u3 = this.circleCells[r3];
            if (null !== u3) {
              const e4 = this.circles;
              for (const t4 of u3)
                if (!c3.circle[t4]) {
                  c3.circle[t4] = true;
                  const i4 = 3 * t4;
                  if (this._circlesCollide(e4[i4], e4[i4 + 1], e4[i4 + 2], l2.x, l2.y, l2.radius) && (!a3 || a3(this.circleKeys[t4])))
                    return n3.push(true), true;
                }
            }
          }
          _forEachCell(e3, t3, i3, o3, r3, n3, s3, a3) {
            const l2 = this._convertToXCellCoord(e3), c3 = this._convertToYCellCoord(t3), h3 = this._convertToXCellCoord(i3), u3 = this._convertToYCellCoord(o3);
            for (let _2 = l2; _2 <= h3; _2++)
              for (let l3 = c3; l3 <= u3; l3++)
                if (r3.call(this, e3, t3, i3, o3, this.xCellCount * l3 + _2, n3, s3, a3))
                  return;
          }
          _convertToXCellCoord(e3) {
            return Math.max(0, Math.min(this.xCellCount - 1, Math.floor(e3 * this.xScale)));
          }
          _convertToYCellCoord(e3) {
            return Math.max(0, Math.min(this.yCellCount - 1, Math.floor(e3 * this.yScale)));
          }
          _circlesCollide(e3, t3, i3, o3, r3, n3) {
            const s3 = o3 - e3, a3 = r3 - t3, l2 = i3 + n3;
            return l2 * l2 > s3 * s3 + a3 * a3;
          }
          _circleAndRectCollide(e3, t3, i3, o3, r3, n3, s3) {
            const a3 = (n3 - o3) / 2, l2 = Math.abs(e3 - (o3 + a3));
            if (l2 > a3 + i3)
              return false;
            const c3 = (s3 - r3) / 2, h3 = Math.abs(t3 - (r3 + c3));
            if (h3 > c3 + i3)
              return false;
            if (l2 <= a3 || h3 <= c3)
              return true;
            const u3 = l2 - a3, _2 = h3 - c3;
            return u3 * u3 + _2 * _2 <= i3 * i3;
          }
        }
        const Je = { unknown: 0, flipRequired: 1, flipNotRequired: 2 }, Qe = Math.tan(85 * Math.PI / 180);
        function et(t3, i3, o3, r3, n3, s3, a3) {
          const l2 = e2.create();
          if (o3)
            if ("globe" === s3.name) {
              const t4 = e2.calculateGlobeLabelMatrix(n3, i3);
              e2.multiply(l2, l2, t4);
            } else {
              const t4 = v2([], a3);
              l2[0] = t4[0], l2[1] = t4[1], l2[4] = t4[2], l2[5] = t4[3], r3 || e2.rotateZ(l2, l2, n3.angle);
            }
          else
            e2.multiply(l2, n3.labelPlaneMatrix, t3);
          return l2;
        }
        function tt(e3, t3, i3, o3, r3, n3, s3) {
          const a3 = et(e3, t3, i3, o3, r3, n3, s3);
          return "globe" === n3.name && i3 || (a3[2] = a3[6] = a3[10] = a3[14] = 0), a3;
        }
        function it(t3, i3, o3, r3, n3, s3, a3) {
          if (o3) {
            if ("globe" === s3.name) {
              const l2 = et(t3, i3, o3, r3, n3, s3, a3);
              return e2.invert(l2, l2), e2.multiply(l2, t3, l2), l2;
            }
            {
              const i4 = e2.clone(t3), o4 = e2.identity([]);
              return o4[0] = a3[0], o4[1] = a3[1], o4[4] = a3[2], o4[5] = a3[3], e2.multiply(i4, i4, o4), r3 || e2.rotateZ(i4, i4, -n3.angle), i4;
            }
          }
          return n3.glCoordMatrix;
        }
        function ot(t3, i3, o3, r3) {
          const n3 = [t3, i3, o3, 1];
          o3 ? e2.transformMat4$1(n3, n3, r3) : pt(n3, n3, r3);
          const s3 = n3[3];
          return n3[0] /= s3, n3[1] /= s3, n3[2] /= s3, n3;
        }
        function rt(e3, t3) {
          return Math.min(0.5 + e3 / t3 * 0.5, 1.5);
        }
        function nt(e3, t3) {
          const i3 = e3[0] / e3[3], o3 = e3[1] / e3[3];
          return i3 >= -t3[0] && i3 <= t3[0] && o3 >= -t3[1] && o3 <= t3[1];
        }
        function st(t3, i3, o3, r3, n3, s3, a3, l2, c3, h3) {
          const u3 = o3.transform, _2 = r3 ? t3.textSizeData : t3.iconSizeData, d3 = e2.evaluateSizeForZoom(_2, o3.transform.zoom), p3 = "globe" === u3.projection.name, m3 = [256 / o3.width * 2 + 1, 256 / o3.height * 2 + 1], f3 = r3 ? t3.text.dynamicLayoutVertexArray : t3.icon.dynamicLayoutVertexArray;
          f3.clear();
          let g3 = null;
          p3 && (g3 = r3 ? t3.text.globeExtVertexArray : t3.icon.globeExtVertexArray);
          const v3 = t3.lineVertexArray, x3 = r3 ? t3.text.placedSymbolArray : t3.icon.placedSymbolArray, y3 = o3.transform.width / o3.transform.height;
          let b2, w2 = false;
          for (let r4 = 0; r4 < x3.length; r4++) {
            const p4 = x3.get(r4), { numGlyphs: T2, writingMode: E3 } = p4;
            if (E3 !== e2.WritingMode.vertical || w2 || b2 === e2.WritingMode.horizontal || (w2 = true), b2 = E3, (p4.hidden || E3 === e2.WritingMode.vertical) && !w2) {
              dt(T2, f3);
              continue;
            }
            w2 = false;
            const C2 = new e2.Point(p4.tileAnchorX, p4.tileAnchorY);
            let { x: M2, y: I2, z: P2 } = u3.projection.projectTilePoint(C2.x, C2.y, h3.canonical);
            if (c3) {
              const [e3, t4, i4] = c3(C2);
              M2 += e3, I2 += t4, P2 += i4;
            }
            const S2 = [M2, I2, P2, 1];
            if (e2.transformMat4$1(S2, S2, i3), !nt(S2, m3)) {
              dt(T2, f3);
              continue;
            }
            const D2 = rt(o3.transform.cameraToCenterDistance, S2[3]), L2 = e2.evaluateSizeForFeature(_2, d3, p4), A2 = a3 ? L2 / D2 : L2 * D2, z2 = ot(M2, I2, P2, n3);
            if (z2[3] <= 0) {
              dt(T2, f3);
              continue;
            }
            let R2 = {};
            const O2 = a3 ? null : c3, B2 = ct(p4, A2, false, l2, i3, n3, s3, t3.glyphOffsetArray, v3, f3, g3, z2, C2, R2, y3, O2, u3.projection, h3, a3);
            w2 = B2.useVertical, O2 && B2.needsFlipping && (R2 = {}), (B2.notEnoughRoom || w2 || B2.needsFlipping && ct(p4, A2, true, l2, i3, n3, s3, t3.glyphOffsetArray, v3, f3, g3, z2, C2, R2, y3, O2, u3.projection, h3, a3).notEnoughRoom) && dt(T2, f3);
          }
          r3 ? (t3.text.dynamicLayoutVertexBuffer.updateData(f3), g3 && t3.text.globeExtVertexBuffer.updateData(g3)) : (t3.icon.dynamicLayoutVertexBuffer.updateData(f3), g3 && t3.icon.globeExtVertexBuffer.updateData(g3));
        }
        function at(e3, t3, i3, o3, r3, n3, s3, a3, l2, c3, h3, u3, _2, d3, p3, m3) {
          const { lineStartIndex: f3, glyphStartIndex: g3, segment: v3 } = a3, x3 = g3 + a3.numGlyphs, y3 = f3 + a3.lineLength, b2 = t3.getoffsetX(g3), w2 = t3.getoffsetX(x3 - 1), T2 = _t(e3 * b2, i3, o3, r3, n3, s3, v3, f3, y3, l2, c3, h3, u3, _2, true, d3, p3, m3);
          if (!T2)
            return null;
          const E3 = _t(e3 * w2, i3, o3, r3, n3, s3, v3, f3, y3, l2, c3, h3, u3, _2, true, d3, p3, m3);
          return E3 ? { first: T2, last: E3 } : null;
        }
        function lt(t3, i3, o3, r3) {
          return t3 === e2.WritingMode.horizontal && Math.abs(r3) > Math.abs(o3) ? { useVertical: true } : t3 === e2.WritingMode.vertical ? r3 > 0 ? { needsFlipping: true } : null : i3 !== Je.unknown && function(e3, t4) {
            return 0 === e3 || Math.abs(t4 / e3) > Qe;
          }(o3, r3) ? i3 === Je.flipRequired ? { needsFlipping: true } : null : o3 < 0 ? { needsFlipping: true } : null;
        }
        function ct(t3, i3, o3, r3, n3, s3, a3, l2, c3, h3, u3, _2, d3, p3, m3, f3, g3, v3, x3) {
          const y3 = i3 / 24, b2 = t3.lineOffsetX * y3, w2 = t3.lineOffsetY * y3, { lineStartIndex: T2, glyphStartIndex: E3, numGlyphs: C2, segment: M2, writingMode: I2, flipState: P2 } = t3, S2 = T2 + t3.lineLength, D2 = (t4) => {
            if (u3) {
              const [i5, o5, r5] = t4.up, n4 = h3.length;
              e2.updateGlobeVertexNormal(u3, n4 + 0, i5, o5, r5), e2.updateGlobeVertexNormal(u3, n4 + 1, i5, o5, r5), e2.updateGlobeVertexNormal(u3, n4 + 2, i5, o5, r5), e2.updateGlobeVertexNormal(u3, n4 + 3, i5, o5, r5);
            }
            const [i4, o4, r4] = t4.point;
            e2.addDynamicAttributes(h3, i4, o4, r4, t4.angle);
          };
          if (C2 > 1) {
            const e3 = at(y3, l2, b2, w2, o3, _2, d3, t3, c3, s3, p3, f3, false, g3, v3, x3);
            if (!e3)
              return { notEnoughRoom: true };
            if (r3 && !o3) {
              let [i4, o4, r4] = e3.first.point, [n4, s4, l3] = e3.last.point;
              [i4, o4] = ot(i4, o4, r4, a3), [n4, s4] = ot(n4, s4, l3, a3);
              const c4 = lt(I2, P2, (n4 - i4) * m3, s4 - o4);
              if (t3.flipState = c4 && c4.needsFlipping ? Je.flipRequired : Je.flipNotRequired, c4)
                return c4;
            }
            D2(e3.first);
            for (let e4 = E3 + 1; e4 < E3 + C2 - 1; e4++) {
              const t4 = _t(y3 * l2.getoffsetX(e4), b2, w2, o3, _2, d3, M2, T2, S2, c3, s3, p3, f3, false, false, g3, v3, x3);
              if (!t4)
                return h3.length -= 4 * (e4 - E3), { notEnoughRoom: true };
              D2(t4);
            }
            D2(e3.last);
          } else {
            if (r3 && !o3) {
              const i5 = ot(d3.x, d3.y, 0, n3), o4 = T2 + M2 + 1, r4 = new e2.Point(c3.getx(o4), c3.gety(o4)), s4 = ot(r4.x, r4.y, 0, n3), a4 = s4[3] > 0 ? s4 : ut(d3, r4, i5, 1, n3, void 0, g3, v3.canonical), l3 = lt(I2, P2, (a4[0] - i5[0]) * m3, a4[1] - i5[1]);
              if (t3.flipState = l3 && l3.needsFlipping ? Je.flipRequired : Je.flipNotRequired, l3)
                return l3;
            }
            const i4 = _t(y3 * l2.getoffsetX(E3), b2, w2, o3, _2, d3, M2, T2, S2, c3, s3, p3, f3, false, false, g3, v3, x3);
            if (!i4)
              return { notEnoughRoom: true };
            D2(i4);
          }
          return {};
        }
        function ht(e3, t3, i3, o3, r3) {
          const { x: n3, y: s3, z: a3 } = o3.projectTilePoint(e3.x, e3.y, t3);
          if (!r3)
            return ot(n3, s3, a3, i3);
          const [l2, c3, h3] = r3(e3);
          return ot(n3 + l2, s3 + c3, a3 + h3, i3);
        }
        function ut(t3, i3, o3, r3, n3, s3, a3, l2) {
          const c3 = ht(t3.sub(i3)._unit()._add(t3), l2, n3, a3, s3);
          return e2.sub(c3, o3, c3), e2.normalize(c3, c3), e2.scaleAndAdd(c3, o3, c3, r3);
        }
        function _t(t3, i3, o3, r3, n3, s3, a3, l2, c3, h3, u3, _2, d3, p3, m3, f3, g3, v3) {
          const x3 = r3 ? t3 - i3 : t3 + i3;
          let y3 = x3 > 0 ? 1 : -1, b2 = 0;
          r3 && (y3 *= -1, b2 = Math.PI), y3 < 0 && (b2 += Math.PI);
          let w2 = l2 + a3 + (y3 > 0 ? 0 : 1) | 0, T2 = n3, E3 = n3, C2 = 0, M2 = 0;
          const I2 = Math.abs(x3), P2 = [], S2 = [];
          let D2 = s3, L2 = D2;
          const A2 = () => ut(L2, D2, E3, I2 - C2 + 1, u3, d3, f3, g3.canonical);
          for (; C2 + M2 <= I2; ) {
            if (w2 += y3, w2 < l2 || w2 >= c3)
              return null;
            if (E3 = T2, L2 = D2, P2.push(E3), p3 && S2.push(L2), D2 = new e2.Point(h3.getx(w2), h3.gety(w2)), T2 = _2[w2], !T2) {
              const e3 = ht(D2, g3.canonical, u3, f3, d3);
              T2 = e3[3] > 0 ? _2[w2] = e3 : A2();
            }
            C2 += M2, M2 = e2.distance(E3, T2);
          }
          m3 && d3 && (_2[w2] && (T2 = A2(), M2 = e2.distance(E3, T2)), _2[w2] = T2);
          const z2 = (I2 - C2) / M2, R2 = D2.sub(L2)._mult(z2)._add(L2), O2 = e2.sub([], T2, E3), B2 = e2.scaleAndAdd([], E3, O2, z2);
          let k2 = [0, 0, 1], F2 = O2[0], U2 = O2[1];
          if (v3 && (k2 = f3.upVector(g3.canonical, R2.x, R2.y), 0 !== k2[0] || 0 !== k2[1] || 1 !== k2[2])) {
            const t4 = [k2[2], 0, -k2[0]], i4 = e2.cross([], k2, t4);
            e2.normalize(t4, t4), e2.normalize(i4, i4), F2 = e2.dot(O2, t4), U2 = e2.dot(O2, i4);
          }
          if (o3) {
            const t4 = e2.cross([], k2, O2);
            e2.normalize(t4, t4), e2.scaleAndAdd(B2, B2, t4, o3 * y3);
          }
          const N2 = b2 + Math.atan2(U2, F2);
          return P2.push(B2), p3 && S2.push(R2), { point: B2, angle: N2, path: P2, tilePath: S2, up: k2 };
        }
        function dt(e3, t3) {
          const i3 = t3.length, o3 = i3 + 4 * e3;
          t3.resize(o3), t3.float32.fill(-1 / 0, 4 * i3, 4 * o3);
        }
        function pt(e3, t3, i3) {
          const o3 = t3[0], r3 = t3[1];
          return e3[0] = i3[0] * o3 + i3[4] * r3 + i3[12], e3[1] = i3[1] * o3 + i3[5] * r3 + i3[13], e3[3] = i3[3] * o3 + i3[7] * r3 + i3[15], e3;
        }
        const mt = 100;
        class ft {
          constructor(e3, t3, i3 = new Ke(e3.width + 200, e3.height + 200, 25), o3 = new Ke(e3.width + 200, e3.height + 200, 25)) {
            this.transform = e3, this.grid = i3, this.ignoredGrid = o3, this.pitchfactor = Math.cos(e3._pitch) * e3.cameraToCenterDistance, this.screenRightBoundary = e3.width + mt, this.screenBottomBoundary = e3.height + mt, this.gridRightBoundary = e3.width + 200, this.gridBottomBoundary = e3.height + 200, this.fogState = t3;
          }
          placeCollisionBox(e3, t3, i3, o3, r3, n3, s3, a3) {
            let l2 = i3.projectedAnchorX, c3 = i3.projectedAnchorY, h3 = i3.projectedAnchorZ;
            const u3 = i3.elevation, _2 = i3.tileID, d3 = e3.getProjection();
            if (u3 && _2) {
              const [e4, t4, o4] = d3.upVector(_2.canonical, i3.tileAnchorX, i3.tileAnchorY), r4 = d3.upVectorScale(_2.canonical, this.transform.center.lat, this.transform.worldSize).metersToTile;
              l2 += e4 * u3 * r4, c3 += t4 * u3 * r4, h3 += o4 * u3 * r4;
            }
            const p3 = this.projectAndGetPerspectiveRatio(s3, l2, c3, h3, i3.tileID, "globe" === d3.name || !!u3 || this.transform.pitch > 0, d3), m3 = n3 * p3.perspectiveRatio, f3 = (i3.x1 * t3 + o3.x - i3.padding) * m3 + p3.point.x, g3 = (i3.y1 * t3 + o3.y - i3.padding) * m3 + p3.point.y, v3 = (i3.x2 * t3 + o3.x + i3.padding) * m3 + p3.point.x, x3 = (i3.y2 * t3 + o3.y + i3.padding) * m3 + p3.point.y, y3 = p3.perspectiveRatio <= 0.55 || p3.occluded;
            return !this.isInsideGrid(f3, g3, v3, x3) || !r3 && this.grid.hitTest(f3, g3, v3, x3, a3) || y3 ? { box: [], offscreen: false, occluded: p3.occluded } : { box: [f3, g3, v3, x3], offscreen: this.isOffscreen(f3, g3, v3, x3), occluded: false };
          }
          placeCollisionCircles(t3, i3, o3, r3, n3, s3, a3, l2, c3, h3, u3, _2, d3, p3, m3) {
            const f3 = [], g3 = this.transform.elevation, v3 = t3.getProjection(), x3 = g3 ? g3.getAtTileOffsetFunc(m3, this.transform.center.lat, this.transform.worldSize, v3) : null, y3 = new e2.Point(o3.tileAnchorX, o3.tileAnchorY);
            let { x: b2, y: w2, z: T2 } = v3.projectTilePoint(y3.x, y3.y, m3.canonical);
            if (x3) {
              const [e3, t4, i4] = x3(y3);
              b2 += e3, w2 += t4, T2 += i4;
            }
            const E3 = "globe" === v3.name, C2 = this.projectAndGetPerspectiveRatio(a3, b2, w2, T2, m3, E3 || !!g3 || this.transform.pitch > 0, v3), { perspectiveRatio: M2 } = C2, I2 = (u3 ? s3 / M2 : s3 * M2) / e2.ONE_EM, P2 = ot(b2, w2, T2, l2), S2 = C2.signedDistanceFromCamera > 0 ? at(I2, n3, o3.lineOffsetX * I2, o3.lineOffsetY * I2, false, P2, y3, o3, r3, l2, {}, g3 && !u3 ? x3 : null, u3 && !!g3, v3, m3, u3) : null;
            let D2 = false, L2 = false, A2 = true;
            if (S2 && !C2.occluded) {
              const t4 = 0.5 * d3 * M2 + p3, o4 = new e2.Point(-100, -100), r4 = new e2.Point(this.screenRightBoundary, this.screenBottomBoundary), n4 = new Ye(), { first: s4, last: a4 } = S2, l3 = s4.path.length;
              let u4 = [];
              for (let e3 = l3 - 1; e3 >= 1; e3--)
                u4.push(s4.path[e3]);
              for (let e3 = 1; e3 < a4.path.length; e3++)
                u4.push(a4.path[e3]);
              const m4 = 2.5 * t4;
              c3 && (u4 = u4.map(([e3, t5, i4], o5) => (x3 && !E3 && (i4 = x3(o5 < l3 - 1 ? s4.tilePath[l3 - 1 - o5] : a4.tilePath[o5 - l3 + 2])[2]), ot(e3, t5, i4, c3))), u4.some((e3) => e3[3] <= 0) && (u4 = []));
              let g4 = [];
              if (u4.length > 0) {
                let t5 = 1 / 0, i4 = -1 / 0, n5 = 1 / 0, s5 = -1 / 0;
                for (const e3 of u4)
                  t5 = Math.min(t5, e3[0]), n5 = Math.min(n5, e3[1]), i4 = Math.max(i4, e3[0]), s5 = Math.max(s5, e3[1]);
                i4 >= o4.x && t5 <= r4.x && s5 >= o4.y && n5 <= r4.y && (g4 = [u4.map((t6) => new e2.Point(t6[0], t6[1]))], (t5 < o4.x || i4 > r4.x || n5 < o4.y || s5 > r4.y) && (g4 = e2.clipLine(g4, o4.x, o4.y, r4.x, r4.y)));
              }
              for (const e3 of g4) {
                n4.reset(e3, 0.25 * t4);
                let o5 = 0;
                o5 = n4.length <= 0.5 * t4 ? 1 : Math.ceil(n4.paddedLength / m4) + 1;
                for (let e4 = 0; e4 < o5; e4++) {
                  const r5 = e4 / Math.max(o5 - 1, 1), s5 = n4.lerp(r5), a5 = s5.x + mt, l4 = s5.y + mt;
                  f3.push(a5, l4, t4, 0);
                  const c4 = a5 - t4, u5 = l4 - t4, d4 = a5 + t4, p4 = l4 + t4;
                  if (A2 = A2 && this.isOffscreen(c4, u5, d4, p4), L2 = L2 || this.isInsideGrid(c4, u5, d4, p4), !i3 && this.grid.hitTestCircle(a5, l4, t4, _2) && (D2 = true, !h3))
                    return { circles: [], offscreen: false, collisionDetected: D2, occluded: false };
                }
              }
            }
            return { circles: !h3 && D2 || !L2 ? [] : f3, offscreen: A2, collisionDetected: D2, occluded: C2.occluded };
          }
          queryRenderedSymbols(t3) {
            if (0 === t3.length || 0 === this.grid.keysLength() && 0 === this.ignoredGrid.keysLength())
              return {};
            const i3 = [];
            let o3 = 1 / 0, r3 = 1 / 0, n3 = -1 / 0, s3 = -1 / 0;
            for (const a4 of t3) {
              const t4 = new e2.Point(a4.x + mt, a4.y + mt);
              o3 = Math.min(o3, t4.x), r3 = Math.min(r3, t4.y), n3 = Math.max(n3, t4.x), s3 = Math.max(s3, t4.y), i3.push(t4);
            }
            const a3 = this.grid.query(o3, r3, n3, s3).concat(this.ignoredGrid.query(o3, r3, n3, s3)), l2 = {}, c3 = {};
            for (const t4 of a3) {
              const o4 = t4.key;
              if (void 0 === l2[o4.bucketInstanceId] && (l2[o4.bucketInstanceId] = {}), l2[o4.bucketInstanceId][o4.featureIndex])
                continue;
              const r4 = [new e2.Point(t4.x1, t4.y1), new e2.Point(t4.x2, t4.y1), new e2.Point(t4.x2, t4.y2), new e2.Point(t4.x1, t4.y2)];
              e2.polygonIntersectsPolygon(i3, r4) && (l2[o4.bucketInstanceId][o4.featureIndex] = true, void 0 === c3[o4.bucketInstanceId] && (c3[o4.bucketInstanceId] = []), c3[o4.bucketInstanceId].push(o4.featureIndex));
            }
            return c3;
          }
          insertCollisionBox(e3, t3, i3, o3, r3) {
            (t3 ? this.ignoredGrid : this.grid).insert({ bucketInstanceId: i3, featureIndex: o3, collisionGroupID: r3 }, e3[0], e3[1], e3[2], e3[3]);
          }
          insertCollisionCircles(e3, t3, i3, o3, r3) {
            const n3 = t3 ? this.ignoredGrid : this.grid, s3 = { bucketInstanceId: i3, featureIndex: o3, collisionGroupID: r3 };
            for (let t4 = 0; t4 < e3.length; t4 += 4)
              n3.insertCircle(s3, e3[t4], e3[t4 + 1], e3[t4 + 2]);
          }
          projectAndGetPerspectiveRatio(t3, i3, o3, r3, n3, s3, a3) {
            const l2 = [i3, o3, r3, 1];
            let c3 = false;
            if (r3 || this.transform.pitch > 0) {
              if (e2.transformMat4$1(l2, l2, t3), this.fogState && n3 && "globe" !== a3.name) {
                const t4 = function(t5, i4, o4, r4, n4, s4) {
                  const a4 = s4.calculateFogTileMatrix(n4), l3 = [i4, o4, r4];
                  return e2.transformMat4(l3, l3, a4), C(t5, l3, s4.pitch, s4._fov);
                }(this.fogState, i3, o3, r3, n3.toUnwrapped(), this.transform);
                c3 = t4 > 0.9;
              }
            } else
              pt(l2, l2, t3);
            const h3 = l2[3];
            return { point: new e2.Point((l2[0] / h3 + 1) / 2 * this.transform.width + mt, (-l2[1] / h3 + 1) / 2 * this.transform.height + mt), perspectiveRatio: Math.min(0.5 + this.transform.getCameraToCenterDistance(a3) / h3 * 0.5, 1.5), signedDistanceFromCamera: h3, occluded: s3 && l2[2] > h3 || c3 };
          }
          isOffscreen(e3, t3, i3, o3) {
            return i3 < mt || e3 >= this.screenRightBoundary || o3 < mt || t3 > this.screenBottomBoundary;
          }
          isInsideGrid(e3, t3, i3, o3) {
            return i3 >= 0 && e3 < this.gridRightBoundary && o3 >= 0 && t3 < this.gridBottomBoundary;
          }
          getViewportMatrix() {
            const t3 = e2.identity([]);
            return e2.translate(t3, t3, [-100, -100, 0]), t3;
          }
        }
        function gt(t3, i3, o3) {
          const r3 = i3.createTileMatrix(t3, t3.worldSize, o3.toUnwrapped());
          return e2.multiply(new Float32Array(16), t3.projMatrix, r3);
        }
        function vt(e3, t3, i3) {
          if (t3.projection.name === i3.projection.name)
            return e3.projMatrix;
          const o3 = i3.clone();
          return o3.setProjection(t3.projection), gt(o3, t3.getProjection(), e3);
        }
        function xt(e3, t3, i3) {
          return t3.name === i3.projection.name ? e3.projMatrix : gt(i3, t3, e3);
        }
        class yt {
          constructor(e3, t3, i3, o3) {
            this.opacity = e3 ? Math.max(0, Math.min(1, e3.opacity + (e3.placed ? t3 : -t3))) : o3 && i3 ? 1 : 0, this.placed = i3;
          }
          isHidden() {
            return 0 === this.opacity && !this.placed;
          }
        }
        class bt {
          constructor(e3, t3, i3, o3, r3, n3 = false) {
            this.text = new yt(e3 ? e3.text : null, t3, i3, r3), this.icon = new yt(e3 ? e3.icon : null, t3, o3, r3), this.clipped = n3;
          }
          isHidden() {
            return this.text.isHidden() && this.icon.isHidden();
          }
        }
        class wt {
          constructor(e3, t3, i3, o3 = false) {
            this.text = e3, this.icon = t3, this.skipFade = i3, this.clipped = o3;
          }
        }
        class Tt {
          constructor() {
            this.invProjMatrix = e2.create(), this.viewportMatrix = e2.create(), this.circles = [];
          }
        }
        class Et {
          constructor(e3, t3, i3, o3, r3) {
            this.bucketInstanceId = e3, this.featureIndex = t3, this.sourceLayerIndex = i3, this.bucketIndex = o3, this.tileID = r3;
          }
        }
        class Ct {
          constructor(e3) {
            this.crossSourceCollisions = e3, this.maxGroupID = 0, this.collisionGroups = {};
          }
          get(e3) {
            if (this.crossSourceCollisions)
              return { ID: 0, predicate: null };
            if (!this.collisionGroups[e3]) {
              const t3 = ++this.maxGroupID;
              this.collisionGroups[e3] = { ID: t3, predicate: (e4) => e4.collisionGroupID === t3 };
            }
            return this.collisionGroups[e3];
          }
        }
        function Mt(t3, i3, o3, r3, n3) {
          const { horizontalAlign: s3, verticalAlign: a3 } = e2.getAnchorAlignment(t3), l2 = -(s3 - 0.5) * i3, c3 = -(a3 - 0.5) * o3, h3 = e2.evaluateVariableOffset(t3, r3);
          return new e2.Point(l2 + h3[0] * n3, c3 + h3[1] * n3);
        }
        function It(t3, i3, o3, r3, n3) {
          const s3 = new e2.Point(t3, i3);
          return o3 && s3._rotate(r3 ? n3 : -n3), s3;
        }
        class Pt {
          constructor(e3, t3, i3, o3, r3) {
            this.transform = e3.clone(), this.projection = e3.projection.name, this.collisionIndex = new ft(this.transform, r3), this.placements = {}, this.opacities = {}, this.variableOffsets = {}, this.stale = false, this.commitTime = 0, this.fadeDuration = t3, this.retainedQueryData = {}, this.collisionGroups = new Ct(i3), this.collisionCircleArrays = {}, this.prevPlacement = o3, o3 && (o3.prevPlacement = void 0), this.placedOrientations = {};
          }
          getBucketParts(t3, i3, o3, r3) {
            const n3 = o3.getBucket(i3), s3 = o3.latestFeatureIndex;
            if (!n3 || !s3 || i3.id !== n3.layerIds[0])
              return;
            const a3 = n3.layers[0].layout, l2 = o3.collisionBoxArray, c3 = Math.pow(2, this.transform.zoom - o3.tileID.overscaledZ), h3 = o3.tileSize / e2.EXTENT, u3 = o3.tileID.toUnwrapped();
            this.transform.setProjection(n3.projection);
            const _2 = (d3 = o3.tileID, p3 = n3.getProjection(), m3 = this.transform, p3.name === this.projection ? m3.calculateProjMatrix(d3.toUnwrapped()) : gt(m3, p3, d3));
            var d3, p3, m3;
            const f3 = "map" === a3.get("text-pitch-alignment"), g3 = "map" === a3.get("text-rotation-alignment");
            i3.compileFilter();
            const v3 = i3.dynamicFilter(), x3 = i3.dynamicFilterNeedsFeature(), y3 = this.transform.calculatePixelsToTileUnitsMatrix(o3), b2 = tt(_2, o3.tileID.canonical, f3, g3, this.transform, n3.getProjection(), y3);
            let w2 = null;
            if (f3) {
              const t4 = it(_2, o3.tileID.canonical, f3, g3, this.transform, n3.getProjection(), y3);
              w2 = e2.multiply([], this.transform.labelPlaneMatrix, t4);
            }
            let T2 = null;
            v3 && o3.latestFeatureIndex && (T2 = { unwrappedTileID: u3, dynamicFilter: v3, dynamicFilterNeedsFeature: x3, featureIndex: o3.latestFeatureIndex }), this.retainedQueryData[n3.bucketInstanceId] = new Et(n3.bucketInstanceId, s3, n3.sourceLayerIndex, n3.index, o3.tileID);
            const E3 = { bucket: n3, layout: a3, posMatrix: _2, textLabelPlaneMatrix: b2, labelToScreenMatrix: w2, clippingData: T2, scale: c3, textPixelRatio: h3, holdingForFade: o3.holdingForFade(), collisionBoxArray: l2, partiallyEvaluatedTextSize: e2.evaluateSizeForZoom(n3.textSizeData, this.transform.zoom), partiallyEvaluatedIconSize: e2.evaluateSizeForZoom(n3.iconSizeData, this.transform.zoom), collisionGroup: this.collisionGroups.get(n3.sourceID) };
            if (r3)
              for (const e3 of n3.sortKeyRanges) {
                const { sortKey: i4, symbolInstanceStart: o4, symbolInstanceEnd: r4 } = e3;
                t3.push({ sortKey: i4, symbolInstanceStart: o4, symbolInstanceEnd: r4, parameters: E3 });
              }
            else
              t3.push({ symbolInstanceStart: 0, symbolInstanceEnd: n3.symbolInstances.length, parameters: E3 });
          }
          attemptAnchorPlacement(e3, t3, i3, o3, r3, n3, s3, a3, l2, c3, h3, u3, _2, d3, p3, m3, f3, g3) {
            const { textOffset0: v3, textOffset1: x3, crossTileID: y3 } = u3, b2 = [v3, x3], w2 = Mt(e3, i3, o3, b2, r3), T2 = this.collisionIndex.placeCollisionBox(d3, r3, t3, It(w2.x, w2.y, n3, s3, this.transform.angle), h3, a3, l2, c3.predicate);
            if (m3) {
              const e4 = d3.getSymbolInstanceIconSize(g3, this.transform.zoom, u3.placedIconSymbolIndex);
              if (0 === this.collisionIndex.placeCollisionBox(d3, e4, m3, It(w2.x, w2.y, n3, s3, this.transform.angle), h3, a3, l2, c3.predicate).box.length)
                return;
            }
            if (T2.box.length > 0) {
              let t4;
              return this.prevPlacement && this.prevPlacement.variableOffsets[y3] && this.prevPlacement.placements[y3] && this.prevPlacement.placements[y3].text && (t4 = this.prevPlacement.variableOffsets[y3].anchor), this.variableOffsets[y3] = { textOffset: b2, width: i3, height: o3, anchor: e3, textScale: r3, prevAnchor: t4 }, this.markUsedJustification(d3, e3, u3, p3), d3.allowVerticalPlacement && (this.markUsedOrientation(d3, p3, u3), this.placedOrientations[y3] = p3), { shift: w2, placedGlyphBoxes: T2 };
            }
          }
          placeLayerBucketPart(t3, i3, o3, r3) {
            const { bucket: n3, layout: s3, posMatrix: a3, textLabelPlaneMatrix: l2, labelToScreenMatrix: c3, clippingData: h3, textPixelRatio: u3, holdingForFade: _2, collisionBoxArray: d3, partiallyEvaluatedTextSize: p3, partiallyEvaluatedIconSize: m3, collisionGroup: f3 } = t3.parameters, g3 = s3.get("text-optional"), v3 = s3.get("icon-optional"), x3 = s3.get("text-allow-overlap"), y3 = s3.get("icon-allow-overlap"), b2 = "map" === s3.get("text-rotation-alignment"), w2 = "map" === s3.get("text-pitch-alignment"), T2 = "none" !== s3.get("icon-text-fit"), E3 = "viewport-y" === s3.get("symbol-z-order");
            this.transform.setProjection(n3.projection);
            let C2 = x3 && (y3 || !n3.hasIconData() || v3), M2 = y3 && (x3 || !n3.hasTextData() || g3);
            !n3.collisionArrays && d3 && n3.deserializeCollisionBoxes(d3), o3 && r3 && n3.updateCollisionDebugBuffers(this.transform.zoom, d3);
            const I2 = (t4, r4, d4) => {
              const { crossTileID: E4, numVerticalGlyphVertices: I3 } = t4;
              if (h3) {
                const o4 = { zoom: this.transform.zoom, pitch: this.transform.pitch };
                let r5 = null;
                if (h3.dynamicFilterNeedsFeature) {
                  const e3 = this.retainedQueryData[n3.bucketInstanceId];
                  r5 = h3.featureIndex.loadFeature({ featureIndex: t4.featureIndex, bucketIndex: e3.bucketIndex, sourceLayerIndex: e3.sourceLayerIndex, layoutVertexArrayOffset: 0 });
                }
                if (!(0, h3.dynamicFilter)(o4, r5, this.retainedQueryData[n3.bucketInstanceId].tileID.canonical, new e2.Point(t4.tileAnchorX, t4.tileAnchorY), this.transform.calculateDistanceTileData(h3.unwrappedTileID)))
                  return this.placements[E4] = new wt(false, false, false, true), void i3.add(E4);
              }
              if (i3.has(E4))
                return;
              if (_2)
                return void (this.placements[E4] = new wt(false, false, false));
              let P2 = false, S2 = false, D2 = true, L2 = false, A2 = false, z2 = null, R2 = { box: null, offscreen: null, occluded: null }, O2 = { box: null, offscreen: null, occluded: null }, B2 = null, k2 = null, F2 = null, U2 = 0, N2 = 0, j2 = 0;
              d4.textFeatureIndex ? U2 = d4.textFeatureIndex : t4.useRuntimeCollisionCircles && (U2 = t4.featureIndex), d4.verticalTextFeatureIndex && (N2 = d4.verticalTextFeatureIndex);
              const G2 = (e3) => {
                e3.tileID = this.retainedQueryData[n3.bucketInstanceId].tileID;
                const t5 = this.transform.elevation;
                (t5 || e3.elevation) && (e3.elevation = t5 ? t5.getAtTileOffset(e3.tileID, e3.tileAnchorX, e3.tileAnchorY) : 0);
              }, Z2 = d4.textBox;
              if (Z2) {
                G2(Z2);
                const i4 = (i5) => {
                  let o5 = e2.WritingMode.horizontal;
                  if (n3.allowVerticalPlacement && !i5 && this.prevPlacement) {
                    const e3 = this.prevPlacement.placedOrientations[E4];
                    e3 && (this.placedOrientations[E4] = e3, o5 = e3, this.markUsedOrientation(n3, o5, t4));
                  }
                  return o5;
                }, o4 = (t5, i5) => {
                  if (n3.allowVerticalPlacement && I3 > 0 && d4.verticalTextBox) {
                    for (const o5 of n3.writingModes)
                      if (o5 === e2.WritingMode.vertical ? (R2 = i5(), O2 = R2) : R2 = t5(), R2 && R2.box && R2.box.length)
                        break;
                  } else
                    R2 = t5();
                };
                if (s3.get("text-variable-anchor")) {
                  let l3 = s3.get("text-variable-anchor");
                  if (this.prevPlacement && this.prevPlacement.variableOffsets[E4]) {
                    const e3 = this.prevPlacement.variableOffsets[E4];
                    l3.indexOf(e3.anchor) > 0 && (l3 = l3.filter((t5) => t5 !== e3.anchor), l3.unshift(e3.anchor));
                  }
                  const c4 = (e3, i5, o5) => {
                    const s4 = n3.getSymbolInstanceTextSize(p3, t4, this.transform.zoom, r4), c5 = (e3.x2 - e3.x1) * s4 + 2 * e3.padding, h5 = (e3.y2 - e3.y1) * s4 + 2 * e3.padding, _3 = T2 && !y3 ? i5 : null;
                    _3 && G2(_3);
                    let d5 = { box: [], offscreen: false, occluded: false };
                    const g4 = x3 ? 2 * l3.length : l3.length;
                    for (let i6 = 0; i6 < g4; ++i6) {
                      const g5 = this.attemptAnchorPlacement(l3[i6 % l3.length], e3, c5, h5, s4, b2, w2, u3, a3, f3, i6 >= l3.length, t4, r4, n3, o5, _3, p3, m3);
                      if (g5 && (d5 = g5.placedGlyphBoxes, d5 && d5.box && d5.box.length)) {
                        P2 = true, z2 = g5.shift;
                        break;
                      }
                    }
                    return d5;
                  };
                  o4(() => c4(Z2, d4.iconBox, e2.WritingMode.horizontal), () => {
                    const t5 = d4.verticalTextBox;
                    return t5 && G2(t5), n3.allowVerticalPlacement && !(R2 && R2.box && R2.box.length) && I3 > 0 && t5 ? c4(t5, d4.verticalIconBox, e2.WritingMode.vertical) : { box: null, offscreen: null, occluded: null };
                  }), R2 && (P2 = R2.box, D2 = R2.offscreen, L2 = R2.occluded);
                  const h4 = i4(!(!R2 || !R2.box));
                  if (!P2 && this.prevPlacement) {
                    const e3 = this.prevPlacement.variableOffsets[E4];
                    e3 && (this.variableOffsets[E4] = e3, this.markUsedJustification(n3, e3.anchor, t4, h4));
                  }
                } else {
                  const s4 = (i5, o5) => {
                    const s5 = n3.getSymbolInstanceTextSize(p3, t4, this.transform.zoom, r4), l3 = this.collisionIndex.placeCollisionBox(n3, s5, i5, new e2.Point(0, 0), x3, u3, a3, f3.predicate);
                    return l3 && l3.box && l3.box.length && (this.markUsedOrientation(n3, o5, t4), this.placedOrientations[E4] = o5), l3;
                  };
                  o4(() => s4(Z2, e2.WritingMode.horizontal), () => {
                    const t5 = d4.verticalTextBox;
                    return n3.allowVerticalPlacement && I3 > 0 && t5 ? (G2(t5), s4(t5, e2.WritingMode.vertical)) : { box: null, offscreen: null, occluded: null };
                  }), i4(!!(R2 && R2.box && R2.box.length));
                }
              }
              if (B2 = R2, P2 = B2 && B2.box && B2.box.length > 0, D2 = B2 && B2.offscreen, L2 = B2 && B2.occluded, t4.useRuntimeCollisionCircles) {
                const i4 = n3.text.placedSymbolArray.get(t4.centerJustifiedTextSymbolIndex >= 0 ? t4.centerJustifiedTextSymbolIndex : t4.verticalPlacedTextSymbolIndex), r5 = e2.evaluateSizeForFeature(n3.textSizeData, p3, i4), h4 = s3.get("text-padding");
                k2 = this.collisionIndex.placeCollisionCircles(n3, x3, i4, n3.lineVertexArray, n3.glyphOffsetArray, r5, a3, l2, c3, o3, w2, f3.predicate, t4.collisionCircleDiameter * r5 / e2.ONE_EM, h4, this.retainedQueryData[n3.bucketInstanceId].tileID), P2 = x3 || k2.circles.length > 0 && !k2.collisionDetected, D2 = D2 && k2.offscreen, L2 = k2.occluded;
              }
              if (d4.iconFeatureIndex && (j2 = d4.iconFeatureIndex), d4.iconBox) {
                const i4 = (i5) => {
                  G2(i5);
                  const o4 = T2 && z2 ? It(z2.x, z2.y, b2, w2, this.transform.angle) : new e2.Point(0, 0), r5 = n3.getSymbolInstanceIconSize(m3, this.transform.zoom, t4.placedIconSymbolIndex);
                  return this.collisionIndex.placeCollisionBox(n3, r5, i5, o4, y3, u3, a3, f3.predicate);
                };
                O2 && O2.box && O2.box.length && d4.verticalIconBox ? (F2 = i4(d4.verticalIconBox), S2 = F2.box.length > 0) : (F2 = i4(d4.iconBox), S2 = F2.box.length > 0), D2 = D2 && F2.offscreen, A2 = F2.occluded;
              }
              const V2 = g3 || 0 === t4.numHorizontalGlyphVertices && 0 === I3, W2 = v3 || 0 === t4.numIconVertices;
              if (V2 || W2 ? W2 ? V2 || (S2 = S2 && P2) : P2 = S2 && P2 : S2 = P2 = S2 && P2, P2 && B2 && B2.box && this.collisionIndex.insertCollisionBox(B2.box, s3.get("text-ignore-placement"), n3.bucketInstanceId, O2 && O2.box && N2 ? N2 : U2, f3.ID), S2 && F2 && this.collisionIndex.insertCollisionBox(F2.box, s3.get("icon-ignore-placement"), n3.bucketInstanceId, j2, f3.ID), k2 && (P2 && this.collisionIndex.insertCollisionCircles(k2.circles, s3.get("text-ignore-placement"), n3.bucketInstanceId, U2, f3.ID), o3)) {
                const e3 = n3.bucketInstanceId;
                let t5 = this.collisionCircleArrays[e3];
                void 0 === t5 && (t5 = this.collisionCircleArrays[e3] = new Tt());
                for (let e4 = 0; e4 < k2.circles.length; e4 += 4)
                  t5.circles.push(k2.circles[e4 + 0]), t5.circles.push(k2.circles[e4 + 1]), t5.circles.push(k2.circles[e4 + 2]), t5.circles.push(k2.collisionDetected ? 1 : 0);
              }
              const X2 = "globe" !== n3.projection.name;
              C2 = C2 && (X2 || !L2), M2 = M2 && (X2 || !A2), this.placements[E4] = new wt(P2 || C2, S2 || M2, D2 || n3.justReloaded), i3.add(E4);
            };
            if (E3) {
              const e3 = n3.getSortedSymbolIndexes(this.transform.angle);
              for (let t4 = e3.length - 1; t4 >= 0; --t4) {
                const i4 = e3[t4];
                I2(n3.symbolInstances.get(i4), i4, n3.collisionArrays[i4]);
              }
            } else
              for (let e3 = t3.symbolInstanceStart; e3 < t3.symbolInstanceEnd; e3++)
                I2(n3.symbolInstances.get(e3), e3, n3.collisionArrays[e3]);
            if (o3 && n3.bucketInstanceId in this.collisionCircleArrays) {
              const t4 = this.collisionCircleArrays[n3.bucketInstanceId];
              e2.invert(t4.invProjMatrix, a3), t4.viewportMatrix = this.collisionIndex.getViewportMatrix();
            }
            n3.justReloaded = false;
          }
          markUsedJustification(t3, i3, o3, r3) {
            const { leftJustifiedTextSymbolIndex: n3, centerJustifiedTextSymbolIndex: s3, rightJustifiedTextSymbolIndex: a3, verticalPlacedTextSymbolIndex: l2, crossTileID: c3 } = o3, h3 = e2.getAnchorJustification(i3), u3 = r3 === e2.WritingMode.vertical ? l2 : "left" === h3 ? n3 : "center" === h3 ? s3 : "right" === h3 ? a3 : -1;
            n3 >= 0 && (t3.text.placedSymbolArray.get(n3).crossTileID = u3 >= 0 && n3 !== u3 ? 0 : c3), s3 >= 0 && (t3.text.placedSymbolArray.get(s3).crossTileID = u3 >= 0 && s3 !== u3 ? 0 : c3), a3 >= 0 && (t3.text.placedSymbolArray.get(a3).crossTileID = u3 >= 0 && a3 !== u3 ? 0 : c3), l2 >= 0 && (t3.text.placedSymbolArray.get(l2).crossTileID = u3 >= 0 && l2 !== u3 ? 0 : c3);
          }
          markUsedOrientation(t3, i3, o3) {
            const r3 = i3 === e2.WritingMode.horizontal || i3 === e2.WritingMode.horizontalOnly ? i3 : 0, n3 = i3 === e2.WritingMode.vertical ? i3 : 0, { leftJustifiedTextSymbolIndex: s3, centerJustifiedTextSymbolIndex: a3, rightJustifiedTextSymbolIndex: l2, verticalPlacedTextSymbolIndex: c3 } = o3, h3 = t3.text.placedSymbolArray;
            s3 >= 0 && (h3.get(s3).placedOrientation = r3), a3 >= 0 && (h3.get(a3).placedOrientation = r3), l2 >= 0 && (h3.get(l2).placedOrientation = r3), c3 >= 0 && (h3.get(c3).placedOrientation = n3);
          }
          commit(e3) {
            this.commitTime = e3, this.zoomAtLastRecencyCheck = this.transform.zoom;
            const t3 = this.prevPlacement;
            let i3 = false;
            this.prevZoomAdjustment = t3 ? t3.zoomAdjustment(this.transform.zoom) : 0;
            const o3 = t3 ? t3.symbolFadeChange(e3) : 1, r3 = t3 ? t3.opacities : {}, n3 = t3 ? t3.variableOffsets : {}, s3 = t3 ? t3.placedOrientations : {};
            for (const e4 in this.placements) {
              const t4 = this.placements[e4], n4 = r3[e4];
              n4 ? (this.opacities[e4] = new bt(n4, o3, t4.text, t4.icon, null, t4.clipped), i3 = i3 || t4.text !== n4.text.placed || t4.icon !== n4.icon.placed) : (this.opacities[e4] = new bt(null, o3, t4.text, t4.icon, t4.skipFade, t4.clipped), i3 = i3 || t4.text || t4.icon);
            }
            for (const e4 in r3) {
              const t4 = r3[e4];
              if (!this.opacities[e4]) {
                const r4 = new bt(t4, o3, false, false);
                r4.isHidden() || (this.opacities[e4] = r4, i3 = i3 || t4.text.placed || t4.icon.placed);
              }
            }
            for (const e4 in n3)
              this.variableOffsets[e4] || !this.opacities[e4] || this.opacities[e4].isHidden() || (this.variableOffsets[e4] = n3[e4]);
            for (const e4 in s3)
              this.placedOrientations[e4] || !this.opacities[e4] || this.opacities[e4].isHidden() || (this.placedOrientations[e4] = s3[e4]);
            i3 ? this.lastPlacementChangeTime = e3 : "number" != typeof this.lastPlacementChangeTime && (this.lastPlacementChangeTime = t3 ? t3.lastPlacementChangeTime : e3);
          }
          updateLayerOpacities(e3, t3) {
            const i3 = /* @__PURE__ */ new Set();
            for (const o3 of t3) {
              const t4 = o3.getBucket(e3);
              t4 && o3.latestFeatureIndex && e3.id === t4.layerIds[0] && this.updateBucketOpacities(t4, i3, o3.collisionBoxArray);
            }
          }
          updateBucketOpacities(t3, i3, o3) {
            t3.hasTextData() && t3.text.opacityVertexArray.clear(), t3.hasIconData() && t3.icon.opacityVertexArray.clear(), t3.hasIconCollisionBoxData() && t3.iconCollisionBox.collisionVertexArray.clear(), t3.hasTextCollisionBoxData() && t3.textCollisionBox.collisionVertexArray.clear();
            const r3 = t3.layers[0].layout, n3 = !!t3.layers[0].dynamicFilter(), s3 = new bt(null, 0, false, false, true), a3 = r3.get("text-allow-overlap"), l2 = r3.get("icon-allow-overlap"), c3 = r3.get("text-variable-anchor"), h3 = "map" === r3.get("text-rotation-alignment"), u3 = "map" === r3.get("text-pitch-alignment"), _2 = "none" !== r3.get("icon-text-fit"), d3 = new bt(null, 0, a3 && (l2 || !t3.hasIconData() || r3.get("icon-optional")), l2 && (a3 || !t3.hasTextData() || r3.get("text-optional")), true);
            !t3.collisionArrays && o3 && (t3.hasIconCollisionBoxData() || t3.hasTextCollisionBoxData()) && t3.deserializeCollisionBoxes(o3);
            const p3 = (e3, t4, i4) => {
              for (let o4 = 0; o4 < t4 / 4; o4++)
                e3.opacityVertexArray.emplaceBack(i4);
            };
            let m3 = 0;
            for (let o4 = 0; o4 < t3.symbolInstances.length; o4++) {
              const r4 = t3.symbolInstances.get(o4), { numHorizontalGlyphVertices: a4, numVerticalGlyphVertices: l3, crossTileID: f3, numIconVertices: g3 } = r4, v3 = i3.has(f3);
              let x3 = this.opacities[f3];
              v3 ? x3 = s3 : x3 || (x3 = d3, this.opacities[f3] = x3), i3.add(f3);
              const y3 = a4 > 0 || l3 > 0, b2 = g3 > 0, w2 = this.placedOrientations[f3], T2 = w2 === e2.WritingMode.vertical, E3 = w2 === e2.WritingMode.horizontal || w2 === e2.WritingMode.horizontalOnly;
              if (!y3 && !b2 || x3.isHidden() || m3++, y3) {
                const e3 = kt(x3.text);
                p3(t3.text, a4, T2 ? Ft : e3), p3(t3.text, l3, E3 ? Ft : e3);
                const i4 = x3.text.isHidden(), { leftJustifiedTextSymbolIndex: o5, centerJustifiedTextSymbolIndex: n4, rightJustifiedTextSymbolIndex: s4, verticalPlacedTextSymbolIndex: c4 } = r4, h4 = t3.text.placedSymbolArray, u4 = i4 || T2 ? 1 : 0;
                o5 >= 0 && (h4.get(o5).hidden = u4), n4 >= 0 && (h4.get(n4).hidden = u4), s4 >= 0 && (h4.get(s4).hidden = u4), c4 >= 0 && (h4.get(c4).hidden = i4 || E3 ? 1 : 0);
                const _3 = this.variableOffsets[f3];
                _3 && this.markUsedJustification(t3, _3.anchor, r4, w2);
                const d4 = this.placedOrientations[f3];
                d4 && (this.markUsedJustification(t3, "left", r4, d4), this.markUsedOrientation(t3, d4, r4));
              }
              if (b2) {
                const e3 = kt(x3.icon), { placedIconSymbolIndex: i4, verticalPlacedIconSymbolIndex: o5 } = r4, n4 = t3.icon.placedSymbolArray, s4 = x3.icon.isHidden() ? 1 : 0;
                i4 >= 0 && (p3(t3.icon, g3, T2 ? Ft : e3), n4.get(i4).hidden = s4), o5 >= 0 && (p3(t3.icon, r4.numVerticalIconVertices, E3 ? Ft : e3), n4.get(o5).hidden = s4);
              }
              if (t3.hasIconCollisionBoxData() || t3.hasTextCollisionBoxData()) {
                const i4 = t3.collisionArrays[o4];
                if (i4) {
                  let o5 = new e2.Point(0, 0), r5 = true;
                  if (i4.textBox || i4.verticalTextBox) {
                    if (c3) {
                      const e3 = this.variableOffsets[f3];
                      e3 ? (o5 = Mt(e3.anchor, e3.width, e3.height, e3.textOffset, e3.textScale), h3 && o5._rotate(u3 ? this.transform.angle : -this.transform.angle)) : r5 = false;
                    }
                    n3 && (r5 = !x3.clipped), i4.textBox && St(t3.textCollisionBox.collisionVertexArray, x3.text.placed, !r5 || T2, o5.x, o5.y), i4.verticalTextBox && St(t3.textCollisionBox.collisionVertexArray, x3.text.placed, !r5 || E3, o5.x, o5.y);
                  }
                  const s4 = r5 && Boolean(!E3 && i4.verticalIconBox);
                  i4.iconBox && St(t3.iconCollisionBox.collisionVertexArray, x3.icon.placed, s4, _2 ? o5.x : 0, _2 ? o5.y : 0), i4.verticalIconBox && St(t3.iconCollisionBox.collisionVertexArray, x3.icon.placed, !s4, _2 ? o5.x : 0, _2 ? o5.y : 0);
                }
              }
            }
            if (t3.fullyClipped = 0 === m3, t3.sortFeatures(this.transform.angle), this.retainedQueryData[t3.bucketInstanceId] && (this.retainedQueryData[t3.bucketInstanceId].featureSortOrder = t3.featureSortOrder), t3.hasTextData() && t3.text.opacityVertexBuffer && t3.text.opacityVertexBuffer.updateData(t3.text.opacityVertexArray), t3.hasIconData() && t3.icon.opacityVertexBuffer && t3.icon.opacityVertexBuffer.updateData(t3.icon.opacityVertexArray), t3.hasIconCollisionBoxData() && t3.iconCollisionBox.collisionVertexBuffer && t3.iconCollisionBox.collisionVertexBuffer.updateData(t3.iconCollisionBox.collisionVertexArray), t3.hasTextCollisionBoxData() && t3.textCollisionBox.collisionVertexBuffer && t3.textCollisionBox.collisionVertexBuffer.updateData(t3.textCollisionBox.collisionVertexArray), t3.bucketInstanceId in this.collisionCircleArrays) {
              const e3 = this.collisionCircleArrays[t3.bucketInstanceId];
              t3.placementInvProjMatrix = e3.invProjMatrix, t3.placementViewportMatrix = e3.viewportMatrix, t3.collisionCircleArray = e3.circles, delete this.collisionCircleArrays[t3.bucketInstanceId];
            }
          }
          symbolFadeChange(e3) {
            return 0 === this.fadeDuration ? 1 : (e3 - this.commitTime) / this.fadeDuration + this.prevZoomAdjustment;
          }
          zoomAdjustment(e3) {
            return Math.max(0, (this.transform.zoom - e3) / 1.5);
          }
          hasTransitions(e3) {
            return this.stale || e3 - this.lastPlacementChangeTime < this.fadeDuration;
          }
          stillRecent(e3, t3) {
            const i3 = this.zoomAtLastRecencyCheck === t3 ? 1 - this.zoomAdjustment(t3) : 1;
            return this.zoomAtLastRecencyCheck = t3, this.commitTime + this.fadeDuration * i3 > e3;
          }
          setStale() {
            this.stale = true;
          }
        }
        function St(e3, t3, i3, o3, r3) {
          e3.emplaceBack(t3 ? 1 : 0, i3 ? 1 : 0, o3 || 0, r3 || 0), e3.emplaceBack(t3 ? 1 : 0, i3 ? 1 : 0, o3 || 0, r3 || 0), e3.emplaceBack(t3 ? 1 : 0, i3 ? 1 : 0, o3 || 0, r3 || 0), e3.emplaceBack(t3 ? 1 : 0, i3 ? 1 : 0, o3 || 0, r3 || 0);
        }
        const Dt = Math.pow(2, 25), Lt = Math.pow(2, 24), At = Math.pow(2, 17), zt = Math.pow(2, 16), Rt = Math.pow(2, 9), Ot = Math.pow(2, 8), Bt = Math.pow(2, 1);
        function kt(e3) {
          if (0 === e3.opacity && !e3.placed)
            return 0;
          if (1 === e3.opacity && e3.placed)
            return 4294967295;
          const t3 = e3.placed ? 1 : 0, i3 = Math.floor(127 * e3.opacity);
          return i3 * Dt + t3 * Lt + i3 * At + t3 * zt + i3 * Rt + t3 * Ot + i3 * Bt + t3;
        }
        const Ft = 0;
        class Ut {
          constructor(e3) {
            this._sortAcrossTiles = "viewport-y" !== e3.layout.get("symbol-z-order") && void 0 !== e3.layout.get("symbol-sort-key").constantOr(1), this._currentTileIndex = 0, this._currentPartIndex = 0, this._seenCrossTileIDs = /* @__PURE__ */ new Set(), this._bucketParts = [];
          }
          continuePlacement(e3, t3, i3, o3, r3) {
            const n3 = this._bucketParts;
            for (; this._currentTileIndex < e3.length; )
              if (t3.getBucketParts(n3, o3, e3[this._currentTileIndex], this._sortAcrossTiles), this._currentTileIndex++, r3())
                return true;
            for (this._sortAcrossTiles && (this._sortAcrossTiles = false, n3.sort((e4, t4) => e4.sortKey - t4.sortKey)); this._currentPartIndex < n3.length; ) {
              const e4 = n3[this._currentPartIndex];
              if (t3.placeLayerBucketPart(e4, this._seenCrossTileIDs, i3, 0 === e4.symbolInstanceStart), this._currentPartIndex++, r3())
                return true;
            }
            return false;
          }
        }
        class Nt {
          constructor(e3, t3, i3, o3, r3, n3, s3, a3) {
            this.placement = new Pt(e3, r3, n3, s3, a3), this._currentPlacementIndex = t3.length - 1, this._forceFullPlacement = i3, this._showCollisionBoxes = o3, this._done = false;
          }
          isDone() {
            return this._done;
          }
          continuePlacement(t3, i3, o3) {
            const r3 = e2.exported.now(), n3 = () => {
              const t4 = e2.exported.now() - r3;
              return !this._forceFullPlacement && t4 > 2;
            };
            for (; this._currentPlacementIndex >= 0; ) {
              const e3 = i3[t3[this._currentPlacementIndex]], r4 = this.placement.collisionIndex.transform.zoom;
              if ("symbol" === e3.type && (!e3.minzoom || e3.minzoom <= r4) && (!e3.maxzoom || e3.maxzoom > r4)) {
                if (this._inProgressLayer || (this._inProgressLayer = new Ut(e3)), this._inProgressLayer.continuePlacement(o3[e3.source], this.placement, this._showCollisionBoxes, e3, n3))
                  return;
                delete this._inProgressLayer;
              }
              this._currentPlacementIndex--;
            }
            this._done = true;
          }
          commit(e3) {
            return this.placement.commit(e3), this.placement;
          }
        }
        const jt = 512 / e2.EXTENT / 2;
        class Gt {
          constructor(t3, i3, o3) {
            this.tileID = t3, this.bucketInstanceId = o3, this.index = new e2.KDBush(i3.length, 16, Int32Array), this.keys = [], this.crossTileIDs = [];
            const r3 = t3.canonical.x * e2.EXTENT, n3 = t3.canonical.y * e2.EXTENT;
            for (let e3 = 0; e3 < i3.length; e3++) {
              const { key: t4, crossTileID: o4, tileAnchorX: s3, tileAnchorY: a3 } = i3.get(e3), l2 = Math.floor((r3 + s3) * jt), c3 = Math.floor((n3 + a3) * jt);
              this.index.add(l2, c3), this.keys.push(t4), this.crossTileIDs.push(o4);
            }
            this.index.finish();
          }
          findMatches(t3, i3, o3) {
            const r3 = this.tileID.canonical.z < i3.canonical.z ? 1 : Math.pow(2, this.tileID.canonical.z - i3.canonical.z), n3 = jt / Math.pow(2, i3.canonical.z - this.tileID.canonical.z), s3 = i3.canonical.x * e2.EXTENT, a3 = i3.canonical.y * e2.EXTENT;
            for (let e3 = 0; e3 < t3.length; e3++) {
              const i4 = t3.get(e3);
              if (i4.crossTileID)
                continue;
              const { key: l2, tileAnchorX: c3, tileAnchorY: h3 } = i4, u3 = Math.floor((s3 + c3) * n3), _2 = Math.floor((a3 + h3) * n3), d3 = this.index.range(u3 - r3, _2 - r3, u3 + r3, _2 + r3);
              for (const e4 of d3) {
                const t4 = this.crossTileIDs[e4];
                if (this.keys[e4] === l2 && !o3.has(t4)) {
                  o3.add(t4), i4.crossTileID = t4;
                  break;
                }
              }
            }
          }
        }
        class Zt {
          constructor() {
            this.maxCrossTileID = 0;
          }
          generate() {
            return ++this.maxCrossTileID;
          }
        }
        class Vt {
          constructor() {
            this.indexes = {}, this.usedCrossTileIDs = {}, this.lng = 0;
          }
          handleWrapJump(e3) {
            const t3 = Math.round((e3 - this.lng) / 360);
            if (0 !== t3)
              for (const e4 in this.indexes) {
                const i3 = this.indexes[e4], o3 = {};
                for (const e5 in i3) {
                  const r3 = i3[e5];
                  r3.tileID = r3.tileID.unwrapTo(r3.tileID.wrap + t3), o3[r3.tileID.key] = r3;
                }
                this.indexes[e4] = o3;
              }
            this.lng = e3;
          }
          addBucket(e3, t3, i3) {
            if (this.indexes[e3.overscaledZ] && this.indexes[e3.overscaledZ][e3.key]) {
              if (this.indexes[e3.overscaledZ][e3.key].bucketInstanceId === t3.bucketInstanceId)
                return false;
              this.removeBucketCrossTileIDs(e3.overscaledZ, this.indexes[e3.overscaledZ][e3.key]);
            }
            for (let e4 = 0; e4 < t3.symbolInstances.length; e4++)
              t3.symbolInstances.get(e4).crossTileID = 0;
            this.usedCrossTileIDs[e3.overscaledZ] || (this.usedCrossTileIDs[e3.overscaledZ] = /* @__PURE__ */ new Set());
            const o3 = this.usedCrossTileIDs[e3.overscaledZ];
            for (const i4 in this.indexes) {
              const r3 = this.indexes[i4];
              if (Number(i4) > e3.overscaledZ)
                for (const i5 in r3) {
                  const n3 = r3[i5];
                  n3.tileID.isChildOf(e3) && n3.findMatches(t3.symbolInstances, e3, o3);
                }
              else {
                const n3 = r3[e3.scaledTo(Number(i4)).key];
                n3 && n3.findMatches(t3.symbolInstances, e3, o3);
              }
            }
            for (let e4 = 0; e4 < t3.symbolInstances.length; e4++) {
              const r3 = t3.symbolInstances.get(e4);
              r3.crossTileID || (r3.crossTileID = i3.generate(), o3.add(r3.crossTileID));
            }
            return void 0 === this.indexes[e3.overscaledZ] && (this.indexes[e3.overscaledZ] = {}), this.indexes[e3.overscaledZ][e3.key] = new Gt(e3, t3.symbolInstances, t3.bucketInstanceId), true;
          }
          removeBucketCrossTileIDs(e3, t3) {
            for (const i3 of t3.crossTileIDs)
              this.usedCrossTileIDs[e3].delete(i3);
          }
          removeStaleBuckets(e3) {
            let t3 = false;
            for (const i3 in this.indexes) {
              const o3 = this.indexes[i3];
              for (const r3 in o3)
                e3[o3[r3].bucketInstanceId] || (this.removeBucketCrossTileIDs(i3, o3[r3]), delete o3[r3], t3 = true);
            }
            return t3;
          }
        }
        class Wt {
          constructor() {
            this.layerIndexes = {}, this.crossTileIDs = new Zt(), this.maxBucketInstanceId = 0, this.bucketsInCurrentPlacement = {};
          }
          addLayer(e3, t3, i3, o3) {
            let r3 = this.layerIndexes[e3.id];
            void 0 === r3 && (r3 = this.layerIndexes[e3.id] = new Vt());
            let n3 = false;
            const s3 = {};
            "globe" !== o3.name && r3.handleWrapJump(i3);
            for (const i4 of t3) {
              const t4 = i4.getBucket(e3);
              t4 && e3.id === t4.layerIds[0] && (t4.bucketInstanceId || (t4.bucketInstanceId = ++this.maxBucketInstanceId), r3.addBucket(i4.tileID, t4, this.crossTileIDs) && (n3 = true), s3[t4.bucketInstanceId] = true);
            }
            return r3.removeStaleBuckets(s3) && (n3 = true), n3;
          }
          pruneUnusedLayers(e3) {
            const t3 = {};
            e3.forEach((e4) => {
              t3[e4] = true;
            });
            for (const e4 in this.layerIndexes)
              t3[e4] || delete this.layerIndexes[e4];
          }
        }
        const Xt = (t3, i3) => e2.emitValidationErrors(t3, i3 && i3.filter((e3) => "source.canvas" !== e3.identifier)), qt = e2.pick(Ge, ["addLayer", "removeLayer", "setPaintProperty", "setLayoutProperty", "setFilter", "addSource", "removeSource", "setLayerZoomRange", "setLight", "setTransition", "setGeoJSONSourceData", "setTerrain", "setFog", "setProjection"]), $t = e2.pick(Ge, ["setCenter", "setZoom", "setBearing", "setPitch"]), Ht = { version: 8, layers: [], sources: {} }, Yt = { fill: true, line: true, background: true, hillshade: true, raster: true };
        class Kt extends e2.Evented {
          constructor(t3, i3 = {}) {
            super(), this.map = t3, this.dispatcher = new S(Ue(), this), this.imageManager = new y2(), this.imageManager.setEventedParent(this), this.glyphManager = new e2.GlyphManager(t3._requestManager, i3.localFontFamily ? e2.LocalGlyphMode.all : i3.localIdeographFontFamily ? e2.LocalGlyphMode.ideographs : e2.LocalGlyphMode.none, i3.localFontFamily || i3.localIdeographFontFamily), this.crossTileSymbolIndex = new Wt(), this._layers = {}, this._num3DLayers = 0, this._numSymbolLayers = 0, this._numCircleLayers = 0, this._serializedLayers = {}, this._sourceCaches = {}, this._otherSourceCaches = {}, this._symbolSourceCaches = {}, this._loaded = false, this._availableImages = [], this._order = [], this._drapedFirstOrder = [], this._markersNeedUpdate = false, this._resetUpdates(), this.dispatcher.broadcast("setReferrer", e2.getReferrer());
            const o3 = this;
            this._rtlTextPluginCallback = Kt.registerForPluginStateChange((t4) => {
              o3.dispatcher.broadcast("syncRTLPluginState", { pluginStatus: t4.pluginStatus, pluginURL: t4.pluginURL }, (t5, i4) => {
                if (e2.triggerPluginCompletionEvent(t5), i4 && i4.every((e3) => e3))
                  for (const e3 in o3._sourceCaches) {
                    const t6 = o3._sourceCaches[e3], i5 = t6.getSource().type;
                    "vector" !== i5 && "geojson" !== i5 || t6.reload();
                  }
              });
            }), this.on("data", (e3) => {
              if ("source" !== e3.dataType || "metadata" !== e3.sourceDataType)
                return;
              const t4 = this.getSource(e3.sourceId);
              if (t4 && t4.vectorLayerIds)
                for (const e4 in this._layers) {
                  const i4 = this._layers[e4];
                  i4.source === t4.id && this._validateLayer(i4);
                }
            });
          }
          loadURL(t3, i3 = {}) {
            this.fire(new e2.Event("dataloading", { dataType: "style" }));
            const o3 = "boolean" == typeof i3.validate ? i3.validate : !e2.isMapboxURL(t3);
            t3 = this.map._requestManager.normalizeStyleURL(t3, i3.accessToken);
            const r3 = this.map._requestManager.transformRequest(t3, e2.ResourceType.Style);
            this._request = e2.getJSON(r3, (t4, i4) => {
              this._request = null, t4 ? this.fire(new e2.ErrorEvent(t4)) : i4 && this._load(i4, o3);
            });
          }
          loadJSON(t3, i3 = {}) {
            this.fire(new e2.Event("dataloading", { dataType: "style" })), this._request = e2.exported.frame(() => {
              this._request = null, this._load(t3, false !== i3.validate);
            });
          }
          loadEmpty() {
            this.fire(new e2.Event("dataloading", { dataType: "style" })), this._load(Ht, false);
          }
          _updateLayerCount(e3, t3) {
            const i3 = t3 ? 1 : -1;
            e3.is3D() && (this._num3DLayers += i3), "circle" === e3.type && (this._numCircleLayers += i3), "symbol" === e3.type && (this._numSymbolLayers += i3);
          }
          _load(t3, i3) {
            if (i3 && Xt(this, e2.validateStyle(t3)))
              return;
            this._loaded = true, this.stylesheet = e2.clone$1(t3), this._updateMapProjection();
            for (const e3 in t3.sources)
              this.addSource(e3, t3.sources[e3], { validate: false });
            this._changed = false, t3.sprite ? this._loadSprite(t3.sprite) : (this.imageManager.setLoaded(true), this.dispatcher.broadcast("spriteLoaded", true)), this.glyphManager.setURL(t3.glyphs);
            const o3 = je(this.stylesheet.layers);
            this._order = o3.map((e3) => e3.id), this._layers = {}, this._serializedLayers = {};
            for (const t4 of o3) {
              const i4 = e2.createStyleLayer(t4);
              i4.setEventedParent(this, { layer: { id: i4.id } }), this._layers[i4.id] = i4, this._serializedLayers[i4.id] = i4.serialize(), this._updateLayerCount(i4, true);
            }
            this.dispatcher.broadcast("setLayers", this._serializeLayers(this._order)), this.light = new w(this.stylesheet.light), this.stylesheet.terrain && !this.terrainSetForDrapingOnly() && this._createTerrain(this.stylesheet.terrain, 1), this.stylesheet.fog && this._createFog(this.stylesheet.fog), this._updateDrapeFirstLayers(), this.fire(new e2.Event("data", { dataType: "style" })), this.fire(new e2.Event("style.load"));
          }
          terrainSetForDrapingOnly() {
            return !!this.terrain && 0 === this.terrain.drapeRenderMode;
          }
          setProjection(e3) {
            e3 ? this.stylesheet.projection = e3 : delete this.stylesheet.projection, this._updateMapProjection();
          }
          applyProjectionUpdate() {
            this._loaded && (this.dispatcher.broadcast("setProjection", this.map.transform.projectionOptions), this.map.transform.projection.requiresDraping ? this.getTerrain() || this.stylesheet.terrain || this.setTerrainForDraping() : this.terrainSetForDrapingOnly() && this.setTerrain(null));
          }
          _updateMapProjection() {
            this.map._useExplicitProjection ? this.applyProjectionUpdate() : this.map._prioritizeAndUpdateProjection(null, this.stylesheet.projection);
          }
          _loadSprite(t3) {
            this._spriteRequest = function(t4, i3, o3) {
              let r3, n3, s3;
              const a3 = e2.exported.devicePixelRatio > 1 ? "@2x" : "";
              let l2 = e2.getJSON(i3.transformRequest(i3.normalizeSpriteURL(t4, a3, ".json"), e2.ResourceType.SpriteJSON), (e3, t5) => {
                l2 = null, s3 || (s3 = e3, r3 = t5, h3());
              }), c3 = e2.getImage(i3.transformRequest(i3.normalizeSpriteURL(t4, a3, ".png"), e2.ResourceType.SpriteImage), (e3, t5) => {
                c3 = null, s3 || (s3 = e3, n3 = t5, h3());
              });
              function h3() {
                if (s3)
                  o3(s3);
                else if (r3 && n3) {
                  const t5 = e2.exported.getImageData(n3), i4 = {};
                  for (const o4 in r3) {
                    const { width: n4, height: s4, x: a4, y: l3, sdf: c4, pixelRatio: h4, stretchX: u3, stretchY: _2, content: d3 } = r3[o4], p3 = new e2.RGBAImage({ width: n4, height: s4 });
                    e2.RGBAImage.copy(t5, p3, { x: a4, y: l3 }, { x: 0, y: 0 }, { width: n4, height: s4 }), i4[o4] = { data: p3, pixelRatio: h4, sdf: c4, stretchX: u3, stretchY: _2, content: d3 };
                  }
                  o3(null, i4);
                }
              }
              return { cancel() {
                l2 && (l2.cancel(), l2 = null), c3 && (c3.cancel(), c3 = null);
              } };
            }(t3, this.map._requestManager, (t4, i3) => {
              if (this._spriteRequest = null, t4)
                this.fire(new e2.ErrorEvent(t4));
              else if (i3)
                for (const e3 in i3)
                  this.imageManager.addImage(e3, i3[e3]);
              this.imageManager.setLoaded(true), this._availableImages = this.imageManager.listImages(), this.dispatcher.broadcast("setImages", this._availableImages), this.dispatcher.broadcast("spriteLoaded", true), this.fire(new e2.Event("data", { dataType: "style" }));
            });
          }
          _validateLayer(t3) {
            const i3 = this.getSource(t3.source);
            if (!i3)
              return;
            const o3 = t3.sourceLayer;
            o3 && ("geojson" === i3.type || i3.vectorLayerIds && -1 === i3.vectorLayerIds.indexOf(o3)) && this.fire(new e2.ErrorEvent(new Error(`Source layer "${o3}" does not exist on source "${i3.id}" as specified by style layer "${t3.id}"`)));
          }
          loaded() {
            if (!this._loaded)
              return false;
            if (Object.keys(this._updatedSources).length)
              return false;
            for (const e3 in this._sourceCaches)
              if (!this._sourceCaches[e3].loaded())
                return false;
            return !!this.imageManager.isLoaded();
          }
          _serializeLayers(e3) {
            const t3 = [];
            for (const i3 of e3) {
              const e4 = this._layers[i3];
              "custom" !== e4.type && t3.push(e4.serialize());
            }
            return t3;
          }
          hasTransitions() {
            if (this.light && this.light.hasTransition())
              return true;
            if (this.fog && this.fog.hasTransition())
              return true;
            for (const e3 in this._sourceCaches)
              if (this._sourceCaches[e3].hasTransition())
                return true;
            for (const e3 in this._layers)
              if (this._layers[e3].hasTransition())
                return true;
            return false;
          }
          get order() {
            return this.map._optimizeForTerrain && this.terrain ? this._drapedFirstOrder : this._order;
          }
          isLayerDraped(e3) {
            return !!this.terrain && ("function" == typeof e3.isLayerDraped ? e3.isLayerDraped() : Yt[e3.type]);
          }
          _checkLoaded() {
            if (!this._loaded)
              throw new Error("Style is not done loading");
          }
          update(t3) {
            if (!this._loaded)
              return;
            const i3 = this._changed;
            if (this._changed) {
              const e3 = Object.keys(this._updatedLayers), i4 = Object.keys(this._removedLayers);
              (e3.length || i4.length) && this._updateWorkerLayers(e3, i4);
              for (const e4 in this._updatedSources) {
                const t4 = this._updatedSources[e4];
                "reload" === t4 ? this._reloadSource(e4) : "clear" === t4 && this._clearSource(e4);
              }
              this._updateTilesForChangedImages();
              for (const e4 in this._updatedPaintProps)
                this._layers[e4].updateTransitions(t3);
              this.light.updateTransitions(t3), this.fog && this.fog.updateTransitions(t3), this._resetUpdates();
            }
            const o3 = {};
            for (const e3 in this._sourceCaches) {
              const t4 = this._sourceCaches[e3];
              o3[e3] = t4.used, t4.used = false;
            }
            for (const e3 of this._order) {
              const i4 = this._layers[e3];
              if (i4.recalculate(t3, this._availableImages), !i4.isHidden(t3.zoom)) {
                const e4 = this._getLayerSourceCache(i4);
                e4 && (e4.used = true);
              }
              const o4 = this.map.painter;
              if (o4) {
                const e4 = i4.getProgramIds();
                if (!e4)
                  continue;
                const r3 = i4.getProgramConfiguration(t3.zoom);
                for (const t4 of e4)
                  o4.useProgram(t4, r3);
              }
            }
            for (const t4 in o3) {
              const i4 = this._sourceCaches[t4];
              o3[t4] !== i4.used && i4.getSource().fire(new e2.Event("data", { sourceDataType: "visibility", dataType: "source", sourceId: i4.getSource().id }));
            }
            this.light.recalculate(t3), this.terrain && this.terrain.recalculate(t3), this.fog && this.fog.recalculate(t3), this.z = t3.zoom, this._markersNeedUpdate && (this._updateMarkersOpacity(), this._markersNeedUpdate = false), i3 && this.fire(new e2.Event("data", { dataType: "style" }));
          }
          _updateTilesForChangedImages() {
            const e3 = Object.keys(this._changedImages);
            if (e3.length) {
              for (const t3 in this._sourceCaches)
                this._sourceCaches[t3].reloadTilesForDependencies(["icons", "patterns"], e3);
              this._changedImages = {};
            }
          }
          _updateWorkerLayers(e3, t3) {
            this.dispatcher.broadcast("updateLayers", { layers: this._serializeLayers(e3), removedIds: t3 });
          }
          _resetUpdates() {
            this._changed = false, this._updatedLayers = {}, this._removedLayers = {}, this._updatedSources = {}, this._updatedPaintProps = {}, this._changedImages = {};
          }
          setState(i3) {
            if (this._checkLoaded(), Xt(this, e2.validateStyle(i3)))
              return false;
            (i3 = e2.clone$1(i3)).layers = je(i3.layers);
            const o3 = function(e3, i4) {
              if (!e3)
                return [{ command: Ge.setStyle, args: [i4] }];
              let o4 = [];
              try {
                if (!t2(e3.version, i4.version))
                  return [{ command: Ge.setStyle, args: [i4] }];
                t2(e3.center, i4.center) || o4.push({ command: Ge.setCenter, args: [i4.center] }), t2(e3.zoom, i4.zoom) || o4.push({ command: Ge.setZoom, args: [i4.zoom] }), t2(e3.bearing, i4.bearing) || o4.push({ command: Ge.setBearing, args: [i4.bearing] }), t2(e3.pitch, i4.pitch) || o4.push({ command: Ge.setPitch, args: [i4.pitch] }), t2(e3.sprite, i4.sprite) || o4.push({ command: Ge.setSprite, args: [i4.sprite] }), t2(e3.glyphs, i4.glyphs) || o4.push({ command: Ge.setGlyphs, args: [i4.glyphs] }), t2(e3.transition, i4.transition) || o4.push({ command: Ge.setTransition, args: [i4.transition] }), t2(e3.light, i4.light) || o4.push({ command: Ge.setLight, args: [i4.light] }), t2(e3.fog, i4.fog) || o4.push({ command: Ge.setFog, args: [i4.fog] }), t2(e3.projection, i4.projection) || o4.push({ command: Ge.setProjection, args: [i4.projection] });
                const r4 = {}, n3 = [];
                !function(e4, i5, o5, r5) {
                  let n4;
                  for (n4 in i5 = i5 || {}, e4 = e4 || {})
                    e4.hasOwnProperty(n4) && (i5.hasOwnProperty(n4) || Ve(n4, o5, r5));
                  for (n4 in i5) {
                    if (!i5.hasOwnProperty(n4))
                      continue;
                    const s4 = i5[n4];
                    e4.hasOwnProperty(n4) ? t2(e4[n4], s4) || ("geojson" === e4[n4].type && "geojson" === s4.type && Xe(e4, i5, n4) ? o5.push({ command: Ge.setGeoJSONSourceData, args: [n4, s4.data] }) : We(n4, i5, o5, r5)) : Ze(n4, i5, o5);
                  }
                }(e3.sources, i4.sources, n3, r4);
                const s3 = [];
                e3.layers && e3.layers.forEach((e4) => {
                  e4.source && r4[e4.source] ? o4.push({ command: Ge.removeLayer, args: [e4.id] }) : s3.push(e4);
                });
                let a3 = e3.terrain;
                a3 && r4[a3.source] && (o4.push({ command: Ge.setTerrain, args: [void 0] }), a3 = void 0), o4 = o4.concat(n3), t2(a3, i4.terrain) || o4.push({ command: Ge.setTerrain, args: [i4.terrain] }), function(e4, i5, o5) {
                  i5 = i5 || [];
                  const r5 = (e4 = e4 || []).map($e), n4 = i5.map($e), s4 = e4.reduce(He, {}), a4 = i5.reduce(He, {}), l2 = r5.slice(), c3 = /* @__PURE__ */ Object.create(null);
                  let h3, u3, _2, d3, p3, m3, f3;
                  for (h3 = 0, u3 = 0; h3 < r5.length; h3++)
                    _2 = r5[h3], a4.hasOwnProperty(_2) ? u3++ : (o5.push({ command: Ge.removeLayer, args: [_2] }), l2.splice(l2.indexOf(_2, u3), 1));
                  for (h3 = 0, u3 = 0; h3 < n4.length; h3++)
                    _2 = n4[n4.length - 1 - h3], l2[l2.length - 1 - h3] !== _2 && (s4.hasOwnProperty(_2) ? (o5.push({ command: Ge.removeLayer, args: [_2] }), l2.splice(l2.lastIndexOf(_2, l2.length - u3), 1)) : u3++, m3 = l2[l2.length - h3], o5.push({ command: Ge.addLayer, args: [a4[_2], m3] }), l2.splice(l2.length - h3, 0, _2), c3[_2] = true);
                  for (h3 = 0; h3 < n4.length; h3++)
                    if (_2 = n4[h3], d3 = s4[_2], p3 = a4[_2], !c3[_2] && !t2(d3, p3))
                      if (t2(d3.source, p3.source) && t2(d3["source-layer"], p3["source-layer"]) && t2(d3.type, p3.type)) {
                        for (f3 in qe(d3.layout, p3.layout, o5, _2, null, Ge.setLayoutProperty), qe(d3.paint, p3.paint, o5, _2, null, Ge.setPaintProperty), t2(d3.filter, p3.filter) || o5.push({ command: Ge.setFilter, args: [_2, p3.filter] }), t2(d3.minzoom, p3.minzoom) && t2(d3.maxzoom, p3.maxzoom) || o5.push({ command: Ge.setLayerZoomRange, args: [_2, p3.minzoom, p3.maxzoom] }), d3)
                          d3.hasOwnProperty(f3) && "layout" !== f3 && "paint" !== f3 && "filter" !== f3 && "metadata" !== f3 && "minzoom" !== f3 && "maxzoom" !== f3 && (0 === f3.indexOf("paint.") ? qe(d3[f3], p3[f3], o5, _2, f3.slice(6), Ge.setPaintProperty) : t2(d3[f3], p3[f3]) || o5.push({ command: Ge.setLayerProperty, args: [_2, f3, p3[f3]] }));
                        for (f3 in p3)
                          p3.hasOwnProperty(f3) && !d3.hasOwnProperty(f3) && "layout" !== f3 && "paint" !== f3 && "filter" !== f3 && "metadata" !== f3 && "minzoom" !== f3 && "maxzoom" !== f3 && (0 === f3.indexOf("paint.") ? qe(d3[f3], p3[f3], o5, _2, f3.slice(6), Ge.setPaintProperty) : t2(d3[f3], p3[f3]) || o5.push({ command: Ge.setLayerProperty, args: [_2, f3, p3[f3]] }));
                      } else
                        o5.push({ command: Ge.removeLayer, args: [_2] }), m3 = l2[l2.lastIndexOf(_2) + 1], o5.push({ command: Ge.addLayer, args: [p3, m3] });
                }(s3, i4.layers, o4);
              } catch (e4) {
                console.warn("Unable to compute style diff:", e4), o4 = [{ command: Ge.setStyle, args: [i4] }];
              }
              return o4;
            }(this.serialize(), i3).filter((e3) => !(e3.command in $t));
            if (0 === o3.length)
              return false;
            const r3 = o3.filter((e3) => !(e3.command in qt));
            if (r3.length > 0)
              throw new Error(`Unimplemented: ${r3.map((e3) => e3.command).join(", ")}.`);
            return o3.forEach((e3) => {
              "setTransition" !== e3.command && "setProjection" !== e3.command && this[e3.command].apply(this, e3.args);
            }), this.stylesheet = i3, this._updateMapProjection(), true;
          }
          addImage(t3, i3) {
            return this.getImage(t3) ? this.fire(new e2.ErrorEvent(new Error("An image with this name already exists."))) : (this.imageManager.addImage(t3, i3), this._afterImageUpdated(t3), this);
          }
          updateImage(e3, t3) {
            this.imageManager.updateImage(e3, t3);
          }
          getImage(e3) {
            return this.imageManager.getImage(e3);
          }
          removeImage(t3) {
            return this.getImage(t3) ? (this.imageManager.removeImage(t3), this._afterImageUpdated(t3), this) : this.fire(new e2.ErrorEvent(new Error("No image with this name exists.")));
          }
          _afterImageUpdated(t3) {
            this._availableImages = this.imageManager.listImages(), this._changedImages[t3] = true, this._changed = true, this.dispatcher.broadcast("setImages", this._availableImages), this.fire(new e2.Event("data", { dataType: "style" }));
          }
          listImages() {
            return this._checkLoaded(), this._availableImages.slice();
          }
          addSource(t3, i3, o3 = {}) {
            if (this._checkLoaded(), void 0 !== this.getSource(t3))
              throw new Error("There is already a source with this ID");
            if (!i3.type)
              throw new Error(`The type property must be defined, but only the following properties were given: ${Object.keys(i3).join(", ")}.`);
            if (["vector", "raster", "geojson", "video", "image"].indexOf(i3.type) >= 0 && this._validate(e2.validateSource, `sources.${t3}`, i3, null, o3))
              return;
            this.map && this.map._collectResourceTiming && (i3.collectResourceTiming = true);
            const r3 = De(t3, i3, this.dispatcher, this);
            r3.setEventedParent(this, () => ({ isSourceLoaded: this._isSourceCacheLoaded(t3), source: r3.serialize(), sourceId: t3 }));
            const n3 = (i4) => {
              const o4 = (i4 ? "symbol:" : "other:") + t3, n4 = this._sourceCaches[o4] = new e2.SourceCache(o4, r3, i4);
              (i4 ? this._symbolSourceCaches : this._otherSourceCaches)[t3] = n4, n4.style = this, n4.onAdd(this.map);
            };
            n3(false), "vector" !== i3.type && "geojson" !== i3.type || n3(true), r3.onAdd && r3.onAdd(this.map), this._changed = true;
          }
          removeSource(t3) {
            this._checkLoaded();
            const i3 = this.getSource(t3);
            if (!i3)
              throw new Error("There is no source with this ID");
            for (const i4 in this._layers)
              if (this._layers[i4].source === t3)
                return this.fire(new e2.ErrorEvent(new Error(`Source "${t3}" cannot be removed while layer "${i4}" is using it.`)));
            if (this.terrain && this.terrain.get().source === t3)
              return this.fire(new e2.ErrorEvent(new Error(`Source "${t3}" cannot be removed while terrain is using it.`)));
            const o3 = this._getSourceCaches(t3);
            for (const t4 of o3)
              delete this._sourceCaches[t4.id], delete this._updatedSources[t4.id], t4.fire(new e2.Event("data", { sourceDataType: "metadata", dataType: "source", sourceId: t4.getSource().id })), t4.setEventedParent(null), t4.clearTiles();
            return delete this._otherSourceCaches[t3], delete this._symbolSourceCaches[t3], i3.setEventedParent(null), i3.onRemove && i3.onRemove(this.map), this._changed = true, this;
          }
          setGeoJSONSourceData(e3, t3) {
            this._checkLoaded(), this.getSource(e3).setData(t3), this._changed = true;
          }
          getSource(e3) {
            const t3 = this._getSourceCache(e3);
            return t3 && t3.getSource();
          }
          _getSources() {
            const e3 = [];
            for (const t3 in this._otherSourceCaches) {
              const i3 = this._getSourceCache(t3);
              i3 && e3.push(i3.getSource());
            }
            return e3;
          }
          addLayer(t3, i3, o3 = {}) {
            this._checkLoaded();
            const r3 = t3.id;
            if (this.getLayer(r3))
              return void this.fire(new e2.ErrorEvent(new Error(`Layer with id "${r3}" already exists on this map`)));
            let n3;
            if ("custom" === t3.type) {
              if (Xt(this, e2.validateCustomStyleLayer(t3)))
                return;
              n3 = e2.createStyleLayer(t3);
            } else {
              if ("object" == typeof t3.source && (this.addSource(r3, t3.source), t3 = e2.clone$1(t3), t3 = e2.extend(t3, { source: r3 })), this._validate(e2.validateLayer, `layers.${r3}`, t3, { arrayIndex: -1 }, o3))
                return;
              n3 = e2.createStyleLayer(t3), this._validateLayer(n3), n3.setEventedParent(this, { layer: { id: r3 } }), this._serializedLayers[n3.id] = n3.serialize(), this._updateLayerCount(n3, true);
            }
            const s3 = i3 ? this._order.indexOf(i3) : this._order.length;
            if (i3 && -1 === s3)
              return void this.fire(new e2.ErrorEvent(new Error(`Layer with id "${i3}" does not exist on this map.`)));
            this._order.splice(s3, 0, r3), this._layerOrderChanged = true, this._layers[r3] = n3;
            const a3 = this._getLayerSourceCache(n3);
            if (this._removedLayers[r3] && n3.source && a3 && "custom" !== n3.type) {
              const e3 = this._removedLayers[r3];
              delete this._removedLayers[r3], e3.type !== n3.type ? this._updatedSources[n3.source] = "clear" : (this._updatedSources[n3.source] = "reload", a3.pause());
            }
            this._updateLayer(n3), n3.onAdd && n3.onAdd(this.map), this._updateDrapeFirstLayers();
          }
          moveLayer(t3, i3) {
            if (this._checkLoaded(), this._changed = true, !this._layers[t3])
              return void this.fire(new e2.ErrorEvent(new Error(`The layer '${t3}' does not exist in the map's style and cannot be moved.`)));
            if (t3 === i3)
              return;
            const o3 = this._order.indexOf(t3);
            this._order.splice(o3, 1);
            const r3 = i3 ? this._order.indexOf(i3) : this._order.length;
            i3 && -1 === r3 ? this.fire(new e2.ErrorEvent(new Error(`Layer with id "${i3}" does not exist on this map.`))) : (this._order.splice(r3, 0, t3), this._layerOrderChanged = true, this._updateDrapeFirstLayers());
          }
          removeLayer(t3) {
            this._checkLoaded();
            const i3 = this._layers[t3];
            if (!i3)
              return void this.fire(new e2.ErrorEvent(new Error(`The layer '${t3}' does not exist in the map's style and cannot be removed.`)));
            i3.setEventedParent(null), this._updateLayerCount(i3, false);
            const o3 = this._order.indexOf(t3);
            this._order.splice(o3, 1), this._layerOrderChanged = true, this._changed = true, this._removedLayers[t3] = i3, delete this._layers[t3], delete this._serializedLayers[t3], delete this._updatedLayers[t3], delete this._updatedPaintProps[t3], i3.onRemove && i3.onRemove(this.map), this._updateDrapeFirstLayers();
          }
          getLayer(e3) {
            return this._layers[e3];
          }
          hasLayer(e3) {
            return e3 in this._layers;
          }
          hasLayerType(e3) {
            for (const t3 in this._layers)
              if (this._layers[t3].type === e3)
                return true;
            return false;
          }
          setLayerZoomRange(t3, i3, o3) {
            this._checkLoaded();
            const r3 = this.getLayer(t3);
            r3 ? r3.minzoom === i3 && r3.maxzoom === o3 || (null != i3 && (r3.minzoom = i3), null != o3 && (r3.maxzoom = o3), this._updateLayer(r3)) : this.fire(new e2.ErrorEvent(new Error(`The layer '${t3}' does not exist in the map's style and cannot have zoom extent.`)));
          }
          setFilter(i3, o3, r3 = {}) {
            this._checkLoaded();
            const n3 = this.getLayer(i3);
            if (n3) {
              if (!t2(n3.filter, o3))
                return null == o3 ? (n3.filter = void 0, void this._updateLayer(n3)) : void (this._validate(e2.validateFilter, `layers.${n3.id}.filter`, o3, { layerType: n3.type }, r3) || (n3.filter = e2.clone$1(o3), this._updateLayer(n3)));
            } else
              this.fire(new e2.ErrorEvent(new Error(`The layer '${i3}' does not exist in the map's style and cannot be filtered.`)));
          }
          getFilter(t3) {
            const i3 = this.getLayer(t3);
            return i3 && e2.clone$1(i3.filter);
          }
          setLayoutProperty(i3, o3, r3, n3 = {}) {
            this._checkLoaded();
            const s3 = this.getLayer(i3);
            s3 ? t2(s3.getLayoutProperty(o3), r3) || (s3.setLayoutProperty(o3, r3, n3), this._updateLayer(s3)) : this.fire(new e2.ErrorEvent(new Error(`The layer '${i3}' does not exist in the map's style and cannot be styled.`)));
          }
          getLayoutProperty(t3, i3) {
            const o3 = this.getLayer(t3);
            if (o3)
              return o3.getLayoutProperty(i3);
            this.fire(new e2.ErrorEvent(new Error(`The layer '${t3}' does not exist in the map's style.`)));
          }
          setPaintProperty(i3, o3, r3, n3 = {}) {
            this._checkLoaded();
            const s3 = this.getLayer(i3);
            s3 ? t2(s3.getPaintProperty(o3), r3) || (s3.setPaintProperty(o3, r3, n3) && this._updateLayer(s3), this._changed = true, this._updatedPaintProps[i3] = true) : this.fire(new e2.ErrorEvent(new Error(`The layer '${i3}' does not exist in the map's style and cannot be styled.`)));
          }
          getPaintProperty(e3, t3) {
            const i3 = this.getLayer(e3);
            return i3 && i3.getPaintProperty(t3);
          }
          setFeatureState(t3, i3) {
            this._checkLoaded();
            const o3 = t3.source, r3 = t3.sourceLayer, n3 = this.getSource(o3);
            if (!n3)
              return void this.fire(new e2.ErrorEvent(new Error(`The source '${o3}' does not exist in the map's style.`)));
            const s3 = n3.type;
            if ("geojson" === s3 && r3)
              return void this.fire(new e2.ErrorEvent(new Error("GeoJSON sources cannot have a sourceLayer parameter.")));
            if ("vector" === s3 && !r3)
              return void this.fire(new e2.ErrorEvent(new Error("The sourceLayer parameter must be provided for vector source types.")));
            void 0 === t3.id && this.fire(new e2.ErrorEvent(new Error("The feature id parameter must be provided.")));
            const a3 = this._getSourceCaches(o3);
            for (const e3 of a3)
              e3.setFeatureState(r3, t3.id, i3);
          }
          removeFeatureState(t3, i3) {
            this._checkLoaded();
            const o3 = t3.source, r3 = this.getSource(o3);
            if (!r3)
              return void this.fire(new e2.ErrorEvent(new Error(`The source '${o3}' does not exist in the map's style.`)));
            const n3 = r3.type, s3 = "vector" === n3 ? t3.sourceLayer : void 0;
            if ("vector" === n3 && !s3)
              return void this.fire(new e2.ErrorEvent(new Error("The sourceLayer parameter must be provided for vector source types.")));
            if (i3 && "string" != typeof t3.id && "number" != typeof t3.id)
              return void this.fire(new e2.ErrorEvent(new Error("A feature id is required to remove its specific state property.")));
            const a3 = this._getSourceCaches(o3);
            for (const e3 of a3)
              e3.removeFeatureState(s3, t3.id, i3);
          }
          getFeatureState(t3) {
            this._checkLoaded();
            const i3 = t3.source, o3 = t3.sourceLayer, r3 = this.getSource(i3);
            if (r3) {
              if ("vector" !== r3.type || o3)
                return void 0 === t3.id && this.fire(new e2.ErrorEvent(new Error("The feature id parameter must be provided."))), this._getSourceCaches(i3)[0].getFeatureState(o3, t3.id);
              this.fire(new e2.ErrorEvent(new Error("The sourceLayer parameter must be provided for vector source types.")));
            } else
              this.fire(new e2.ErrorEvent(new Error(`The source '${i3}' does not exist in the map's style.`)));
          }
          getTransition() {
            return e2.extend({ duration: 300, delay: 0 }, this.stylesheet && this.stylesheet.transition);
          }
          serialize() {
            const t3 = {};
            for (const e3 in this._sourceCaches) {
              const i3 = this._sourceCaches[e3].getSource();
              t3[i3.id] || (t3[i3.id] = i3.serialize());
            }
            return e2.filterObject({ version: this.stylesheet.version, name: this.stylesheet.name, metadata: this.stylesheet.metadata, light: this.stylesheet.light, terrain: this.getTerrain() || void 0, fog: this.stylesheet.fog, center: this.stylesheet.center, zoom: this.stylesheet.zoom, bearing: this.stylesheet.bearing, pitch: this.stylesheet.pitch, sprite: this.stylesheet.sprite, glyphs: this.stylesheet.glyphs, transition: this.stylesheet.transition, projection: this.stylesheet.projection, sources: t3, layers: this._serializeLayers(this._order) }, (e3) => void 0 !== e3);
          }
          _updateLayer(e3) {
            this._updatedLayers[e3.id] = true;
            const t3 = this._getLayerSourceCache(e3);
            e3.source && !this._updatedSources[e3.source] && t3 && "raster" !== t3.getSource().type && (this._updatedSources[e3.source] = "reload", t3.pause()), this._changed = true, e3.invalidateCompiledFilter();
          }
          _flattenAndSortRenderedFeatures(e3) {
            const t3 = (e4) => "fill-extrusion" === this._layers[e4].type, i3 = {}, o3 = [];
            for (let r4 = this._order.length - 1; r4 >= 0; r4--) {
              const n3 = this._order[r4];
              if (t3(n3)) {
                i3[n3] = r4;
                for (const t4 of e3) {
                  const e4 = t4[n3];
                  if (e4)
                    for (const t5 of e4)
                      o3.push(t5);
                }
              }
            }
            o3.sort((e4, t4) => t4.intersectionZ - e4.intersectionZ);
            const r3 = [];
            for (let n3 = this._order.length - 1; n3 >= 0; n3--) {
              const s3 = this._order[n3];
              if (t3(s3))
                for (let e4 = o3.length - 1; e4 >= 0; e4--) {
                  const t4 = o3[e4].feature;
                  if (i3[t4.layer.id] < n3)
                    break;
                  r3.push(t4), o3.pop();
                }
              else
                for (const t4 of e3) {
                  const e4 = t4[s3];
                  if (e4)
                    for (const t5 of e4)
                      r3.push(t5.feature);
                }
            }
            return r3;
          }
          queryRenderedFeatures(t3, i3, o3) {
            i3 && i3.filter && this._validate(e2.validateFilter, "queryRenderedFeatures.filter", i3.filter, null, i3);
            const r3 = {};
            if (i3 && i3.layers) {
              if (!Array.isArray(i3.layers))
                return this.fire(new e2.ErrorEvent(new Error("parameters.layers must be an Array."))), [];
              for (const t4 of i3.layers) {
                const i4 = this._layers[t4];
                if (!i4)
                  return this.fire(new e2.ErrorEvent(new Error(`The layer '${t4}' does not exist in the map's style and cannot be queried for features.`))), [];
                r3[i4.source] = true;
              }
            }
            const n3 = [];
            i3.availableImages = this._availableImages;
            const s3 = i3 && i3.layers ? i3.layers.some((e3) => {
              const t4 = this.getLayer(e3);
              return t4 && t4.is3D();
            }) : this.has3DLayers(), a3 = L.createFromScreenPoints(t3, o3);
            for (const e3 in this._sourceCaches) {
              const t4 = this._sourceCaches[e3].getSource().id;
              i3.layers && !r3[t4] || n3.push(Ae(this._sourceCaches[e3], this._layers, this._serializedLayers, a3, i3, o3, s3, !!this.map._showQueryGeometry));
            }
            return this.placement && n3.push(function(e3, t4, i4, o4, r4, n4, s4) {
              const a4 = {}, l2 = n4.queryRenderedSymbols(o4), c3 = [];
              for (const e4 of Object.keys(l2).map(Number))
                c3.push(s4[e4]);
              c3.sort(Re);
              for (const i5 of c3) {
                const o5 = i5.featureIndex.lookupSymbolFeatures(l2[i5.bucketInstanceId], t4, i5.bucketIndex, i5.sourceLayerIndex, r4.filter, r4.layers, r4.availableImages, e3);
                for (const e4 in o5) {
                  const t5 = a4[e4] = a4[e4] || [], r5 = o5[e4];
                  r5.sort((e5, t6) => {
                    const o6 = i5.featureSortOrder;
                    if (o6) {
                      const i6 = o6.indexOf(e5.featureIndex);
                      return o6.indexOf(t6.featureIndex) - i6;
                    }
                    return t6.featureIndex - e5.featureIndex;
                  });
                  for (const e5 of r5)
                    t5.push(e5);
                }
              }
              for (const t5 in a4)
                a4[t5].forEach((o5) => {
                  const r5 = o5.feature, n5 = i4(e3[t5]);
                  if (!n5)
                    return;
                  const s5 = n5.getFeatureState(r5.layer["source-layer"], r5.id);
                  r5.source = r5.layer.source, r5.layer["source-layer"] && (r5.sourceLayer = r5.layer["source-layer"]), r5.state = s5;
                });
              return a4;
            }(this._layers, this._serializedLayers, this._getLayerSourceCache.bind(this), a3.screenGeometry, i3, this.placement.collisionIndex, this.placement.retainedQueryData)), this._flattenAndSortRenderedFeatures(n3);
          }
          querySourceFeatures(t3, i3) {
            i3 && i3.filter && this._validate(e2.validateFilter, "querySourceFeatures.filter", i3.filter, null, i3);
            const o3 = this._getSourceCaches(t3);
            let r3 = [];
            for (const e3 of o3)
              r3 = r3.concat(ze(e3, i3));
            return r3;
          }
          addSourceType(e3, t3, i3) {
            return Kt.getSourceType(e3) ? i3(new Error(`A source type called "${e3}" already exists.`)) : (Kt.setSourceType(e3, t3), t3.workerSourceURL ? void this.dispatcher.broadcast("loadWorkerSource", { name: e3, url: t3.workerSourceURL }, i3) : i3(null, null));
          }
          getLight() {
            return this.light.getLight();
          }
          setLight(e3, i3 = {}) {
            this._checkLoaded();
            const o3 = this.light.getLight();
            let r3 = false;
            for (const i4 in e3)
              if (!t2(e3[i4], o3[i4])) {
                r3 = true;
                break;
              }
            if (!r3)
              return;
            const n3 = this._setTransitionParameters({ duration: 300, delay: 0 });
            this.light.setLight(e3, i3), this.light.updateTransitions(n3);
          }
          getTerrain() {
            return this.terrain && 1 === this.terrain.drapeRenderMode ? this.terrain.get() : null;
          }
          setTerrainForDraping() {
            this.setTerrain({ source: "", exaggeration: 0 }, 0);
          }
          setTerrain(i3, o3 = 1) {
            if (this._checkLoaded(), !i3)
              return delete this.terrain, delete this.stylesheet.terrain, this.dispatcher.broadcast("enableTerrain", false), this._force3DLayerUpdate(), void (this._markersNeedUpdate = true);
            let r3 = i3;
            if (1 === o3) {
              if ("object" == typeof r3.source) {
                const t3 = "terrain-dem-src";
                this.addSource(t3, r3.source), r3 = e2.clone$1(r3), r3 = e2.extend(r3, { source: t3 });
              }
              if (this._validate(e2.validateTerrain, "terrain", r3))
                return;
            }
            if (!this.terrain || this.terrain && o3 !== this.terrain.drapeRenderMode) {
              if (!r3)
                return;
              this._createTerrain(r3, o3);
            } else {
              const i4 = this.terrain, o4 = i4.get();
              for (const t3 of Object.keys(e2.spec.terrain))
                !r3.hasOwnProperty(t3) && e2.spec.terrain[t3].default && (r3[t3] = e2.spec.terrain[t3].default);
              for (const e3 in r3)
                if (!t2(r3[e3], o4[e3])) {
                  i4.set(r3), this.stylesheet.terrain = r3;
                  const e4 = this._setTransitionParameters({ duration: 0 });
                  i4.updateTransitions(e4);
                  break;
                }
            }
            this._updateDrapeFirstLayers(), this._markersNeedUpdate = true;
          }
          _createFog(e3) {
            const t3 = this.fog = new P(e3, this.map.transform);
            this.stylesheet.fog = e3;
            const i3 = this._setTransitionParameters({ duration: 0 });
            t3.updateTransitions(i3);
          }
          _updateMarkersOpacity() {
            0 !== this.map._markers.length && this.map._requestDomTask(() => {
              for (const e3 of this.map._markers)
                e3._evaluateOpacity();
            });
          }
          getFog() {
            return this.fog ? this.fog.get() : null;
          }
          setFog(e3) {
            if (this._checkLoaded(), !e3)
              return delete this.fog, delete this.stylesheet.fog, void (this._markersNeedUpdate = true);
            if (this.fog) {
              const i3 = this.fog, o3 = i3.get();
              0 === Object.keys(e3).length && i3.set(e3);
              for (const r3 in e3)
                if (!t2(e3[r3], o3[r3])) {
                  i3.set(e3), this.stylesheet.fog = e3;
                  const t3 = this._setTransitionParameters({ duration: 0 });
                  i3.updateTransitions(t3);
                  break;
                }
            } else
              this._createFog(e3);
            this._markersNeedUpdate = true;
          }
          _setTransitionParameters(t3) {
            return { now: e2.exported.now(), transition: e2.extend(t3, this.stylesheet.transition) };
          }
          _updateDrapeFirstLayers() {
            if (!this.map._optimizeForTerrain || !this.terrain)
              return;
            const e3 = this._order.filter((e4) => this.isLayerDraped(this._layers[e4])), t3 = this._order.filter((e4) => !this.isLayerDraped(this._layers[e4]));
            this._drapedFirstOrder = [], this._drapedFirstOrder.push(...e3), this._drapedFirstOrder.push(...t3);
          }
          _createTerrain(e3, t3) {
            const i3 = this.terrain = new E2(e3, t3);
            this.stylesheet.terrain = e3, this.dispatcher.broadcast("enableTerrain", !this.terrainSetForDrapingOnly()), this._force3DLayerUpdate();
            const o3 = this._setTransitionParameters({ duration: 0 });
            i3.updateTransitions(o3);
          }
          _force3DLayerUpdate() {
            for (const e3 in this._layers) {
              const t3 = this._layers[e3];
              "fill-extrusion" === t3.type && this._updateLayer(t3);
            }
          }
          _forceSymbolLayerUpdate() {
            for (const e3 in this._layers) {
              const t3 = this._layers[e3];
              "symbol" === t3.type && this._updateLayer(t3);
            }
          }
          _validate(t3, i3, o3, r3, n3 = {}) {
            return (!n3 || false !== n3.validate) && Xt(this, t3.call(e2.validateStyle, e2.extend({ key: i3, style: this.serialize(), value: o3, styleSpec: e2.spec }, r3)));
          }
          _remove() {
            this._request && (this._request.cancel(), this._request = null), this._spriteRequest && (this._spriteRequest.cancel(), this._spriteRequest = null), e2.evented.off("pluginStateChange", this._rtlTextPluginCallback);
            for (const e3 in this._layers)
              this._layers[e3].setEventedParent(null);
            for (const e3 in this._sourceCaches)
              this._sourceCaches[e3].clearTiles(), this._sourceCaches[e3].setEventedParent(null);
            this.imageManager.setEventedParent(null), this.setEventedParent(null), this.dispatcher.remove();
          }
          _clearSource(e3) {
            const t3 = this._getSourceCaches(e3);
            for (const e4 of t3)
              e4.clearTiles();
          }
          _reloadSource(e3) {
            const t3 = this._getSourceCaches(e3);
            for (const e4 of t3)
              e4.resume(), e4.reload();
          }
          _reloadSources() {
            for (const e3 of this._getSources())
              e3.reload && e3.reload();
          }
          _updateSources(e3) {
            for (const t3 in this._sourceCaches)
              this._sourceCaches[t3].update(e3);
          }
          _generateCollisionBoxes() {
            for (const e3 in this._sourceCaches) {
              const t3 = this._sourceCaches[e3];
              t3.resume(), t3.reload();
            }
          }
          _updatePlacement(t3, i3, o3, r3, n3 = false) {
            let s3 = false, a3 = false;
            const l2 = {};
            for (const e3 of this._order) {
              const i4 = this._layers[e3];
              if ("symbol" !== i4.type)
                continue;
              if (!l2[i4.source]) {
                const e4 = this._getLayerSourceCache(i4);
                if (!e4)
                  continue;
                l2[i4.source] = e4.getRenderableIds(true).map((t4) => e4.getTileByID(t4)).sort((e5, t4) => t4.tileID.overscaledZ - e5.tileID.overscaledZ || (e5.tileID.isLessThan(t4.tileID) ? -1 : 1));
              }
              const o4 = this.crossTileSymbolIndex.addLayer(i4, l2[i4.source], t3.center.lng, t3.projection);
              s3 = s3 || o4;
            }
            if (this.crossTileSymbolIndex.pruneUnusedLayers(this._order), n3 = n3 || this._layerOrderChanged || 0 === o3, this._layerOrderChanged && this.fire(new e2.Event("neworder")), (n3 || !this.pauseablePlacement || this.pauseablePlacement.isDone() && !this.placement.stillRecent(e2.exported.now(), t3.zoom)) && (this.pauseablePlacement = new Nt(t3, this._order, n3, i3, o3, r3, this.placement, this.fog && t3.projection.supportsFog ? this.fog.state : null), this._layerOrderChanged = false), this.pauseablePlacement.isDone() ? this.placement.setStale() : (this.pauseablePlacement.continuePlacement(this._order, this._layers, l2), this.pauseablePlacement.isDone() && (this.placement = this.pauseablePlacement.commit(e2.exported.now()), a3 = true), s3 && this.pauseablePlacement.placement.setStale()), a3 || s3)
              for (const e3 of this._order) {
                const t4 = this._layers[e3];
                "symbol" === t4.type && this.placement.updateLayerOpacities(t4, l2[t4.source]);
              }
            return !this.pauseablePlacement.isDone() || this.placement.hasTransitions(e2.exported.now());
          }
          _releaseSymbolFadeTiles() {
            for (const e3 in this._sourceCaches)
              this._sourceCaches[e3].releaseSymbolFadeTiles();
          }
          getImages(e3, t3, i3) {
            this.imageManager.getImages(t3.icons, i3), this._updateTilesForChangedImages();
            const o3 = (e4) => {
              e4 && e4.setDependencies(t3.tileID.key, t3.type, t3.icons);
            };
            o3(this._otherSourceCaches[t3.source]), o3(this._symbolSourceCaches[t3.source]);
          }
          getGlyphs(e3, t3, i3) {
            this.glyphManager.getGlyphs(t3.stacks, i3);
          }
          getResource(t3, i3, o3) {
            return e2.makeRequest(i3, o3);
          }
          _getSourceCache(e3) {
            return this._otherSourceCaches[e3];
          }
          _getLayerSourceCache(e3) {
            return "symbol" === e3.type ? this._symbolSourceCaches[e3.source] : this._otherSourceCaches[e3.source];
          }
          _getSourceCaches(e3) {
            const t3 = [];
            return this._otherSourceCaches[e3] && t3.push(this._otherSourceCaches[e3]), this._symbolSourceCaches[e3] && t3.push(this._symbolSourceCaches[e3]), t3;
          }
          _isSourceCacheLoaded(t3) {
            const i3 = this._getSourceCaches(t3);
            return 0 === i3.length ? (this.fire(new e2.ErrorEvent(new Error(`There is no source with ID '${t3}'`))), false) : i3.every((e3) => e3.loaded());
          }
          has3DLayers() {
            return this._num3DLayers > 0;
          }
          hasSymbolLayers() {
            return this._numSymbolLayers > 0;
          }
          hasCircleLayers() {
            return this._numCircleLayers > 0;
          }
          _clearWorkerCaches() {
            this.dispatcher.broadcast("clearCaches");
          }
          destroy() {
            this._clearWorkerCaches(), this.terrainSetForDrapingOnly() && (delete this.terrain, delete this.stylesheet.terrain);
          }
        }
        Kt.getSourceType = function(e3) {
          return Se[e3];
        }, Kt.setSourceType = function(e3, t3) {
          Se[e3] = t3;
        }, Kt.registerForPluginStateChange = e2.registerForPluginStateChange;
        var Jt = "\n#define EPSILON 0.0000001\n#define PI 3.141592653589793\n#define EXTENT 8192.0\n#define HALF_PI PI/2.0\n#define QUARTER_PI PI/4.0\n#define RAD_TO_DEG 180.0/PI\n#define DEG_TO_RAD PI/180.0\n#define GLOBE_RADIUS EXTENT/PI/2.0", Qt = "attribute highp vec3 a_pos_3f;uniform lowp mat4 u_matrix;varying highp vec3 v_uv;void main() {const mat3 half_neg_pi_around_x=mat3(1.0,0.0, 0.0,0.0,0.0,-1.0,0.0,1.0, 0.0);v_uv=half_neg_pi_around_x*a_pos_3f;vec4 pos=u_matrix*vec4(a_pos_3f,1.0);gl_Position=pos.xyww;}", ei = "\n#define ELEVATION_SCALE 7.0\n#define ELEVATION_OFFSET 450.0\n#ifdef PROJECTION_GLOBE_VIEW\nuniform vec3 u_tile_tl_up;uniform vec3 u_tile_tr_up;uniform vec3 u_tile_br_up;uniform vec3 u_tile_bl_up;uniform float u_tile_up_scale;vec3 elevationVector(vec2 pos) {vec2 uv=pos/EXTENT;vec3 up=normalize(mix(\nmix(u_tile_tl_up,u_tile_tr_up,uv.xxx),mix(u_tile_bl_up,u_tile_br_up,uv.xxx),uv.yyy));return up*u_tile_up_scale;}\n#else\nvec3 elevationVector(vec2 pos) { return vec3(0,0,1); }\n#endif\nconst float skirtOffset=24575.0;vec3 decomposeToPosAndSkirt(vec2 posWithComposedSkirt)\n{float skirt=float(posWithComposedSkirt.x >=skirtOffset);vec2 pos=posWithComposedSkirt-vec2(skirt*skirtOffset,0.0);return vec3(pos,skirt);}\n#ifdef TERRAIN\n#ifdef TERRAIN_DEM_FLOAT_FORMAT\nuniform highp sampler2D u_dem;uniform highp sampler2D u_dem_prev;\n#else\nuniform sampler2D u_dem;uniform sampler2D u_dem_prev;\n#endif\nuniform vec4 u_dem_unpack;uniform vec2 u_dem_tl;uniform vec2 u_dem_tl_prev;uniform float u_dem_scale;uniform float u_dem_scale_prev;uniform float u_dem_size;uniform float u_dem_lerp;uniform float u_exaggeration;uniform float u_meter_to_dem;uniform mat4 u_label_plane_matrix_inv;uniform sampler2D u_depth;uniform vec2 u_depth_size_inv;vec4 tileUvToDemSample(vec2 uv,float dem_size,float dem_scale,vec2 dem_tl) {vec2 pos=dem_size*(uv*dem_scale+dem_tl)+1.0;vec2 f=fract(pos);return vec4((pos-f+0.5)/(dem_size+2.0),f);}float decodeElevation(vec4 v) {return dot(vec4(v.xyz*255.0,-1.0),u_dem_unpack);}float currentElevation(vec2 apos) {\n#ifdef TERRAIN_DEM_FLOAT_FORMAT\nvec2 pos=(u_dem_size*(apos/8192.0*u_dem_scale+u_dem_tl)+1.5)/(u_dem_size+2.0);return u_exaggeration*texture2D(u_dem,pos).a;\n#else\nfloat dd=1.0/(u_dem_size+2.0);vec4 r=tileUvToDemSample(apos/8192.0,u_dem_size,u_dem_scale,u_dem_tl);vec2 pos=r.xy;vec2 f=r.zw;float tl=decodeElevation(texture2D(u_dem,pos));\n#ifdef TERRAIN_DEM_NEAREST_FILTER\nreturn u_exaggeration*tl;\n#endif\nfloat tr=decodeElevation(texture2D(u_dem,pos+vec2(dd,0.0)));float bl=decodeElevation(texture2D(u_dem,pos+vec2(0.0,dd)));float br=decodeElevation(texture2D(u_dem,pos+vec2(dd,dd)));return u_exaggeration*mix(mix(tl,tr,f.x),mix(bl,br,f.x),f.y);\n#endif\n}float prevElevation(vec2 apos) {\n#ifdef TERRAIN_DEM_FLOAT_FORMAT\nvec2 pos=(u_dem_size*(apos/8192.0*u_dem_scale_prev+u_dem_tl_prev)+1.5)/(u_dem_size+2.0);return u_exaggeration*texture2D(u_dem_prev,pos).a;\n#else\nfloat dd=1.0/(u_dem_size+2.0);vec4 r=tileUvToDemSample(apos/8192.0,u_dem_size,u_dem_scale_prev,u_dem_tl_prev);vec2 pos=r.xy;vec2 f=r.zw;float tl=decodeElevation(texture2D(u_dem_prev,pos));float tr=decodeElevation(texture2D(u_dem_prev,pos+vec2(dd,0.0)));float bl=decodeElevation(texture2D(u_dem_prev,pos+vec2(0.0,dd)));float br=decodeElevation(texture2D(u_dem_prev,pos+vec2(dd,dd)));return u_exaggeration*mix(mix(tl,tr,f.x),mix(bl,br,f.x),f.y);\n#endif\n}\n#ifdef TERRAIN_VERTEX_MORPHING\nfloat elevation(vec2 apos) {\n#ifdef ZERO_EXAGGERATION\nreturn 0.0;\n#endif\nfloat nextElevation=currentElevation(apos);float prevElevation=prevElevation(apos);return mix(prevElevation,nextElevation,u_dem_lerp);}\n#else\nfloat elevation(vec2 apos) {\n#ifdef ZERO_EXAGGERATION\nreturn 0.0;\n#endif\nreturn currentElevation(apos);}\n#endif\nhighp float unpack_depth(highp vec4 rgba_depth)\n{const highp vec4 bit_shift=vec4(1.0/(255.0*255.0*255.0),1.0/(255.0*255.0),1.0/255.0,1.0);return dot(rgba_depth,bit_shift)*2.0-1.0;}bool isOccluded(vec4 frag) {vec3 coord=frag.xyz/frag.w;float depth=unpack_depth(texture2D(u_depth,(coord.xy+1.0)*0.5));return coord.z > depth+0.0005;}float occlusionFade(vec4 frag) {vec3 coord=frag.xyz/frag.w;vec3 df=vec3(5.0*u_depth_size_inv,0.0);vec2 uv=0.5*coord.xy+0.5;vec4 depth=vec4(\nunpack_depth(texture2D(u_depth,uv-df.xz)),unpack_depth(texture2D(u_depth,uv+df.xz)),unpack_depth(texture2D(u_depth,uv-df.zy)),unpack_depth(texture2D(u_depth,uv+df.zy))\n);return dot(vec4(0.25),vec4(1.0)-clamp(300.0*(vec4(coord.z-0.001)-depth),0.0,1.0));}vec4 fourSample(vec2 pos,vec2 off) {\n#ifdef TERRAIN_DEM_FLOAT_FORMAT\nfloat tl=texture2D(u_dem,pos).a;float tr=texture2D(u_dem,pos+vec2(off.x,0.0)).a;float bl=texture2D(u_dem,pos+vec2(0.0,off.y)).a;float br=texture2D(u_dem,pos+off).a;\n#else\nvec4 demtl=vec4(texture2D(u_dem,pos).xyz*255.0,-1.0);float tl=dot(demtl,u_dem_unpack);vec4 demtr=vec4(texture2D(u_dem,pos+vec2(off.x,0.0)).xyz*255.0,-1.0);float tr=dot(demtr,u_dem_unpack);vec4 dembl=vec4(texture2D(u_dem,pos+vec2(0.0,off.y)).xyz*255.0,-1.0);float bl=dot(dembl,u_dem_unpack);vec4 dembr=vec4(texture2D(u_dem,pos+off).xyz*255.0,-1.0);float br=dot(dembr,u_dem_unpack);\n#endif\nreturn vec4(tl,tr,bl,br);}float flatElevation(vec2 pack) {vec2 apos=floor(pack/8.0);vec2 span=10.0*(pack-apos*8.0);vec2 uvTex=(apos-vec2(1.0,1.0))/8190.0;float size=u_dem_size+2.0;float dd=1.0/size;vec2 pos=u_dem_size*(uvTex*u_dem_scale+u_dem_tl)+1.0;vec2 f=fract(pos);pos=(pos-f+0.5)*dd;vec4 h=fourSample(pos,vec2(dd));float z=mix(mix(h.x,h.y,f.x),mix(h.z,h.w,f.x),f.y);vec2 w=floor(0.5*(span*u_meter_to_dem-1.0));vec2 d=dd*w;h=fourSample(pos-d,2.0*d+vec2(dd));vec4 diff=abs(h.xzxy-h.ywzw);vec2 slope=min(vec2(0.25),u_meter_to_dem*0.5*(diff.xz+diff.yw)/(2.0*w+vec2(1.0)));vec2 fix=slope*span;float base=z+max(fix.x,fix.y);return u_exaggeration*base;}float elevationFromUint16(float word) {return u_exaggeration*(word/ELEVATION_SCALE-ELEVATION_OFFSET);}\n#else\nfloat elevation(vec2 pos) { return 0.0; }bool isOccluded(vec4 frag) { return false; }float occlusionFade(vec4 frag) { return 1.0; }\n#endif", ti = "#ifdef FOG\nuniform mediump vec4 u_fog_color;uniform mediump vec2 u_fog_range;uniform mediump float u_fog_horizon_blend;uniform mediump mat4 u_fog_matrix;varying vec3 v_fog_pos;float fog_range(float depth) {return (depth-u_fog_range[0])/(u_fog_range[1]-u_fog_range[0]);}float fog_horizon_blending(vec3 camera_dir) {float t=max(0.0,camera_dir.z/u_fog_horizon_blend);return u_fog_color.a*exp(-3.0*t*t);}float fog_opacity(float t) {const float decay=6.0;float falloff=1.0-min(1.0,exp(-decay*t));falloff*=falloff*falloff;return u_fog_color.a*min(1.0,1.00747*falloff);}vec3 fog_position(vec3 pos) {return (u_fog_matrix*vec4(pos,1.0)).xyz;}vec3 fog_position(vec2 pos) {return fog_position(vec3(pos,0.0));}float fog(vec3 pos) {float depth=length(pos);float opacity=fog_opacity(fog_range(depth));return opacity*fog_horizon_blending(pos/depth);}\n#endif", ii = "#ifdef FOG\nuniform mediump vec4 u_fog_color;uniform mediump vec2 u_fog_range;uniform mediump float u_fog_horizon_blend;uniform mediump float u_fog_temporal_offset;varying vec3 v_fog_pos;uniform highp vec3 u_frustum_tl;uniform highp vec3 u_frustum_tr;uniform highp vec3 u_frustum_br;uniform highp vec3 u_frustum_bl;uniform highp vec3 u_globe_pos;uniform highp float u_globe_radius;uniform highp vec2 u_viewport;uniform float u_globe_transition;uniform int u_is_globe;float fog_range(float depth) {return (depth-u_fog_range[0])/(u_fog_range[1]-u_fog_range[0]);}float fog_horizon_blending(vec3 camera_dir) {float t=max(0.0,camera_dir.z/u_fog_horizon_blend);return u_fog_color.a*exp(-3.0*t*t);}float fog_opacity(float t) {const float decay=6.0;float falloff=1.0-min(1.0,exp(-decay*t));falloff*=falloff*falloff;return u_fog_color.a*min(1.0,1.00747*falloff);}float globe_glow_progress() {highp vec2 uv=gl_FragCoord.xy/u_viewport;highp vec3 ray_dir=mix(\nmix(u_frustum_tl,u_frustum_tr,uv.x),mix(u_frustum_bl,u_frustum_br,uv.x),1.0-uv.y);highp vec3 dir=normalize(ray_dir);highp vec3 closest_point=dot(u_globe_pos,dir)*dir;highp float sdf=length(closest_point-u_globe_pos)/u_globe_radius;return sdf+PI*0.5;}float fog_opacity(vec3 pos) {float depth=length(pos);return fog_opacity(fog_range(depth));}vec3 fog_apply(vec3 color,vec3 pos) {float depth=length(pos);float opacity;if (u_is_globe==1) {float glow_progress=globe_glow_progress();float t=mix(glow_progress,depth,u_globe_transition);opacity=fog_opacity(fog_range(t));} else {opacity=fog_opacity(fog_range(depth));opacity*=fog_horizon_blending(pos/depth);}return mix(color,u_fog_color.rgb,opacity);}vec4 fog_apply_from_vert(vec4 color,float fog_opac) {float alpha=EPSILON+color.a;color.rgb=mix(color.rgb/alpha,u_fog_color.rgb,fog_opac)*alpha;return color;}vec3 fog_apply_sky_gradient(vec3 camera_ray,vec3 sky_color) {float horizon_blend=fog_horizon_blending(normalize(camera_ray));return mix(sky_color,u_fog_color.rgb,horizon_blend);}vec4 fog_apply_premultiplied(vec4 color,vec3 pos) {float alpha=EPSILON+color.a;color.rgb=fog_apply(color.rgb/alpha,pos)*alpha;return color;}vec3 fog_dither(vec3 color) {vec2 dither_seed=gl_FragCoord.xy+u_fog_temporal_offset;return dither(color,dither_seed);}vec4 fog_dither(vec4 color) {return vec4(fog_dither(color.rgb),color.a);}\n#endif";
        let oi = {}, ri = {};
        const ni = [];
        hi(Jt, ni), hi(ei, ni), hi(ti, ni), hi(ii, ni), oi = ui("", ei), ri = ui(ii, ti);
        const si = ui("\n#if __VERSION__ >=300\n#define varying in\n#define gl_FragColor glFragColor\n#define texture2D texture\n#define textureCube texture\nout vec4 glFragColor;\n#endif\nhighp vec3 hash(highp vec2 p) {highp vec3 p3=fract(p.xyx*vec3(443.8975,397.2973,491.1871));p3+=dot(p3,p3.yxz+19.19);return fract((p3.xxy+p3.yzz)*p3.zyx);}vec3 dither(vec3 color,highp vec2 seed) {vec3 rnd=hash(seed)+hash(seed+0.59374)-0.5;return color+rnd/255.0;}highp float unpack_depth(highp vec4 rgba_depth)\n{const highp vec4 bit_shift=vec4(1.0/(255.0*255.0*255.0),1.0/(255.0*255.0),1.0/255.0,1.0);return dot(rgba_depth,bit_shift)*2.0-1.0;}highp vec4 pack_depth(highp float ndc_z) {highp float depth=ndc_z*0.5+0.5;const highp vec4 bit_shift=vec4(255.0*255.0*255.0,255.0*255.0,255.0,1.0);const highp vec4 bit_mask =vec4(0.0,1.0/255.0,1.0/255.0,1.0/255.0);highp vec4 res=fract(depth*bit_shift);res-=res.xxyz*bit_mask;return res;}", "\n#if __VERSION__ >=300\n#define attribute in\n#define varying out\n#define texture2D texture\n#endif\nfloat wrap(float n,float min,float max) {float d=max-min;float w=mod(mod(n-min,d)+d,d)+min;return (w==min) ? max : w;}\n#ifdef PROJECTION_GLOBE_VIEW\nvec3 mercator_tile_position(mat4 matrix,vec2 tile_anchor,vec3 tile_id,vec2 mercator_center) {\n#ifndef PROJECTED_POS_ON_VIEWPORT\nfloat tiles=tile_id.z;vec2 mercator=(tile_anchor/EXTENT+tile_id.xy)/tiles;mercator-=mercator_center;mercator.x=wrap(mercator.x,-0.5,0.5);vec4 mercator_tile=vec4(mercator.xy*EXTENT,EXTENT/(2.0*PI),1.0);mercator_tile=matrix*mercator_tile;return mercator_tile.xyz;\n#else\nreturn vec3(0.0);\n#endif\n}vec3 mix_globe_mercator(vec3 globe,vec3 mercator,float t) {return mix(globe,mercator,t);}mat3 globe_mercator_surface_vectors(vec3 pos_normal,vec3 up_dir,float zoom_transition) {vec3 normal=zoom_transition==0.0 ? pos_normal : normalize(mix(pos_normal,up_dir,zoom_transition));vec3 xAxis=normalize(vec3(normal.z,0.0,-normal.x));vec3 yAxis=normalize(cross(normal,xAxis));return mat3(xAxis,yAxis,normal);}\n#endif\nvec2 unpack_float(const float packedValue) {int packedIntValue=int(packedValue);int v0=packedIntValue/256;return vec2(v0,packedIntValue-v0*256);}vec2 unpack_opacity(const float packedOpacity) {int intOpacity=int(packedOpacity)/2;return vec2(float(intOpacity)/127.0,mod(packedOpacity,2.0));}vec4 decode_color(const vec2 encodedColor) {return vec4(\nunpack_float(encodedColor[0])/255.0,unpack_float(encodedColor[1])/255.0\n);}float unpack_mix_vec2(const vec2 packedValue,const float t) {return mix(packedValue[0],packedValue[1],t);}vec4 unpack_mix_color(const vec4 packedColors,const float t) {vec4 minColor=decode_color(vec2(packedColors[0],packedColors[1]));vec4 maxColor=decode_color(vec2(packedColors[2],packedColors[3]));return mix(minColor,maxColor,t);}vec2 get_pattern_pos(const vec2 pixel_coord_upper,const vec2 pixel_coord_lower,const vec2 pattern_size,const float tile_units_to_pixels,const vec2 pos) {vec2 offset=mod(mod(mod(pixel_coord_upper,pattern_size)*256.0,pattern_size)*256.0+pixel_coord_lower,pattern_size);return (tile_units_to_pixels*pos+offset)/pattern_size;}const vec4 AWAY=vec4(-1000.0,-1000.0,-1000.0,1);//Normalized device coordinate that is not rendered."), ai = Jt, li = "\n#ifdef GL_ES\nprecision mediump float;\n#else\n\n#if !defined(lowp)\n#define lowp\n#endif\n\n#if !defined(mediump)\n#define mediump\n#endif\n\n#if !defined(highp)\n#define highp\n#endif\n\n#endif";
        var ci = { background: ui("uniform vec4 u_color;uniform float u_opacity;\n#ifdef LIGHTING_3D_MODE\nvarying vec4 v_color;\n#endif\nvoid main() {vec4 out_color;\n#ifdef LIGHTING_3D_MODE\nout_color=v_color;\n#else\nout_color=u_color;\n#endif\n#ifdef FOG\nout_color=fog_dither(fog_apply_premultiplied(out_color,v_fog_pos));\n#endif\ngl_FragColor=out_color*u_opacity;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "attribute vec2 a_pos;uniform mat4 u_matrix;\n#ifdef LIGHTING_3D_MODE\nuniform vec4 u_color;varying vec4 v_color;\n#endif\nvoid main() {gl_Position=u_matrix*vec4(a_pos,0,1);\n#ifdef LIGHTING_3D_MODE\nv_color=apply_lighting(u_color);\n#endif\n#ifdef FOG\nv_fog_pos=fog_position(a_pos);\n#endif\n}"), backgroundPattern: ui("uniform vec2 u_pattern_tl;uniform vec2 u_pattern_br;uniform vec2 u_texsize;uniform float u_opacity;uniform sampler2D u_image;varying vec2 v_pos;void main() {vec2 imagecoord=mod(v_pos,1.0);vec2 pos=mix(u_pattern_tl/u_texsize,u_pattern_br/u_texsize,imagecoord);vec4 out_color=texture2D(u_image,pos);\n#ifdef LIGHTING_3D_MODE\nout_color=apply_lighting(out_color);\n#endif\n#ifdef FOG\nout_color=fog_dither(fog_apply_premultiplied(out_color,v_fog_pos));\n#endif\ngl_FragColor=out_color*u_opacity;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "uniform mat4 u_matrix;uniform vec2 u_pattern_size;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform float u_tile_units_to_pixels;attribute vec2 a_pos;varying vec2 v_pos;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);v_pos=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,u_pattern_size,u_tile_units_to_pixels,a_pos);\n#ifdef FOG\nv_fog_pos=fog_position(a_pos);\n#endif\n}"), circle: ui("varying vec3 v_data;varying float v_visibility;\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define mediump float radius\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define highp vec4 stroke_color\n#pragma mapbox: define mediump float stroke_width\n#pragma mapbox: define lowp float stroke_opacity\nvoid main() {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize mediump float radius\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize highp vec4 stroke_color\n#pragma mapbox: initialize mediump float stroke_width\n#pragma mapbox: initialize lowp float stroke_opacity\nvec2 extrude=v_data.xy;float extrude_length=length(extrude);lowp float antialiasblur=v_data.z;float antialiased_blur=-max(blur,antialiasblur);float opacity_t=smoothstep(0.0,antialiased_blur,extrude_length-1.0);float color_t=stroke_width < 0.01 ? 0.0 : smoothstep(\nantialiased_blur,0.0,extrude_length-radius/(radius+stroke_width)\n);vec4 out_color=mix(color*opacity,stroke_color*stroke_opacity,color_t);\n#ifdef LIGHTING_3D_MODE\nout_color=apply_lighting(out_color);\n#endif\n#ifdef FOG\nout_color=fog_apply_premultiplied(out_color,v_fog_pos);\n#endif\ngl_FragColor=out_color*(v_visibility*opacity_t);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "#define NUM_VISIBILITY_RINGS 2\n#define INV_SQRT2 0.70710678\n#define ELEVATION_BIAS 0.0001\n#define NUM_SAMPLES_PER_RING 16\nuniform mat4 u_matrix;uniform mat2 u_extrude_scale;uniform lowp float u_device_pixel_ratio;uniform highp float u_camera_to_center_distance;attribute vec2 a_pos;\n#ifdef PROJECTION_GLOBE_VIEW\nattribute vec3 a_pos_3;attribute vec3 a_pos_normal_3;uniform mat4 u_inv_rot_matrix;uniform vec2 u_merc_center;uniform vec3 u_tile_id;uniform float u_zoom_transition;uniform vec3 u_up_dir;\n#endif\nvarying vec3 v_data;varying float v_visibility;\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define mediump float radius\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define highp vec4 stroke_color\n#pragma mapbox: define mediump float stroke_width\n#pragma mapbox: define lowp float stroke_opacity\nvec2 calc_offset(vec2 extrusion,float radius,float stroke_width, float view_scale) {return extrusion*(radius+stroke_width)*u_extrude_scale*view_scale;}float cantilevered_elevation(vec2 pos,float radius,float stroke_width,float view_scale) {vec2 c1=pos+calc_offset(vec2(-1,-1),radius,stroke_width,view_scale);vec2 c2=pos+calc_offset(vec2(1,-1),radius,stroke_width,view_scale);vec2 c3=pos+calc_offset(vec2(1,1),radius,stroke_width,view_scale);vec2 c4=pos+calc_offset(vec2(-1,1),radius,stroke_width,view_scale);float h1=elevation(c1)+ELEVATION_BIAS;float h2=elevation(c2)+ELEVATION_BIAS;float h3=elevation(c3)+ELEVATION_BIAS;float h4=elevation(c4)+ELEVATION_BIAS;return max(h4,max(h3,max(h1,h2)));}float circle_elevation(vec2 pos) {\n#if defined(TERRAIN)\nreturn elevation(pos)+ELEVATION_BIAS;\n#else\nreturn 0.0;\n#endif\n}vec4 project_vertex(vec2 extrusion,vec4 world_center,vec4 projected_center,float radius,float stroke_width, float view_scale,mat3 surface_vectors) {vec2 sample_offset=calc_offset(extrusion,radius,stroke_width,view_scale);\n#ifdef PITCH_WITH_MAP\n#ifdef PROJECTION_GLOBE_VIEW\nreturn u_matrix*( world_center+vec4(sample_offset.x*surface_vectors[0]+sample_offset.y*surface_vectors[1],0) );\n#else\nreturn u_matrix*( world_center+vec4(sample_offset,0,0) );\n#endif\n#else\nreturn projected_center+vec4(sample_offset,0,0);\n#endif\n}float get_sample_step() {\n#ifdef PITCH_WITH_MAP\nreturn 2.0*PI/float(NUM_SAMPLES_PER_RING);\n#else\nreturn PI/float(NUM_SAMPLES_PER_RING);\n#endif\n}void main(void) {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize mediump float radius\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize highp vec4 stroke_color\n#pragma mapbox: initialize mediump float stroke_width\n#pragma mapbox: initialize lowp float stroke_opacity\nvec2 extrude=vec2(mod(a_pos,2.0)*2.0-1.0);vec2 circle_center=floor(a_pos*0.5);vec4 world_center;mat3 surface_vectors;\n#ifdef PROJECTION_GLOBE_VIEW\nvec3 pos_normal_3=a_pos_normal_3/16384.0;surface_vectors=globe_mercator_surface_vectors(pos_normal_3,u_up_dir,u_zoom_transition);vec3 surface_extrusion=extrude.x*surface_vectors[0]+extrude.y*surface_vectors[1];vec3 globe_elevation=elevationVector(circle_center)*circle_elevation(circle_center);vec3 globe_pos=a_pos_3+surface_extrusion+globe_elevation;vec3 mercator_elevation=u_up_dir*u_tile_up_scale*circle_elevation(circle_center);vec3 merc_pos=mercator_tile_position(u_inv_rot_matrix,circle_center,u_tile_id,u_merc_center)+surface_extrusion+mercator_elevation;vec3 pos=mix_globe_mercator(globe_pos,merc_pos,u_zoom_transition);world_center=vec4(pos,1);\n#else \nsurface_vectors=mat3(1.0);float height=circle_elevation(circle_center);world_center=vec4(circle_center,height,1);\n#endif\nvec4 projected_center=u_matrix*world_center;float view_scale=0.0;\n#ifdef PITCH_WITH_MAP\n#ifdef SCALE_WITH_MAP\nview_scale=1.0;\n#else\nview_scale=projected_center.w/u_camera_to_center_distance;\n#endif\n#else\n#ifdef SCALE_WITH_MAP\nview_scale=u_camera_to_center_distance;\n#else\nview_scale=projected_center.w;\n#endif\n#endif\ngl_Position=project_vertex(extrude,world_center,projected_center,radius,stroke_width,view_scale,surface_vectors);float visibility=0.0;\n#ifdef TERRAIN\nfloat step=get_sample_step();vec4 occlusion_world_center;vec4 occlusion_projected_center;\n#ifdef PITCH_WITH_MAP\nfloat cantilevered_height=cantilevered_elevation(circle_center,radius,stroke_width,view_scale);occlusion_world_center=vec4(circle_center,cantilevered_height,1);occlusion_projected_center=u_matrix*occlusion_world_center;\n#else\nocclusion_world_center=world_center;occlusion_projected_center=projected_center;\n#endif\nfor(int ring=0; ring < NUM_VISIBILITY_RINGS; ring++) {float scale=(float(ring)+1.0)/float(NUM_VISIBILITY_RINGS);for(int i=0; i < NUM_SAMPLES_PER_RING; i++) {vec2 extrusion=vec2(cos(step*float(i)),-sin(step*float(i)))*scale;vec4 frag_pos=project_vertex(extrusion,occlusion_world_center,occlusion_projected_center,radius,stroke_width,view_scale,surface_vectors);visibility+=float(!isOccluded(frag_pos));}}visibility/=float(NUM_VISIBILITY_RINGS)*float(NUM_SAMPLES_PER_RING);\n#else\nvisibility=1.0;\n#endif\n#ifdef PROJECTION_GLOBE_VIEW\nvisibility=1.0;\n#endif\nv_visibility=visibility;lowp float antialiasblur=1.0/u_device_pixel_ratio/(radius+stroke_width);v_data=vec3(extrude.x,extrude.y,antialiasblur);\n#ifdef FOG\nv_fog_pos=fog_position(world_center.xyz);\n#endif\n}"), clippingMask: ui("void main() {gl_FragColor=vec4(1.0);}", "attribute vec2 a_pos;uniform mat4 u_matrix;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);}"), heatmap: ui("uniform highp float u_intensity;varying vec2 v_extrude;\n#pragma mapbox: define highp float weight\n#define GAUSS_COEF 0.3989422804014327\nvoid main() {\n#pragma mapbox: initialize highp float weight\nfloat d=-0.5*3.0*3.0*dot(v_extrude,v_extrude);float val=weight*u_intensity*GAUSS_COEF*exp(d);gl_FragColor=vec4(val,1.0,1.0,1.0);\n#ifdef FOG\nif (u_is_globe==0) {gl_FragColor.r*=pow(1.0-fog_opacity(v_fog_pos),2.0);}\n#endif\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "uniform mat4 u_matrix;uniform float u_extrude_scale;uniform float u_opacity;uniform float u_intensity;attribute vec2 a_pos;\n#ifdef PROJECTION_GLOBE_VIEW\nattribute vec3 a_pos_3;attribute vec3 a_pos_normal_3;uniform mat4 u_inv_rot_matrix;uniform vec2 u_merc_center;uniform vec3 u_tile_id;uniform float u_zoom_transition;uniform vec3 u_up_dir;\n#endif\nvarying vec2 v_extrude;\n#pragma mapbox: define highp float weight\n#pragma mapbox: define mediump float radius\nconst highp float ZERO=1.0/255.0/16.0;\n#define GAUSS_COEF 0.3989422804014327\nvoid main(void) {\n#pragma mapbox: initialize highp float weight\n#pragma mapbox: initialize mediump float radius\nvec2 unscaled_extrude=vec2(mod(a_pos,2.0)*2.0-1.0);float S=sqrt(-2.0*log(ZERO/weight/u_intensity/GAUSS_COEF))/3.0;v_extrude=S*unscaled_extrude;vec2 extrude=v_extrude*radius*u_extrude_scale;vec2 tilePos=floor(a_pos*0.5);vec3 pos;\n#ifdef PROJECTION_GLOBE_VIEW\nvec3 pos_normal_3=a_pos_normal_3/16384.0;mat3 surface_vectors=globe_mercator_surface_vectors(pos_normal_3,u_up_dir,u_zoom_transition);vec3 surface_extrusion=extrude.x*surface_vectors[0]+extrude.y*surface_vectors[1];vec3 globe_elevation=elevationVector(tilePos)*elevation(tilePos);vec3 globe_pos=a_pos_3+surface_extrusion+globe_elevation;vec3 mercator_elevation=u_up_dir*u_tile_up_scale*elevation(tilePos);vec3 merc_pos=mercator_tile_position(u_inv_rot_matrix,tilePos,u_tile_id,u_merc_center)+surface_extrusion+mercator_elevation;pos=mix_globe_mercator(globe_pos,merc_pos,u_zoom_transition);\n#else\npos=vec3(tilePos+extrude,elevation(tilePos));\n#endif\ngl_Position=u_matrix*vec4(pos,1);\n#ifdef FOG\nv_fog_pos=fog_position(pos);\n#endif\n}"), heatmapTexture: ui("uniform sampler2D u_image;uniform sampler2D u_color_ramp;uniform float u_opacity;varying vec2 v_pos;void main() {float t=texture2D(u_image,v_pos).r;vec4 color=texture2D(u_color_ramp,vec2(t,0.5));gl_FragColor=color*u_opacity;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(0.0);\n#endif\n}", "attribute vec2 a_pos;varying vec2 v_pos;void main() {gl_Position=vec4(a_pos,0,1);v_pos=a_pos*0.5+0.5;}"), collisionBox: ui("varying float v_placed;varying float v_notUsed;void main() {vec4 red =vec4(1.0,0.0,0.0,1.0);vec4 blue=vec4(0.0,0.0,1.0,0.5);gl_FragColor =mix(red,blue,step(0.5,v_placed))*0.5;gl_FragColor*=mix(1.0,0.1,step(0.5,v_notUsed));}", "attribute vec3 a_pos;attribute vec2 a_anchor_pos;attribute vec2 a_extrude;attribute vec2 a_placed;attribute vec2 a_shift;attribute float a_size_scale;attribute vec2 a_padding;uniform mat4 u_matrix;uniform vec2 u_extrude_scale;uniform float u_camera_to_center_distance;varying float v_placed;varying float v_notUsed;void main() {vec4 projectedPoint=u_matrix*vec4(a_pos+elevationVector(a_anchor_pos)*elevation(a_anchor_pos),1);highp float camera_to_anchor_distance=projectedPoint.w;highp float collision_perspective_ratio=clamp(\n0.5+0.5*(u_camera_to_center_distance/camera_to_anchor_distance),0.0,1.5);gl_Position=projectedPoint;gl_Position.xy+=(a_extrude*a_size_scale+a_shift+a_padding)*u_extrude_scale*gl_Position.w*collision_perspective_ratio;v_placed=a_placed.x;v_notUsed=a_placed.y;}"), collisionCircle: ui("varying float v_radius;varying vec2 v_extrude;varying float v_perspective_ratio;varying float v_collision;void main() {float alpha=0.5*min(v_perspective_ratio,1.0);float stroke_radius=0.9*max(v_perspective_ratio,1.0);float distance_to_center=length(v_extrude);float distance_to_edge=abs(distance_to_center-v_radius);float opacity_t=smoothstep(-stroke_radius,0.0,-distance_to_edge);vec4 color=mix(vec4(0.0,0.0,1.0,0.5),vec4(1.0,0.0,0.0,1.0),v_collision);gl_FragColor=color*alpha*opacity_t;}", "attribute vec2 a_pos_2f;attribute float a_radius;attribute vec2 a_flags;uniform mat4 u_matrix;uniform mat4 u_inv_matrix;uniform vec2 u_viewport_size;uniform float u_camera_to_center_distance;varying float v_radius;varying vec2 v_extrude;varying float v_perspective_ratio;varying float v_collision;vec3 toTilePosition(vec2 screenPos) {vec4 rayStart=u_inv_matrix*vec4(screenPos,-1.0,1.0);vec4 rayEnd  =u_inv_matrix*vec4(screenPos, 1.0,1.0);rayStart.xyz/=rayStart.w;rayEnd.xyz  /=rayEnd.w;highp float t=(0.0-rayStart.z)/(rayEnd.z-rayStart.z);return mix(rayStart.xyz,rayEnd.xyz,t);}void main() {vec2 quadCenterPos=a_pos_2f;float radius=a_radius;float collision=a_flags.x;float vertexIdx=a_flags.y;vec2 quadVertexOffset=vec2(\nmix(-1.0,1.0,float(vertexIdx >=2.0)),mix(-1.0,1.0,float(vertexIdx >=1.0 && vertexIdx <=2.0)));vec2 quadVertexExtent=quadVertexOffset*radius;vec3 tilePos=toTilePosition(quadCenterPos);vec4 clipPos=u_matrix*vec4(tilePos,1.0);highp float camera_to_anchor_distance=clipPos.w;highp float collision_perspective_ratio=clamp(\n0.5+0.5*(u_camera_to_center_distance/camera_to_anchor_distance),0.0,4.0);float padding_factor=1.2;v_radius=radius;v_extrude=quadVertexExtent*padding_factor;v_perspective_ratio=collision_perspective_ratio;v_collision=collision;gl_Position=vec4(clipPos.xyz/clipPos.w,1.0)+vec4(quadVertexExtent*padding_factor/u_viewport_size*2.0,0.0,0.0);}"), debug: ui("uniform highp vec4 u_color;uniform sampler2D u_overlay;varying vec2 v_uv;void main() {vec4 overlay_color=texture2D(u_overlay,v_uv);gl_FragColor=mix(u_color,overlay_color,overlay_color.a);}", "attribute vec2 a_pos;\n#ifdef PROJECTION_GLOBE_VIEW\nattribute vec3 a_pos_3;\n#endif\nvarying vec2 v_uv;uniform mat4 u_matrix;uniform float u_overlay_scale;void main() {float h=elevation(a_pos);v_uv=a_pos/8192.0;\n#ifdef PROJECTION_GLOBE_VIEW\ngl_Position=u_matrix*vec4(a_pos_3+elevationVector(a_pos)*h,1);\n#else\ngl_Position=u_matrix*vec4(a_pos*u_overlay_scale,h,1);\n#endif\n}"), fill: ui("#pragma mapbox: define highp vec4 color\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize lowp float opacity\nvec4 out_color=color;\n#ifdef LIGHTING_3D_MODE\nout_color=apply_lighting(out_color);\n#endif\n#ifdef FOG\nout_color=fog_dither(fog_apply_premultiplied(out_color,v_fog_pos));\n#endif\ngl_FragColor=out_color*opacity;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "attribute vec2 a_pos;uniform mat4 u_matrix;\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize lowp float opacity\ngl_Position=u_matrix*vec4(a_pos,0,1);\n#ifdef FOG\nv_fog_pos=fog_position(a_pos);\n#endif\n}"), fillOutline: ui("varying vec2 v_pos;\n#pragma mapbox: define highp vec4 outline_color\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize highp vec4 outline_color\n#pragma mapbox: initialize lowp float opacity\nfloat dist=length(v_pos-gl_FragCoord.xy);float alpha=1.0-smoothstep(0.0,1.0,dist);vec4 out_color=outline_color;\n#ifdef LIGHTING_3D_MODE\nout_color=apply_lighting(out_color);\n#endif\n#ifdef FOG\nout_color=fog_dither(fog_apply_premultiplied(out_color,v_fog_pos));\n#endif\ngl_FragColor=out_color*(alpha*opacity);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "attribute vec2 a_pos;uniform mat4 u_matrix;uniform vec2 u_world;varying vec2 v_pos;\n#pragma mapbox: define highp vec4 outline_color\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize highp vec4 outline_color\n#pragma mapbox: initialize lowp float opacity\ngl_Position=u_matrix*vec4(a_pos,0,1);v_pos=(gl_Position.xy/gl_Position.w+1.0)/2.0*u_world;\n#ifdef FOG\nv_fog_pos=fog_position(a_pos);\n#endif\n}"), fillOutlinePattern: ui("uniform vec2 u_texsize;uniform sampler2D u_image;varying vec2 v_pos;varying vec2 v_pos_world;\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp vec4 pattern\nvoid main() {\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump vec4 pattern\nvec2 pattern_tl=pattern.xy;vec2 pattern_br=pattern.zw;vec2 imagecoord=mod(v_pos,1.0);vec2 pos=mix(pattern_tl/u_texsize,pattern_br/u_texsize,imagecoord);float dist=length(v_pos_world-gl_FragCoord.xy);float alpha=1.0-smoothstep(0.0,1.0,dist);vec4 out_color=texture2D(u_image,pos);\n#ifdef LIGHTING_3D_MODE\nout_color=apply_lighting(out_color);\n#endif\n#ifdef FOG\nout_color=fog_dither(fog_apply_premultiplied(out_color,v_fog_pos));\n#endif\ngl_FragColor=out_color*(alpha*opacity);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "uniform mat4 u_matrix;uniform vec2 u_world;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform float u_tile_units_to_pixels;attribute vec2 a_pos;varying vec2 v_pos;varying vec2 v_pos_world;\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp vec4 pattern\n#pragma mapbox: define lowp float pixel_ratio\nvoid main() {\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump vec4 pattern\n#pragma mapbox: initialize lowp float pixel_ratio\nvec2 pattern_tl=pattern.xy;vec2 pattern_br=pattern.zw;gl_Position=u_matrix*vec4(a_pos,0,1);vec2 display_size=(pattern_br-pattern_tl)/pixel_ratio;v_pos=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,display_size,u_tile_units_to_pixels,a_pos);v_pos_world=(gl_Position.xy/gl_Position.w+1.0)/2.0*u_world;\n#ifdef FOG\nv_fog_pos=fog_position(a_pos);\n#endif\n}"), fillPattern: ui("uniform vec2 u_texsize;uniform sampler2D u_image;varying vec2 v_pos;\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp vec4 pattern\nvoid main() {\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump vec4 pattern\nvec2 pattern_tl=pattern.xy;vec2 pattern_br=pattern.zw;vec2 imagecoord=mod(v_pos,1.0);vec2 pos=mix(pattern_tl/u_texsize,pattern_br/u_texsize,imagecoord);vec4 out_color=texture2D(u_image,pos);\n#ifdef LIGHTING_3D_MODE\nout_color=apply_lighting(out_color);\n#endif\n#ifdef FOG\nout_color=fog_dither(fog_apply_premultiplied(out_color,v_fog_pos));\n#endif\ngl_FragColor=out_color*opacity;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "uniform mat4 u_matrix;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform float u_tile_units_to_pixels;attribute vec2 a_pos;varying vec2 v_pos;\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp vec4 pattern\n#pragma mapbox: define lowp float pixel_ratio\nvoid main() {\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump vec4 pattern\n#pragma mapbox: initialize lowp float pixel_ratio\nvec2 pattern_tl=pattern.xy;vec2 pattern_br=pattern.zw;vec2 display_size=(pattern_br-pattern_tl)/pixel_ratio;gl_Position=u_matrix*vec4(a_pos,0,1);v_pos=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,display_size,u_tile_units_to_pixels,a_pos);\n#ifdef FOG\nv_fog_pos=fog_position(a_pos);\n#endif\n}"), fillExtrusion: ui("varying vec4 v_color;\n#ifdef RENDER_SHADOWS\nvarying highp vec4 v_pos_light_view_0;varying highp vec4 v_pos_light_view_1;varying float v_depth;\n#endif\n#ifdef FAUX_AO\nuniform lowp vec2 u_ao;varying vec3 v_ao;\n#endif\n#ifdef ZERO_ROOF_RADIUS\nvarying vec4 v_roof_color;\n#endif\n#if defined(ZERO_ROOF_RADIUS) || defined(RENDER_SHADOWS)\nvarying highp vec3 v_normal;\n#endif\nvoid main() {\n#if defined(ZERO_ROOF_RADIUS) || defined(RENDER_SHADOWS)\nvec3 normal=v_normal;\n#endif\nfloat z;vec4 color;\n#ifdef ZERO_ROOF_RADIUS\nz=float(normal.z > 0.00001);color=mix(v_color,v_roof_color,z);\n#else\ncolor=v_color;\n#endif\n#ifdef FAUX_AO\nfloat intensity=u_ao[0];float h=max(0.0,v_ao.z);float h_floors=h/u_ao[1];float y_shade=1.0-0.9*intensity*min(v_ao.y,1.0);float shade=(1.0-0.08*intensity)*(y_shade+(1.0-y_shade)*(1.0-pow(1.0-min(h_floors/16.0,1.0),16.0)))+0.08*intensity*min(h_floors/160.0,1.0);float concave=v_ao.x*v_ao.x;\n#ifdef ZERO_ROOF_RADIUS\nconcave*=(1.0-z);\n#endif\nfloat x_shade=mix(1.0,mix(0.6,0.75,min(h_floors/30.0,1.0)),intensity)+0.1*intensity*min(h,1.0);shade*=mix(1.0,x_shade*x_shade*x_shade,concave);color.rgb=color.rgb*shade;\n#endif\n#ifdef RENDER_SHADOWS\n#ifdef ZERO_ROOF_RADIUS\nnormal=mix(normal,vec3(0.0,0.0,1.0),z);\n#endif\ncolor.xyz=shadowed_color_normal(color.xyz,normalize(normal),v_pos_light_view_0,v_pos_light_view_1,v_depth);\n#endif\n#ifdef FOG\ncolor=fog_dither(fog_apply_premultiplied(color,v_fog_pos));\n#endif\ngl_FragColor=color;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "uniform mat4 u_matrix;uniform vec3 u_lightcolor;uniform lowp vec3 u_lightpos;uniform lowp float u_lightintensity;uniform float u_vertical_gradient;uniform lowp float u_opacity;uniform float u_edge_radius;attribute vec4 a_pos_normal_ed;attribute vec2 a_centroid_pos;\n#ifdef PROJECTION_GLOBE_VIEW\nattribute vec3 a_pos_3;attribute vec3 a_pos_normal_3;uniform mat4 u_inv_rot_matrix;uniform vec2 u_merc_center;uniform vec3 u_tile_id;uniform float u_zoom_transition;uniform vec3 u_up_dir;uniform float u_height_lift;\n#endif\nvarying vec4 v_color;\n#ifdef RENDER_SHADOWS\nuniform mat4 u_light_matrix_0;uniform mat4 u_light_matrix_1;varying highp vec4 v_pos_light_view_0;varying highp vec4 v_pos_light_view_1;varying float v_depth;\n#endif\n#ifdef ZERO_ROOF_RADIUS\nvarying vec4 v_roof_color;\n#endif\n#if defined(ZERO_ROOF_RADIUS) || defined(RENDER_SHADOWS)\nvarying highp vec3 v_normal;\n#endif\n#ifdef FAUX_AO\nuniform lowp vec2 u_ao;varying vec3 v_ao;\n#endif\n#pragma mapbox: define highp float base\n#pragma mapbox: define highp float height\n#pragma mapbox: define highp vec4 color\nvoid main() {\n#pragma mapbox: initialize highp float base\n#pragma mapbox: initialize highp float height\n#pragma mapbox: initialize highp vec4 color\nvec4 pos_nx=floor(a_pos_normal_ed*0.5);vec4 top_up_ny_start=a_pos_normal_ed-2.0*pos_nx;vec3 top_up_ny=top_up_ny_start.xyz;float x_normal=pos_nx.z/8192.0;vec3 normal=top_up_ny.y==1.0 ? vec3(0.0,0.0,1.0) : normalize(vec3(x_normal,(2.0*top_up_ny.z-1.0)*(1.0-abs(x_normal)),0.0));\n#if defined(ZERO_ROOF_RADIUS) || defined(RENDER_SHADOWS)\nv_normal=normal;\n#endif\nbase=max(0.0,base);height=max(0.0,top_up_ny.y==0.0 && top_up_ny.x==1.0 ? height-u_edge_radius : height);float t=top_up_ny.x;vec2 centroid_pos=vec2(0.0);\n#if defined(HAS_CENTROID) || defined(TERRAIN)\ncentroid_pos=a_centroid_pos;\n#endif\nfloat ele=0.0;float h=0.0;float c_ele;vec3 pos;\n#ifdef TERRAIN\nbool flat_roof=centroid_pos.x !=0.0 && t > 0.0;ele=elevation(pos_nx.xy);c_ele=flat_roof ? centroid_pos.y==0.0 ? elevationFromUint16(centroid_pos.x) : flatElevation(centroid_pos) : ele;h=flat_roof ? max(c_ele+height,ele+base+2.0) : ele+(t > 0.0 ? height : base==0.0 ?-5.0 : base);pos=vec3(pos_nx.xy,h);\n#else\nh=t > 0.0 ? height : base;pos=vec3(pos_nx.xy,h);\n#endif\n#ifdef PROJECTION_GLOBE_VIEW\nfloat lift=float((t+base) > 0.0)*u_height_lift;h+=lift;vec3 globe_normal=normalize(mix(a_pos_normal_3/16384.0,u_up_dir,u_zoom_transition));vec3 globe_pos=a_pos_3+globe_normal*(u_tile_up_scale*h);vec3 merc_pos=mercator_tile_position(u_inv_rot_matrix,pos.xy,u_tile_id,u_merc_center)+u_up_dir*u_tile_up_scale*pos.z;pos=mix_globe_mercator(globe_pos,merc_pos,u_zoom_transition);\n#endif\nfloat hidden=float(centroid_pos.x==0.0 && centroid_pos.y==1.0);gl_Position=mix(u_matrix*vec4(pos,1),AWAY,hidden);\n#ifdef RENDER_SHADOWS\nv_pos_light_view_0=u_light_matrix_0*vec4(pos,1);v_pos_light_view_1=u_light_matrix_1*vec4(pos,1);v_depth=gl_Position.w;\n#endif\nfloat NdotL=0.0;float colorvalue=0.0;\n#ifdef LIGHTING_3D_MODE\nNdotL=calculate_NdotL(normal);\n#else\ncolorvalue=color.r*0.2126+color.g*0.7152+color.b*0.0722;vec4 ambientlight=vec4(0.03,0.03,0.03,1.0);color+=ambientlight;NdotL=clamp(dot(normal,u_lightpos),0.0,1.0);NdotL=mix((1.0-u_lightintensity),max((1.0-colorvalue+u_lightintensity),1.0),NdotL);\n#endif\nif (normal.y !=0.0) {float r=0.84;\n#ifndef LIGHTING_3D_MODE\nr=mix(0.7,0.98,1.0-u_lightintensity);\n#endif\nNdotL*=(\n(1.0-u_vertical_gradient)+(u_vertical_gradient*clamp((t+base)*pow(height/150.0,0.5),r,1.0)));}v_color=vec4(0.0,0.0,0.0,1.0);\n#ifdef FAUX_AO\nfloat concave=pos_nx.w-floor(pos_nx.w*0.5)*2.0;float start=top_up_ny_start.w;float y_ground=1.0-clamp(t+base,0.0,1.0);float top_height=height;\n#ifdef TERRAIN\ntop_height=mix(max(c_ele+height,ele+base+2.0),ele+height,float(centroid_pos.x==0.0))-ele;y_ground+=y_ground*5.0/max(3.0,top_height);\n#endif\nv_ao=vec3(mix(concave,-concave,start),y_ground,h-ele);NdotL*=(1.0+0.05*(1.0-top_up_ny.y)*u_ao[0]);\n#ifdef PROJECTION_GLOBE_VIEW\ntop_height+=u_height_lift;\n#endif\ngl_Position.z-=(0.0000006*(min(top_height,500.)+2.0*min(base,500.0)+60.0*concave+3.0*start))*gl_Position.w;\n#endif\n#ifdef LIGHTING_3D_MODE\nv_color=apply_lighting(color,NdotL);\n#else\nv_color.rgb+=clamp(color.rgb*NdotL*u_lightcolor,mix(vec3(0.0),vec3(0.3),1.0-u_lightcolor),vec3(1.0));\n#endif\nv_color*=u_opacity;\n#ifdef ZERO_ROOF_RADIUS\nv_roof_color=vec4(0.0,0.0,0.0,1.0);\n#ifdef LIGHTING_3D_MODE\nv_roof_color=apply_lighting(color,calculate_NdotL(vec3(0.0,0.0,1.0)));\n#else\nfloat roofNdotL=clamp(u_lightpos.z,0.0,1.0);roofNdotL=mix((1.0-u_lightintensity),max((1.0-colorvalue+u_lightintensity),1.0),roofNdotL);v_roof_color.rgb+=clamp(color.rgb*roofNdotL*u_lightcolor,mix(vec3(0.0),vec3(0.3),1.0-u_lightcolor),vec3(1.0));\n#endif\nv_roof_color*=u_opacity;\n#endif\n#ifdef FOG\nv_fog_pos=fog_position(pos);\n#endif\n}"), fillExtrusionPattern: ui("uniform vec2 u_texsize;uniform sampler2D u_image;\n#ifdef FAUX_AO\nuniform lowp vec2 u_ao;varying vec3 v_ao;\n#endif\n#ifdef LIGHTING_3D_MODE\nvarying float v_NdotL;\n#endif\nvarying vec2 v_pos;varying vec4 v_lighting;uniform lowp float u_opacity;\n#pragma mapbox: define lowp float base\n#pragma mapbox: define lowp float height\n#pragma mapbox: define lowp vec4 pattern\n#pragma mapbox: define lowp float pixel_ratio\nvoid main() {\n#pragma mapbox: initialize lowp float base\n#pragma mapbox: initialize lowp float height\n#pragma mapbox: initialize mediump vec4 pattern\n#pragma mapbox: initialize lowp float pixel_ratio\nvec2 pattern_tl=pattern.xy;vec2 pattern_br=pattern.zw;vec2 imagecoord=mod(v_pos,1.0);vec2 pos=mix(pattern_tl/u_texsize,pattern_br/u_texsize,imagecoord);vec4 out_color=texture2D(u_image,pos);\n#ifdef LIGHTING_3D_MODE\nout_color=apply_lighting(out_color,v_NdotL)*u_opacity;\n#else\nout_color=out_color*v_lighting;\n#endif\n#ifdef FAUX_AO\nfloat intensity=u_ao[0];float h=max(0.0,v_ao.z);float h_floors=h/u_ao[1];float y_shade=1.0-0.9*intensity*min(v_ao.y,1.0);float shade=(1.0-0.08*intensity)*(y_shade+(1.0-y_shade)*(1.0-pow(1.0-min(h_floors/16.0,1.0),16.0)))+0.08*intensity*min(h_floors/160.0,1.0);float concave=v_ao.x*v_ao.x;float x_shade=mix(1.0,mix(0.6,0.75,min(h_floors/30.0,1.0)),intensity)+0.1*intensity*min(h,1.0);shade*=mix(1.0,x_shade*x_shade*x_shade,concave);out_color.rgb=out_color.rgb*shade;\n#endif\n#ifdef FOG\nout_color=fog_dither(fog_apply_premultiplied(out_color,v_fog_pos));\n#endif\ngl_FragColor=out_color;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "uniform mat4 u_matrix;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform float u_height_factor;uniform float u_tile_units_to_pixels;uniform float u_vertical_gradient;uniform lowp float u_opacity;uniform vec3 u_lightcolor;uniform lowp vec3 u_lightpos;uniform lowp float u_lightintensity;attribute vec4 a_pos_normal_ed;attribute vec2 a_centroid_pos;\n#ifdef PROJECTION_GLOBE_VIEW\nattribute vec3 a_pos_3;attribute vec3 a_pos_normal_3;uniform mat4 u_inv_rot_matrix;uniform vec2 u_merc_center;uniform vec3 u_tile_id;uniform float u_zoom_transition;uniform vec3 u_up_dir;uniform float u_height_lift;\n#endif\nvarying vec2 v_pos;varying vec4 v_lighting;\n#ifdef FAUX_AO\nuniform lowp vec2 u_ao;varying vec3 v_ao;\n#endif\n#ifdef LIGHTING_3D_MODE\nvarying float v_NdotL;\n#endif\n#pragma mapbox: define lowp float base\n#pragma mapbox: define lowp float height\n#pragma mapbox: define lowp vec4 pattern\n#pragma mapbox: define lowp float pixel_ratio\nvoid main() {\n#pragma mapbox: initialize lowp float base\n#pragma mapbox: initialize lowp float height\n#pragma mapbox: initialize mediump vec4 pattern\n#pragma mapbox: initialize lowp float pixel_ratio\nvec2 pattern_tl=pattern.xy;vec2 pattern_br=pattern.zw;vec4 pos_nx=floor(a_pos_normal_ed*0.5);mediump vec4 top_up_ny_start=a_pos_normal_ed-2.0*pos_nx;mediump vec3 top_up_ny=top_up_ny_start.xyz;float x_normal=pos_nx.z/8192.0;vec3 normal=top_up_ny.y==1.0 ? vec3(0.0,0.0,1.0) : normalize(vec3(x_normal,(2.0*top_up_ny.z-1.0)*(1.0-abs(x_normal)),0.0));float edgedistance=a_pos_normal_ed.w;vec2 display_size=(pattern_br-pattern_tl)/pixel_ratio;base=max(0.0,base);height=max(0.0,height);float t=top_up_ny.x;float z=t > 0.0 ? height : base;vec2 centroid_pos=vec2(0.0);\n#if defined(HAS_CENTROID) || defined(TERRAIN)\ncentroid_pos=a_centroid_pos;\n#endif\nfloat ele=0.0;float h=z;vec3 p;float c_ele;\n#ifdef TERRAIN\nbool flat_roof=centroid_pos.x !=0.0 && t > 0.0;ele=elevation(pos_nx.xy);c_ele=flat_roof ? centroid_pos.y==0.0 ? elevationFromUint16(centroid_pos.x) : flatElevation(centroid_pos) : ele;h=flat_roof ? max(c_ele+height,ele+base+2.0) : ele+(t > 0.0 ? height : base==0.0 ?-5.0 : base);p=vec3(pos_nx.xy,h);\n#else\np=vec3(pos_nx.xy,z);\n#endif\n#ifdef PROJECTION_GLOBE_VIEW\nfloat lift=float((t+base) > 0.0)*u_height_lift;h+=lift;vec3 globe_normal=normalize(mix(a_pos_normal_3/16384.0,u_up_dir,u_zoom_transition));vec3 globe_pos=a_pos_3+globe_normal*(u_tile_up_scale*(p.z+lift));vec3 merc_pos=mercator_tile_position(u_inv_rot_matrix,p.xy,u_tile_id,u_merc_center)+u_up_dir*u_tile_up_scale*p.z;p=mix_globe_mercator(globe_pos,merc_pos,u_zoom_transition);\n#endif\nfloat hidden=float(centroid_pos.x==0.0 && centroid_pos.y==1.0);gl_Position=mix(u_matrix*vec4(p,1),AWAY,hidden);vec2 pos=normal.z==1.0\n? pos_nx.xy\n: vec2(edgedistance,z*u_height_factor);v_pos=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,display_size,u_tile_units_to_pixels,pos);v_lighting=vec4(0.0,0.0,0.0,1.0);float NdotL=0.0;\n#ifdef LIGHTING_3D_MODE\nNdotL=calculate_NdotL(normal);\n#else\nNdotL=clamp(dot(normal,u_lightpos),0.0,1.0);NdotL=mix((1.0-u_lightintensity),max((0.5+u_lightintensity),1.0),NdotL);\n#endif\nif (normal.y !=0.0) {float r=0.84;\n#ifndef LIGHTING_3D_MODE\nr=mix(0.7,0.98,1.0-u_lightintensity);\n#endif\nNdotL*=(\n(1.0-u_vertical_gradient)+(u_vertical_gradient*clamp((t+base)*pow(height/150.0,0.5),r,1.0)));}\n#ifdef FAUX_AO\nfloat concave=pos_nx.w-floor(pos_nx.w*0.5)*2.0;float start=top_up_ny_start.w;float y_ground=1.0-clamp(t+base,0.0,1.0);float top_height=height;\n#ifdef TERRAIN\ntop_height=mix(max(c_ele+height,ele+base+2.0),ele+height,float(centroid_pos.x==0.0))-ele;y_ground+=y_ground*5.0/max(3.0,top_height);\n#endif\nv_ao=vec3(mix(concave,-concave,start),y_ground,h-ele);NdotL*=(1.0+0.05*(1.0-top_up_ny.y)*u_ao[0]);\n#ifdef PROJECTION_GLOBE_VIEW\ntop_height+=u_height_lift;\n#endif\ngl_Position.z-=(0.0000006*(min(top_height,500.)+2.0*min(base,500.0)+60.0*concave+3.0*start))*gl_Position.w;\n#endif\n#ifdef LIGHTING_3D_MODE\nv_NdotL=NdotL;\n#else\nv_lighting.rgb+=clamp(NdotL*u_lightcolor,mix(vec3(0.0),vec3(0.3),1.0-u_lightcolor),vec3(1.0));v_lighting*=u_opacity;\n#endif \n#ifdef FOG\nv_fog_pos=fog_position(p);\n#endif\n}"), hillshadePrepare: ui("#ifdef GL_ES\nprecision highp float;\n#endif\nuniform sampler2D u_image;varying vec2 v_pos;uniform vec2 u_dimension;uniform float u_zoom;uniform vec4 u_unpack;float getElevation(vec2 coord) {\n#ifdef TERRAIN_DEM_FLOAT_FORMAT\nreturn texture2D(u_image,coord).a/4.0;\n#else\nvec4 data=texture2D(u_image,coord)*255.0;data.a=-1.0;return dot(data,u_unpack)/4.0;\n#endif\n}void main() {vec2 epsilon=1.0/u_dimension;float a=getElevation(v_pos+vec2(-epsilon.x,-epsilon.y));float b=getElevation(v_pos+vec2(0,-epsilon.y));float c=getElevation(v_pos+vec2(epsilon.x,-epsilon.y));float d=getElevation(v_pos+vec2(-epsilon.x,0));float e=getElevation(v_pos+vec2(epsilon.x,0));float f=getElevation(v_pos+vec2(-epsilon.x,epsilon.y));float g=getElevation(v_pos+vec2(0,epsilon.y));float h=getElevation(v_pos+vec2(epsilon.x,epsilon.y));float exaggerationFactor=u_zoom < 2.0 ? 0.4 : u_zoom < 4.5 ? 0.35 : 0.3;float exaggeration=u_zoom < 15.0 ? (u_zoom-15.0)*exaggerationFactor : 0.0;vec2 deriv=vec2(\n(c+e+e+h)-(a+d+d+f),(f+g+g+h)-(a+b+b+c)\n)/pow(2.0,exaggeration+(19.2562-u_zoom));gl_FragColor=clamp(vec4(\nderiv.x/2.0+0.5,deriv.y/2.0+0.5,1.0,1.0),0.0,1.0);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "uniform mat4 u_matrix;uniform vec2 u_dimension;attribute vec2 a_pos;attribute vec2 a_texture_pos;varying vec2 v_pos;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);highp vec2 epsilon=1.0/u_dimension;float scale=(u_dimension.x-2.0)/u_dimension.x;v_pos=(a_texture_pos/8192.0)*scale+epsilon;}"), hillshade: ui("uniform sampler2D u_image;varying vec2 v_pos;uniform vec2 u_latrange;uniform vec2 u_light;uniform vec4 u_shadow;uniform vec4 u_highlight;uniform vec4 u_accent;void main() {vec4 pixel=texture2D(u_image,v_pos);vec2 deriv=((pixel.rg*2.0)-1.0);float scaleFactor=cos(radians((u_latrange[0]-u_latrange[1])*(1.0-v_pos.y)+u_latrange[1]));float slope=atan(1.25*length(deriv)/scaleFactor);float aspect=deriv.x !=0.0 ? atan(deriv.y,-deriv.x) : PI/2.0*(deriv.y > 0.0 ? 1.0 :-1.0);float intensity=u_light.x;float azimuth=u_light.y+PI;float base=1.875-intensity*1.75;float maxValue=0.5*PI;float scaledSlope=intensity !=0.5 ? ((pow(base,slope)-1.0)/(pow(base,maxValue)-1.0))*maxValue : slope;float accent=cos(scaledSlope);vec4 accent_color=(1.0-accent)*u_accent*clamp(intensity*2.0,0.0,1.0);float shade=abs(mod((aspect+azimuth)/PI+0.5,2.0)-1.0);vec4 shade_color=mix(u_shadow,u_highlight,shade)*sin(scaledSlope)*clamp(intensity*2.0,0.0,1.0);gl_FragColor=accent_color*(1.0-shade_color.a)+shade_color;\n#ifdef LIGHTING_3D_MODE\ngl_FragColor=apply_lighting(gl_FragColor);\n#endif\n#ifdef FOG\ngl_FragColor=fog_dither(fog_apply_premultiplied(gl_FragColor,v_fog_pos));\n#endif\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "uniform mat4 u_matrix;attribute vec2 a_pos;attribute vec2 a_texture_pos;varying vec2 v_pos;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);v_pos=a_texture_pos/8192.0;\n#ifdef FOG\nv_fog_pos=fog_position(a_pos);\n#endif\n}"), line: ui("uniform lowp float u_device_pixel_ratio;uniform float u_alpha_discard_threshold;uniform highp vec2 u_trim_offset;varying vec2 v_width2;varying vec2 v_normal;varying float v_gamma_scale;varying highp vec4 v_uv;\n#ifdef RENDER_LINE_DASH\nuniform sampler2D u_dash_image;varying vec2 v_tex;\n#endif\n#ifdef RENDER_LINE_GRADIENT\nuniform sampler2D u_gradient_image;\n#endif\nuniform float u_border_width;uniform vec4 u_border_color;float luminance(vec3 c) {return (c.r+c.r+c.b+c.g+c.g+c.g)*0.1667;}\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define lowp float floorwidth\n#pragma mapbox: define lowp vec4 dash\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\nfloat linearstep(float edge0,float edge1,float x) {return  clamp((x-edge0)/(edge1-edge0),0.0,1.0);}void main() {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize lowp float floorwidth\n#pragma mapbox: initialize lowp vec4 dash\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\nfloat dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);\n#ifdef RENDER_LINE_DASH\nfloat sdfdist=texture2D(u_dash_image,v_tex).a;float sdfgamma=1.0/(2.0*u_device_pixel_ratio)/dash.z;alpha*=linearstep(0.5-sdfgamma/floorwidth,0.5+sdfgamma/floorwidth,sdfdist);\n#endif\nhighp vec4 out_color;\n#ifdef RENDER_LINE_GRADIENT\nout_color=texture2D(u_gradient_image,v_uv.xy);\n#else\nout_color=color;\n#endif\nfloat trimmed=1.0;\n#ifdef RENDER_LINE_TRIM_OFFSET\nhighp float start=v_uv[2];highp float end=v_uv[3];highp float trim_start=u_trim_offset[0];highp float trim_end=u_trim_offset[1];highp float line_progress=(start+(v_uv.x)*(end-start));if (trim_end > trim_start) {if (line_progress <=trim_end && line_progress >=trim_start) {out_color=vec4(0,0,0,0);trimmed=0.0;}}\n#endif\n#ifdef LIGHTING_3D_MODE\nout_color=apply_lighting(out_color);\n#endif\n#ifdef FOG\nout_color=fog_dither(fog_apply_premultiplied(out_color,v_fog_pos));\n#endif\n#ifdef RENDER_LINE_ALPHA_DISCARD\nif (alpha < u_alpha_discard_threshold) {discard;}\n#endif\n#ifdef RENDER_LINE_BORDER\nfloat edgeBlur=(u_border_width+1.0/u_device_pixel_ratio);float alpha2=clamp(min(dist-(v_width2.t-edgeBlur),v_width2.s-dist)/edgeBlur,0.0,1.0);if (alpha2 < 1.) {float smoothAlpha=smoothstep(0.6,1.0,alpha2);\n#ifdef RENDER_LINE_BORDER_AUTO\nfloat Y=(out_color.a > 0.01) ? luminance(out_color.rgb/out_color.a) : 1.;float adjustment=(Y > 0.) ? 0.5/Y : 0.45;if (out_color.a > 0.25 && Y < 0.25) {vec3 borderColor=(Y > 0.) ? out_color.rgb : vec3(1,1,1)*out_color.a;out_color.rgb=out_color.rgb+borderColor*(adjustment*(1.0-smoothAlpha));} else {out_color.rgb*=(0.6 +0.4*smoothAlpha);}\n#else\nout_color.rgb=mix(u_border_color.rgb*u_border_color.a*trimmed,out_color.rgb,smoothAlpha);\n#endif\n}\n#endif\ngl_FragColor=out_color*(alpha*opacity);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "\n#define EXTRUDE_SCALE 0.015873016\nattribute vec2 a_pos_normal;attribute vec4 a_data;\n#if defined(RENDER_LINE_GRADIENT) || defined(RENDER_LINE_TRIM_OFFSET)\nattribute highp vec4 a_packed;\n#endif\n#ifdef RENDER_LINE_DASH\nattribute float a_linesofar;\n#endif\nuniform mat4 u_matrix;uniform mat2 u_pixels_to_tile_units;uniform vec2 u_units_to_pixels;uniform lowp float u_device_pixel_ratio;varying vec2 v_normal;varying vec2 v_width2;varying float v_gamma_scale;varying highp vec4 v_uv;\n#ifdef RENDER_LINE_DASH\nuniform vec2 u_texsize;uniform float u_tile_units_to_pixels;varying vec2 v_tex;\n#endif\n#ifdef RENDER_LINE_GRADIENT\nuniform float u_image_height;\n#endif\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define lowp float floorwidth\n#pragma mapbox: define lowp vec4 dash\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define mediump float gapwidth\n#pragma mapbox: define lowp float offset\n#pragma mapbox: define mediump float width\nvoid main() {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize lowp float floorwidth\n#pragma mapbox: initialize lowp vec4 dash\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump float gapwidth\n#pragma mapbox: initialize lowp float offset\n#pragma mapbox: initialize mediump float width\nfloat ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*EXTRUDE_SCALE;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*EXTRUDE_SCALE*normal.y*mat2(t,-u,u,t);vec4 projected_extrude=u_matrix*vec4(dist*u_pixels_to_tile_units,0.0,0.0);gl_Position=u_matrix*vec4(pos+offset2*u_pixels_to_tile_units,0.0,1.0)+projected_extrude;\n#ifndef RENDER_TO_TEXTURE\nfloat extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length(projected_extrude.xy/gl_Position.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;\n#else\nv_gamma_scale=1.0;\n#endif\n#if defined(RENDER_LINE_GRADIENT) || defined(RENDER_LINE_TRIM_OFFSET)\nfloat a_uv_x=a_packed[0];float a_split_index=a_packed[1];highp float a_clip_start=a_packed[2];highp float a_clip_end=a_packed[3];\n#ifdef RENDER_LINE_GRADIENT\nhighp float texel_height=1.0/u_image_height;highp float half_texel_height=0.5*texel_height;v_uv=vec4(a_uv_x,a_split_index*texel_height-half_texel_height,a_clip_start,a_clip_end);\n#else\nv_uv=vec4(a_uv_x,0.0,a_clip_start,a_clip_end);\n#endif\n#endif\n#ifdef RENDER_LINE_DASH\nfloat scale=dash.z==0.0 ? 0.0 : u_tile_units_to_pixels/dash.z;float height=dash.y;v_tex=vec2(a_linesofar*scale/floorwidth,(-normal.y*height+dash.x+0.5)/u_texsize.y);\n#endif\nv_width2=vec2(outset,inset);\n#ifdef FOG\nv_fog_pos=fog_position(pos);\n#endif\n}"), linePattern: ui("uniform lowp float u_device_pixel_ratio;uniform vec2 u_texsize;uniform float u_tile_units_to_pixels;uniform sampler2D u_image;varying vec2 v_normal;varying vec2 v_width2;varying float v_linesofar;varying float v_gamma_scale;varying float v_width;\n#pragma mapbox: define lowp vec4 pattern\n#pragma mapbox: define lowp float pixel_ratio\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize mediump vec4 pattern\n#pragma mapbox: initialize lowp float pixel_ratio\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\nvec2 pattern_tl=pattern.xy;vec2 pattern_br=pattern.zw;vec2 display_size=(pattern_br-pattern_tl)/pixel_ratio;vec2 pattern_size=vec2(display_size.x/u_tile_units_to_pixels,display_size.y);float aspect=display_size.y/v_width;float dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);float x=mod(v_linesofar/pattern_size.x*aspect,1.0);float y=0.5*v_normal.y+0.5;vec2 texel_size=1.0/u_texsize;vec2 pos=mix(pattern_tl*texel_size-texel_size,pattern_br*texel_size+texel_size,vec2(x,y));vec4 color=texture2D(u_image,pos);\n#ifdef LIGHTING_3D_MODE\ncolor=apply_lighting(color);\n#endif\n#ifdef FOG\ncolor=fog_dither(fog_apply_premultiplied(color,v_fog_pos));\n#endif\ngl_FragColor=color*(alpha*opacity);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "\n#define scale 0.015873016\nattribute vec2 a_pos_normal;attribute vec4 a_data;attribute float a_linesofar;uniform mat4 u_matrix;uniform vec2 u_units_to_pixels;uniform mat2 u_pixels_to_tile_units;uniform lowp float u_device_pixel_ratio;varying vec2 v_normal;varying vec2 v_width2;varying float v_linesofar;varying float v_gamma_scale;varying float v_width;\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp float offset\n#pragma mapbox: define mediump float gapwidth\n#pragma mapbox: define mediump float width\n#pragma mapbox: define lowp float floorwidth\n#pragma mapbox: define lowp vec4 pattern\n#pragma mapbox: define lowp float pixel_ratio\nvoid main() {\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize lowp float offset\n#pragma mapbox: initialize mediump float gapwidth\n#pragma mapbox: initialize mediump float width\n#pragma mapbox: initialize lowp float floorwidth\n#pragma mapbox: initialize mediump vec4 pattern\n#pragma mapbox: initialize lowp float pixel_ratio\nfloat ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*scale;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);vec4 projected_extrude=u_matrix*vec4(dist*u_pixels_to_tile_units,0.0,0.0);gl_Position=u_matrix*vec4(pos+offset2*u_pixels_to_tile_units,0.0,1.0)+projected_extrude;\n#ifndef RENDER_TO_TEXTURE\nfloat extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length(projected_extrude.xy/gl_Position.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;\n#else\nv_gamma_scale=1.0;\n#endif\nv_linesofar=a_linesofar;v_width2=vec2(outset,inset);v_width=floorwidth;\n#ifdef FOG\nv_fog_pos=fog_position(pos);\n#endif\n}"), raster: ui("uniform float u_fade_t;uniform float u_opacity;uniform sampler2D u_image0;uniform sampler2D u_image1;varying vec2 v_pos0;varying vec2 v_pos1;uniform float u_brightness_low;uniform float u_brightness_high;uniform float u_saturation_factor;uniform float u_contrast_factor;uniform vec3 u_spin_weights;void main() {vec4 color0=texture2D(u_image0,v_pos0);vec4 color1=texture2D(u_image1,v_pos1);if (color0.a > 0.0) {color0.rgb=color0.rgb/color0.a;}if (color1.a > 0.0) {color1.rgb=color1.rgb/color1.a;}vec4 color=mix(color0,color1,u_fade_t);color.a*=u_opacity;vec3 rgb=color.rgb;rgb=vec3(\ndot(rgb,u_spin_weights.xyz),dot(rgb,u_spin_weights.zxy),dot(rgb,u_spin_weights.yzx));float average=(color.r+color.g+color.b)/3.0;rgb+=(average-rgb)*u_saturation_factor;rgb=(rgb-0.5)*u_contrast_factor+0.5;vec3 u_high_vec=vec3(u_brightness_low,u_brightness_low,u_brightness_low);vec3 u_low_vec=vec3(u_brightness_high,u_brightness_high,u_brightness_high);vec3 out_color=mix(u_high_vec,u_low_vec,rgb);\n#ifdef LIGHTING_3D_MODE\nout_color=apply_lighting(out_color);\n#endif\n#ifdef FOG\nout_color=fog_dither(fog_apply(out_color,v_fog_pos));\n#endif\ngl_FragColor=vec4(out_color*color.a,color.a);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "uniform mat4 u_matrix;uniform vec2 u_tl_parent;uniform float u_scale_parent;uniform vec2 u_perspective_transform;attribute vec2 a_pos;attribute vec2 a_texture_pos;varying vec2 v_pos0;varying vec2 v_pos1;void main() {float w=1.0+dot(a_texture_pos,u_perspective_transform);gl_Position=u_matrix*vec4(a_pos*w,0,w);v_pos0=a_texture_pos/8192.0;v_pos1=(v_pos0*u_scale_parent)+u_tl_parent;\n#ifdef FOG\nv_fog_pos=fog_position(a_pos);\n#endif\n}"), symbolIcon: ui("uniform sampler2D u_texture;varying vec2 v_tex;varying float v_fade_opacity;\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize lowp float opacity\nlowp float alpha=opacity*v_fade_opacity;gl_FragColor=texture2D(u_texture,v_tex)*alpha;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "attribute vec4 a_pos_offset;attribute vec4 a_tex_size;attribute vec4 a_pixeloffset;attribute vec4 a_projected_pos;attribute float a_fade_opacity;\n#ifdef PROJECTION_GLOBE_VIEW\nattribute vec3 a_globe_anchor;attribute vec3 a_globe_normal;\n#endif\nuniform bool u_is_size_zoom_constant;uniform bool u_is_size_feature_constant;uniform highp float u_size_t;uniform highp float u_size;uniform highp float u_camera_to_center_distance;uniform bool u_rotate_symbol;uniform highp float u_aspect_ratio;uniform float u_fade_change;uniform mat4 u_matrix;uniform mat4 u_label_plane_matrix;uniform mat4 u_coord_matrix;uniform bool u_is_text;uniform bool u_pitch_with_map;uniform vec2 u_texsize;uniform vec3 u_up_vector;\n#ifdef PROJECTION_GLOBE_VIEW\nuniform vec3 u_tile_id;uniform mat4 u_inv_rot_matrix;uniform vec2 u_merc_center;uniform vec3 u_camera_forward;uniform float u_zoom_transition;uniform vec3 u_ecef_origin;uniform mat4 u_tile_matrix;\n#endif\nvarying vec2 v_tex;varying float v_fade_opacity;\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize lowp float opacity\nvec2 a_pos=a_pos_offset.xy;vec2 a_offset=a_pos_offset.zw;vec2 a_tex=a_tex_size.xy;vec2 a_size=a_tex_size.zw;float a_size_min=floor(a_size[0]*0.5);vec2 a_pxoffset=a_pixeloffset.xy;vec2 a_min_font_scale=a_pixeloffset.zw/256.0;highp float segment_angle=-a_projected_pos[3];float size;if (!u_is_size_zoom_constant && !u_is_size_feature_constant) {size=mix(a_size_min,a_size[1],u_size_t)/128.0;} else if (u_is_size_zoom_constant && !u_is_size_feature_constant) {size=a_size_min/128.0;} else {size=u_size;}vec2 tile_anchor=a_pos;vec3 h=elevationVector(tile_anchor)*elevation(tile_anchor);float globe_occlusion_fade;vec3 world_pos;vec3 mercator_pos;\n#ifdef PROJECTION_GLOBE_VIEW\nmercator_pos=mercator_tile_position(u_inv_rot_matrix,tile_anchor,u_tile_id,u_merc_center);world_pos=mix_globe_mercator(a_globe_anchor+h,mercator_pos,u_zoom_transition);vec4 ecef_point=u_tile_matrix*vec4(world_pos,1.0);vec3 origin_to_point=ecef_point.xyz-u_ecef_origin;globe_occlusion_fade=dot(origin_to_point,u_camera_forward) >=0.0 ? 0.0 : 1.0;\n#else\nworld_pos=vec3(tile_anchor,0)+h;globe_occlusion_fade=1.0;\n#endif\nvec4 projected_point=u_matrix*vec4(world_pos,1);highp float camera_to_anchor_distance=projected_point.w;highp float distance_ratio=u_pitch_with_map ?\ncamera_to_anchor_distance/u_camera_to_center_distance :\nu_camera_to_center_distance/camera_to_anchor_distance;highp float perspective_ratio=clamp(\n0.5+0.5*distance_ratio,0.0,1.5);size*=perspective_ratio;float font_scale=u_is_text ? size/24.0 : size;highp float symbol_rotation=0.0;if (u_rotate_symbol) {vec4 offsetProjected_point;\n#ifdef PROJECTION_GLOBE_VIEW\nvec3 displacement=vec3(a_globe_normal.z,0,-a_globe_normal.x);offsetProjected_point=u_matrix*vec4(a_globe_anchor+displacement,1);\n#else\noffsetProjected_point=u_matrix*vec4(tile_anchor+vec2(1,0),0,1);\n#endif\nvec2 a=projected_point.xy/projected_point.w;vec2 b=offsetProjected_point.xy/offsetProjected_point.w;symbol_rotation=atan((b.y-a.y)/u_aspect_ratio,b.x-a.x);}vec4 projected_pos;\n#ifdef PROJECTION_GLOBE_VIEW\nvec3 proj_pos=mix_globe_mercator(a_projected_pos.xyz+h,mercator_pos,u_zoom_transition);projected_pos=u_label_plane_matrix*vec4(proj_pos,1.0);\n#else\nprojected_pos=u_label_plane_matrix*vec4(a_projected_pos.xy,h.z,1.0);\n#endif\nhighp float angle_sin=sin(segment_angle+symbol_rotation);highp float angle_cos=cos(segment_angle+symbol_rotation);mat2 rotation_matrix=mat2(angle_cos,-1.0*angle_sin,angle_sin,angle_cos);float z=0.0;vec2 offset=rotation_matrix*(a_offset/32.0*max(a_min_font_scale,font_scale)+a_pxoffset/16.0);\n#ifdef TERRAIN\n#ifdef PITCH_WITH_MAP_TERRAIN\nvec4 tile_pos=u_label_plane_matrix_inv*vec4(a_projected_pos.xy+offset,0.0,1.0);z=elevation(tile_pos.xy);\n#endif\n#endif\nfloat occlusion_fade=occlusionFade(projected_point)*globe_occlusion_fade;\n#ifdef PROJECTION_GLOBE_VIEW\nvec3 xAxis=u_pitch_with_map ? normalize(cross(a_globe_normal,u_up_vector)) : vec3(1,0,0);vec3 yAxis=u_pitch_with_map ? normalize(cross(a_globe_normal,xAxis)) : vec3(0,1,0);gl_Position=mix(u_coord_matrix*vec4(projected_pos.xyz/projected_pos.w+xAxis*offset.x+yAxis*offset.y,1.0),AWAY,float(projected_point.w <=0.0 || occlusion_fade==0.0));\n#else\ngl_Position=mix(u_coord_matrix*vec4(projected_pos.xy/projected_pos.w+offset,z,1.0),AWAY,float(projected_point.w <=0.0 || occlusion_fade==0.0));\n#endif\nfloat projection_transition_fade=1.0;\n#if defined(PROJECTED_POS_ON_VIEWPORT) && defined(PROJECTION_GLOBE_VIEW)\nprojection_transition_fade=1.0-step(EPSILON,u_zoom_transition);\n#endif\nv_tex=a_tex/u_texsize;vec2 fade_opacity=unpack_opacity(a_fade_opacity);float fade_change=fade_opacity[1] > 0.5 ? u_fade_change :-u_fade_change;v_fade_opacity=max(0.0,min(occlusion_fade,fade_opacity[0]+fade_change))*projection_transition_fade;}"), symbolSDF: ui("#define SDF_PX 8.0\nuniform bool u_is_halo;uniform sampler2D u_texture;uniform highp float u_gamma_scale;uniform lowp float u_device_pixel_ratio;uniform bool u_is_text;varying vec2 v_data0;varying vec3 v_data1;\n#pragma mapbox: define highp vec4 fill_color\n#pragma mapbox: define highp vec4 halo_color\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp float halo_width\n#pragma mapbox: define lowp float halo_blur\nvoid main() {\n#pragma mapbox: initialize highp vec4 fill_color\n#pragma mapbox: initialize highp vec4 halo_color\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize lowp float halo_width\n#pragma mapbox: initialize lowp float halo_blur\nfloat EDGE_GAMMA=0.105/u_device_pixel_ratio;vec2 tex=v_data0.xy;float gamma_scale=v_data1.x;float size=v_data1.y;float fade_opacity=v_data1[2];float fontScale=u_is_text ? size/24.0 : size;lowp vec4 color=fill_color;highp float gamma=EDGE_GAMMA/(fontScale*u_gamma_scale);lowp float buff=(256.0-64.0)/256.0;if (u_is_halo) {color=halo_color;gamma=(halo_blur*1.19/SDF_PX+EDGE_GAMMA)/(fontScale*u_gamma_scale);buff=(6.0-halo_width/fontScale)/SDF_PX;}lowp float dist=texture2D(u_texture,tex).a;highp float gamma_scaled=gamma*gamma_scale;highp float alpha=smoothstep(buff-gamma_scaled,buff+gamma_scaled,dist);gl_FragColor=color*(alpha*opacity*fade_opacity);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "attribute vec4 a_pos_offset;attribute vec4 a_tex_size;attribute vec4 a_pixeloffset;attribute vec4 a_projected_pos;attribute float a_fade_opacity;\n#ifdef PROJECTION_GLOBE_VIEW\nattribute vec3 a_globe_anchor;attribute vec3 a_globe_normal;\n#endif\nuniform bool u_is_size_zoom_constant;uniform bool u_is_size_feature_constant;uniform highp float u_size_t;uniform highp float u_size;uniform mat4 u_matrix;uniform mat4 u_label_plane_matrix;uniform mat4 u_coord_matrix;uniform bool u_is_text;uniform bool u_pitch_with_map;uniform bool u_rotate_symbol;uniform highp float u_aspect_ratio;uniform highp float u_camera_to_center_distance;uniform float u_fade_change;uniform vec2 u_texsize;uniform vec3 u_up_vector;\n#ifdef PROJECTION_GLOBE_VIEW\nuniform vec3 u_tile_id;uniform mat4 u_inv_rot_matrix;uniform vec2 u_merc_center;uniform vec3 u_camera_forward;uniform float u_zoom_transition;uniform vec3 u_ecef_origin;uniform mat4 u_tile_matrix;\n#endif\nvarying vec2 v_data0;varying vec3 v_data1;\n#pragma mapbox: define highp vec4 fill_color\n#pragma mapbox: define highp vec4 halo_color\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp float halo_width\n#pragma mapbox: define lowp float halo_blur\nvoid main() {\n#pragma mapbox: initialize highp vec4 fill_color\n#pragma mapbox: initialize highp vec4 halo_color\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize lowp float halo_width\n#pragma mapbox: initialize lowp float halo_blur\nvec2 a_pos=a_pos_offset.xy;vec2 a_offset=a_pos_offset.zw;vec2 a_tex=a_tex_size.xy;vec2 a_size=a_tex_size.zw;float a_size_min=floor(a_size[0]*0.5);vec2 a_pxoffset=a_pixeloffset.xy;highp float segment_angle=-a_projected_pos[3];float size;if (!u_is_size_zoom_constant && !u_is_size_feature_constant) {size=mix(a_size_min,a_size[1],u_size_t)/128.0;} else if (u_is_size_zoom_constant && !u_is_size_feature_constant) {size=a_size_min/128.0;} else {size=u_size;}vec2 tile_anchor=a_pos;vec3 h=elevationVector(tile_anchor)*elevation(tile_anchor);float globe_occlusion_fade;vec3 world_pos;vec3 mercator_pos;\n#ifdef PROJECTION_GLOBE_VIEW\nmercator_pos=mercator_tile_position(u_inv_rot_matrix,tile_anchor,u_tile_id,u_merc_center);world_pos=mix_globe_mercator(a_globe_anchor+h,mercator_pos,u_zoom_transition);vec4 ecef_point=u_tile_matrix*vec4(world_pos,1.0);vec3 origin_to_point=ecef_point.xyz-u_ecef_origin;globe_occlusion_fade=dot(origin_to_point,u_camera_forward) >=0.0 ? 0.0 : 1.0;\n#else\nworld_pos=vec3(tile_anchor,0)+h;globe_occlusion_fade=1.0;\n#endif\nvec4 projected_point=u_matrix*vec4(world_pos,1);highp float camera_to_anchor_distance=projected_point.w;highp float distance_ratio=u_pitch_with_map ?\ncamera_to_anchor_distance/u_camera_to_center_distance :\nu_camera_to_center_distance/camera_to_anchor_distance;highp float perspective_ratio=clamp(\n0.5+0.5*distance_ratio,0.0,1.5);size*=perspective_ratio;float fontScale=u_is_text ? size/24.0 : size;highp float symbol_rotation=0.0;if (u_rotate_symbol) {vec4 offsetprojected_point;\n#ifdef PROJECTION_GLOBE_VIEW\nvec3 displacement=vec3(a_globe_normal.z,0,-a_globe_normal.x);offsetprojected_point=u_matrix*vec4(a_globe_anchor+displacement,1);\n#else\noffsetprojected_point=u_matrix*vec4(tile_anchor+vec2(1,0),0,1);\n#endif\nvec2 a=projected_point.xy/projected_point.w;vec2 b=offsetprojected_point.xy/offsetprojected_point.w;symbol_rotation=atan((b.y-a.y)/u_aspect_ratio,b.x-a.x);}vec4 projected_pos;\n#ifdef PROJECTION_GLOBE_VIEW\nvec3 proj_pos=mix_globe_mercator(a_projected_pos.xyz+h,mercator_pos,u_zoom_transition);projected_pos=u_label_plane_matrix*vec4(proj_pos,1.0);\n#else\nprojected_pos=u_label_plane_matrix*vec4(a_projected_pos.xy,h.z,1.0);\n#endif\nhighp float angle_sin=sin(segment_angle+symbol_rotation);highp float angle_cos=cos(segment_angle+symbol_rotation);mat2 rotation_matrix=mat2(angle_cos,-1.0*angle_sin,angle_sin,angle_cos);float z=0.0;vec2 offset=rotation_matrix*(a_offset/32.0*fontScale+a_pxoffset);\n#ifdef TERRAIN\n#ifdef PITCH_WITH_MAP_TERRAIN\nvec4 tile_pos=u_label_plane_matrix_inv*vec4(a_projected_pos.xy+offset,0.0,1.0);z=elevation(tile_pos.xy);\n#endif\n#endif\nfloat occlusion_fade=occlusionFade(projected_point)*globe_occlusion_fade;\n#ifdef PROJECTION_GLOBE_VIEW\nvec3 xAxis=u_pitch_with_map ? normalize(cross(a_globe_normal,u_up_vector)) : vec3(1,0,0);vec3 yAxis=u_pitch_with_map ? normalize(cross(a_globe_normal,xAxis)) : vec3(0,1,0);gl_Position=mix(u_coord_matrix*vec4(projected_pos.xyz/projected_pos.w+xAxis*offset.x+yAxis*offset.y,1.0),AWAY,float(projected_point.w <=0.0 || occlusion_fade==0.0));\n#else\ngl_Position=mix(u_coord_matrix*vec4(projected_pos.xy/projected_pos.w+offset,z,1.0),AWAY,float(projected_point.w <=0.0 || occlusion_fade==0.0));\n#endif\nfloat gamma_scale=gl_Position.w;float projection_transition_fade=1.0;\n#if defined(PROJECTED_POS_ON_VIEWPORT) && defined(PROJECTION_GLOBE_VIEW)\nprojection_transition_fade=1.0-step(EPSILON,u_zoom_transition);\n#endif\nvec2 fade_opacity=unpack_opacity(a_fade_opacity);float fade_change=fade_opacity[1] > 0.5 ? u_fade_change :-u_fade_change;float interpolated_fade_opacity=max(0.0,min(occlusion_fade,fade_opacity[0]+fade_change));v_data0=a_tex/u_texsize;v_data1=vec3(gamma_scale,size,interpolated_fade_opacity*projection_transition_fade);}"), symbolTextAndIcon: ui("#define SDF_PX 8.0\n#define SDF 1.0\n#define ICON 0.0\nuniform bool u_is_halo;uniform sampler2D u_texture;uniform sampler2D u_texture_icon;uniform highp float u_gamma_scale;uniform lowp float u_device_pixel_ratio;varying vec4 v_data0;varying vec4 v_data1;\n#pragma mapbox: define highp vec4 fill_color\n#pragma mapbox: define highp vec4 halo_color\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp float halo_width\n#pragma mapbox: define lowp float halo_blur\nvoid main() {\n#pragma mapbox: initialize highp vec4 fill_color\n#pragma mapbox: initialize highp vec4 halo_color\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize lowp float halo_width\n#pragma mapbox: initialize lowp float halo_blur\nfloat fade_opacity=v_data1[2];if (v_data1.w==ICON) {vec2 tex_icon=v_data0.zw;lowp float alpha=opacity*fade_opacity;gl_FragColor=texture2D(u_texture_icon,tex_icon)*alpha;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\nreturn;}vec2 tex=v_data0.xy;float EDGE_GAMMA=0.105/u_device_pixel_ratio;float gamma_scale=v_data1.x;float size=v_data1.y;float fontScale=size/24.0;lowp vec4 color=fill_color;highp float gamma=EDGE_GAMMA/(fontScale*u_gamma_scale);lowp float buff=(256.0-64.0)/256.0;if (u_is_halo) {color=halo_color;gamma=(halo_blur*1.19/SDF_PX+EDGE_GAMMA)/(fontScale*u_gamma_scale);buff=(6.0-halo_width/fontScale)/SDF_PX;}lowp float dist=texture2D(u_texture,tex).a;highp float gamma_scaled=gamma*gamma_scale;highp float alpha=smoothstep(buff-gamma_scaled,buff+gamma_scaled,dist);gl_FragColor=color*(alpha*opacity*fade_opacity);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "attribute vec4 a_pos_offset;attribute vec4 a_tex_size;attribute vec4 a_projected_pos;attribute float a_fade_opacity;\n#ifdef PROJECTION_GLOBE_VIEW\nattribute vec3 a_globe_anchor;attribute vec3 a_globe_normal;\n#endif\nuniform bool u_is_size_zoom_constant;uniform bool u_is_size_feature_constant;uniform highp float u_size_t;uniform highp float u_size;uniform mat4 u_matrix;uniform mat4 u_label_plane_matrix;uniform mat4 u_coord_matrix;uniform bool u_is_text;uniform bool u_pitch_with_map;uniform bool u_rotate_symbol;uniform highp float u_aspect_ratio;uniform highp float u_camera_to_center_distance;uniform float u_fade_change;uniform vec2 u_texsize;uniform vec3 u_up_vector;uniform vec2 u_texsize_icon;\n#ifdef PROJECTION_GLOBE_VIEW\nuniform vec3 u_tile_id;uniform mat4 u_inv_rot_matrix;uniform vec2 u_merc_center;uniform vec3 u_camera_forward;uniform float u_zoom_transition;uniform vec3 u_ecef_origin;uniform mat4 u_tile_matrix;\n#endif\nvarying vec4 v_data0;varying vec4 v_data1;\n#pragma mapbox: define highp vec4 fill_color\n#pragma mapbox: define highp vec4 halo_color\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp float halo_width\n#pragma mapbox: define lowp float halo_blur\nvoid main() {\n#pragma mapbox: initialize highp vec4 fill_color\n#pragma mapbox: initialize highp vec4 halo_color\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize lowp float halo_width\n#pragma mapbox: initialize lowp float halo_blur\nvec2 a_pos=a_pos_offset.xy;vec2 a_offset=a_pos_offset.zw;vec2 a_tex=a_tex_size.xy;vec2 a_size=a_tex_size.zw;float a_size_min=floor(a_size[0]*0.5);float is_sdf=a_size[0]-2.0*a_size_min;highp float segment_angle=-a_projected_pos[3];float size;if (!u_is_size_zoom_constant && !u_is_size_feature_constant) {size=mix(a_size_min,a_size[1],u_size_t)/128.0;} else if (u_is_size_zoom_constant && !u_is_size_feature_constant) {size=a_size_min/128.0;} else {size=u_size;}vec2 tile_anchor=a_pos;vec3 h=elevationVector(tile_anchor)*elevation(tile_anchor);float globe_occlusion_fade;vec3 world_pos;vec3 mercator_pos;\n#ifdef PROJECTION_GLOBE_VIEW\nmercator_pos=mercator_tile_position(u_inv_rot_matrix,tile_anchor,u_tile_id,u_merc_center);world_pos=mix_globe_mercator(a_globe_anchor+h,mercator_pos,u_zoom_transition);vec4 ecef_point=u_tile_matrix*vec4(world_pos,1.0);vec3 origin_to_point=ecef_point.xyz-u_ecef_origin;globe_occlusion_fade=dot(origin_to_point,u_camera_forward) >=0.0 ? 0.0 : 1.0;\n#else\nworld_pos=vec3(tile_anchor,0)+h;globe_occlusion_fade=1.0;\n#endif\nvec4 projected_point=u_matrix*vec4(world_pos,1);highp float camera_to_anchor_distance=projected_point.w;highp float distance_ratio=u_pitch_with_map ?\ncamera_to_anchor_distance/u_camera_to_center_distance :\nu_camera_to_center_distance/camera_to_anchor_distance;highp float perspective_ratio=clamp(\n0.5+0.5*distance_ratio,0.0,1.5);size*=perspective_ratio;float font_scale=size/24.0;highp float symbol_rotation=0.0;if (u_rotate_symbol) {vec4 offset_projected_point=u_matrix*vec4(a_pos+vec2(1,0),0,1);vec2 a=projected_point.xy/projected_point.w;vec2 b=offset_projected_point.xy/offset_projected_point.w;symbol_rotation=atan((b.y-a.y)/u_aspect_ratio,b.x-a.x);}vec4 projected_pos;\n#ifdef PROJECTION_GLOBE_VIEW\nvec3 proj_pos=mix_globe_mercator(a_projected_pos.xyz+h,mercator_pos,u_zoom_transition);projected_pos=u_label_plane_matrix*vec4(proj_pos,1.0);\n#else\nprojected_pos=u_label_plane_matrix*vec4(a_projected_pos.xy,h.z,1.0);\n#endif\nhighp float angle_sin=sin(segment_angle+symbol_rotation);highp float angle_cos=cos(segment_angle+symbol_rotation);mat2 rotation_matrix=mat2(angle_cos,-1.0*angle_sin,angle_sin,angle_cos);float z=0.0;vec2 offset=rotation_matrix*(a_offset/32.0*font_scale);\n#ifdef TERRAIN\n#ifdef PITCH_WITH_MAP_TERRAIN\nvec4 tile_pos=u_label_plane_matrix_inv*vec4(a_projected_pos.xy+offset,0.0,1.0);z=elevation(tile_pos.xy);\n#endif\n#endif\nfloat occlusion_fade=occlusionFade(projected_point)*globe_occlusion_fade;\n#ifdef PROJECTION_GLOBE_VIEW\nvec3 xAxis=u_pitch_with_map ? normalize(cross(a_globe_normal,u_up_vector)) : vec3(1,0,0);vec3 yAxis=u_pitch_with_map ? normalize(cross(a_globe_normal,xAxis)) : vec3(0,1,0);gl_Position=mix(u_coord_matrix*vec4(projected_pos.xyz/projected_pos.w+xAxis*offset.x+yAxis*offset.y,1.0),AWAY,float(projected_point.w <=0.0 || occlusion_fade==0.0));\n#else\ngl_Position=mix(u_coord_matrix*vec4(projected_pos.xy/projected_pos.w+offset,z,1.0),AWAY,float(projected_point.w <=0.0 || occlusion_fade==0.0));\n#endif\nfloat gamma_scale=gl_Position.w;vec2 fade_opacity=unpack_opacity(a_fade_opacity);float fade_change=fade_opacity[1] > 0.5 ? u_fade_change :-u_fade_change;float interpolated_fade_opacity=max(0.0,min(occlusion_fade,fade_opacity[0]+fade_change));float projection_transition_fade=1.0;\n#if defined(PROJECTED_POS_ON_VIEWPORT) && defined(PROJECTION_GLOBE_VIEW)\nprojection_transition_fade=1.0-step(EPSILON,u_zoom_transition);\n#endif\nv_data0.xy=a_tex/u_texsize;v_data0.zw=a_tex/u_texsize_icon;v_data1=vec4(gamma_scale,size,interpolated_fade_opacity*projection_transition_fade,is_sdf);}"), terrainRaster: ui("uniform sampler2D u_image0;varying vec2 v_pos0;\n#ifdef FOG\nvarying float v_fog_opacity;\n#endif\n#ifdef RENDER_SHADOWS\nvarying vec4 v_pos_light_view_0;varying vec4 v_pos_light_view_1;varying float v_depth;\n#endif\nvoid main() {vec4 color=texture2D(u_image0,v_pos0);\n#ifdef RENDER_SHADOWS\ncolor.xyz=shadowed_color(color.xyz,v_pos_light_view_0,v_pos_light_view_1,v_depth);\n#endif\n#ifdef FOG\n#ifdef ZERO_EXAGGERATION\ncolor=fog_dither(fog_apply_premultiplied(color,v_fog_pos));\n#else\ncolor=fog_dither(fog_apply_from_vert(color,v_fog_opacity));\n#endif\n#endif\ngl_FragColor=color;\n#ifdef TERRAIN_WIREFRAME\ngl_FragColor=vec4(1.0,0.0,0.0,0.8);\n#endif\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "uniform mat4 u_matrix;uniform float u_skirt_height;attribute vec2 a_pos;varying vec2 v_pos0;\n#ifdef FOG\nvarying float v_fog_opacity;\n#endif\n#ifdef RENDER_SHADOWS\nuniform mat4 u_light_matrix_0;uniform mat4 u_light_matrix_1;varying vec4 v_pos_light_view_0;varying vec4 v_pos_light_view_1;varying float v_depth;\n#endif\nconst float wireframeOffset=0.00015;void main() {vec3 decomposedPosAndSkirt=decomposeToPosAndSkirt(a_pos);float skirt=decomposedPosAndSkirt.z;vec2 decodedPos=decomposedPosAndSkirt.xy;float elevation=elevation(decodedPos)-skirt*u_skirt_height;\n#ifdef TERRAIN_WIREFRAME\nelevation+=wireframeOffset;\n#endif\nv_pos0=decodedPos/8192.0;gl_Position=u_matrix*vec4(decodedPos,elevation,1.0);\n#ifdef FOG\n#ifdef ZERO_EXAGGERATION\nv_fog_pos=fog_position(decodedPos);\n#else\nv_fog_opacity=fog(fog_position(vec3(decodedPos,elevation)));\n#endif\n#endif\n#ifdef RENDER_SHADOWS\nvec3 pos=vec3(decodedPos,elevation);v_pos_light_view_0=u_light_matrix_0*vec4(pos,1.);v_pos_light_view_1=u_light_matrix_1*vec4(pos,1.);v_depth=gl_Position.w;\n#endif\n}"), terrainDepth: ui("#ifdef GL_ES\nprecision highp float;\n#endif\nvarying float v_depth;void main() {gl_FragColor=pack_depth(v_depth);}", "uniform mat4 u_matrix;attribute vec2 a_pos;varying float v_depth;void main() {float elevation=elevation(a_pos);gl_Position=u_matrix*vec4(a_pos,elevation,1.0);v_depth=gl_Position.z/gl_Position.w;}"), skybox: ui("\nvarying lowp vec3 v_uv;uniform lowp samplerCube u_cubemap;uniform lowp float u_opacity;uniform highp float u_temporal_offset;uniform highp vec3 u_sun_direction;float sun_disk(highp vec3 ray_direction,highp vec3 sun_direction) {highp float cos_angle=dot(normalize(ray_direction),sun_direction);const highp float cos_sun_angular_diameter=0.99996192306;const highp float smoothstep_delta=1e-5;return smoothstep(\ncos_sun_angular_diameter-smoothstep_delta,cos_sun_angular_diameter+smoothstep_delta,cos_angle);}float map(float value,float start,float end,float new_start,float new_end) {return ((value-start)*(new_end-new_start))/(end-start)+new_start;}void main() {vec3 uv=v_uv;const float y_bias=0.015;uv.y+=y_bias;uv.y=pow(abs(uv.y),1.0/5.0);uv.y=map(uv.y,0.0,1.0,-1.0,1.0);vec3 sky_color=textureCube(u_cubemap,uv).rgb;\n#ifdef FOG\nsky_color=fog_apply_sky_gradient(v_uv.xzy,sky_color);\n#endif\nsky_color.rgb=dither(sky_color.rgb,gl_FragCoord.xy+u_temporal_offset);sky_color+=0.1*sun_disk(v_uv,u_sun_direction);gl_FragColor=vec4(sky_color*u_opacity,u_opacity);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", Qt), skyboxGradient: ui("varying highp vec3 v_uv;uniform lowp sampler2D u_color_ramp;uniform highp vec3 u_center_direction;uniform lowp float u_radius;uniform lowp float u_opacity;uniform highp float u_temporal_offset;void main() {float progress=acos(dot(normalize(v_uv),u_center_direction))/u_radius;vec4 color=texture2D(u_color_ramp,vec2(progress,0.5));\n#ifdef FOG\ncolor.rgb=fog_apply_sky_gradient(v_uv.xzy,color.rgb/color.a)*color.a;\n#endif\ncolor*=u_opacity;color.rgb=dither(color.rgb,gl_FragCoord.xy+u_temporal_offset);gl_FragColor=color;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", Qt), skyboxCapture: ui("\nvarying highp vec3 v_position;uniform highp float u_sun_intensity;uniform highp float u_luminance;uniform lowp vec3 u_sun_direction;uniform highp vec4 u_color_tint_r;uniform highp vec4 u_color_tint_m;\n#ifdef GL_ES\nprecision highp float;\n#endif\n#define BETA_R                  vec3(5.5e-6,13.0e-6,22.4e-6)\n#define BETA_M                  vec3(21e-6,21e-6,21e-6)\n#define MIE_G                   0.76\n#define DENSITY_HEIGHT_SCALE_R  8000.0\n#define DENSITY_HEIGHT_SCALE_M  1200.0\n#define PLANET_RADIUS           6360e3\n#define ATMOSPHERE_RADIUS       6420e3\n#define SAMPLE_STEPS            10\n#define DENSITY_STEPS           4\nfloat ray_sphere_exit(vec3 orig,vec3 dir,float radius) {float a=dot(dir,dir);float b=2.0*dot(dir,orig);float c=dot(orig,orig)-radius*radius;float d=sqrt(b*b-4.0*a*c);return (-b+d)/(2.0*a);}vec3 extinction(vec2 density) {return exp(-vec3(BETA_R*u_color_tint_r.a*density.x+BETA_M*u_color_tint_m.a*density.y));}vec2 local_density(vec3 point) {float height=max(length(point)-PLANET_RADIUS,0.0);float exp_r=exp(-height/DENSITY_HEIGHT_SCALE_R);float exp_m=exp(-height/DENSITY_HEIGHT_SCALE_M);return vec2(exp_r,exp_m);}float phase_ray(float cos_angle) {return (3.0/(16.0*PI))*(1.0+cos_angle*cos_angle);}float phase_mie(float cos_angle) {return (3.0/(8.0*PI))*((1.0-MIE_G*MIE_G)*(1.0+cos_angle*cos_angle))/((2.0+MIE_G*MIE_G)*pow(1.0+MIE_G*MIE_G-2.0*MIE_G*cos_angle,1.5));}vec2 density_to_atmosphere(vec3 point,vec3 light_dir) {float ray_len=ray_sphere_exit(point,light_dir,ATMOSPHERE_RADIUS);float step_len=ray_len/float(DENSITY_STEPS);vec2 density_point_to_atmosphere=vec2(0.0);for (int i=0; i < DENSITY_STEPS;++i) {vec3 point_on_ray=point+light_dir*((float(i)+0.5)*step_len);density_point_to_atmosphere+=local_density(point_on_ray)*step_len;;}return density_point_to_atmosphere;}vec3 atmosphere(vec3 ray_dir,vec3 sun_direction,float sun_intensity) {vec2 density_orig_to_point=vec2(0.0);vec3 scatter_r=vec3(0.0);vec3 scatter_m=vec3(0.0);vec3 origin=vec3(0.0,PLANET_RADIUS,0.0);float ray_len=ray_sphere_exit(origin,ray_dir,ATMOSPHERE_RADIUS);float step_len=ray_len/float(SAMPLE_STEPS);for (int i=0; i < SAMPLE_STEPS;++i) {vec3 point_on_ray=origin+ray_dir*((float(i)+0.5)*step_len);vec2 density=local_density(point_on_ray)*step_len;density_orig_to_point+=density;vec2 density_point_to_atmosphere=density_to_atmosphere(point_on_ray,sun_direction);vec2 density_orig_to_atmosphere=density_orig_to_point+density_point_to_atmosphere;vec3 extinction=extinction(density_orig_to_atmosphere);scatter_r+=density.x*extinction;scatter_m+=density.y*extinction;}float cos_angle=dot(ray_dir,sun_direction);float phase_r=phase_ray(cos_angle);float phase_m=phase_mie(cos_angle);vec3 beta_r=BETA_R*u_color_tint_r.rgb*u_color_tint_r.a;vec3 beta_m=BETA_M*u_color_tint_m.rgb*u_color_tint_m.a;return (scatter_r*phase_r*beta_r+scatter_m*phase_m*beta_m)*sun_intensity;}const float A=0.15;const float B=0.50;const float C=0.10;const float D=0.20;const float E=0.02;const float F=0.30;vec3 uncharted2_tonemap(vec3 x) {return ((x*(A*x+C*B)+D*E)/(x*(A*x+B)+D*F))-E/F;}void main() {vec3 ray_direction=v_position;ray_direction.y=pow(ray_direction.y,5.0);const float y_bias=0.015;ray_direction.y+=y_bias;vec3 color=atmosphere(normalize(ray_direction),u_sun_direction,u_sun_intensity);float white_scale=1.0748724675633854;color=uncharted2_tonemap((log2(2.0/pow(u_luminance,4.0)))*color)*white_scale;gl_FragColor=vec4(color,1.0);}", "attribute highp vec3 a_pos_3f;uniform mat3 u_matrix_3f;varying highp vec3 v_position;float map(float value,float start,float end,float new_start,float new_end) {return ((value-start)*(new_end-new_start))/(end-start)+new_start;}void main() {vec4 pos=vec4(u_matrix_3f*a_pos_3f,1.0);v_position=pos.xyz;v_position.y*=-1.0;v_position.y=map(v_position.y,-1.0,1.0,0.0,1.0);gl_Position=vec4(a_pos_3f.xy,0.0,1.0);}"), globeRaster: ui("uniform sampler2D u_image0;varying vec2 v_pos0;\n#ifndef FOG\nuniform highp vec3 u_frustum_tl;uniform highp vec3 u_frustum_tr;uniform highp vec3 u_frustum_br;uniform highp vec3 u_frustum_bl;uniform highp vec3 u_globe_pos;uniform highp float u_globe_radius;uniform vec2 u_viewport;\n#endif\nvoid main() {vec4 color;\n#ifdef CUSTOM_ANTIALIASING\nvec2 uv=gl_FragCoord.xy/u_viewport;highp vec3 ray_dir=mix(\nmix(u_frustum_tl,u_frustum_tr,uv.x),mix(u_frustum_bl,u_frustum_br,uv.x),1.0-uv.y);vec3 dir=normalize(ray_dir);vec3 closest_point=dot(u_globe_pos,dir)*dir;float norm_dist_from_center=1.0-length(closest_point-u_globe_pos)/u_globe_radius;const float antialias_pixel=2.0;float antialias_factor=antialias_pixel*fwidth(norm_dist_from_center);float antialias=smoothstep(0.0,antialias_factor,norm_dist_from_center);vec4 raster=texture2D(u_image0,v_pos0);color=vec4(raster.rgb*antialias,raster.a*antialias);\n#else\ncolor=texture2D(u_image0,v_pos0);\n#endif\n#ifdef FOG\ncolor=fog_dither(fog_apply_premultiplied(color,v_fog_pos));\n#endif\ngl_FragColor=color;\n#ifdef TERRAIN_WIREFRAME\ngl_FragColor=vec4(1.0,0.0,0.0,0.8);\n#endif\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "uniform mat4 u_proj_matrix;uniform mat4 u_normalize_matrix;uniform mat4 u_globe_matrix;uniform mat4 u_merc_matrix;uniform float u_zoom_transition;uniform vec2 u_merc_center;uniform mat3 u_grid_matrix;uniform float u_skirt_height;\n#ifdef GLOBE_POLES\nattribute vec3 a_globe_pos;attribute vec2 a_uv;\n#else\nattribute vec2 a_pos;\n#endif\nvarying vec2 v_pos0;const float wireframeOffset=1e3;float mercatorXfromLng(float lng) {return (180.0+lng)/360.0;}float mercatorYfromLat(float lat) {return (180.0-(RAD_TO_DEG*log(tan(QUARTER_PI+lat/2.0*DEG_TO_RAD))))/360.0;}vec3 latLngToECEF(vec2 latLng) {latLng=DEG_TO_RAD*latLng;float cosLat=cos(latLng[0]);float sinLat=sin(latLng[0]);float cosLng=cos(latLng[1]);float sinLng=sin(latLng[1]);float sx=cosLat*sinLng*GLOBE_RADIUS;float sy=-sinLat*GLOBE_RADIUS;float sz=cosLat*cosLng*GLOBE_RADIUS;return vec3(sx,sy,sz);}void main() {\n#ifdef GLOBE_POLES\nvec3 globe_pos=a_globe_pos;vec2 uv=a_uv;\n#else\nfloat tiles=u_grid_matrix[0][2];float idx=u_grid_matrix[1][2];float idy=u_grid_matrix[2][2];vec3 decomposed_pos_and_skirt=decomposeToPosAndSkirt(a_pos);vec3 latLng=u_grid_matrix*vec3(decomposed_pos_and_skirt.xy,1.0);float mercatorY=mercatorYfromLat(latLng[0]);float uvY=mercatorY*tiles-idy;float mercatorX=mercatorXfromLng(latLng[1]);float uvX=mercatorX*tiles-idx;vec3 globe_pos=latLngToECEF(latLng.xy);vec2 merc_pos=vec2(mercatorX,mercatorY);vec2 uv=vec2(uvX,uvY);\n#endif\nv_pos0=uv;vec2 tile_pos=uv*EXTENT;vec3 globe_derived_up_vector=normalize(globe_pos)*u_tile_up_scale;\n#ifdef GLOBE_POLES\nvec3 up_vector=globe_derived_up_vector;\n#else\nvec3 up_vector=elevationVector(tile_pos);\n#endif\nfloat height=elevation(tile_pos);\n#ifdef TERRAIN_WIREFRAME\nheight+=wireframeOffset;\n#endif\nglobe_pos+=up_vector*height;\n#ifndef GLOBE_POLES\nglobe_pos-=globe_derived_up_vector*u_skirt_height*decomposed_pos_and_skirt.z;\n#endif\n#ifdef GLOBE_POLES\nvec4 interpolated_pos=u_globe_matrix*vec4(globe_pos,1.0);\n#else\nvec4 globe_world_pos=u_globe_matrix*vec4(globe_pos,1.0);vec4 merc_world_pos=vec4(0.0);if (u_zoom_transition > 0.0) {merc_world_pos=vec4(merc_pos,height-u_skirt_height*decomposed_pos_and_skirt.z,1.0);merc_world_pos.xy-=u_merc_center;merc_world_pos.x=wrap(merc_world_pos.x,-0.5,0.5);merc_world_pos=u_merc_matrix*merc_world_pos;}vec4 interpolated_pos=vec4(mix(globe_world_pos.xyz,merc_world_pos.xyz,u_zoom_transition),1.0);\n#endif\ngl_Position=u_proj_matrix*interpolated_pos;\n#ifdef FOG\nv_fog_pos=fog_position((u_normalize_matrix*vec4(globe_pos,1.0)).xyz);\n#endif\n}"), globeAtmosphere: ui("uniform float u_transition;uniform highp float u_fadeout_range;uniform highp float u_temporal_offset;uniform vec3 u_start_color;uniform vec4 u_color;uniform vec4 u_space_color;uniform vec4 u_high_color;uniform float u_star_intensity;uniform float u_star_size;uniform float u_star_density;uniform float u_horizon_angle;uniform mat4 u_rotation_matrix;varying highp vec3 v_ray_dir;varying highp vec3 v_horizon_dir;highp float random(highp vec3 p) {p=fract(p*vec3(23.2342,97.1231,91.2342));p+=dot(p.zxy,p.yxz+123.1234);return fract(p.x*p.y);}float stars(vec3 p,float scale,vec2 offset) {vec2 uv_scale=(u_viewport/u_star_size)*scale;vec3 position=vec3(p.xy*uv_scale+offset*u_viewport,p.z);vec3 q=fract(position)-0.5;vec3 id=floor(position);float random_visibility=step(random(id),u_star_density);float circle=smoothstep(0.5+u_star_intensity,0.5,length(q));return circle*random_visibility;}void main() {highp vec3 dir=normalize(v_ray_dir);float globe_pos_dot_dir;\n#ifdef PROJECTION_GLOBE_VIEW\nglobe_pos_dot_dir=dot(u_globe_pos,dir);highp vec3 closest_point_forward=abs(globe_pos_dot_dir)*dir;float norm_dist_from_center=length(closest_point_forward-u_globe_pos)/u_globe_radius;if (norm_dist_from_center < 0.98) {discard;return;}\n#endif\nhighp vec3 horizon_dir=normalize(v_horizon_dir);float horizon_angle_mercator=dir.y < horizon_dir.y ?\n0.0 : max(acos(dot(dir,horizon_dir)),0.0);float horizon_angle;\n#ifdef PROJECTION_GLOBE_VIEW\nhighp vec3 closest_point=globe_pos_dot_dir*dir;float closest_point_to_center=length(closest_point-u_globe_pos);float theta=asin(clamp(closest_point_to_center/length(u_globe_pos),-1.0,1.0));horizon_angle=globe_pos_dot_dir < 0.0 ?\nPI-theta-u_horizon_angle : theta-u_horizon_angle;float angle_t=pow(u_transition,10.0);horizon_angle=mix(horizon_angle,horizon_angle_mercator,angle_t);\n#else\nhorizon_angle=horizon_angle_mercator;\n#endif\nhorizon_angle/=PI;float t=exp(-horizon_angle/u_fadeout_range);float alpha_0=u_color.a;float alpha_1=u_high_color.a;float alpha_2=u_space_color.a;vec3 color_stop_0=u_color.rgb;vec3 color_stop_1=u_high_color.rgb;vec3 color_stop_2=u_space_color.rgb;vec3 c0=mix(color_stop_2,color_stop_1,alpha_1);vec3 c1=mix(c0,color_stop_0,alpha_0);vec3 c2=mix(c0,c1,t);vec3 c =mix(color_stop_2,c2,t);float a0=mix(alpha_2,1.0,alpha_1);float a1=mix(a0,1.0,alpha_0);float a2=mix(a0,a1,t);float a =mix(alpha_2,a2,t);vec2 uv=gl_FragCoord.xy/u_viewport-0.5;float aspect_ratio=u_viewport.x/u_viewport.y;vec4 uv_dir=vec4(normalize(vec3(uv.x*aspect_ratio,uv.y,1.0)),1.0);uv_dir=u_rotation_matrix*uv_dir;vec3 n=abs(uv_dir.xyz);vec2 uv_remap=(n.x > n.y && n.x > n.z) ? uv_dir.yz/uv_dir.x:\n(n.y > n.x && n.y > n.z) ? uv_dir.zx/uv_dir.y:\nuv_dir.xy/uv_dir.z;uv_remap.x/=aspect_ratio;vec3 D=vec3(uv_remap,1.0);highp float star_field=0.0;if (u_star_intensity > 0.0) {star_field+=stars(D,1.2,vec2(0.0,0.0));star_field+=stars(D,1.0,vec2(1.0,0.0));star_field+=stars(D,0.8,vec2(0.0,1.0));star_field+=stars(D,0.6,vec2(1.0,1.0));star_field*=(1.0-pow(t,0.25+(1.0-u_high_color.a)*0.75));c+=star_field*alpha_2;}c=dither(c,gl_FragCoord.xy+u_temporal_offset);gl_FragColor=vec4(c,a);}", "attribute vec3 a_pos;attribute vec2 a_uv;uniform vec3 u_frustum_tl;uniform vec3 u_frustum_tr;uniform vec3 u_frustum_br;uniform vec3 u_frustum_bl;uniform float u_horizon;varying highp vec3 v_ray_dir;varying highp vec3 v_horizon_dir;void main() {v_ray_dir=mix(\nmix(u_frustum_tl,u_frustum_tr,a_uv.x),mix(u_frustum_bl,u_frustum_br,a_uv.x),a_uv.y);v_horizon_dir=mix(\nmix(u_frustum_tl,u_frustum_bl,u_horizon),mix(u_frustum_tr,u_frustum_br,u_horizon),a_uv.x);gl_Position=vec4(a_pos,1.0);}") };
        function hi(e3, t3) {
          const i3 = e3.replace(/\s*\/\/[^\n]*\n/g, "\n").split("\n");
          for (let e4 of i3)
            if (e4 = e4.trim(), "#" === e4[0] && e4.includes("if") && !e4.includes("endif")) {
              e4 = e4.replace("#", "").replace(/ifdef|ifndef|elif|if/g, "").replace(/!|defined|\(|\)|\|\||&&/g, "").replace(/\s+/g, " ").trim();
              const i4 = e4.split(" ");
              for (const e5 of i4)
                t3.includes(e5) || t3.push(e5);
            }
        }
        function ui(e3, t3) {
          const i3 = /#pragma mapbox: ([\w]+) ([\w]+) ([\w]+) ([\w]+)/g, o3 = t3.match(/attribute (highp |mediump |lowp )?([\w]+) ([\w]+)/g), r3 = {}, n3 = [...ni];
          return hi(e3, n3), hi(t3, n3), { fragmentSource: e3 = e3.replace(i3, (e4, t4, i4, o4, n4) => (r3[n4] = true, "define" === t4 ? `
#ifndef HAS_UNIFORM_u_${n4}
varying ${i4} ${o4} ${n4};
#else
uniform ${i4} ${o4} u_${n4};
#endif
` : `
#ifdef HAS_UNIFORM_u_${n4}
    ${i4} ${o4} ${n4} = u_${n4};
#endif
`)), vertexSource: t3 = t3.replace(i3, (e4, t4, i4, o4, n4) => {
            const s3 = "float" === o4 ? "vec2" : "vec4", a3 = n4.match(/color/) ? "color" : s3;
            return r3[n4] ? "define" === t4 ? `
#ifndef HAS_UNIFORM_u_${n4}
uniform lowp float u_${n4}_t;
attribute ${i4} ${s3} a_${n4};
varying ${i4} ${o4} ${n4};
#else
uniform ${i4} ${o4} u_${n4};
#endif
` : "vec4" === a3 ? `
#ifndef HAS_UNIFORM_u_${n4}
    ${n4} = a_${n4};
#else
    ${i4} ${o4} ${n4} = u_${n4};
#endif
` : `
#ifndef HAS_UNIFORM_u_${n4}
    ${n4} = unpack_mix_${a3}(a_${n4}, u_${n4}_t);
#else
    ${i4} ${o4} ${n4} = u_${n4};
#endif
` : "define" === t4 ? `
#ifndef HAS_UNIFORM_u_${n4}
uniform lowp float u_${n4}_t;
attribute ${i4} ${s3} a_${n4};
#else
uniform ${i4} ${o4} u_${n4};
#endif
` : "vec4" === a3 ? `
#ifndef HAS_UNIFORM_u_${n4}
    ${i4} ${o4} ${n4} = a_${n4};
#else
    ${i4} ${o4} ${n4} = u_${n4};
#endif
` : `
#ifndef HAS_UNIFORM_u_${n4}
    ${i4} ${o4} ${n4} = unpack_mix_${a3}(a_${n4}, u_${n4}_t);
#else
    ${i4} ${o4} ${n4} = u_${n4};
#endif
`;
          }), staticAttributes: o3, usedDefines: n3 };
        }
        class _i {
          constructor() {
            this.boundProgram = null, this.boundLayoutVertexBuffer = null, this.boundPaintVertexBuffers = [], this.boundIndexBuffer = null, this.boundVertexOffset = null, this.boundDynamicVertexBuffers = [], this.vao = null;
          }
          bind(e3, t3, i3, o3, r3, n3, s3) {
            this.context = e3;
            let a3 = this.boundPaintVertexBuffers.length !== o3.length;
            for (let e4 = 0; !a3 && e4 < o3.length; e4++)
              this.boundPaintVertexBuffers[e4] !== o3[e4] && (a3 = true);
            let l2 = this.boundDynamicVertexBuffers.length !== s3.length;
            for (let e4 = 0; !l2 && e4 < s3.length; e4++)
              this.boundDynamicVertexBuffers[e4] !== s3[e4] && (l2 = true);
            if (!e3.extVertexArrayObject || !this.vao || this.boundProgram !== t3 || this.boundLayoutVertexBuffer !== i3 || a3 || l2 || this.boundIndexBuffer !== r3 || this.boundVertexOffset !== n3)
              this.freshBind(t3, i3, o3, r3, n3, s3);
            else {
              e3.bindVertexArrayOES.set(this.vao);
              for (const e4 of s3)
                e4 && e4.bind();
              r3 && r3.dynamicDraw && r3.bind();
            }
          }
          freshBind(e3, t3, i3, o3, r3, n3) {
            let s3;
            const a3 = e3.numAttributes, l2 = this.context, c3 = l2.gl;
            if (l2.extVertexArrayObject)
              this.vao && this.destroy(), this.vao = l2.extVertexArrayObject.createVertexArrayOES(), l2.bindVertexArrayOES.set(this.vao), s3 = 0, this.boundProgram = e3, this.boundLayoutVertexBuffer = t3, this.boundPaintVertexBuffers = i3, this.boundIndexBuffer = o3, this.boundVertexOffset = r3, this.boundDynamicVertexBuffers = n3;
            else {
              s3 = l2.currentNumAttributes || 0;
              for (let e4 = a3; e4 < s3; e4++)
                c3.disableVertexAttribArray(e4);
            }
            t3.enableAttributes(c3, e3), t3.bind(), t3.setVertexAttribPointers(c3, e3, r3);
            for (const t4 of i3)
              t4.enableAttributes(c3, e3), t4.bind(), t4.setVertexAttribPointers(c3, e3, r3);
            for (const t4 of n3)
              t4 && (t4.enableAttributes(c3, e3), t4.bind(), t4.setVertexAttribPointers(c3, e3, r3));
            o3 && o3.bind(), l2.currentNumAttributes = a3;
          }
          destroy() {
            this.vao && (this.context.extVertexArrayObject.deleteVertexArrayOES(this.vao), this.vao = null);
          }
        }
        function di(t3, i3) {
          const o3 = Math.pow(2, i3.canonical.z), r3 = i3.canonical.y;
          return [new e2.MercatorCoordinate(0, r3 / o3).toLngLat().lat, new e2.MercatorCoordinate(0, (r3 + 1) / o3).toLngLat().lat];
        }
        function pi(t3, i3, o3, r3, n3, s3, a3) {
          const l2 = t3.context, c3 = l2.gl, h3 = o3.fbo;
          if (!h3)
            return;
          t3.prepareDrawTile();
          const u3 = t3.useProgram("hillshade");
          l2.activeTexture.set(c3.TEXTURE0), c3.bindTexture(c3.TEXTURE_2D, h3.colorAttachment.get());
          const _2 = ((e3, t4, i4, o4) => {
            const r4 = i4.paint.get("hillshade-shadow-color"), n4 = i4.paint.get("hillshade-highlight-color"), s4 = i4.paint.get("hillshade-accent-color");
            let a4 = i4.paint.get("hillshade-illumination-direction") * (Math.PI / 180);
            "viewport" === i4.paint.get("hillshade-illumination-anchor") && (a4 -= e3.transform.angle);
            const l3 = !e3.options.moving;
            return { u_matrix: o4 || e3.transform.calculateProjMatrix(t4.tileID.toUnwrapped(), l3), u_image: 0, u_latrange: di(0, t4.tileID), u_light: [i4.paint.get("hillshade-exaggeration"), a4], u_shadow: r4, u_highlight: n4, u_accent: s4 };
          })(t3, o3, r3, t3.terrain ? i3.projMatrix : null);
          t3.prepareDrawProgram(l2, u3, i3.toUnwrapped());
          const { tileBoundsBuffer: d3, tileBoundsIndexBuffer: p3, tileBoundsSegments: m3 } = t3.getTileBoundsBuffers(o3);
          u3.draw(l2, c3.TRIANGLES, n3, s3, a3, e2.CullFaceMode.disabled, _2, r3.id, d3, p3, m3);
        }
        function mi(t3, i3, o3) {
          if (!i3.needsDEMTextureUpload)
            return;
          const r3 = t3.context, n3 = r3.gl;
          r3.pixelStoreUnpackPremultiplyAlpha.set(false), i3.demTexture = i3.demTexture || t3.getTileTexture(o3.stride);
          const s3 = o3.getPixels();
          i3.demTexture ? i3.demTexture.update(s3, { premultiply: false }) : i3.demTexture = new e2.Texture(r3, s3, n3.RGBA, { premultiply: false }), i3.needsDEMTextureUpload = false;
        }
        function fi(t3, i3, o3, r3, n3, s3) {
          const a3 = t3.context, l2 = a3.gl;
          if (!i3.dem)
            return;
          const c3 = i3.dem;
          if (a3.activeTexture.set(l2.TEXTURE1), mi(t3, i3, c3), !i3.demTexture)
            return;
          i3.demTexture.bind(l2.NEAREST, l2.CLAMP_TO_EDGE);
          const h3 = c3.dim;
          a3.activeTexture.set(l2.TEXTURE0);
          let u3 = i3.fbo;
          if (!u3) {
            const t4 = new e2.Texture(a3, { width: h3, height: h3, data: null }, l2.RGBA);
            t4.bind(l2.LINEAR, l2.CLAMP_TO_EDGE), u3 = i3.fbo = a3.createFramebuffer(h3, h3, true), u3.colorAttachment.set(t4.texture);
          }
          a3.bindFramebuffer.set(u3.framebuffer), a3.viewport.set([0, 0, h3, h3]);
          const { tileBoundsBuffer: _2, tileBoundsIndexBuffer: d3, tileBoundsSegments: p3 } = t3.getMercatorTileBoundsBuffers();
          t3.useProgram("hillshadePrepare").draw(a3, l2.TRIANGLES, r3, n3, s3, e2.CullFaceMode.disabled, ((t4, i4) => {
            const o4 = i4.stride, r4 = e2.create();
            return e2.ortho(r4, 0, e2.EXTENT, -e2.EXTENT, 0, 0, 1), e2.translate(r4, r4, [0, -e2.EXTENT, 0]), { u_matrix: r4, u_image: 1, u_dimension: [o4, o4], u_zoom: t4.overscaledZ, u_unpack: i4.unpackVector };
          })(i3.tileID, c3), o3.id, _2, d3, p3), i3.needsHillshadePrepare = false;
        }
        const gi = (t3) => ({ u_matrix: new e2.UniformMatrix4f(t3), u_image0: new e2.Uniform1i(t3), u_skirt_height: new e2.Uniform1f(t3) }), vi = (e3, t3) => ({ u_matrix: e3, u_image0: 0, u_skirt_height: t3 }), xi = (e3, t3, i3, o3, r3, n3, s3, a3, l2, c3, h3, u3, _2, d3, p3) => ({ u_proj_matrix: Float32Array.from(e3), u_globe_matrix: t3, u_normalize_matrix: Float32Array.from(o3), u_merc_matrix: i3, u_zoom_transition: r3, u_merc_center: n3, u_image0: 0, u_frustum_tl: s3, u_frustum_tr: a3, u_frustum_br: l2, u_frustum_bl: c3, u_globe_pos: h3, u_globe_radius: u3, u_viewport: _2, u_grid_matrix: p3 ? Float32Array.from(p3) : new Float32Array(9), u_skirt_height: d3 });
        function yi(e3, t3) {
          return null != e3 && null != t3 && !(!e3.hasData() || !t3.hasData()) && null != e3.demTexture && null != t3.demTexture && e3.tileID.key !== t3.tileID.key;
        }
        const bi = new class {
          constructor() {
            this.operations = {};
          }
          newMorphing(e3, t3, i3, o3, r3) {
            if (e3 in this.operations) {
              const t4 = this.operations[e3];
              t4.to.tileID.key !== i3.tileID.key && (t4.queued = i3);
            } else
              this.operations[e3] = { startTime: o3, phase: 0, duration: r3, from: t3, to: i3, queued: null };
          }
          getMorphValuesForProxy(e3) {
            if (!(e3 in this.operations))
              return null;
            const t3 = this.operations[e3];
            return { from: t3.from, to: t3.to, phase: t3.phase };
          }
          update(e3) {
            for (const t3 in this.operations) {
              const i3 = this.operations[t3];
              for (i3.phase = (e3 - i3.startTime) / i3.duration; i3.phase >= 1 || !this._validOp(i3); )
                if (!this._nextOp(i3, e3)) {
                  delete this.operations[t3];
                  break;
                }
            }
          }
          _nextOp(e3, t3) {
            return !!e3.queued && (e3.from = e3.to, e3.to = e3.queued, e3.queued = null, e3.phase = 0, e3.startTime = t3, true);
          }
          _validOp(e3) {
            return e3.from.hasData() && e3.to.hasData();
          }
        }(), wi = { 0: null, 1: "TERRAIN_VERTEX_MORPHING", 2: "TERRAIN_WIREFRAME" };
        function Ti(e3) {
          return 6 * Math.pow(1.5, 22 - e3);
        }
        function Ei(e3, t3) {
          const i3 = 1 << e3.z;
          return !t3 && (0 === e3.x || e3.x === i3 - 1) || 0 === e3.y || e3.y === i3 - 1;
        }
        const Ci = (e3) => ({ u_matrix: e3 });
        function Mi(t3, i3, o3, r3, n3) {
          if (n3 > 0) {
            const s3 = e2.exported.now(), a3 = (s3 - t3.timeAdded) / n3, l2 = i3 ? (s3 - i3.timeAdded) / n3 : -1, c3 = o3.getSource(), h3 = r3.coveringZoomLevel({ tileSize: c3.tileSize, roundZoom: c3.roundZoom }), u3 = !i3 || Math.abs(i3.tileID.overscaledZ - h3) > Math.abs(t3.tileID.overscaledZ - h3), _2 = u3 && t3.refreshedUponExpiration ? 1 : e2.clamp(u3 ? a3 : 1 - l2, 0, 1);
            return t3.refreshedUponExpiration && a3 >= 1 && (t3.refreshedUponExpiration = false), i3 ? { opacity: 1, mix: 1 - _2 } : { opacity: _2, mix: 0 };
          }
          return { opacity: 1, mix: 0 };
        }
        class Ii extends e2.SourceCache {
          constructor(e3) {
            const t3 = { type: "raster-dem", maxzoom: e3.transform.maxZoom }, i3 = new S(Ue(), null), o3 = De("mock-dem", t3, i3, e3.style);
            super("mock-dem", o3, false), o3.setEventedParent(this), this._sourceLoaded = true;
          }
          _loadTile(e3, t3) {
            e3.state = "loaded", t3(null);
          }
        }
        class Pi extends e2.SourceCache {
          constructor(e3) {
            const t3 = De("proxy", { type: "geojson", maxzoom: e3.transform.maxZoom }, new S(Ue(), null), e3.style);
            super("proxy", t3, false), t3.setEventedParent(this), this.map = this.getSource().map = e3, this.used = this._sourceLoaded = true, this.renderCache = [], this.renderCachePool = [], this.proxyCachedFBO = {};
          }
          update(t3, i3, o3) {
            if (t3.freezeTileCoverage)
              return;
            this.transform = t3;
            const r3 = t3.coveringTiles({ tileSize: this._source.tileSize, minzoom: this._source.minzoom, maxzoom: this._source.maxzoom, roundZoom: this._source.roundZoom, reparseOverscaled: this._source.reparseOverscaled }).reduce((i4, o4) => {
              if (i4[o4.key] = "", !this._tiles[o4.key]) {
                const i5 = new e2.Tile(o4, this._source.tileSize * o4.overscaleFactor(), t3.tileZoom);
                i5.state = "loaded", this._tiles[o4.key] = i5;
              }
              return i4;
            }, {});
            for (const e3 in this._tiles)
              e3 in r3 || (this.freeFBO(e3), this._tiles[e3].unloadVectorData(), delete this._tiles[e3]);
          }
          freeFBO(e3) {
            const t3 = this.proxyCachedFBO[e3];
            if (void 0 !== t3) {
              const i3 = Object.values(t3);
              this.renderCachePool.push(...i3), delete this.proxyCachedFBO[e3];
            }
          }
          deallocRenderCache() {
            this.renderCache.forEach((e3) => e3.fb.destroy()), this.renderCache = [], this.renderCachePool = [], this.proxyCachedFBO = {};
          }
        }
        class Si extends e2.OverscaledTileID {
          constructor(e3, t3, i3) {
            super(e3.overscaledZ, e3.wrap, e3.canonical.z, e3.canonical.x, e3.canonical.y), this.proxyTileKey = t3, this.projMatrix = i3;
          }
        }
        class Di extends e2.Elevation {
          constructor(t3, i3) {
            super(), this.painter = t3, this.terrainTileForTile = {}, this.prevTerrainTileForTile = {};
            const [o3, r3, n3] = function(t4) {
              const i4 = new e2.StructArrayLayout2i4(), o4 = new e2.StructArrayLayout3ui6(), r4 = 131;
              i4.reserve(17161), o4.reserve(33800);
              const n4 = e2.EXTENT / 128, s4 = e2.EXTENT + n4 / 2, a4 = s4 + n4;
              for (let t5 = -n4; t5 < a4; t5 += n4)
                for (let o5 = -n4; o5 < a4; o5 += n4) {
                  const r5 = o5 < 0 || o5 > s4 || t5 < 0 || t5 > s4 ? 24575 : 0, n5 = e2.clamp(Math.round(o5), 0, e2.EXTENT), a5 = e2.clamp(Math.round(t5), 0, e2.EXTENT);
                  i4.emplaceBack(n5 + r5, a5);
                }
              const l2 = (e3, t5) => {
                const i5 = t5 * r4 + e3;
                o4.emplaceBack(i5 + 1, i5, i5 + r4), o4.emplaceBack(i5 + r4, i5 + r4 + 1, i5 + 1);
              };
              for (let e3 = 1; e3 < 129; e3++)
                for (let t5 = 1; t5 < 129; t5++)
                  l2(t5, e3);
              return [0, 129].forEach((e3) => {
                for (let t5 = 0; t5 < 130; t5++)
                  l2(t5, e3), l2(e3, t5);
              }), [i4, o4, 32768];
            }(), s3 = t3.context;
            this.gridBuffer = s3.createVertexBuffer(o3, e2.posAttributes.members), this.gridIndexBuffer = s3.createIndexBuffer(r3), this.gridSegments = e2.SegmentVector.simpleSegment(0, 0, o3.length, r3.length), this.gridNoSkirtSegments = e2.SegmentVector.simpleSegment(0, 0, o3.length, n3), this.proxyCoords = [], this.proxiedCoords = {}, this._visibleDemTiles = [], this._drapedRenderBatches = [], this._sourceTilesOverlap = {}, this.proxySourceCache = new Pi(i3.map), this.orthoMatrix = e2.create(), e2.ortho(this.orthoMatrix, "globe" === this.painter.transform.projection.name ? 0.015 : 0, e2.EXTENT, 0, e2.EXTENT, 0, 1);
            const a3 = s3.gl;
            this._overlapStencilMode = new e2.StencilMode({ func: a3.GEQUAL, mask: 255 }, 0, 255, a3.KEEP, a3.KEEP, a3.REPLACE), this._previousZoom = t3.transform.zoom, this.pool = [], this._findCoveringTileCache = {}, this._tilesDirty = {}, this.style = i3, this._useVertexMorphing = true, this._exaggeration = 1, this._mockSourceCache = new Ii(i3.map);
          }
          set style(e3) {
            e3.on("data", this._onStyleDataEvent.bind(this)), e3.on("neworder", this._checkRenderCacheEfficiency.bind(this)), this._style = e3, this._checkRenderCacheEfficiency(), this._style.map.on("moveend", () => {
              this._clearLineLayersFromRenderCache();
            });
          }
          update(t3, i3, o3) {
            if (t3 && t3.terrain) {
              this._style !== t3 && (this.style = t3), this.enabled = true;
              const r3 = t3.terrain.properties;
              this.sourceCache = 0 === t3.terrain.drapeRenderMode ? this._mockSourceCache : t3._getSourceCache(r3.get("source")), this._exaggeration = r3.get("exaggeration");
              const n3 = () => {
                this.sourceCache.used && e2.warnOnce(`Raster DEM source '${this.sourceCache.id}' is used both for terrain and as layer source.
This leads to lower resolution of hillshade. For full hillshade resolution but higher memory consumption, define another raster DEM source.`);
                const t4 = this.getScaledDemTileSize();
                this.sourceCache.update(i3, t4, true), this.resetTileLookupCache(this.sourceCache.id);
              };
              this.sourceCache.usedForTerrain || (this.resetTileLookupCache(this.sourceCache.id), this.sourceCache.usedForTerrain = true, n3(), this._initializing = true), n3(), i3.updateElevation(true, o3), this.resetTileLookupCache(this.proxySourceCache.id), this.proxySourceCache.update(i3), this._emptyDEMTextureDirty = true;
            } else
              this._disable();
          }
          resetTileLookupCache(e3) {
            this._findCoveringTileCache[e3] = {};
          }
          getScaledDemTileSize() {
            return this.sourceCache.getSource().tileSize / 128 * this.proxySourceCache.getSource().tileSize;
          }
          _checkRenderCacheEfficiency() {
            const t3 = this.renderCacheEfficiency(this._style);
            this._style.map._optimizeForTerrain || 100 !== t3.efficiency && e2.warnOnce(`Terrain render cache efficiency is not optimal (${t3.efficiency}%) and performance
                may be affected negatively, consider placing all background, fill and line layers before layer
                with id '${t3.firstUndrapedLayer}' or create a map using optimizeForTerrain: true option.`);
          }
          _onStyleDataEvent(e3) {
            e3.coord && "source" === e3.dataType ? this._clearRenderCacheForTile(e3.sourceCacheId, e3.coord) : "style" === e3.dataType && (this._invalidateRenderCache = true);
          }
          _disable() {
            if (this.enabled && (this.enabled = false, this._sharedDepthStencil = void 0, this.proxySourceCache.deallocRenderCache(), this._style))
              for (const e3 in this._style._sourceCaches)
                this._style._sourceCaches[e3].usedForTerrain = false;
          }
          destroy() {
            this._disable(), this._emptyDEMTexture && this._emptyDEMTexture.destroy(), this._emptyDepthBufferTexture && this._emptyDepthBufferTexture.destroy(), this.pool.forEach((e3) => e3.fb.destroy()), this.pool = [], this._depthFBO && (this._depthFBO.destroy(), this._depthFBO = void 0, this._depthTexture = void 0);
          }
          _source() {
            return this.enabled ? this.sourceCache : null;
          }
          isUsingMockSource() {
            return this.sourceCache === this._mockSourceCache;
          }
          exaggeration() {
            return this._exaggeration;
          }
          get visibleDemTiles() {
            return this._visibleDemTiles;
          }
          get drapeBufferSize() {
            const e3 = 2 * this.proxySourceCache.getSource().tileSize;
            return [e3, e3];
          }
          set useVertexMorphing(e3) {
            this._useVertexMorphing = e3;
          }
          updateTileBinding(t3) {
            if (!this.enabled)
              return;
            this.prevTerrainTileForTile = this.terrainTileForTile;
            const i3 = this.proxySourceCache, o3 = this.painter.transform;
            this._initializing && (this._initializing = 0 === o3._centerAltitude && -1 === this.getAtPointOrZero(e2.MercatorCoordinate.fromLngLat(o3.center), -1), this._emptyDEMTextureDirty = !this._initializing);
            const r3 = this.proxyCoords = i3.getIds().map((e3) => {
              const t4 = i3.getTileByID(e3).tileID;
              return t4.projMatrix = o3.calculateProjMatrix(t4.toUnwrapped()), t4;
            });
            !function(t4, i4) {
              const o4 = i4.transform.pointCoordinate(i4.transform.getCameraPoint()), r4 = new e2.Point(o4.x, o4.y);
              t4.sort((t5, i5) => {
                if (i5.overscaledZ - t5.overscaledZ)
                  return i5.overscaledZ - t5.overscaledZ;
                const o5 = new e2.Point(t5.canonical.x + (1 << t5.canonical.z) * t5.wrap, t5.canonical.y), n4 = new e2.Point(i5.canonical.x + (1 << i5.canonical.z) * i5.wrap, i5.canonical.y), s4 = r4.mult(1 << t5.canonical.z);
                return s4.x -= 0.5, s4.y -= 0.5, s4.distSqr(o5) - s4.distSqr(n4);
              });
            }(r3, this.painter), this._previousZoom = o3.zoom;
            const n3 = this.proxyToSource || {};
            this.proxyToSource = {}, r3.forEach((e3) => {
              this.proxyToSource[e3.key] = {};
            }), this.terrainTileForTile = {};
            const s3 = this._style._sourceCaches;
            for (const e3 in s3) {
              const i4 = s3[e3];
              if (!i4.used)
                continue;
              if (i4 !== this.sourceCache && this.resetTileLookupCache(i4.id), this._setupProxiedCoordsForOrtho(i4, t3[e3], n3), i4.usedForTerrain)
                continue;
              const o4 = t3[e3];
              i4.getSource().reparseOverscaled && this._assignTerrainTiles(o4);
            }
            this.proxiedCoords[i3.id] = r3.map((e3) => new Si(e3, e3.key, this.orthoMatrix)), this._assignTerrainTiles(r3), this._prepareDEMTextures(), this._setupDrapedRenderBatches(), this._initFBOPool(), this._setupRenderCache(n3), this.renderingToTexture = false, this._updateTimestamp = e2.exported.now();
            const a3 = {};
            this._visibleDemTiles = [];
            for (const e3 of this.proxyCoords) {
              const t4 = this.terrainTileForTile[e3.key];
              if (!t4)
                continue;
              const i4 = t4.tileID.key;
              i4 in a3 || (this._visibleDemTiles.push(t4), a3[i4] = i4);
            }
          }
          _assignTerrainTiles(e3) {
            this._initializing || e3.forEach((e4) => {
              if (this.terrainTileForTile[e4.key])
                return;
              const t3 = this._findTileCoveringTileID(e4, this.sourceCache);
              t3 && (this.terrainTileForTile[e4.key] = t3);
            });
          }
          _prepareDEMTextures() {
            const e3 = this.painter.context, t3 = e3.gl;
            for (const i3 in this.terrainTileForTile) {
              const o3 = this.terrainTileForTile[i3], r3 = o3.dem;
              !r3 || o3.demTexture && !o3.needsDEMTextureUpload || (e3.activeTexture.set(t3.TEXTURE1), mi(this.painter, o3, r3));
            }
          }
          _prepareDemTileUniforms(e3, t3, i3, o3) {
            if (!t3 || null == t3.demTexture)
              return false;
            const r3 = e3.tileID.canonical, n3 = Math.pow(2, t3.tileID.canonical.z - r3.z), s3 = o3 || "";
            return i3[`u_dem_tl${s3}`] = [r3.x * n3 % 1, r3.y * n3 % 1], i3[`u_dem_scale${s3}`] = n3, true;
          }
          get emptyDEMTexture() {
            return !this._emptyDEMTextureDirty && this._emptyDEMTexture ? this._emptyDEMTexture : this._updateEmptyDEMTexture();
          }
          get emptyDepthBufferTexture() {
            const t3 = this.painter.context, i3 = t3.gl;
            if (!this._emptyDepthBufferTexture) {
              const o3 = new e2.RGBAImage({ width: 1, height: 1 }, Uint8Array.of(255, 255, 255, 255));
              this._emptyDepthBufferTexture = new e2.Texture(t3, o3, i3.RGBA, { premultiply: false });
            }
            return this._emptyDepthBufferTexture;
          }
          _getLoadedAreaMinimum() {
            let e3 = 0;
            const t3 = this._visibleDemTiles.reduce((t4, i3) => {
              if (!i3.dem)
                return t4;
              const o3 = i3.dem.tree.minimums[0];
              return o3 > 0 && e3++, t4 + o3;
            }, 0);
            return e3 ? t3 / e3 : 0;
          }
          _updateEmptyDEMTexture() {
            const t3 = this.painter.context, i3 = t3.gl;
            t3.activeTexture.set(i3.TEXTURE2);
            const o3 = this._getLoadedAreaMinimum(), r3 = new e2.RGBAImage({ width: 1, height: 1 }, new Uint8Array(e2.DEMData.pack(o3, this.sourceCache.getSource().encoding)));
            this._emptyDEMTextureDirty = false;
            let n3 = this._emptyDEMTexture;
            return n3 ? n3.update(r3, { premultiply: false }) : n3 = this._emptyDEMTexture = new e2.Texture(t3, r3, i3.RGBA, { premultiply: false }), n3;
          }
          setupElevationDraw(t3, i3, o3) {
            const r3 = this.painter.context, n3 = r3.gl, s3 = (a3 = this.sourceCache.getSource().encoding, { u_dem: 2, u_dem_prev: 4, u_dem_unpack: e2.DEMData.getUnpackVector(a3), u_dem_tl: [0, 0], u_dem_tl_prev: [0, 0], u_dem_scale: 0, u_dem_scale_prev: 0, u_dem_size: 0, u_dem_lerp: 1, u_depth: 3, u_depth_size_inv: [0, 0], u_exaggeration: 0 });
            var a3;
            s3.u_dem_size = this.sourceCache.getSource().tileSize, s3.u_exaggeration = this.exaggeration();
            let l2 = null, c3 = null, h3 = 1;
            if (o3 && o3.morphing && this._useVertexMorphing) {
              const e3 = o3.morphing.srcDemTile, i4 = o3.morphing.dstDemTile;
              h3 = o3.morphing.phase, e3 && i4 && (this._prepareDemTileUniforms(t3, e3, s3, "_prev") && (c3 = e3), this._prepareDemTileUniforms(t3, i4, s3) && (l2 = i4));
            }
            if (c3 && l2 ? (r3.activeTexture.set(n3.TEXTURE2), l2.demTexture.bind(n3.NEAREST, n3.CLAMP_TO_EDGE, n3.NEAREST), r3.activeTexture.set(n3.TEXTURE4), c3.demTexture.bind(n3.NEAREST, n3.CLAMP_TO_EDGE, n3.NEAREST), s3.u_dem_lerp = h3) : (l2 = this.terrainTileForTile[t3.tileID.key], r3.activeTexture.set(n3.TEXTURE2), (this._prepareDemTileUniforms(t3, l2, s3) ? l2.demTexture : this.emptyDEMTexture).bind(n3.NEAREST, n3.CLAMP_TO_EDGE)), r3.activeTexture.set(n3.TEXTURE3), o3 && o3.useDepthForOcclusion ? (this._depthTexture && this._depthTexture.bind(n3.NEAREST, n3.CLAMP_TO_EDGE), this._depthFBO && (s3.u_depth_size_inv = [1 / this._depthFBO.width, 1 / this._depthFBO.height])) : (this.emptyDepthBufferTexture.bind(n3.NEAREST, n3.CLAMP_TO_EDGE), s3.u_depth_size_inv = [1, 1]), o3 && o3.useMeterToDem && l2) {
              const t4 = (1 << l2.tileID.canonical.z) * e2.mercatorZfromAltitude(1, this.painter.transform.center.lat) * this.sourceCache.getSource().tileSize;
              s3.u_meter_to_dem = t4;
            }
            if (o3 && o3.labelPlaneMatrixInv && (s3.u_label_plane_matrix_inv = o3.labelPlaneMatrixInv), i3.setTerrainUniformValues(r3, s3), "globe" === this.painter.transform.projection.name) {
              const e3 = this.globeUniformValues(this.painter.transform, t3.tileID.canonical, o3 && o3.useDenormalizedUpVectorScale);
              i3.setGlobeUniformValues(r3, e3);
            }
          }
          globeUniformValues(t3, i3, o3) {
            const r3 = t3.projection;
            return { u_tile_tl_up: r3.upVector(i3, 0, 0), u_tile_tr_up: r3.upVector(i3, e2.EXTENT, 0), u_tile_br_up: r3.upVector(i3, e2.EXTENT, e2.EXTENT), u_tile_bl_up: r3.upVector(i3, 0, e2.EXTENT), u_tile_up_scale: o3 ? e2.globeMetersToEcef(1) : r3.upVectorScale(i3, t3.center.lat, t3.worldSize).metersToTile };
          }
          renderToBackBuffer(t3) {
            const i3 = this.painter, o3 = this.painter.context;
            0 !== t3.length && (o3.bindFramebuffer.set(null), o3.viewport.set([0, 0, i3.width, i3.height]), i3.gpuTimingDeferredRenderStart(), this.renderingToTexture = false, function(t4, i4, o4, r3, n3) {
              if ("globe" === t4.transform.projection.name)
                !function(t5, i5, o5, r4, n4) {
                  const s3 = t5.context, a3 = s3.gl;
                  let l2, c3;
                  const h3 = t5.options.showTerrainWireframe ? 2 : 0, u3 = t5.transform, _2 = e2.globeUseCustomAntiAliasing(t5, s3, u3), d3 = (e3, i6) => {
                    if (c3 === e3)
                      return;
                    const o6 = [wi[e3], "PROJECTION_GLOBE_VIEW"];
                    _2 && o6.push("CUSTOM_ANTIALIASING"), i6 && o6.push(wi[h3]), l2 = t5.useProgram("globeRaster", null, o6), c3 = e3;
                  }, p3 = t5.colorModeForRenderPass(), m3 = new e2.DepthMode(a3.LEQUAL, e2.DepthMode.ReadWrite, t5.depthRangeFor3D);
                  bi.update(n4);
                  const f3 = e2.calculateGlobeMercatorMatrix(u3), g3 = [e2.mercatorXfromLng(u3.center.lng), e2.mercatorYfromLat(u3.center.lat)], v3 = h3 ? [false, true] : [false], x3 = t5.globeSharedBuffers, y3 = [u3.width * e2.exported.devicePixelRatio, u3.height * e2.exported.devicePixelRatio], b2 = Float32Array.from(u3.globeMatrix), w2 = { useDenormalizedUpVectorScale: true };
                  if (v3.forEach((h4) => {
                    const u4 = t5.transform, _3 = Ti(u4.zoom) * i5.exaggeration();
                    c3 = -1;
                    const v4 = h4 ? a3.LINES : a3.TRIANGLES;
                    for (const c4 of r4) {
                      const r5 = o5.getTile(c4), T2 = e2.StencilMode.disabled, E3 = i5.prevTerrainTileForTile[c4.key], C2 = i5.terrainTileForTile[c4.key];
                      yi(E3, C2) && bi.newMorphing(c4.key, E3, C2, n4, 250), s3.activeTexture.set(a3.TEXTURE0), r5.texture.bind(a3.LINEAR, a3.CLAMP_TO_EDGE);
                      const M2 = bi.getMorphValuesForProxy(c4.key), I2 = M2 ? 1 : 0;
                      M2 && e2.extend$1(w2, { morphing: { srcDemTile: M2.from, dstDemTile: M2.to, phase: e2.easeCubicInOut(M2.phase) } });
                      const P2 = e2.tileCornersToBounds(c4.canonical), S2 = e2.getLatitudinalLod(P2.getCenter().lat), D2 = e2.getGridMatrix(c4.canonical, P2, S2, u4.worldSize / u4._pixelsPerMercatorPixel), L2 = e2.globeNormalizeECEF(e2.globeTileBounds(c4.canonical)), A2 = xi(u4.projMatrix, b2, f3, L2, e2.globeToMercatorTransition(u4.zoom), g3, u4.frustumCorners.TL, u4.frustumCorners.TR, u4.frustumCorners.BR, u4.frustumCorners.BL, u4.globeCenterInViewSpace, u4.globeRadius, y3, _3, D2);
                      if (d3(I2, h4), i5.setupElevationDraw(r5, l2, w2), t5.prepareDrawProgram(s3, l2, c4.toUnwrapped()), x3) {
                        const [i6, o6, r6] = h4 ? x3.getWirefameBuffers(t5.context, S2) : x3.getGridBuffers(S2, 0 !== _3);
                        l2.draw(s3, v4, m3, T2, p3, e2.CullFaceMode.backCCW, A2, "globe_raster", i6, o6, r6);
                      }
                    }
                  }), x3) {
                    const n5 = ["GLOBE_POLES", "PROJECTION_GLOBE_VIEW"];
                    _2 && n5.push("CUSTOM_ANTIALIASING"), l2 = t5.useProgram("globeRaster", null, n5);
                    for (const n6 of r4) {
                      const { x: r5, y: c4, z: h4 } = n6.canonical, _3 = 0 === c4, d4 = c4 === (1 << h4) - 1, [f4, v4, b3, T2] = x3.getPoleBuffers(h4);
                      if (T2 && (_3 || d4)) {
                        const c5 = o5.getTile(n6);
                        s3.activeTexture.set(a3.TEXTURE0), c5.texture.bind(a3.LINEAR, a3.CLAMP_TO_EDGE);
                        let x4 = e2.globePoleMatrixForTile(h4, r5, u3);
                        const E3 = e2.globeNormalizeECEF(e2.globeTileBounds(n6.canonical)), C2 = (t6, i6) => t6.draw(s3, a3.TRIANGLES, m3, e2.StencilMode.disabled, p3, e2.CullFaceMode.disabled, xi(u3.projMatrix, x4, x4, E3, 0, g3, u3.frustumCorners.TL, u3.frustumCorners.TR, u3.frustumCorners.BR, u3.frustumCorners.BL, u3.globeCenterInViewSpace, u3.globeRadius, y3, 0), "globe_pole_raster", i6, b3, T2);
                        i5.setupElevationDraw(c5, l2, w2), t5.prepareDrawProgram(s3, l2, n6.toUnwrapped()), _3 && C2(l2, f4), d4 && (x4 = e2.scale(e2.create(), x4, [1, -1, 1]), C2(l2, v4));
                      }
                    }
                  }
                }(t4, i4, o4, r3, n3);
              else {
                const s3 = t4.context, a3 = s3.gl;
                let l2, c3;
                const h3 = t4.options.showTerrainWireframe ? 2 : 0, u3 = (e3, i5) => {
                  if (c3 === e3)
                    return;
                  const o5 = [wi[e3]];
                  i5 && o5.push(wi[h3]), l2 = t4.useProgram("terrainRaster", null, o5), c3 = e3;
                }, _2 = t4.colorModeForRenderPass(), d3 = new e2.DepthMode(a3.LEQUAL, e2.DepthMode.ReadWrite, t4.depthRangeFor3D);
                bi.update(n3);
                const p3 = t4.transform, m3 = Ti(p3.zoom) * i4.exaggeration();
                (h3 ? [false, true] : [false]).forEach((h4) => {
                  c3 = -1;
                  const f3 = h4 ? a3.LINES : a3.TRIANGLES, [g3, v3] = h4 ? i4.getWirefameBuffer() : [i4.gridIndexBuffer, i4.gridSegments];
                  for (const c4 of r3) {
                    const r4 = o4.getTile(c4), x3 = e2.StencilMode.disabled, y3 = i4.prevTerrainTileForTile[c4.key], b2 = i4.terrainTileForTile[c4.key];
                    yi(y3, b2) && bi.newMorphing(c4.key, y3, b2, n3, 250), s3.activeTexture.set(a3.TEXTURE0), r4.texture.bind(a3.LINEAR, a3.CLAMP_TO_EDGE, a3.LINEAR_MIPMAP_NEAREST);
                    const w2 = bi.getMorphValuesForProxy(c4.key), T2 = w2 ? 1 : 0;
                    let E3;
                    w2 && (E3 = { morphing: { srcDemTile: w2.from, dstDemTile: w2.to, phase: e2.easeCubicInOut(w2.phase) } });
                    const C2 = vi(c4.projMatrix, Ei(c4.canonical, p3.renderWorldCopies) ? m3 / 10 : m3);
                    u3(T2, h4), i4.setupElevationDraw(r4, l2, E3), t4.prepareDrawProgram(s3, l2, c4.toUnwrapped()), l2.draw(s3, f3, d3, x3, _2, e2.CullFaceMode.backCCW, C2, "terrain_raster", i4.gridBuffer, g3, v3);
                  }
                });
              }
            }(i3, this, this.proxySourceCache, t3, this._updateTimestamp), this.renderingToTexture = true, i3.gpuTimingDeferredRenderEnd(), t3.splice(0, t3.length));
          }
          renderBatch(t3) {
            if (0 === this._drapedRenderBatches.length)
              return t3 + 1;
            this.renderingToTexture = true;
            const i3 = this.painter, o3 = this.painter.context, r3 = this.proxySourceCache, n3 = this.proxiedCoords[r3.id], s3 = this._drapedRenderBatches.shift(), a3 = [], l2 = i3.style.order;
            let c3 = 0;
            for (const h3 of n3) {
              const n4 = r3.getTileByID(h3.proxyTileKey), u3 = r3.proxyCachedFBO[h3.key] ? r3.proxyCachedFBO[h3.key][t3] : void 0, _2 = void 0 !== u3 ? r3.renderCache[u3] : this.pool[c3++], d3 = void 0 !== u3;
              if (n4.texture = _2.tex, d3 && !_2.dirty) {
                a3.push(n4.tileID);
                continue;
              }
              let p3;
              o3.bindFramebuffer.set(_2.fb.framebuffer), this.renderedToTile = false, _2.dirty && (o3.clear({ color: e2.Color.transparent, stencil: 0 }), _2.dirty = false);
              for (let e3 = s3.start; e3 <= s3.end; ++e3) {
                const t4 = i3.style._layers[l2[e3]];
                if (t4.isHidden(i3.transform.zoom))
                  continue;
                const r4 = i3.style._getLayerSourceCache(t4), n5 = r4 ? this.proxyToSource[h3.key][r4.id] : [h3];
                if (!n5)
                  continue;
                const s4 = n5;
                o3.viewport.set([0, 0, _2.fb.width, _2.fb.height]), p3 !== (r4 ? r4.id : null) && (this._setupStencil(_2, n5, t4, r4), p3 = r4 ? r4.id : null), i3.renderLayer(i3, r4, t4, s4);
              }
              this.renderedToTile ? (_2.dirty = true, a3.push(n4.tileID)) : d3 || --c3, 5 === c3 && (c3 = 0, this.renderToBackBuffer(a3));
            }
            return this.renderToBackBuffer(a3), this.renderingToTexture = false, o3.bindFramebuffer.set(null), o3.viewport.set([0, 0, i3.width, i3.height]), s3.end + 1;
          }
          postRender() {
          }
          renderCacheEfficiency(e3) {
            const t3 = e3.order.length;
            if (0 === t3)
              return { efficiency: 100 };
            let i3, o3 = 0, r3 = 0, n3 = false;
            for (let s3 = 0; s3 < t3; ++s3) {
              const t4 = e3._layers[e3.order[s3]];
              this._style.isLayerDraped(t4) ? (n3 && ++o3, ++r3) : n3 || (n3 = true, i3 = t4.id);
            }
            return 0 === r3 ? { efficiency: 100 } : { efficiency: 100 * (1 - o3 / r3), firstUndrapedLayer: i3 };
          }
          getMinElevationBelowMSL() {
            let e3 = 0;
            return this._visibleDemTiles.filter((e4) => e4.dem).forEach((t3) => {
              e3 = Math.min(e3, t3.dem.tree.minimums[0]);
            }), 0 === e3 ? e3 : (e3 - 30) * this._exaggeration;
          }
          raycast(e3, t3, i3) {
            if (!this._visibleDemTiles)
              return null;
            const o3 = this._visibleDemTiles.filter((e4) => e4.dem).map((o4) => {
              const r3 = o4.tileID, n3 = 1 << r3.overscaledZ, { x: s3, y: a3 } = r3.canonical, l2 = s3 / n3, c3 = (s3 + 1) / n3, h3 = a3 / n3, u3 = (a3 + 1) / n3;
              return { minx: l2, miny: h3, maxx: c3, maxy: u3, t: o4.dem.tree.raycastRoot(l2, h3, c3, u3, e3, t3, i3), tile: o4 };
            });
            o3.sort((e4, t4) => (null !== e4.t ? e4.t : Number.MAX_VALUE) - (null !== t4.t ? t4.t : Number.MAX_VALUE));
            for (const r3 of o3) {
              if (null == r3.t)
                return null;
              const o4 = r3.tile.dem.tree.raycast(r3.minx, r3.miny, r3.maxx, r3.maxy, e3, t3, i3);
              if (null != o4)
                return o4;
            }
            return null;
          }
          _createFBO() {
            const t3 = this.painter.context, i3 = t3.gl, o3 = this.drapeBufferSize;
            t3.activeTexture.set(i3.TEXTURE0);
            const r3 = new e2.Texture(t3, { width: o3[0], height: o3[1], data: null }, i3.RGBA);
            r3.bind(i3.LINEAR, i3.CLAMP_TO_EDGE);
            const n3 = t3.createFramebuffer(o3[0], o3[1], false);
            return n3.colorAttachment.set(r3.texture), n3.depthAttachment = new we(t3, n3.framebuffer), void 0 === this._sharedDepthStencil ? (this._sharedDepthStencil = t3.createRenderbuffer(t3.gl.DEPTH_STENCIL, o3[0], o3[1]), this._stencilRef = 0, n3.depthAttachment.set(this._sharedDepthStencil), t3.clear({ stencil: 0 })) : n3.depthAttachment.set(this._sharedDepthStencil), t3.extTextureFilterAnisotropic && !t3.extTextureFilterAnisotropicForceOff && i3.texParameterf(i3.TEXTURE_2D, t3.extTextureFilterAnisotropic.TEXTURE_MAX_ANISOTROPY_EXT, t3.extTextureFilterAnisotropicMax), { fb: n3, tex: r3, dirty: false };
          }
          _initFBOPool() {
            for (; this.pool.length < Math.min(5, this.proxyCoords.length); )
              this.pool.push(this._createFBO());
          }
          _shouldDisableRenderCache() {
            if (this._style.light && this._style.light.hasTransition())
              return true;
            for (const e3 in this._style._sourceCaches)
              if (this._style._sourceCaches[e3].hasTransition())
                return true;
            return this._style.order.some((e3) => {
              const t3 = this._style._layers[e3], i3 = t3.isHidden(this.painter.transform.zoom);
              return "custom" === t3.type ? !i3 && t3.shouldRedrape() : !i3 && t3.hasTransition();
            });
          }
          _clearLineLayersFromRenderCache() {
            let t3 = false;
            for (const e3 of this._style._getSources())
              if (e3 instanceof Ce) {
                t3 = true;
                break;
              }
            if (!t3)
              return;
            const i3 = {};
            for (let t4 = 0; t4 < this._style.order.length; ++t4) {
              const o3 = this._style._layers[this._style.order[t4]], r3 = this._style._getLayerSourceCache(o3);
              if (r3 && !i3[r3.id] && !o3.isHidden(this.painter.transform.zoom) && "line" === o3.type && o3.widthExpression() instanceof e2.ZoomDependentExpression) {
                i3[r3.id] = true;
                for (const e3 of this.proxyCoords) {
                  const t5 = this.proxyToSource[e3.key][r3.id];
                  if (t5)
                    for (const e4 of t5)
                      this._clearRenderCacheForTile(r3.id, e4);
                }
              }
            }
          }
          _clearRasterLayersFromRenderCache() {
            let e3 = false;
            for (const t4 in this._style._sourceCaches)
              if (this._style._sourceCaches[t4]._source instanceof Me) {
                e3 = true;
                break;
              }
            if (!e3)
              return;
            const t3 = {};
            for (let e4 = 0; e4 < this._style.order.length; ++e4) {
              const i3 = this._style._layers[this._style.order[e4]], o3 = this._style._getLayerSourceCache(i3);
              if (!o3 || t3[o3.id])
                continue;
              if (i3.isHidden(this.painter.transform.zoom) || "raster" !== i3.type)
                continue;
              const r3 = i3.paint.get("raster-fade-duration");
              for (const e5 of this.proxyCoords) {
                const t4 = this.proxyToSource[e5.key][o3.id];
                if (t4)
                  for (const e6 of t4) {
                    const t5 = Mi(o3.getTile(e6), o3.findLoadedParent(e6, 0), o3, this.painter.transform, r3);
                    (1 !== t5.opacity || 0 !== t5.mix) && this._clearRenderCacheForTile(o3.id, e6);
                  }
              }
            }
          }
          _setupDrapedRenderBatches() {
            const e3 = this._style.order, t3 = e3.length;
            if (0 === t3)
              return;
            const i3 = [];
            let o3, r3 = 0, n3 = this._style._layers[e3[r3]];
            for (; !this._style.isLayerDraped(n3) && n3.isHidden(this.painter.transform.zoom) && ++r3 < t3; )
              n3 = this._style._layers[e3[r3]];
            for (; r3 < t3; ++r3) {
              const t4 = this._style._layers[e3[r3]];
              t4.isHidden(this.painter.transform.zoom) || (this._style.isLayerDraped(t4) ? void 0 === o3 && (o3 = r3) : void 0 !== o3 && (i3.push({ start: o3, end: r3 - 1 }), o3 = void 0));
            }
            void 0 !== o3 && i3.push({ start: o3, end: r3 - 1 }), this._drapedRenderBatches = i3;
          }
          _setupRenderCache(e3) {
            const t3 = this.proxySourceCache;
            if (this._shouldDisableRenderCache() || this._invalidateRenderCache) {
              if (this._invalidateRenderCache = false, t3.renderCache.length > t3.renderCachePool.length) {
                const e4 = Object.values(t3.proxyCachedFBO);
                t3.proxyCachedFBO = {};
                for (let i4 = 0; i4 < e4.length; ++i4) {
                  const o4 = Object.values(e4[i4]);
                  t3.renderCachePool.push(...o4);
                }
              }
              return;
            }
            this._clearRasterLayersFromRenderCache();
            const i3 = this.proxyCoords, o3 = this._tilesDirty;
            for (let r4 = i3.length - 1; r4 >= 0; r4--) {
              const n3 = i3[r4];
              if (t3.getTileByID(n3.key), void 0 !== t3.proxyCachedFBO[n3.key]) {
                const i4 = e3[n3.key], r5 = this.proxyToSource[n3.key];
                let s3 = 0;
                for (const e4 in r5) {
                  const t4 = r5[e4], n4 = i4[e4];
                  if (!n4 || n4.length !== t4.length || t4.some((t5, i5) => t5 !== n4[i5] || o3[e4] && o3[e4].hasOwnProperty(t5.key))) {
                    s3 = -1;
                    break;
                  }
                  ++s3;
                }
                for (const e4 in t3.proxyCachedFBO[n3.key])
                  t3.renderCache[t3.proxyCachedFBO[n3.key][e4]].dirty = s3 < 0 || s3 !== Object.values(i4).length;
              }
            }
            const r3 = [...this._drapedRenderBatches];
            r3.sort((e4, t4) => t4.end - t4.start - (e4.end - e4.start));
            for (const e4 of r3)
              for (const o4 of i3) {
                if (t3.proxyCachedFBO[o4.key])
                  continue;
                let i4 = t3.renderCachePool.pop();
                void 0 === i4 && t3.renderCache.length < 50 && (i4 = t3.renderCache.length, t3.renderCache.push(this._createFBO())), void 0 !== i4 && (t3.proxyCachedFBO[o4.key] = {}, t3.proxyCachedFBO[o4.key][e4.start] = i4, t3.renderCache[i4].dirty = true);
              }
            this._tilesDirty = {};
          }
          _setupStencil(e3, t3, i3, o3) {
            if (!o3 || !this._sourceTilesOverlap[o3.id])
              return void (this._overlapStencilType && (this._overlapStencilType = false));
            const r3 = this.painter.context, n3 = r3.gl;
            if (t3.length <= 1)
              return void (this._overlapStencilType = false);
            let s3;
            if (i3.isTileClipped())
              s3 = t3.length, this._overlapStencilMode.test = { func: n3.EQUAL, mask: 255 }, this._overlapStencilType = "Clip";
            else {
              if (!(t3[0].overscaledZ > t3[t3.length - 1].overscaledZ))
                return void (this._overlapStencilType = false);
              s3 = 1, this._overlapStencilMode.test = { func: n3.GREATER, mask: 255 }, this._overlapStencilType = "Mask";
            }
            this._stencilRef + s3 > 255 && (r3.clear({ stencil: 0 }), this._stencilRef = 0), this._stencilRef += s3, this._overlapStencilMode.ref = this._stencilRef, i3.isTileClipped() && this._renderTileClippingMasks(t3, this._overlapStencilMode.ref);
          }
          clipOrMaskOverlapStencilType() {
            return "Clip" === this._overlapStencilType || "Mask" === this._overlapStencilType;
          }
          stencilModeForRTTOverlap(t3) {
            return this.renderingToTexture && this._overlapStencilType ? ("Clip" === this._overlapStencilType && (this._overlapStencilMode.ref = this.painter._tileClippingMaskIDs[t3.key]), this._overlapStencilMode) : e2.StencilMode.disabled;
          }
          _renderTileClippingMasks(t3, i3) {
            const o3 = this.painter, r3 = this.painter.context, n3 = r3.gl;
            o3._tileClippingMaskIDs = {}, r3.setColorMode(e2.ColorMode.disabled), r3.setDepthMode(e2.DepthMode.disabled);
            const s3 = o3.useProgram("clippingMask");
            for (const a3 of t3) {
              const t4 = o3._tileClippingMaskIDs[a3.key] = --i3;
              s3.draw(r3, n3.TRIANGLES, e2.DepthMode.disabled, new e2.StencilMode({ func: n3.ALWAYS, mask: 0 }, t4, 255, n3.KEEP, n3.KEEP, n3.REPLACE), e2.ColorMode.disabled, e2.CullFaceMode.disabled, Ci(a3.projMatrix), "$clipping", o3.tileExtentBuffer, o3.quadTriangleIndexBuffer, o3.tileExtentSegments);
            }
          }
          pointCoordinate(t3) {
            const i3 = this.painter.transform;
            if (t3.x < 0 || t3.x > i3.width || t3.y < 0 || t3.y > i3.height)
              return null;
            const o3 = [t3.x, t3.y, 1, 1];
            e2.transformMat4$1(o3, o3, i3.pixelMatrixInverse), e2.scale$1(o3, o3, 1 / o3[3]), o3[0] /= i3.worldSize, o3[1] /= i3.worldSize;
            const r3 = i3._camera.position, n3 = e2.mercatorZfromAltitude(1, i3.center.lat), s3 = [r3[0], r3[1], r3[2] / n3, 0], a3 = e2.subtract([], o3.slice(0, 3), s3);
            e2.normalize(a3, a3);
            const l2 = this.raycast(s3, a3, this._exaggeration);
            return null !== l2 && l2 ? (e2.scaleAndAdd(s3, s3, a3, l2), s3[3] = s3[2], s3[2] *= n3, s3) : null;
          }
          drawDepth() {
            const t3 = this.painter, i3 = t3.context, o3 = this.proxySourceCache, r3 = Math.ceil(t3.width), n3 = Math.ceil(t3.height);
            if (!this._depthFBO || this._depthFBO.width === r3 && this._depthFBO.height === n3 || (this._depthFBO.destroy(), this._depthFBO = void 0, this._depthTexture = void 0), !this._depthFBO) {
              const t4 = i3.gl, o4 = i3.createFramebuffer(r3, n3, true);
              i3.activeTexture.set(t4.TEXTURE0);
              const s3 = new e2.Texture(i3, { width: r3, height: n3, data: null }, t4.RGBA);
              s3.bind(t4.NEAREST, t4.CLAMP_TO_EDGE), o4.colorAttachment.set(s3.texture);
              const a3 = i3.createRenderbuffer(i3.gl.DEPTH_COMPONENT16, r3, n3);
              o4.depthAttachment.set(a3), this._depthFBO = o4, this._depthTexture = s3;
            }
            i3.bindFramebuffer.set(this._depthFBO.framebuffer), i3.viewport.set([0, 0, r3, n3]), function(t4, i4, o4, r4) {
              if ("globe" === t4.transform.projection.name)
                return;
              const n4 = t4.context, s3 = n4.gl;
              n4.clear({ depth: 1 });
              const a3 = t4.useProgram("terrainDepth"), l2 = new e2.DepthMode(s3.LESS, e2.DepthMode.ReadWrite, t4.depthRangeFor3D);
              for (const t5 of r4) {
                const r5 = o4.getTile(t5), c3 = vi(t5.projMatrix, 0);
                i4.setupElevationDraw(r5, a3), a3.draw(n4, s3.TRIANGLES, l2, e2.StencilMode.disabled, e2.ColorMode.unblended, e2.CullFaceMode.backCCW, c3, "terrain_depth", i4.gridBuffer, i4.gridIndexBuffer, i4.gridNoSkirtSegments);
              }
            }(t3, this, o3, this.proxyCoords);
          }
          _setupProxiedCoordsForOrtho(e3, t3, i3) {
            if (e3.getSource() instanceof Pe)
              return this._setupProxiedCoordsForImageSource(e3, t3, i3);
            this._findCoveringTileCache[e3.id] = this._findCoveringTileCache[e3.id] || {};
            const o3 = this.proxiedCoords[e3.id] = [], r3 = this.proxyCoords;
            for (let t4 = 0; t4 < r3.length; t4++) {
              const n4 = r3[t4], s3 = this._findTileCoveringTileID(n4, e3);
              if (s3) {
                const t5 = this._createProxiedId(n4, s3, i3[n4.key] && i3[n4.key][e3.id]);
                o3.push(t5), this.proxyToSource[n4.key][e3.id] = [t5];
              }
            }
            let n3 = false;
            for (let r4 = 0; r4 < t3.length; r4++) {
              const s3 = e3.getTile(t3[r4]);
              if (!s3 || !s3.hasData())
                continue;
              const a3 = this._findTileCoveringTileID(s3.tileID, this.proxySourceCache);
              if (a3 && a3.tileID.canonical.z !== s3.tileID.canonical.z) {
                const t4 = this.proxyToSource[a3.tileID.key][e3.id], r5 = this._createProxiedId(a3.tileID, s3, i3[a3.tileID.key] && i3[a3.tileID.key][e3.id]);
                t4 ? t4.splice(t4.length - 1, 0, r5) : this.proxyToSource[a3.tileID.key][e3.id] = [r5], o3.push(r5), n3 = true;
              }
            }
            this._sourceTilesOverlap[e3.id] = n3;
          }
          _setupProxiedCoordsForImageSource(t3, i3, o3) {
            if (!t3.getSource().loaded())
              return;
            const r3 = this.proxiedCoords[t3.id] = [], n3 = this.proxyCoords, s3 = t3.getSource(), a3 = new e2.Point(s3.tileID.x, s3.tileID.y)._div(1 << s3.tileID.z), l2 = s3.coordinates.map(e2.MercatorCoordinate.fromLngLat).reduce((e3, t4) => (e3.min.x = Math.min(e3.min.x, t4.x - a3.x), e3.min.y = Math.min(e3.min.y, t4.y - a3.y), e3.max.x = Math.max(e3.max.x, t4.x - a3.x), e3.max.y = Math.max(e3.max.y, t4.y - a3.y), e3), { min: new e2.Point(Number.MAX_VALUE, Number.MAX_VALUE), max: new e2.Point(-Number.MAX_VALUE, -Number.MAX_VALUE) }), c3 = (t4, i4) => {
              const o4 = t4.wrap + t4.canonical.x / (1 << t4.canonical.z), r4 = t4.canonical.y / (1 << t4.canonical.z), n4 = e2.EXTENT / (1 << t4.canonical.z), s4 = i4.wrap + i4.canonical.x / (1 << i4.canonical.z), a4 = i4.canonical.y / (1 << i4.canonical.z);
              return o4 + n4 < s4 + l2.min.x || o4 > s4 + l2.max.x || r4 + n4 < a4 + l2.min.y || r4 > a4 + l2.max.y;
            };
            for (let e3 = 0; e3 < n3.length; e3++) {
              const s4 = n3[e3];
              for (let e4 = 0; e4 < i3.length; e4++) {
                const n4 = t3.getTile(i3[e4]);
                if (!n4 || !n4.hasData())
                  continue;
                if (c3(s4, n4.tileID))
                  continue;
                const a4 = this._createProxiedId(s4, n4, o3[s4.key] && o3[s4.key][t3.id]), l3 = this.proxyToSource[s4.key][t3.id];
                l3 ? l3.push(a4) : this.proxyToSource[s4.key][t3.id] = [a4], r3.push(a4);
              }
            }
          }
          _createProxiedId(t3, i3, o3) {
            let r3 = this.orthoMatrix;
            if (o3) {
              const e3 = o3.find((e4) => e4.key === i3.tileID.key);
              if (e3)
                return e3;
            }
            if (i3.tileID.key !== t3.key) {
              const o4 = t3.canonical.z - i3.tileID.canonical.z;
              let n3, s3, a3;
              r3 = e2.create();
              const l2 = i3.tileID.wrap - t3.wrap << t3.overscaledZ;
              o4 > 0 ? (n3 = e2.EXTENT >> o4, s3 = n3 * ((i3.tileID.canonical.x << o4) - t3.canonical.x + l2), a3 = n3 * ((i3.tileID.canonical.y << o4) - t3.canonical.y)) : (n3 = e2.EXTENT << -o4, s3 = e2.EXTENT * (i3.tileID.canonical.x - (t3.canonical.x + l2 << -o4)), a3 = e2.EXTENT * (i3.tileID.canonical.y - (t3.canonical.y << -o4))), e2.ortho(r3, 0, n3, 0, n3, 0, 1), e2.translate(r3, r3, [s3, a3, 0]);
            }
            return new Si(i3.tileID, t3.key, r3);
          }
          _findTileCoveringTileID(t3, i3) {
            let o3 = i3.getTile(t3);
            if (o3 && o3.hasData())
              return o3;
            const r3 = this._findCoveringTileCache[i3.id], n3 = r3[t3.key];
            if (o3 = n3 ? i3.getTileByID(n3) : null, o3 && o3.hasData() || null === n3)
              return o3;
            let s3 = o3 ? o3.tileID : t3, a3 = s3.overscaledZ;
            const l2 = i3.getSource().minzoom, c3 = [];
            if (!n3) {
              const r4 = i3.getSource().maxzoom;
              if (t3.canonical.z >= r4) {
                const o4 = t3.canonical.z - r4;
                i3.getSource().reparseOverscaled ? (a3 = Math.max(t3.canonical.z + 2, i3.transform.tileZoom), s3 = new e2.OverscaledTileID(a3, t3.wrap, r4, t3.canonical.x >> o4, t3.canonical.y >> o4)) : 0 !== o4 && (a3 = r4, s3 = new e2.OverscaledTileID(a3, t3.wrap, r4, t3.canonical.x >> o4, t3.canonical.y >> o4));
              }
              s3.key !== t3.key && (c3.push(s3.key), o3 = i3.getTile(s3));
            }
            const h3 = (e3) => {
              c3.forEach((t4) => {
                r3[t4] = e3;
              }), c3.length = 0;
            };
            for (a3 -= 1; a3 >= l2 && (!o3 || !o3.hasData()); a3--) {
              o3 && h3(o3.tileID.key);
              const e3 = s3.calculateScaledKey(a3);
              if (o3 = i3.getTileByID(e3), o3 && o3.hasData())
                break;
              const t4 = r3[e3];
              if (null === t4)
                break;
              void 0 === t4 ? c3.push(e3) : o3 = i3.getTileByID(t4);
            }
            return h3(o3 ? o3.tileID.key : null), o3 && o3.hasData() ? o3 : null;
          }
          findDEMTileFor(e3) {
            return this.enabled ? this._findTileCoveringTileID(e3, this.sourceCache) : null;
          }
          prepareDrawTile() {
            this.renderedToTile = true;
          }
          _clearRenderCacheForTile(e3, t3) {
            let i3 = this._tilesDirty[e3];
            i3 || (i3 = this._tilesDirty[e3] = {}), i3[t3.key] = true;
          }
          getWirefameBuffer() {
            if (!this.wireframeSegments) {
              const t3 = function(t4) {
                let i3 = 0;
                const o3 = new e2.StructArrayLayout2ui4(), r3 = 131;
                for (let e3 = 1; e3 < 129; e3++) {
                  for (let t5 = 1; t5 < 129; t5++)
                    i3 = e3 * r3 + t5, o3.emplaceBack(i3, i3 + 1), o3.emplaceBack(i3, i3 + r3), o3.emplaceBack(i3 + 1, i3 + r3), 128 === e3 && o3.emplaceBack(i3 + r3, i3 + r3 + 1);
                  o3.emplaceBack(i3 + 1, i3 + 1 + r3);
                }
                return o3;
              }();
              this.wireframeIndexBuffer = this.painter.context.createIndexBuffer(t3), this.wireframeSegments = e2.SegmentVector.simpleSegment(0, 0, this.gridBuffer.length, t3.length);
            }
            return [this.wireframeIndexBuffer, this.wireframeSegments];
          }
        }
        class Li {
          static cacheKey(e3, t3, i3, o3) {
            let r3 = `${t3}${o3 ? o3.cacheKey : ""}`;
            for (const t4 of i3)
              e3.usedDefines.includes(t4) && (r3 += `/${t4}`);
            return r3;
          }
          constructor(t3, i3, o3, r3, n3, s3) {
            const a3 = t3.gl;
            this.program = a3.createProgram();
            const l2 = function(e3) {
              const t4 = [];
              for (let i4 = 0; i4 < e3.length; i4++) {
                if (null === e3[i4])
                  continue;
                const o4 = e3[i4].split(" ");
                t4.push(o4.pop());
              }
              return t4;
            }(o3.staticAttributes), c3 = r3 ? r3.getBinderAttributes() : [], h3 = l2.concat(c3);
            let u3 = r3 ? r3.defines() : [];
            u3 = u3.concat(s3.map((e3) => `#define ${e3}`));
            const _2 = t3.isWebGL2 ? "#version 300 es\n" : "", d3 = _2 + u3.concat(t3.extStandardDerivatives && 0 === _2.length ? "#extension GL_OES_standard_derivatives : enable\n".concat(li) : li, li, ai, si.fragmentSource, ri.fragmentSource, o3.fragmentSource).join("\n"), p3 = _2 + u3.concat("\n#ifdef GL_ES\nprecision highp float;\n#else\n\n#if !defined(lowp)\n#define lowp\n#endif\n\n#if !defined(mediump)\n#define mediump\n#endif\n\n#if !defined(highp)\n#define highp\n#endif\n\n#endif", ai, si.vertexSource, ri.vertexSource, oi.vertexSource, o3.vertexSource).join("\n"), m3 = a3.createShader(a3.FRAGMENT_SHADER);
            if (a3.isContextLost())
              return void (this.failedToCreate = true);
            a3.shaderSource(m3, d3), a3.compileShader(m3), a3.attachShader(this.program, m3);
            const f3 = a3.createShader(a3.VERTEX_SHADER);
            if (a3.isContextLost())
              this.failedToCreate = true;
            else {
              a3.shaderSource(f3, p3), a3.compileShader(f3), a3.attachShader(this.program, f3), this.attributes = {}, this.numAttributes = h3.length;
              for (let e3 = 0; e3 < this.numAttributes; e3++)
                h3[e3] && (a3.bindAttribLocation(this.program, e3, h3[e3]), this.attributes[h3[e3]] = e3);
              a3.linkProgram(this.program), a3.deleteShader(f3), a3.deleteShader(m3), this.fixedUniforms = n3(t3), this.binderUniforms = r3 ? r3.getUniforms(t3) : [], s3.includes("TERRAIN") && (this.terrainUniforms = ((t4) => ({ u_dem: new e2.Uniform1i(t4), u_dem_prev: new e2.Uniform1i(t4), u_dem_unpack: new e2.Uniform4f(t4), u_dem_tl: new e2.Uniform2f(t4), u_dem_scale: new e2.Uniform1f(t4), u_dem_tl_prev: new e2.Uniform2f(t4), u_dem_scale_prev: new e2.Uniform1f(t4), u_dem_size: new e2.Uniform1f(t4), u_dem_lerp: new e2.Uniform1f(t4), u_exaggeration: new e2.Uniform1f(t4), u_depth: new e2.Uniform1i(t4), u_depth_size_inv: new e2.Uniform2f(t4), u_meter_to_dem: new e2.Uniform1f(t4), u_label_plane_matrix_inv: new e2.UniformMatrix4f(t4) }))(t3)), s3.includes("GLOBE") && (this.globeUniforms = ((t4) => ({ u_tile_tl_up: new e2.Uniform3f(t4), u_tile_tr_up: new e2.Uniform3f(t4), u_tile_br_up: new e2.Uniform3f(t4), u_tile_bl_up: new e2.Uniform3f(t4), u_tile_up_scale: new e2.Uniform1f(t4) }))(t3)), s3.includes("FOG") && (this.fogUniforms = ((t4) => ({ u_fog_matrix: new e2.UniformMatrix4f(t4), u_fog_range: new e2.Uniform2f(t4), u_fog_color: new e2.Uniform4f(t4), u_fog_horizon_blend: new e2.Uniform1f(t4), u_fog_temporal_offset: new e2.Uniform1f(t4), u_frustum_tl: new e2.Uniform3f(t4), u_frustum_tr: new e2.Uniform3f(t4), u_frustum_br: new e2.Uniform3f(t4), u_frustum_bl: new e2.Uniform3f(t4), u_globe_pos: new e2.Uniform3f(t4), u_globe_radius: new e2.Uniform1f(t4), u_globe_transition: new e2.Uniform1f(t4), u_is_globe: new e2.Uniform1i(t4), u_viewport: new e2.Uniform2f(t4) }))(t3));
            }
          }
          setTerrainUniformValues(e3, t3) {
            if (!this.terrainUniforms)
              return;
            const i3 = this.terrainUniforms;
            if (!this.failedToCreate) {
              e3.program.set(this.program);
              for (const e4 in t3)
                i3[e4] && i3[e4].set(this.program, e4, t3[e4]);
            }
          }
          setGlobeUniformValues(e3, t3) {
            if (!this.globeUniforms)
              return;
            const i3 = this.globeUniforms;
            if (!this.failedToCreate) {
              e3.program.set(this.program);
              for (const e4 in t3)
                i3[e4] && i3[e4].set(this.program, e4, t3[e4]);
            }
          }
          setFogUniformValues(e3, t3) {
            if (!this.fogUniforms)
              return;
            const i3 = this.fogUniforms;
            if (!this.failedToCreate) {
              e3.program.set(this.program);
              for (const e4 in t3)
                i3[e4].set(this.program, e4, t3[e4]);
            }
          }
          draw(e3, t3, i3, o3, r3, n3, s3, a3, l2, c3, h3, u3, _2, d3, p3) {
            const m3 = e3.gl;
            if (this.failedToCreate)
              return;
            e3.program.set(this.program), e3.setDepthMode(i3), e3.setStencilMode(o3), e3.setColorMode(r3), e3.setCullFace(n3);
            for (const e4 of Object.keys(this.fixedUniforms))
              this.fixedUniforms[e4].set(this.program, e4, s3[e4]);
            d3 && d3.setUniforms(this.program, e3, this.binderUniforms, u3, { zoom: _2 });
            const f3 = { [m3.LINES]: 2, [m3.TRIANGLES]: 3, [m3.LINE_STRIP]: 1 }[t3];
            for (const i4 of h3.get()) {
              const o4 = i4.vaos || (i4.vaos = {});
              (o4[a3] || (o4[a3] = new _i())).bind(e3, this, l2, d3 ? d3.getPaintVertexBuffers() : [], c3, i4.vertexOffset, p3 || []), m3.drawElements(t3, i4.primitiveLength * f3, m3.UNSIGNED_SHORT, i4.primitiveOffset * f3 * 2);
            }
          }
        }
        function Ai(e3, t3) {
          const i3 = Math.pow(2, t3.tileID.overscaledZ), o3 = t3.tileSize * Math.pow(2, e3.transform.tileZoom) / i3, r3 = o3 * (t3.tileID.canonical.x + t3.tileID.wrap * i3), n3 = o3 * t3.tileID.canonical.y;
          return { u_image: 0, u_texsize: t3.imageAtlasTexture.size, u_tile_units_to_pixels: 1 / D(t3, 1, e3.transform.tileZoom), u_pixel_coord_upper: [r3 >> 16, n3 >> 16], u_pixel_coord_lower: [65535 & r3, 65535 & n3] };
        }
        const zi = e2.create(), Ri = (t3, i3, o3, r3, n3, s3, a3, l2, c3, h3, u3) => {
          const _2 = i3.style.light, d3 = _2.properties.get("position"), p3 = [d3.x, d3.y, d3.z], m3 = e2.create$1();
          "viewport" === _2.properties.get("anchor") && (e2.fromRotation(m3, -i3.transform.angle), e2.transformMat3(p3, p3, m3));
          const f3 = _2.properties.get("color"), g3 = i3.transform, v3 = { u_matrix: t3, u_lightpos: p3, u_lightintensity: _2.properties.get("intensity"), u_lightcolor: [f3.r, f3.g, f3.b], u_vertical_gradient: +o3, u_opacity: r3, u_tile_id: [0, 0, 0], u_zoom_transition: 0, u_inv_rot_matrix: zi, u_merc_center: [0, 0], u_up_dir: [0, 0, 0], u_height_lift: 0, u_ao: n3, u_edge_radius: s3 };
          return "globe" === g3.projection.name && (v3.u_tile_id = [a3.canonical.x, a3.canonical.y, 1 << a3.canonical.z], v3.u_zoom_transition = c3, v3.u_inv_rot_matrix = u3, v3.u_merc_center = h3, v3.u_up_dir = g3.projection.upVector(new e2.CanonicalTileID(0, 0, 0), h3[0] * e2.EXTENT, h3[1] * e2.EXTENT), v3.u_height_lift = l2), v3;
        }, Oi = (t3, i3, o3, r3, n3, s3, a3, l2, c3, h3, u3, _2) => {
          const d3 = Ri(t3, i3, o3, r3, n3, s3, a3, c3, h3, u3, _2), p3 = { u_height_factor: -Math.pow(2, a3.overscaledZ) / l2.tileSize / 8 };
          return e2.extend(d3, Ai(i3, l2), p3);
        }, Bi = (e3) => ({ u_matrix: e3 }), ki = (t3, i3, o3) => e2.extend(Bi(t3), Ai(i3, o3)), Fi = (e3, t3) => ({ u_matrix: e3, u_world: t3 }), Ui = (t3, i3, o3, r3) => e2.extend(ki(t3, i3, o3), { u_world: r3 }), Ni = e2.create(), ji = (t3, i3, o3, r3, n3, s3) => {
          const a3 = t3.transform, l2 = "globe" === a3.projection.name;
          let c3;
          if ("map" === s3.paint.get("circle-pitch-alignment"))
            if (l2) {
              const t4 = e2.globePixelsToTileUnits(a3.zoom, i3.canonical) * a3._pixelsPerMercatorPixel;
              c3 = Float32Array.from([t4, 0, 0, t4]);
            } else
              c3 = a3.calculatePixelsToTileUnitsMatrix(o3);
          else
            c3 = new Float32Array([a3.pixelsToGLUnits[0], 0, 0, a3.pixelsToGLUnits[1]]);
          const h3 = { u_camera_to_center_distance: a3.cameraToCenterDistance, u_matrix: t3.translatePosMatrix(i3.projMatrix, o3, s3.paint.get("circle-translate"), s3.paint.get("circle-translate-anchor")), u_device_pixel_ratio: e2.exported.devicePixelRatio, u_extrude_scale: c3, u_inv_rot_matrix: Ni, u_merc_center: [0, 0], u_tile_id: [0, 0, 0], u_zoom_transition: 0, u_up_dir: [0, 0, 0] };
          if (l2) {
            h3.u_inv_rot_matrix = r3, h3.u_merc_center = n3, h3.u_tile_id = [i3.canonical.x, i3.canonical.y, 1 << i3.canonical.z], h3.u_zoom_transition = e2.globeToMercatorTransition(a3.zoom);
            const t4 = n3[0] * e2.EXTENT, o4 = n3[1] * e2.EXTENT;
            h3.u_up_dir = a3.projection.upVector(new e2.CanonicalTileID(0, 0, 0), t4, o4);
          }
          return h3;
        }, Gi = (e3) => {
          const t3 = [];
          return "map" === e3.paint.get("circle-pitch-alignment") && t3.push("PITCH_WITH_MAP"), "map" === e3.paint.get("circle-pitch-scale") && t3.push("SCALE_WITH_MAP"), t3;
        }, Zi = (t3, i3, o3, r3) => {
          const n3 = e2.EXTENT / o3.tileSize;
          return { u_matrix: t3, u_camera_to_center_distance: i3.getCameraToCenterDistance(r3), u_extrude_scale: [i3.pixelsToGLUnits[0] / n3, i3.pixelsToGLUnits[1] / n3] };
        }, Vi = (e3, t3, i3 = 1) => ({ u_matrix: e3, u_color: t3, u_overlay: 0, u_overlay_scale: i3 }), Wi = e2.create(), Xi = (t3, i3, o3, r3, n3, s3, a3) => {
          const l2 = t3.transform, c3 = "globe" === l2.projection.name, h3 = c3 ? e2.globePixelsToTileUnits(l2.zoom, i3.canonical) * l2._pixelsPerMercatorPixel : D(o3, 1, s3), u3 = { u_matrix: i3.projMatrix, u_extrude_scale: h3, u_intensity: a3, u_inv_rot_matrix: Wi, u_merc_center: [0, 0], u_tile_id: [0, 0, 0], u_zoom_transition: 0, u_up_dir: [0, 0, 0] };
          if (c3) {
            u3.u_inv_rot_matrix = r3, u3.u_merc_center = n3, u3.u_tile_id = [i3.canonical.x, i3.canonical.y, 1 << i3.canonical.z], u3.u_zoom_transition = e2.globeToMercatorTransition(l2.zoom);
            const t4 = n3[0] * e2.EXTENT, o4 = n3[1] * e2.EXTENT;
            u3.u_up_dir = l2.projection.upVector(new e2.CanonicalTileID(0, 0, 0), t4, o4);
          }
          return u3;
        }, qi = (e3, t3, i3, o3, r3, n3, s3) => {
          const a3 = e3.transform, l2 = a3.calculatePixelsToTileUnitsMatrix(t3);
          return { u_matrix: Yi(e3, t3, i3, o3), u_pixels_to_tile_units: l2, u_device_pixel_ratio: n3, u_units_to_pixels: [1 / a3.pixelsToGLUnits[0], 1 / a3.pixelsToGLUnits[1]], u_dash_image: 0, u_gradient_image: 1, u_image_height: r3, u_texsize: Ki(i3) ? t3.lineAtlasTexture.size : [0, 0], u_tile_units_to_pixels: Hi(t3, e3.transform), u_alpha_discard_threshold: 0, u_trim_offset: s3 };
        }, $i = (e3, t3, i3, o3, r3) => {
          const n3 = e3.transform;
          return { u_matrix: Yi(e3, t3, i3, o3), u_texsize: t3.imageAtlasTexture.size, u_pixels_to_tile_units: n3.calculatePixelsToTileUnitsMatrix(t3), u_device_pixel_ratio: r3, u_image: 0, u_tile_units_to_pixels: Hi(t3, n3), u_units_to_pixels: [1 / n3.pixelsToGLUnits[0], 1 / n3.pixelsToGLUnits[1]], u_alpha_discard_threshold: 0 };
        };
        function Hi(e3, t3) {
          return 1 / D(e3, 1, t3.tileZoom);
        }
        function Yi(e3, t3, i3, o3) {
          return e3.translatePosMatrix(o3 || t3.tileID.projMatrix, t3, i3.paint.get("line-translate"), i3.paint.get("line-translate-anchor"));
        }
        function Ki(e3) {
          const t3 = e3.paint.get("line-dasharray").value;
          return t3.value || "constant" !== t3.kind;
        }
        const Ji = (e3, t3, i3, o3, r3, n3) => {
          return { u_matrix: e3, u_tl_parent: t3, u_scale_parent: i3, u_fade_t: o3.mix, u_opacity: o3.opacity * r3.paint.get("raster-opacity"), u_image0: 0, u_image1: 1, u_brightness_low: r3.paint.get("raster-brightness-min"), u_brightness_high: r3.paint.get("raster-brightness-max"), u_saturation_factor: (a3 = r3.paint.get("raster-saturation"), a3 > 0 ? 1 - 1 / (1.001 - a3) : -a3), u_contrast_factor: (s3 = r3.paint.get("raster-contrast"), s3 > 0 ? 1 / (1 - s3) : 1 + s3), u_spin_weights: Qi(r3.paint.get("raster-hue-rotate")), u_perspective_transform: n3 };
          var s3, a3;
        };
        function Qi(e3) {
          e3 *= Math.PI / 180;
          const t3 = Math.sin(e3), i3 = Math.cos(e3);
          return [(2 * i3 + 1) / 3, (-Math.sqrt(3) * t3 - i3 + 1) / 3, (Math.sqrt(3) * t3 - i3 + 1) / 3];
        }
        const eo = e2.create(), to = (t3, i3, o3, r3, n3, s3, a3, l2, c3, h3, u3, _2, d3, p3, m3, f3) => {
          const g3 = n3.transform, v3 = { u_is_size_zoom_constant: +("constant" === t3 || "source" === t3), u_is_size_feature_constant: +("constant" === t3 || "camera" === t3), u_size_t: i3 ? i3.uSizeT : 0, u_size: i3 ? i3.uSize : 0, u_camera_to_center_distance: g3.cameraToCenterDistance, u_rotate_symbol: +o3, u_aspect_ratio: g3.width / g3.height, u_fade_change: n3.options.fadeDuration ? n3.symbolFadeChange : 1, u_matrix: s3, u_label_plane_matrix: a3, u_coord_matrix: l2, u_is_text: +c3, u_pitch_with_map: +r3, u_texsize: h3, u_texture: 0, u_tile_id: [0, 0, 0], u_zoom_transition: 0, u_inv_rot_matrix: eo, u_merc_center: [0, 0], u_camera_forward: [0, 0, 0], u_ecef_origin: [0, 0, 0], u_tile_matrix: eo, u_up_vector: [0, -1, 0] };
          return "globe" === f3.name && (v3.u_tile_id = [u3.canonical.x, u3.canonical.y, 1 << u3.canonical.z], v3.u_zoom_transition = _2, v3.u_inv_rot_matrix = p3, v3.u_merc_center = d3, v3.u_camera_forward = g3._camera.forward(), v3.u_ecef_origin = e2.globeECEFOrigin(g3.globeMatrix, u3.toUnwrapped()), v3.u_tile_matrix = Float32Array.from(g3.globeMatrix), v3.u_up_vector = m3), v3;
        }, io = (t3, i3, o3, r3, n3, s3, a3, l2, c3, h3, u3, _2, d3, p3, m3, f3, g3) => e2.extend(to(t3, i3, o3, r3, n3, s3, a3, l2, c3, h3, _2, d3, p3, m3, f3, g3), { u_gamma_scale: r3 ? n3.transform.cameraToCenterDistance * Math.cos(n3.terrain ? 0 : n3.transform._pitch) : 1, u_device_pixel_ratio: e2.exported.devicePixelRatio, u_is_halo: +u3 }), oo = (t3, i3, o3, r3, n3, s3, a3, l2, c3, h3, u3, _2, d3, p3, m3, f3) => e2.extend(io(t3, i3, o3, r3, n3, s3, a3, l2, true, c3, true, u3, _2, d3, p3, m3, f3), { u_texsize_icon: h3, u_texture_icon: 1 }), ro = (e3, t3, i3) => ({ u_matrix: e3, u_opacity: t3, u_color: i3 }), no = (t3, i3, o3, r3, n3) => e2.extend(function(e3, t4, i4) {
          const o4 = t4.imageManager.getPattern(e3.toString()), { width: r4, height: n4 } = t4.imageManager.getPixelSize(), s3 = Math.pow(2, i4.tileID.overscaledZ), a3 = i4.tileSize * Math.pow(2, t4.transform.tileZoom) / s3, l2 = a3 * (i4.tileID.canonical.x + i4.tileID.wrap * s3), c3 = a3 * i4.tileID.canonical.y;
          return { u_image: 0, u_pattern_tl: o4.tl, u_pattern_br: o4.br, u_texsize: [r4, n4], u_pattern_size: o4.displaySize, u_tile_units_to_pixels: 1 / D(i4, 1, t4.transform.tileZoom), u_pixel_coord_upper: [l2 >> 16, c3 >> 16], u_pixel_coord_lower: [65535 & l2, 65535 & c3] };
        }(r3, o3, n3), { u_matrix: t3, u_opacity: i3 }), so = { fillExtrusion: (t3) => ({ u_matrix: new e2.UniformMatrix4f(t3), u_lightpos: new e2.Uniform3f(t3), u_lightintensity: new e2.Uniform1f(t3), u_lightcolor: new e2.Uniform3f(t3), u_vertical_gradient: new e2.Uniform1f(t3), u_opacity: new e2.Uniform1f(t3), u_edge_radius: new e2.Uniform1f(t3), u_ao: new e2.Uniform2f(t3), u_tile_id: new e2.Uniform3f(t3), u_zoom_transition: new e2.Uniform1f(t3), u_inv_rot_matrix: new e2.UniformMatrix4f(t3), u_merc_center: new e2.Uniform2f(t3), u_up_dir: new e2.Uniform3f(t3), u_height_lift: new e2.Uniform1f(t3) }), fillExtrusionPattern: (t3) => ({ u_matrix: new e2.UniformMatrix4f(t3), u_lightpos: new e2.Uniform3f(t3), u_lightintensity: new e2.Uniform1f(t3), u_lightcolor: new e2.Uniform3f(t3), u_vertical_gradient: new e2.Uniform1f(t3), u_height_factor: new e2.Uniform1f(t3), u_edge_radius: new e2.Uniform1f(t3), u_ao: new e2.Uniform2f(t3), u_tile_id: new e2.Uniform3f(t3), u_zoom_transition: new e2.Uniform1f(t3), u_inv_rot_matrix: new e2.UniformMatrix4f(t3), u_merc_center: new e2.Uniform2f(t3), u_up_dir: new e2.Uniform3f(t3), u_height_lift: new e2.Uniform1f(t3), u_image: new e2.Uniform1i(t3), u_texsize: new e2.Uniform2f(t3), u_pixel_coord_upper: new e2.Uniform2f(t3), u_pixel_coord_lower: new e2.Uniform2f(t3), u_tile_units_to_pixels: new e2.Uniform1f(t3), u_opacity: new e2.Uniform1f(t3) }), fill: (t3) => ({ u_matrix: new e2.UniformMatrix4f(t3) }), fillPattern: (t3) => ({ u_matrix: new e2.UniformMatrix4f(t3), u_image: new e2.Uniform1i(t3), u_texsize: new e2.Uniform2f(t3), u_pixel_coord_upper: new e2.Uniform2f(t3), u_pixel_coord_lower: new e2.Uniform2f(t3), u_tile_units_to_pixels: new e2.Uniform1f(t3) }), fillOutline: (t3) => ({ u_matrix: new e2.UniformMatrix4f(t3), u_world: new e2.Uniform2f(t3) }), fillOutlinePattern: (t3) => ({ u_matrix: new e2.UniformMatrix4f(t3), u_world: new e2.Uniform2f(t3), u_image: new e2.Uniform1i(t3), u_texsize: new e2.Uniform2f(t3), u_pixel_coord_upper: new e2.Uniform2f(t3), u_pixel_coord_lower: new e2.Uniform2f(t3), u_tile_units_to_pixels: new e2.Uniform1f(t3) }), circle: (t3) => ({ u_camera_to_center_distance: new e2.Uniform1f(t3), u_extrude_scale: new e2.UniformMatrix2f(t3), u_device_pixel_ratio: new e2.Uniform1f(t3), u_matrix: new e2.UniformMatrix4f(t3), u_inv_rot_matrix: new e2.UniformMatrix4f(t3), u_merc_center: new e2.Uniform2f(t3), u_tile_id: new e2.Uniform3f(t3), u_zoom_transition: new e2.Uniform1f(t3), u_up_dir: new e2.Uniform3f(t3) }), collisionBox: (t3) => ({ u_matrix: new e2.UniformMatrix4f(t3), u_camera_to_center_distance: new e2.Uniform1f(t3), u_extrude_scale: new e2.Uniform2f(t3) }), collisionCircle: (t3) => ({ u_matrix: new e2.UniformMatrix4f(t3), u_inv_matrix: new e2.UniformMatrix4f(t3), u_camera_to_center_distance: new e2.Uniform1f(t3), u_viewport_size: new e2.Uniform2f(t3) }), debug: (t3) => ({ u_color: new e2.UniformColor(t3), u_matrix: new e2.UniformMatrix4f(t3), u_overlay: new e2.Uniform1i(t3), u_overlay_scale: new e2.Uniform1f(t3) }), clippingMask: (t3) => ({ u_matrix: new e2.UniformMatrix4f(t3) }), heatmap: (t3) => ({ u_extrude_scale: new e2.Uniform1f(t3), u_intensity: new e2.Uniform1f(t3), u_matrix: new e2.UniformMatrix4f(t3), u_inv_rot_matrix: new e2.UniformMatrix4f(t3), u_merc_center: new e2.Uniform2f(t3), u_tile_id: new e2.Uniform3f(t3), u_zoom_transition: new e2.Uniform1f(t3), u_up_dir: new e2.Uniform3f(t3) }), heatmapTexture: (t3) => ({ u_image: new e2.Uniform1i(t3), u_color_ramp: new e2.Uniform1i(t3), u_opacity: new e2.Uniform1f(t3) }), hillshade: (t3) => ({ u_matrix: new e2.UniformMatrix4f(t3), u_image: new e2.Uniform1i(t3), u_latrange: new e2.Uniform2f(t3), u_light: new e2.Uniform2f(t3), u_shadow: new e2.UniformColor(t3), u_highlight: new e2.UniformColor(t3), u_accent: new e2.UniformColor(t3) }), hillshadePrepare: (t3) => ({ u_matrix: new e2.UniformMatrix4f(t3), u_image: new e2.Uniform1i(t3), u_dimension: new e2.Uniform2f(t3), u_zoom: new e2.Uniform1f(t3), u_unpack: new e2.Uniform4f(t3) }), line: (t3) => ({ u_matrix: new e2.UniformMatrix4f(t3), u_pixels_to_tile_units: new e2.UniformMatrix2f(t3), u_device_pixel_ratio: new e2.Uniform1f(t3), u_units_to_pixels: new e2.Uniform2f(t3), u_dash_image: new e2.Uniform1i(t3), u_gradient_image: new e2.Uniform1i(t3), u_image_height: new e2.Uniform1f(t3), u_texsize: new e2.Uniform2f(t3), u_tile_units_to_pixels: new e2.Uniform1f(t3), u_alpha_discard_threshold: new e2.Uniform1f(t3), u_trim_offset: new e2.Uniform2f(t3) }), linePattern: (t3) => ({ u_matrix: new e2.UniformMatrix4f(t3), u_texsize: new e2.Uniform2f(t3), u_pixels_to_tile_units: new e2.UniformMatrix2f(t3), u_device_pixel_ratio: new e2.Uniform1f(t3), u_image: new e2.Uniform1i(t3), u_units_to_pixels: new e2.Uniform2f(t3), u_tile_units_to_pixels: new e2.Uniform1f(t3), u_alpha_discard_threshold: new e2.Uniform1f(t3) }), raster: (t3) => ({ u_matrix: new e2.UniformMatrix4f(t3), u_tl_parent: new e2.Uniform2f(t3), u_scale_parent: new e2.Uniform1f(t3), u_fade_t: new e2.Uniform1f(t3), u_opacity: new e2.Uniform1f(t3), u_image0: new e2.Uniform1i(t3), u_image1: new e2.Uniform1i(t3), u_brightness_low: new e2.Uniform1f(t3), u_brightness_high: new e2.Uniform1f(t3), u_saturation_factor: new e2.Uniform1f(t3), u_contrast_factor: new e2.Uniform1f(t3), u_spin_weights: new e2.Uniform3f(t3), u_perspective_transform: new e2.Uniform2f(t3) }), symbolIcon: (t3) => ({ u_is_size_zoom_constant: new e2.Uniform1i(t3), u_is_size_feature_constant: new e2.Uniform1i(t3), u_size_t: new e2.Uniform1f(t3), u_size: new e2.Uniform1f(t3), u_camera_to_center_distance: new e2.Uniform1f(t3), u_rotate_symbol: new e2.Uniform1i(t3), u_aspect_ratio: new e2.Uniform1f(t3), u_fade_change: new e2.Uniform1f(t3), u_matrix: new e2.UniformMatrix4f(t3), u_label_plane_matrix: new e2.UniformMatrix4f(t3), u_coord_matrix: new e2.UniformMatrix4f(t3), u_is_text: new e2.Uniform1i(t3), u_pitch_with_map: new e2.Uniform1i(t3), u_texsize: new e2.Uniform2f(t3), u_tile_id: new e2.Uniform3f(t3), u_zoom_transition: new e2.Uniform1f(t3), u_inv_rot_matrix: new e2.UniformMatrix4f(t3), u_merc_center: new e2.Uniform2f(t3), u_camera_forward: new e2.Uniform3f(t3), u_tile_matrix: new e2.UniformMatrix4f(t3), u_up_vector: new e2.Uniform3f(t3), u_ecef_origin: new e2.Uniform3f(t3), u_texture: new e2.Uniform1i(t3) }), symbolSDF: (t3) => ({ u_is_size_zoom_constant: new e2.Uniform1i(t3), u_is_size_feature_constant: new e2.Uniform1i(t3), u_size_t: new e2.Uniform1f(t3), u_size: new e2.Uniform1f(t3), u_camera_to_center_distance: new e2.Uniform1f(t3), u_rotate_symbol: new e2.Uniform1i(t3), u_aspect_ratio: new e2.Uniform1f(t3), u_fade_change: new e2.Uniform1f(t3), u_matrix: new e2.UniformMatrix4f(t3), u_label_plane_matrix: new e2.UniformMatrix4f(t3), u_coord_matrix: new e2.UniformMatrix4f(t3), u_is_text: new e2.Uniform1i(t3), u_pitch_with_map: new e2.Uniform1i(t3), u_texsize: new e2.Uniform2f(t3), u_texture: new e2.Uniform1i(t3), u_gamma_scale: new e2.Uniform1f(t3), u_device_pixel_ratio: new e2.Uniform1f(t3), u_tile_id: new e2.Uniform3f(t3), u_zoom_transition: new e2.Uniform1f(t3), u_inv_rot_matrix: new e2.UniformMatrix4f(t3), u_merc_center: new e2.Uniform2f(t3), u_camera_forward: new e2.Uniform3f(t3), u_tile_matrix: new e2.UniformMatrix4f(t3), u_up_vector: new e2.Uniform3f(t3), u_ecef_origin: new e2.Uniform3f(t3), u_is_halo: new e2.Uniform1i(t3) }), symbolTextAndIcon: (t3) => ({ u_is_size_zoom_constant: new e2.Uniform1i(t3), u_is_size_feature_constant: new e2.Uniform1i(t3), u_size_t: new e2.Uniform1f(t3), u_size: new e2.Uniform1f(t3), u_camera_to_center_distance: new e2.Uniform1f(t3), u_rotate_symbol: new e2.Uniform1i(t3), u_aspect_ratio: new e2.Uniform1f(t3), u_fade_change: new e2.Uniform1f(t3), u_matrix: new e2.UniformMatrix4f(t3), u_label_plane_matrix: new e2.UniformMatrix4f(t3), u_coord_matrix: new e2.UniformMatrix4f(t3), u_is_text: new e2.Uniform1i(t3), u_pitch_with_map: new e2.Uniform1i(t3), u_texsize: new e2.Uniform2f(t3), u_texsize_icon: new e2.Uniform2f(t3), u_texture: new e2.Uniform1i(t3), u_texture_icon: new e2.Uniform1i(t3), u_gamma_scale: new e2.Uniform1f(t3), u_device_pixel_ratio: new e2.Uniform1f(t3), u_is_halo: new e2.Uniform1i(t3) }), background: (t3) => ({ u_matrix: new e2.UniformMatrix4f(t3), u_opacity: new e2.Uniform1f(t3), u_color: new e2.UniformColor(t3) }), backgroundPattern: (t3) => ({ u_matrix: new e2.UniformMatrix4f(t3), u_opacity: new e2.Uniform1f(t3), u_image: new e2.Uniform1i(t3), u_pattern_tl: new e2.Uniform2f(t3), u_pattern_br: new e2.Uniform2f(t3), u_texsize: new e2.Uniform2f(t3), u_pattern_size: new e2.Uniform2f(t3), u_pixel_coord_upper: new e2.Uniform2f(t3), u_pixel_coord_lower: new e2.Uniform2f(t3), u_tile_units_to_pixels: new e2.Uniform1f(t3) }), terrainRaster: gi, terrainDepth: gi, skybox: (t3) => ({ u_matrix: new e2.UniformMatrix4f(t3), u_sun_direction: new e2.Uniform3f(t3), u_cubemap: new e2.Uniform1i(t3), u_opacity: new e2.Uniform1f(t3), u_temporal_offset: new e2.Uniform1f(t3) }), skyboxGradient: (t3) => ({ u_matrix: new e2.UniformMatrix4f(t3), u_color_ramp: new e2.Uniform1i(t3), u_center_direction: new e2.Uniform3f(t3), u_radius: new e2.Uniform1f(t3), u_opacity: new e2.Uniform1f(t3), u_temporal_offset: new e2.Uniform1f(t3) }), skyboxCapture: (t3) => ({ u_matrix_3f: new e2.UniformMatrix3f(t3), u_sun_direction: new e2.Uniform3f(t3), u_sun_intensity: new e2.Uniform1f(t3), u_color_tint_r: new e2.Uniform4f(t3), u_color_tint_m: new e2.Uniform4f(t3), u_luminance: new e2.Uniform1f(t3) }), globeRaster: (t3) => ({ u_proj_matrix: new e2.UniformMatrix4f(t3), u_globe_matrix: new e2.UniformMatrix4f(t3), u_normalize_matrix: new e2.UniformMatrix4f(t3), u_merc_matrix: new e2.UniformMatrix4f(t3), u_zoom_transition: new e2.Uniform1f(t3), u_merc_center: new e2.Uniform2f(t3), u_image0: new e2.Uniform1i(t3), u_grid_matrix: new e2.UniformMatrix3f(t3), u_skirt_height: new e2.Uniform1f(t3), u_frustum_tl: new e2.Uniform3f(t3), u_frustum_tr: new e2.Uniform3f(t3), u_frustum_br: new e2.Uniform3f(t3), u_frustum_bl: new e2.Uniform3f(t3), u_globe_pos: new e2.Uniform3f(t3), u_globe_radius: new e2.Uniform1f(t3), u_viewport: new e2.Uniform2f(t3) }), globeAtmosphere: (t3) => ({ u_frustum_tl: new e2.Uniform3f(t3), u_frustum_tr: new e2.Uniform3f(t3), u_frustum_br: new e2.Uniform3f(t3), u_frustum_bl: new e2.Uniform3f(t3), u_horizon: new e2.Uniform1f(t3), u_transition: new e2.Uniform1f(t3), u_fadeout_range: new e2.Uniform1f(t3), u_color: new e2.Uniform4f(t3), u_high_color: new e2.Uniform4f(t3), u_space_color: new e2.Uniform4f(t3), u_star_intensity: new e2.Uniform1f(t3), u_star_density: new e2.Uniform1f(t3), u_star_size: new e2.Uniform1f(t3), u_temporal_offset: new e2.Uniform1f(t3), u_horizon_angle: new e2.Uniform1f(t3), u_rotation_matrix: new e2.UniformMatrix4f(t3) }) };
        let ao;
        function lo(t3, i3, o3, r3, n3, s3, a3) {
          const l2 = t3.context, c3 = l2.gl, h3 = t3.transform, u3 = t3.useProgram("collisionBox"), _2 = [];
          let d3 = 0, p3 = 0;
          for (let m4 = 0; m4 < r3.length; m4++) {
            const f4 = r3[m4], g4 = i3.getTile(f4), v4 = g4.getBucket(o3);
            if (!v4)
              continue;
            const x4 = vt(f4, v4, h3);
            let y4 = x4;
            0 === n3[0] && 0 === n3[1] || (y4 = t3.translatePosMatrix(x4, g4, n3, s3));
            const b2 = a3 ? v4.textCollisionBox : v4.iconCollisionBox, w2 = v4.collisionCircleArray;
            if (w2.length > 0) {
              const t4 = e2.create(), i4 = y4;
              e2.mul(t4, v4.placementInvProjMatrix, h3.glCoordMatrix), e2.mul(t4, t4, v4.placementViewportMatrix), _2.push({ circleArray: w2, circleOffset: p3, transform: i4, invTransform: t4, projection: v4.getProjection() }), d3 += w2.length / 4, p3 = d3;
            }
            b2 && (t3.terrain && t3.terrain.setupElevationDraw(g4, u3), u3.draw(l2, c3.LINES, e2.DepthMode.disabled, e2.StencilMode.disabled, t3.colorModeForRenderPass(), e2.CullFaceMode.disabled, Zi(y4, h3, g4, v4.getProjection()), o3.id, b2.layoutVertexBuffer, b2.indexBuffer, b2.segments, null, h3.zoom, null, [b2.collisionVertexBuffer, b2.collisionVertexBufferExt]));
          }
          if (!a3 || !_2.length)
            return;
          const m3 = t3.useProgram("collisionCircle"), f3 = new e2.StructArrayLayout2f1f2i16();
          f3.resize(4 * d3), f3._trim();
          let g3 = 0;
          for (const e3 of _2)
            for (let t4 = 0; t4 < e3.circleArray.length / 4; t4++) {
              const i4 = 4 * t4, o4 = e3.circleArray[i4 + 0], r4 = e3.circleArray[i4 + 1], n4 = e3.circleArray[i4 + 2], s4 = e3.circleArray[i4 + 3];
              f3.emplace(g3++, o4, r4, n4, s4, 0), f3.emplace(g3++, o4, r4, n4, s4, 1), f3.emplace(g3++, o4, r4, n4, s4, 2), f3.emplace(g3++, o4, r4, n4, s4, 3);
            }
          (!ao || ao.length < 2 * d3) && (ao = function(t4) {
            const i4 = 2 * t4, o4 = new e2.StructArrayLayout3ui6();
            o4.resize(i4), o4._trim();
            for (let e3 = 0; e3 < i4; e3++) {
              const t5 = 6 * e3;
              o4.uint16[t5 + 0] = 4 * e3 + 0, o4.uint16[t5 + 1] = 4 * e3 + 1, o4.uint16[t5 + 2] = 4 * e3 + 2, o4.uint16[t5 + 3] = 4 * e3 + 2, o4.uint16[t5 + 4] = 4 * e3 + 3, o4.uint16[t5 + 5] = 4 * e3 + 0;
            }
            return o4;
          }(d3));
          const v3 = l2.createIndexBuffer(ao, true), x3 = l2.createVertexBuffer(f3, e2.collisionCircleLayout.members, true);
          for (const i4 of _2) {
            const r4 = { u_matrix: i4.transform, u_inv_matrix: i4.invTransform, u_camera_to_center_distance: (y3 = h3).getCameraToCenterDistance(i4.projection), u_viewport_size: [y3.width, y3.height] };
            m3.draw(l2, c3.TRIANGLES, e2.DepthMode.disabled, e2.StencilMode.disabled, t3.colorModeForRenderPass(), e2.CullFaceMode.disabled, r4, o3.id, x3, v3, e2.SegmentVector.simpleSegment(0, 2 * i4.circleOffset, i4.circleArray.length, i4.circleArray.length / 2), null, h3.zoom);
          }
          var y3;
          x3.destroy(), v3.destroy();
        }
        const co = e2.create();
        function ho({ width: t3, height: i3, anchor: o3, textOffset: r3, textScale: n3 }, s3) {
          const { horizontalAlign: a3, verticalAlign: l2 } = e2.getAnchorAlignment(o3), c3 = -(a3 - 0.5) * t3, h3 = -(l2 - 0.5) * i3, u3 = e2.evaluateVariableOffset(o3, r3);
          return new e2.Point((c3 / n3 + u3[0]) * s3, (h3 / n3 + u3[1]) * s3);
        }
        function uo(t3, i3, o3, r3, n3, s3, a3, l2, c3, h3, u3) {
          const _2 = t3.text.placedSymbolArray, d3 = t3.text.dynamicLayoutVertexArray, p3 = t3.icon.dynamicLayoutVertexArray, m3 = {}, f3 = t3.getProjection(), g3 = xt(l2, f3, s3), v3 = s3.elevation, x3 = f3.upVectorScale(l2.canonical, s3.center.lat, s3.worldSize).metersToTile;
          d3.clear();
          for (let p4 = 0; p4 < _2.length; p4++) {
            const y3 = _2.get(p4), { tileAnchorX: b2, tileAnchorY: w2, numGlyphs: T2 } = y3, E3 = y3.hidden || !y3.crossTileID || t3.allowVerticalPlacement && !y3.placedOrientation ? null : r3[y3.crossTileID];
            if (E3) {
              let r4 = 0, _3 = 0, p5 = 0;
              if (v3) {
                const e3 = v3 ? v3.getAtTileOffset(l2, b2, w2) : 0, [t4, i4, o4] = f3.upVector(l2.canonical, b2, w2);
                r4 = e3 * t4 * x3, _3 = e3 * i4 * x3, p5 = e3 * o4 * x3;
              }
              let [C2, M2, I2, P2] = ot(y3.projectedAnchorX + r4, y3.projectedAnchorY + _3, y3.projectedAnchorZ + p5, o3 ? g3 : a3);
              const S2 = rt(s3.getCameraToCenterDistance(f3), P2);
              let D2 = n3.evaluateSizeForFeature(t3.textSizeData, h3, y3) * S2 / e2.ONE_EM;
              o3 && (D2 *= t3.tilePixelRatio / c3);
              const L2 = ho(E3, D2);
              o3 ? ({ x: C2, y: M2, z: I2 } = f3.projectTilePoint(b2 + L2.x, w2 + L2.y, l2.canonical), [C2, M2, I2] = ot(C2 + r4, M2 + _3, I2 + p5, a3)) : (i3 && L2._rotate(-s3.angle), C2 += L2.x, M2 += L2.y, I2 = 0);
              const A2 = t3.allowVerticalPlacement && y3.placedOrientation === e2.WritingMode.vertical ? Math.PI / 2 : 0;
              for (let t4 = 0; t4 < T2; t4++)
                e2.addDynamicAttributes(d3, C2, M2, I2, A2);
              u3 && y3.associatedIconIndex >= 0 && (m3[y3.associatedIconIndex] = { x: C2, y: M2, z: I2, angle: A2 });
            } else
              dt(T2, d3);
          }
          if (u3) {
            p3.clear();
            const i4 = t3.icon.placedSymbolArray;
            for (let t4 = 0; t4 < i4.length; t4++) {
              const o4 = i4.get(t4), { numGlyphs: r4 } = o4, n4 = m3[t4];
              if (o4.hidden || !n4)
                dt(r4, p3);
              else {
                const { x: t5, y: i5, z: o5, angle: s4 } = n4;
                for (let n5 = 0; n5 < r4; n5++)
                  e2.addDynamicAttributes(p3, t5, i5, o5, s4);
              }
            }
            t3.icon.dynamicLayoutVertexBuffer.updateData(p3);
          }
          t3.text.dynamicLayoutVertexBuffer.updateData(d3);
        }
        function _o(e3, t3, i3) {
          return i3.iconsInText && t3 ? "symbolTextAndIcon" : e3 ? "symbolSDF" : "symbolIcon";
        }
        function po(t3, i3, o3, r3, n3, s3, a3, l2, c3, h3, u3, _2) {
          const d3 = t3.context, p3 = d3.gl, m3 = t3.transform, f3 = "map" === l2, g3 = "map" === c3, v3 = f3 && "point" !== o3.layout.get("symbol-placement"), x3 = f3 && !g3 && !v3, y3 = void 0 !== o3.layout.get("symbol-sort-key").constantOr(1);
          let b2 = false;
          const w2 = t3.depthModeForSublayer(0, e2.DepthMode.ReadOnly), T2 = [e2.mercatorXfromLng(m3.center.lng), e2.mercatorYfromLat(m3.center.lat)], E3 = o3.layout.get("text-variable-anchor"), C2 = "globe" === m3.projection.name, M2 = [], I2 = [0, -1, 0];
          let P2 = I2;
          !C2 && !m3.mercatorFromTransition || f3 || (P2 = function(t4) {
            const i4 = t4._camera.getWorldToCamera(t4.worldSize, 1), o4 = e2.multiply([], i4, t4.globeMatrix);
            e2.invert(o4, o4);
            const r4 = [0, 0, 0], n4 = [0, 1, 0, 0];
            return e2.transformMat4$1(n4, n4, o4), r4[0] = n4[0], r4[1] = n4[1], r4[2] = n4[2], e2.normalize(r4, r4), r4;
          }(m3));
          for (const l3 of r3) {
            const r4 = i3.getTile(l3), c4 = r4.getBucket(o3);
            if (!c4)
              continue;
            if ("mercator" === c4.projection.name && C2)
              continue;
            const u4 = n3 ? c4.text : c4.icon;
            if (!u4 || c4.fullyClipped || !u4.segments.get().length)
              continue;
            const _3 = u4.programConfigurations.get(o3.id), d4 = n3 || c4.sdfIcons, w3 = n3 ? c4.textSizeData : c4.iconSizeData, S2 = g3 || 0 !== m3.pitch, D2 = e2.evaluateSizeForZoom(w3, m3.zoom);
            let L2, A2, z2, R2, O2 = [0, 0], B2 = null;
            if (n3)
              A2 = r4.glyphAtlasTexture, z2 = p3.LINEAR, L2 = r4.glyphAtlasTexture.size, c4.iconsInText && (O2 = r4.imageAtlasTexture.size, B2 = r4.imageAtlasTexture, R2 = S2 || t3.options.rotating || t3.options.zooming || "composite" === w3.kind || "camera" === w3.kind ? p3.LINEAR : p3.NEAREST);
            else {
              const e3 = 1 !== o3.layout.get("icon-size").constantOr(0) || c4.iconsNeedLinear;
              A2 = r4.imageAtlasTexture, z2 = d4 || t3.options.rotating || t3.options.zooming || e3 || S2 ? p3.LINEAR : p3.NEAREST, L2 = r4.imageAtlasTexture.size;
            }
            const k2 = "globe" === c4.projection.name, F2 = k2 ? P2 : I2, U2 = k2 ? e2.globeToMercatorTransition(m3.zoom) : 0, N2 = xt(l3, c4.getProjection(), m3), j2 = m3.calculatePixelsToTileUnitsMatrix(r4), G2 = et(N2, r4.tileID.canonical, g3, f3, m3, c4.getProjection(), j2), Z2 = t3.terrain && g3 && v3 ? e2.invert(e2.create(), G2) : co, V2 = it(N2, r4.tileID.canonical, g3, f3, m3, c4.getProjection(), j2), W2 = E3 && c4.hasTextData(), X2 = "none" !== o3.layout.get("icon-text-fit") && W2 && c4.hasIconData();
            if (v3) {
              const e3 = m3.elevation, i4 = e3 ? e3.getAtTileOffsetFunc(l3, m3.center.lat, m3.worldSize, c4.getProjection()) : null, o4 = tt(N2, r4.tileID.canonical, g3, f3, m3, c4.getProjection(), j2);
              st(c4, N2, t3, n3, o4, V2, g3, h3, i4, l3);
            }
            const q2 = v3 || n3 && E3 || X2, $2 = t3.translatePosMatrix(N2, r4, s3, a3), H2 = q2 ? co : G2, Y2 = t3.translatePosMatrix(V2, r4, s3, a3, true), K2 = c4.getProjection().createInversionMatrix(m3, l3.canonical), J2 = [];
            t3.terrainRenderModeElevated() && g3 && J2.push("PITCH_WITH_MAP_TERRAIN"), k2 && J2.push("PROJECTION_GLOBE_VIEW"), q2 && J2.push("PROJECTED_POS_ON_VIEWPORT");
            const Q2 = d4 && 0 !== o3.paint.get(n3 ? "text-halo-width" : "icon-halo-width").constantOr(1);
            let ee2;
            ee2 = d4 ? c4.iconsInText ? oo(w3.kind, D2, x3, g3, t3, $2, H2, Y2, L2, O2, l3, U2, T2, K2, F2, c4.getProjection()) : io(w3.kind, D2, x3, g3, t3, $2, H2, Y2, n3, L2, true, l3, U2, T2, K2, F2, c4.getProjection()) : to(w3.kind, D2, x3, g3, t3, $2, H2, Y2, n3, L2, l3, U2, T2, K2, F2, c4.getProjection());
            const te2 = { program: t3.useProgram(_o(d4, n3, c4), _3, J2), buffers: u4, uniformValues: ee2, atlasTexture: A2, atlasTextureIcon: B2, atlasInterpolation: z2, atlasInterpolationIcon: R2, isSDF: d4, hasHalo: Q2, tile: r4, labelPlaneMatrixInv: Z2 };
            if (y3 && c4.canOverlap) {
              b2 = true;
              const t4 = u4.segments.get();
              for (const i4 of t4)
                M2.push({ segments: new e2.SegmentVector([i4]), sortKey: i4.sortKey, state: te2 });
            } else
              M2.push({ segments: u4.segments, sortKey: 0, state: te2 });
          }
          b2 && M2.sort((e3, t4) => e3.sortKey - t4.sortKey);
          for (const e3 of M2) {
            const i4 = e3.state;
            if (t3.terrain && t3.terrain.setupElevationDraw(i4.tile, i4.program, { useDepthForOcclusion: !C2, labelPlaneMatrixInv: i4.labelPlaneMatrixInv }), d3.activeTexture.set(p3.TEXTURE0), i4.atlasTexture.bind(i4.atlasInterpolation, p3.CLAMP_TO_EDGE), i4.atlasTextureIcon && (d3.activeTexture.set(p3.TEXTURE1), i4.atlasTextureIcon && i4.atlasTextureIcon.bind(i4.atlasInterpolationIcon, p3.CLAMP_TO_EDGE)), i4.isSDF) {
              const r4 = i4.uniformValues;
              i4.hasHalo && (r4.u_is_halo = 1, mo(i4.buffers, e3.segments, o3, t3, i4.program, w2, u3, _2, r4)), r4.u_is_halo = 0;
            }
            mo(i4.buffers, e3.segments, o3, t3, i4.program, w2, u3, _2, i4.uniformValues);
          }
        }
        function mo(t3, i3, o3, r3, n3, s3, a3, l2, c3) {
          const h3 = r3.context, u3 = [t3.dynamicLayoutVertexBuffer, t3.opacityVertexBuffer, t3.globeExtVertexBuffer];
          n3.draw(h3, h3.gl.TRIANGLES, s3, a3, l2, e2.CullFaceMode.disabled, c3, o3.id, t3.layoutVertexBuffer, t3.indexBuffer, i3, o3.paint, r3.transform.zoom, t3.programConfigurations.get(o3.id), u3);
        }
        function fo(t3, i3, o3, r3, n3, s3, a3) {
          const l2 = t3.context.gl, c3 = o3.paint.get("fill-pattern"), h3 = c3 && c3.constantOr(1);
          let u3, _2, d3, p3, m3;
          a3 ? (_2 = h3 && !o3.getPaintProperty("fill-outline-color") ? "fillOutlinePattern" : "fillOutline", u3 = l2.LINES) : (_2 = h3 ? "fillPattern" : "fill", u3 = l2.TRIANGLES);
          for (const f3 of r3) {
            const r4 = i3.getTile(f3);
            if (h3 && !r4.patternsLoaded())
              continue;
            const g3 = r4.getBucket(o3);
            if (!g3)
              continue;
            t3.prepareDrawTile();
            const v3 = g3.programConfigurations.get(o3.id), x3 = t3.useProgram(_2, v3);
            h3 && (t3.context.activeTexture.set(l2.TEXTURE0), r4.imageAtlasTexture.bind(l2.LINEAR, l2.CLAMP_TO_EDGE), v3.updatePaintBuffers());
            const y3 = c3.constantOr(null);
            if (y3 && r4.imageAtlas) {
              const e3 = r4.imageAtlas.patternPositions[y3.toString()];
              e3 && v3.setConstantPatternPositions(e3);
            }
            const b2 = t3.translatePosMatrix(f3.projMatrix, r4, o3.paint.get("fill-translate"), o3.paint.get("fill-translate-anchor"));
            if (a3) {
              p3 = g3.indexBuffer2, m3 = g3.segments2;
              const e3 = t3.terrain && t3.terrain.renderingToTexture ? t3.terrain.drapeBufferSize : [l2.drawingBufferWidth, l2.drawingBufferHeight];
              d3 = "fillOutlinePattern" === _2 && h3 ? Ui(b2, t3, r4, e3) : Fi(b2, e3);
            } else
              p3 = g3.indexBuffer, m3 = g3.segments, d3 = h3 ? ki(b2, t3, r4) : Bi(b2);
            t3.prepareDrawProgram(t3.context, x3, f3.toUnwrapped()), x3.draw(t3.context, u3, n3, t3.stencilModeForClipping(f3), s3, e2.CullFaceMode.disabled, d3, o3.id, g3.layoutVertexBuffer, p3, m3, o3.paint, t3.transform.zoom, v3);
          }
        }
        function go(t3, i3, o3, r3, n3, s3, a3) {
          const l2 = t3.context, c3 = l2.gl, h3 = t3.transform, u3 = o3.paint.get("fill-extrusion-pattern"), _2 = u3.constantOr(1), d3 = o3.paint.get("fill-extrusion-opacity"), p3 = [o3.paint.get("fill-extrusion-ambient-occlusion-intensity"), o3.paint.get("fill-extrusion-ambient-occlusion-radius")], m3 = o3.layout.get("fill-extrusion-edge-radius"), f3 = m3 > 0 && !o3.paint.get("fill-extrusion-rounded-roof"), g3 = f3 ? 0 : m3, v3 = "globe" === h3.projection.name ? e2.fillExtrusionHeightLift() : 0, x3 = "globe" === h3.projection.name, y3 = x3 ? e2.globeToMercatorTransition(h3.zoom) : 0, b2 = [e2.mercatorXfromLng(h3.center.lng), e2.mercatorYfromLat(h3.center.lat)], w2 = [];
          x3 && w2.push("PROJECTION_GLOBE_VIEW"), p3[0] > 0 && w2.push("FAUX_AO"), f3 && w2.push("ZERO_ROOF_RADIUS");
          for (const m4 of r3) {
            const r4 = i3.getTile(m4), f4 = r4.getBucket(o3);
            if (!f4 || f4.projection.name !== h3.projection.name)
              continue;
            const T2 = f4.programConfigurations.get(o3.id), E3 = t3.useProgram(_2 ? "fillExtrusionPattern" : "fillExtrusion", T2, w2);
            if (t3.terrain) {
              const e3 = t3.terrain;
              if (t3.style.terrainSetForDrapingOnly())
                e3.setupElevationDraw(r4, E3, { useMeterToDem: true });
              else {
                if (!f4.enableTerrain)
                  continue;
                if (e3.setupElevationDraw(r4, E3, { useMeterToDem: true }), vo(l2, i3, m4, f4, o3, e3), !f4.centroidVertexBuffer) {
                  const e4 = E3.attributes.a_centroid_pos;
                  void 0 !== e4 && c3.vertexAttrib2f(e4, 0, 0);
                }
              }
            }
            _2 && (t3.context.activeTexture.set(c3.TEXTURE0), r4.imageAtlasTexture.bind(c3.LINEAR, c3.CLAMP_TO_EDGE), T2.updatePaintBuffers());
            const C2 = u3.constantOr(null);
            if (C2 && r4.imageAtlas) {
              const e3 = r4.imageAtlas.patternPositions[C2.toString()];
              e3 && T2.setConstantPatternPositions(e3);
            }
            const M2 = t3.translatePosMatrix(m4.projMatrix, r4, o3.paint.get("fill-extrusion-translate"), o3.paint.get("fill-extrusion-translate-anchor")), I2 = h3.projection.createInversionMatrix(h3, m4.canonical), P2 = o3.paint.get("fill-extrusion-vertical-gradient"), S2 = _2 ? Oi(M2, t3, P2, d3, p3, g3, m4, r4, v3, y3, b2, I2) : Ri(M2, t3, P2, d3, p3, g3, m4, v3, y3, b2, I2);
            t3.prepareDrawProgram(l2, E3, m4.toUnwrapped());
            const D2 = [];
            t3.terrain && D2.push(f4.centroidVertexBuffer), x3 && D2.push(f4.layoutVertexExtBuffer), E3.draw(l2, l2.gl.TRIANGLES, n3, s3, a3, e2.CullFaceMode.backCCW, S2, o3.id, f4.layoutVertexBuffer, f4.indexBuffer, f4.segments, o3.paint, t3.transform.zoom, T2, D2);
          }
        }
        function vo(t3, i3, o3, r3, n3, s3) {
          const a3 = [(t4) => {
            let i4 = t4.canonical.x - 1, o4 = t4.wrap;
            return i4 < 0 && (i4 = (1 << t4.canonical.z) - 1, o4--), new e2.OverscaledTileID(t4.overscaledZ, o4, t4.canonical.z, i4, t4.canonical.y);
          }, (t4) => {
            let i4 = t4.canonical.x + 1, o4 = t4.wrap;
            return i4 === 1 << t4.canonical.z && (i4 = 0, o4++), new e2.OverscaledTileID(t4.overscaledZ, o4, t4.canonical.z, i4, t4.canonical.y);
          }, (t4) => new e2.OverscaledTileID(t4.overscaledZ, t4.wrap, t4.canonical.z, t4.canonical.x, (0 === t4.canonical.y ? 1 << t4.canonical.z : t4.canonical.y) - 1), (t4) => new e2.OverscaledTileID(t4.overscaledZ, t4.wrap, t4.canonical.z, t4.canonical.x, t4.canonical.y === (1 << t4.canonical.z) - 1 ? 0 : t4.canonical.y + 1)], l2 = (e3) => {
            const t4 = i3.getSource().minzoom, o4 = (e4) => {
              const t5 = i3.getTileByID(e4);
              if (t5 && t5.hasData())
                return t5.getBucket(n3);
            }, r4 = [0, -1, 1];
            for (const i4 of r4) {
              if (e3.overscaledZ + i4 < t4)
                continue;
              const r5 = o4(e3.calculateScaledKey(e3.overscaledZ + i4));
              if (r5)
                return r5;
            }
          }, c3 = [0, 0, 0], h3 = (t4, i4) => (c3[0] = Math.min(t4.min.y, i4.min.y), c3[1] = Math.max(t4.max.y, i4.max.y), c3[2] = e2.EXTENT - i4.min.x > t4.max.x ? i4.min.x - e2.EXTENT : t4.max.x, c3), u3 = (t4, i4) => (c3[0] = Math.min(t4.min.x, i4.min.x), c3[1] = Math.max(t4.max.x, i4.max.x), c3[2] = e2.EXTENT - i4.min.y > t4.max.y ? i4.min.y - e2.EXTENT : t4.max.y, c3), _2 = [(e3, t4) => h3(e3, t4), (e3, t4) => h3(t4, e3), (e3, t4) => u3(e3, t4), (e3, t4) => u3(t4, e3)], d3 = new e2.Point(0, 0);
          let p3, m3, f3;
          const g3 = (t4, i4, r4, n4, a4) => {
            const l3 = [[n4 ? r4 : t4, n4 ? t4 : r4, 0], [n4 ? r4 : i4, n4 ? i4 : r4, 0]], c4 = a4 < 0 ? e2.EXTENT + a4 : a4, h4 = [n4 ? c4 : (t4 + i4) / 2, n4 ? (t4 + i4) / 2 : c4, 0];
            return 0 === r4 && a4 < 0 || 0 !== r4 && a4 > 0 ? s3.getForTilePoints(f3, [h4], true, m3) : l3.push(h4), s3.getForTilePoints(o3, l3, true, p3), Math.max(l3[0][2], l3[1][2], h4[2]) / s3.exaggeration();
          };
          for (let t4 = 0; t4 < 4; t4++) {
            const i4 = (t4 < 2 ? 1 : 5) - t4, n4 = r3.borders[t4];
            if (0 === n4.length)
              continue;
            const c4 = f3 = a3[t4](o3), h4 = l2(c4);
            if (!(h4 && h4 instanceof e2.FillExtrusionBucket && h4.enableTerrain))
              continue;
            if (r3.borderDoneWithNeighborZ[t4] === h4.canonical.z && h4.borderDoneWithNeighborZ[i4] === r3.canonical.z)
              continue;
            if (m3 = s3.findDEMTileFor(c4), !m3 || !m3.dem)
              continue;
            if (!p3) {
              const e3 = s3.findDEMTileFor(o3);
              if (!e3 || !e3.dem)
                return;
              p3 = e3;
            }
            const u4 = h4.borders[i4];
            let v3 = 0;
            const x3 = h4.borderDoneWithNeighborZ[i4] !== r3.canonical.z;
            if (r3.canonical.z === h4.canonical.z) {
              for (let o4 = 0; o4 < n4.length; o4++) {
                const s4 = r3.featuresOnBorder[n4[o4]], a4 = s4.borders[t4];
                let l3;
                for (; v3 < u4.length && (l3 = h4.featuresOnBorder[u4[v3]], !(l3.borders[i4][1] > a4[0] + 3)); )
                  x3 && h4.encodeCentroid(void 0, l3, false), v3++;
                if (l3 && v3 < u4.length) {
                  const o5 = v3;
                  let n5 = 0;
                  for (; !(l3.borders[i4][0] > a4[1] - 3) && (n5++, ++v3 !== u4.length); )
                    l3 = h4.featuresOnBorder[u4[v3]];
                  if (l3 = h4.featuresOnBorder[u4[o5]], s4.intersectsCount() > 1 || l3.intersectsCount() > 1 || 1 !== n5) {
                    1 !== n5 && (v3 = o5), r3.encodeCentroid(void 0, s4, false), x3 && h4.encodeCentroid(void 0, l3, false);
                    continue;
                  }
                  const c5 = _2[t4](s4, l3), p4 = t4 % 2 ? e2.EXTENT - 1 : 0;
                  d3.x = g3(c5[0], Math.min(e2.EXTENT - 1, c5[1]), p4, t4 < 2, c5[2]), d3.y = 0, r3.encodeCentroid(d3, s4, false), x3 && h4.encodeCentroid(d3, l3, false);
                } else
                  r3.encodeCentroid(void 0, s4, false);
              }
              r3.borderDoneWithNeighborZ[t4] = h4.canonical.z, r3.needsCentroidUpdate = true, x3 && (h4.borderDoneWithNeighborZ[i4] = r3.canonical.z, h4.needsCentroidUpdate = true);
            } else {
              for (const e3 of n4)
                r3.encodeCentroid(void 0, r3.featuresOnBorder[e3], false);
              if (x3) {
                for (const e3 of u4)
                  h4.encodeCentroid(void 0, h4.featuresOnBorder[e3], false);
                h4.borderDoneWithNeighborZ[i4] = r3.canonical.z, h4.needsCentroidUpdate = true;
              }
              r3.borderDoneWithNeighborZ[t4] = h4.canonical.z, r3.needsCentroidUpdate = true;
            }
          }
          (r3.needsCentroidUpdate || !r3.centroidVertexBuffer && 0 !== r3.centroidVertexArray.length) && r3.uploadCentroid(t3);
        }
        const xo = new e2.Color(1, 0, 0, 1), yo = new e2.Color(0, 1, 0, 1), bo = new e2.Color(0, 0, 1, 1), wo = new e2.Color(1, 0, 1, 1), To = new e2.Color(0, 1, 1, 1);
        function Eo(t3, i3, o3) {
          const r3 = t3.context, n3 = t3.transform, s3 = r3.gl, a3 = "globe" === n3.projection.name, l2 = a3 ? ["PROJECTION_GLOBE_VIEW"] : null;
          let c3 = o3.projMatrix;
          if (a3 && e2.globeToMercatorTransition(n3.zoom) > 0) {
            const t4 = e2.transitionTileAABBinECEF(o3.canonical, n3), i4 = e2.globeDenormalizeECEF(t4);
            c3 = e2.multiply(new Float32Array(16), n3.globeMatrix, i4), e2.multiply(c3, n3.projMatrix, c3);
          }
          const h3 = t3.useProgram("debug", null, l2), u3 = i3.getTileByID(o3.key);
          t3.terrain && t3.terrain.setupElevationDraw(u3, h3);
          const _2 = e2.DepthMode.disabled, d3 = e2.StencilMode.disabled, p3 = t3.colorModeForRenderPass(), m3 = "$debug";
          r3.activeTexture.set(s3.TEXTURE0), t3.emptyTexture.bind(s3.LINEAR, s3.CLAMP_TO_EDGE), a3 ? u3._makeGlobeTileDebugBuffers(t3.context, n3) : u3._makeDebugTileBoundsBuffers(t3.context, n3.projection);
          const f3 = u3._tileDebugBuffer || t3.debugBuffer, g3 = u3._tileDebugIndexBuffer || t3.debugIndexBuffer, v3 = u3._tileDebugSegments || t3.debugSegments;
          h3.draw(r3, s3.LINE_STRIP, _2, d3, p3, e2.CullFaceMode.disabled, Vi(c3, e2.Color.red), m3, f3, g3, v3, null, null, null, [u3._globeTileDebugBorderBuffer]);
          const x3 = u3.latestRawTileData, y3 = Math.floor((x3 && x3.byteLength || 0) / 1024), b2 = i3.getTile(o3).tileSize, w2 = 512 / Math.min(b2, 512) * (o3.overscaledZ / n3.zoom) * 0.5;
          let T2 = o3.canonical.toString();
          o3.overscaledZ !== o3.canonical.z && (T2 += ` => ${o3.overscaledZ}`), T2 += ` ${y3}kb`, function(e3, t4) {
            e3.initDebugOverlayCanvas();
            const i4 = e3.debugOverlayCanvas, o4 = e3.context.gl, r4 = e3.debugOverlayCanvas.getContext("2d");
            r4.clearRect(0, 0, i4.width, i4.height), r4.shadowColor = "white", r4.shadowBlur = 2, r4.lineWidth = 1.5, r4.strokeStyle = "white", r4.textBaseline = "top", r4.font = "bold 36px Open Sans, sans-serif", r4.fillText(t4, 5, 5), r4.strokeText(t4, 5, 5), e3.debugOverlayTexture.update(i4), e3.debugOverlayTexture.bind(o4.LINEAR, o4.CLAMP_TO_EDGE);
          }(t3, T2);
          const E3 = u3._tileDebugTextBuffer || t3.debugBuffer, C2 = u3._tileDebugTextIndexBuffer || t3.quadTriangleIndexBuffer, M2 = u3._tileDebugTextSegments || t3.debugSegments;
          h3.draw(r3, s3.TRIANGLES, _2, d3, e2.ColorMode.alphaBlended, e2.CullFaceMode.disabled, Vi(c3, e2.Color.transparent, w2), m3, E3, C2, M2, null, null, null, [u3._globeTileDebugTextBuffer]);
        }
        function Co(e3, t3, i3, o3) {
          Io(e3, 0, t3 + i3 / 2, e3.transform.width, i3, o3);
        }
        function Mo(e3, t3, i3, o3) {
          Io(e3, t3 - i3 / 2, 0, i3, e3.transform.height, o3);
        }
        function Io(t3, i3, o3, r3, n3, s3) {
          const a3 = t3.context, l2 = a3.gl;
          l2.enable(l2.SCISSOR_TEST), l2.scissor(i3 * e2.exported.devicePixelRatio, o3 * e2.exported.devicePixelRatio, r3 * e2.exported.devicePixelRatio, n3 * e2.exported.devicePixelRatio), a3.clear({ color: s3 }), l2.disable(l2.SCISSOR_TEST);
        }
        const Po = e2.createLayout([{ name: "a_pos_3f", components: 3, type: "Float32" }]), { members: So } = Po;
        function Do(e3, t3, i3, o3) {
          e3.emplaceBack(t3, i3, o3);
        }
        class Lo {
          constructor(t3) {
            this.vertexArray = new e2.StructArrayLayout3f12(), this.indices = new e2.StructArrayLayout3ui6(), Do(this.vertexArray, -1, -1, 1), Do(this.vertexArray, 1, -1, 1), Do(this.vertexArray, -1, 1, 1), Do(this.vertexArray, 1, 1, 1), Do(this.vertexArray, -1, -1, -1), Do(this.vertexArray, 1, -1, -1), Do(this.vertexArray, -1, 1, -1), Do(this.vertexArray, 1, 1, -1), this.indices.emplaceBack(5, 1, 3), this.indices.emplaceBack(3, 7, 5), this.indices.emplaceBack(6, 2, 0), this.indices.emplaceBack(0, 4, 6), this.indices.emplaceBack(2, 6, 7), this.indices.emplaceBack(7, 3, 2), this.indices.emplaceBack(5, 4, 0), this.indices.emplaceBack(0, 1, 5), this.indices.emplaceBack(0, 2, 3), this.indices.emplaceBack(3, 1, 0), this.indices.emplaceBack(7, 6, 4), this.indices.emplaceBack(4, 5, 7), this.vertexBuffer = t3.createVertexBuffer(this.vertexArray, So), this.indexBuffer = t3.createIndexBuffer(this.indices), this.segment = e2.SegmentVector.simpleSegment(0, 0, 36, 12);
          }
        }
        function Ao(t3, i3, o3, r3, n3, s3) {
          const a3 = t3.gl, l2 = i3.paint.get("sky-atmosphere-color"), c3 = i3.paint.get("sky-atmosphere-halo-color"), h3 = i3.paint.get("sky-atmosphere-sun-intensity"), u3 = ((e3, t4, i4, o4, r4) => ({ u_matrix_3f: e3, u_sun_direction: t4, u_sun_intensity: i4, u_color_tint_r: [o4.r, o4.g, o4.b, o4.a], u_color_tint_m: [r4.r, r4.g, r4.b, r4.a], u_luminance: 5e-5 }))(e2.fromMat4(e2.create$1(), r3), n3, h3, l2, c3);
          a3.framebufferTexture2D(a3.FRAMEBUFFER, a3.COLOR_ATTACHMENT0, a3.TEXTURE_CUBE_MAP_POSITIVE_X + s3, i3.skyboxTexture, 0), o3.draw(t3, a3.TRIANGLES, e2.DepthMode.disabled, e2.StencilMode.disabled, e2.ColorMode.unblended, e2.CullFaceMode.frontCW, u3, "skyboxCapture", i3.skyboxGeometry.vertexBuffer, i3.skyboxGeometry.indexBuffer, i3.skyboxGeometry.segment);
        }
        const zo = e2.createLayout([{ type: "Float32", name: "a_pos", components: 3 }, { type: "Float32", name: "a_uv", components: 2 }]);
        class Ro {
          constructor(t3) {
            const i3 = new e2.StructArrayLayout5f20();
            i3.emplaceBack(-1, 1, 1, 0, 0), i3.emplaceBack(1, 1, 1, 1, 0), i3.emplaceBack(1, -1, 1, 1, 1), i3.emplaceBack(-1, -1, 1, 0, 1);
            const o3 = new e2.StructArrayLayout3ui6();
            o3.emplaceBack(0, 1, 2), o3.emplaceBack(2, 3, 0), this.vertexBuffer = t3.createVertexBuffer(i3, zo.members), this.indexBuffer = t3.createIndexBuffer(o3), this.segments = e2.SegmentVector.simpleSegment(0, 0, 4, 2);
          }
          destroy() {
            this.vertexBuffer.destroy(), this.indexBuffer.destroy(), this.segments.destroy();
          }
        }
        const Oo = { symbol: function(t3, i3, o3, r3, n3) {
          if ("translucent" !== t3.renderPass)
            return;
          const s3 = e2.StencilMode.disabled, a3 = t3.colorModeForRenderPass();
          o3.layout.get("text-variable-anchor") && function(t4, i4, o4, r4, n4, s4, a4) {
            const l2 = i4.transform, c3 = "map" === n4, h3 = "map" === s4;
            for (const i5 of t4) {
              const t5 = r4.getTile(i5), n5 = t5.getBucket(o4);
              if (!n5 || !n5.text || !n5.text.segments.get().length)
                continue;
              const s5 = e2.evaluateSizeForZoom(n5.textSizeData, l2.zoom), u3 = xt(i5, n5.getProjection(), l2), _2 = l2.calculatePixelsToTileUnitsMatrix(t5), d3 = et(u3, t5.tileID.canonical, h3, c3, l2, n5.getProjection(), _2), p3 = "none" !== o4.layout.get("icon-text-fit") && n5.hasIconData();
              if (s5) {
                const o5 = Math.pow(2, l2.zoom - t5.tileID.overscaledZ);
                uo(n5, c3, h3, a4, e2.symbolSize, l2, d3, i5, o5, s5, p3);
              }
            }
          }(r3, t3, o3, i3, o3.layout.get("text-rotation-alignment"), o3.layout.get("text-pitch-alignment"), n3), 0 !== o3.paint.get("icon-opacity").constantOr(1) && po(t3, i3, o3, r3, false, o3.paint.get("icon-translate"), o3.paint.get("icon-translate-anchor"), o3.layout.get("icon-rotation-alignment"), o3.layout.get("icon-pitch-alignment"), o3.layout.get("icon-keep-upright"), s3, a3), 0 !== o3.paint.get("text-opacity").constantOr(1) && po(t3, i3, o3, r3, true, o3.paint.get("text-translate"), o3.paint.get("text-translate-anchor"), o3.layout.get("text-rotation-alignment"), o3.layout.get("text-pitch-alignment"), o3.layout.get("text-keep-upright"), s3, a3), i3.map.showCollisionBoxes && (lo(t3, i3, o3, r3, o3.paint.get("text-translate"), o3.paint.get("text-translate-anchor"), true), lo(t3, i3, o3, r3, o3.paint.get("icon-translate"), o3.paint.get("icon-translate-anchor"), false));
        }, circle: function(t3, i3, o3, r3) {
          if ("translucent" !== t3.renderPass)
            return;
          const n3 = o3.paint.get("circle-opacity"), s3 = o3.paint.get("circle-stroke-width"), a3 = o3.paint.get("circle-stroke-opacity"), l2 = void 0 !== o3.layout.get("circle-sort-key").constantOr(1);
          if (0 === n3.constantOr(1) && (0 === s3.constantOr(1) || 0 === a3.constantOr(1)))
            return;
          const c3 = t3.context, h3 = c3.gl, u3 = t3.transform, _2 = t3.depthModeForSublayer(0, e2.DepthMode.ReadOnly), d3 = e2.StencilMode.disabled, p3 = t3.colorModeForRenderPass(), m3 = "globe" === u3.projection.name, f3 = [e2.mercatorXfromLng(u3.center.lng), e2.mercatorYfromLat(u3.center.lat)], g3 = [];
          for (let n4 = 0; n4 < r3.length; n4++) {
            const s4 = r3[n4], a4 = i3.getTile(s4), c4 = a4.getBucket(o3);
            if (!c4 || c4.projection.name !== u3.projection.name)
              continue;
            const h4 = c4.programConfigurations.get(o3.id), _3 = Gi(o3);
            m3 && _3.push("PROJECTION_GLOBE_VIEW");
            const d4 = t3.useProgram("circle", h4, _3), p4 = c4.layoutVertexBuffer, v4 = c4.globeExtVertexBuffer, x3 = c4.indexBuffer, y3 = u3.projection.createInversionMatrix(u3, s4.canonical), b2 = { programConfiguration: h4, program: d4, layoutVertexBuffer: p4, globeExtVertexBuffer: v4, indexBuffer: x3, uniformValues: ji(t3, s4, a4, y3, f3, o3), tile: a4 };
            if (l2) {
              const t4 = c4.segments.get();
              for (const i4 of t4)
                g3.push({ segments: new e2.SegmentVector([i4]), sortKey: i4.sortKey, state: b2 });
            } else
              g3.push({ segments: c4.segments, sortKey: 0, state: b2 });
          }
          l2 && g3.sort((e3, t4) => e3.sortKey - t4.sortKey);
          const v3 = { useDepthForOcclusion: !m3 };
          for (const i4 of g3) {
            const { programConfiguration: r4, program: n4, layoutVertexBuffer: s4, globeExtVertexBuffer: a4, indexBuffer: l3, uniformValues: m4, tile: f4 } = i4.state, g4 = i4.segments;
            t3.terrain && t3.terrain.setupElevationDraw(f4, n4, v3), t3.prepareDrawProgram(c3, n4, f4.tileID.toUnwrapped()), n4.draw(c3, h3.TRIANGLES, _2, d3, p3, e2.CullFaceMode.disabled, m4, o3.id, s4, l3, g4, o3.paint, u3.zoom, r4, [a4]);
          }
        }, heatmap: function(t3, i3, o3, r3) {
          if (0 !== o3.paint.get("heatmap-opacity"))
            if ("offscreen" === t3.renderPass) {
              const n3 = t3.context, s3 = n3.gl, a3 = e2.StencilMode.disabled, l2 = new e2.ColorMode([s3.ONE, s3.ONE], e2.Color.transparent, [true, true, true, true]);
              !function(e3, t4, i4, o4) {
                const r4 = e3.gl, n4 = t4.width * o4, s4 = t4.height * o4;
                e3.activeTexture.set(r4.TEXTURE1), e3.viewport.set([0, 0, n4, s4]);
                let a4 = i4.heatmapFbo;
                if (!a4 || a4 && (a4.width !== n4 || a4.height !== s4)) {
                  a4 && a4.destroy();
                  const t5 = r4.createTexture();
                  r4.bindTexture(r4.TEXTURE_2D, t5), r4.texParameteri(r4.TEXTURE_2D, r4.TEXTURE_WRAP_S, r4.CLAMP_TO_EDGE), r4.texParameteri(r4.TEXTURE_2D, r4.TEXTURE_WRAP_T, r4.CLAMP_TO_EDGE), r4.texParameteri(r4.TEXTURE_2D, r4.TEXTURE_MIN_FILTER, r4.LINEAR), r4.texParameteri(r4.TEXTURE_2D, r4.TEXTURE_MAG_FILTER, r4.LINEAR), a4 = i4.heatmapFbo = e3.createFramebuffer(n4, s4, false), function(e4, t6, i5, o5, r5, n5) {
                    const s5 = e4.gl;
                    s5.texImage2D(s5.TEXTURE_2D, 0, e4.isWebGL2 && e4.extRenderToTextureHalfFloat ? s5.RGBA16F : s5.RGBA, r5, n5, 0, s5.RGBA, e4.extRenderToTextureHalfFloat ? e4.isWebGL2 ? s5.HALF_FLOAT : e4.extTextureHalfFloat.HALF_FLOAT_OES : s5.UNSIGNED_BYTE, null), o5.colorAttachment.set(i5);
                  }(e3, 0, t5, a4, n4, s4);
                } else
                  r4.bindTexture(r4.TEXTURE_2D, a4.colorAttachment.get()), e3.bindFramebuffer.set(a4.framebuffer);
              }(n3, t3, o3, "globe" === t3.transform.projection.name ? 0.5 : 0.25), n3.clear({ color: e2.Color.transparent });
              const c3 = t3.transform, h3 = "globe" === c3.projection.name, u3 = h3 ? ["PROJECTION_GLOBE_VIEW"] : null, _2 = h3 ? e2.CullFaceMode.frontCCW : e2.CullFaceMode.disabled, d3 = [e2.mercatorXfromLng(c3.center.lng), e2.mercatorYfromLat(c3.center.lat)];
              for (let p3 = 0; p3 < r3.length; p3++) {
                const m3 = r3[p3];
                if (i3.hasRenderableParent(m3))
                  continue;
                const f3 = i3.getTile(m3), g3 = f3.getBucket(o3);
                if (!g3 || g3.projection.name !== c3.projection.name)
                  continue;
                const v3 = g3.programConfigurations.get(o3.id), x3 = t3.useProgram("heatmap", v3, u3), { zoom: y3 } = t3.transform;
                t3.terrain && t3.terrain.setupElevationDraw(f3, x3), t3.prepareDrawProgram(n3, x3, m3.toUnwrapped());
                const b2 = c3.projection.createInversionMatrix(c3, m3.canonical);
                x3.draw(n3, s3.TRIANGLES, e2.DepthMode.disabled, a3, l2, _2, Xi(t3, m3, f3, b2, d3, y3, o3.paint.get("heatmap-intensity")), o3.id, g3.layoutVertexBuffer, g3.indexBuffer, g3.segments, o3.paint, t3.transform.zoom, v3, h3 ? [g3.globeExtVertexBuffer] : null);
              }
              n3.viewport.set([0, 0, t3.width, t3.height]);
            } else
              "translucent" === t3.renderPass && (t3.context.setColorMode(t3.colorModeForRenderPass()), function(t4, i4) {
                const o4 = t4.context, r4 = o4.gl, n3 = i4.heatmapFbo;
                if (!n3)
                  return;
                o4.activeTexture.set(r4.TEXTURE0), r4.bindTexture(r4.TEXTURE_2D, n3.colorAttachment.get()), o4.activeTexture.set(r4.TEXTURE1);
                let s3 = i4.colorRampTexture;
                s3 || (s3 = i4.colorRampTexture = new e2.Texture(o4, i4.colorRamp, r4.RGBA)), s3.bind(r4.LINEAR, r4.CLAMP_TO_EDGE), t4.useProgram("heatmapTexture").draw(o4, r4.TRIANGLES, e2.DepthMode.disabled, e2.StencilMode.disabled, t4.colorModeForRenderPass(), e2.CullFaceMode.disabled, ((e3, t5, i5, o5) => ({ u_image: 0, u_color_ramp: 1, u_opacity: t5.paint.get("heatmap-opacity") }))(0, i4), i4.id, t4.viewportBuffer, t4.quadTriangleIndexBuffer, t4.viewportSegments, i4.paint, t4.transform.zoom);
              }(t3, o3));
        }, line: function(t3, i3, o3, r3) {
          if ("translucent" !== t3.renderPass)
            return;
          const n3 = o3.paint.get("line-opacity"), s3 = o3.paint.get("line-width");
          if (0 === n3.constantOr(1) || 0 === s3.constantOr(1))
            return;
          const a3 = t3.depthModeForSublayer(0, e2.DepthMode.ReadOnly), l2 = t3.colorModeForRenderPass(), c3 = t3.terrain && t3.terrain.renderingToTexture ? 1 : e2.exported.devicePixelRatio, h3 = o3.paint.get("line-dasharray"), u3 = h3.constantOr(1), _2 = o3.layout.get("line-cap"), d3 = o3.paint.get("line-pattern"), p3 = d3.constantOr(1), m3 = o3.paint.get("line-gradient"), f3 = p3 ? "linePattern" : "line", g3 = t3.context, v3 = g3.gl, x3 = ((e3) => {
            const t4 = [];
            Ki(e3) && t4.push("RENDER_LINE_DASH"), e3.paint.get("line-gradient") && t4.push("RENDER_LINE_GRADIENT");
            const i4 = e3.paint.get("line-trim-offset");
            0 === i4[0] && 0 === i4[1] || t4.push("RENDER_LINE_TRIM_OFFSET");
            const o4 = e3.paint.get("line-pattern").constantOr(1), r4 = 1 !== e3.paint.get("line-opacity").constantOr(1);
            return !o4 && r4 && t4.push("RENDER_LINE_ALPHA_DISCARD"), t4;
          })(o3);
          let y3 = x3.includes("RENDER_LINE_ALPHA_DISCARD");
          t3.terrain && t3.terrain.clipOrMaskOverlapStencilType() && (y3 = false);
          for (const n4 of r3) {
            const r4 = i3.getTile(n4);
            if (p3 && !r4.patternsLoaded())
              continue;
            const s4 = r4.getBucket(o3);
            if (!s4)
              continue;
            t3.prepareDrawTile();
            const b2 = s4.programConfigurations.get(o3.id), w2 = t3.useProgram(f3, b2, x3), T2 = d3.constantOr(null);
            if (T2 && r4.imageAtlas) {
              const e3 = r4.imageAtlas.patternPositions[T2.toString()];
              e3 && b2.setConstantPatternPositions(e3);
            }
            const E3 = h3.constantOr(null), C2 = _2.constantOr(null);
            if (!p3 && E3 && C2 && r4.lineAtlas) {
              const e3 = r4.lineAtlas.getDash(E3, C2);
              e3 && b2.setConstantPatternPositions(e3);
            }
            let [M2, I2] = o3.paint.get("line-trim-offset");
            if ("round" === C2 || "square" === C2) {
              const e3 = 1;
              M2 !== I2 && (0 === M2 && (M2 -= e3), 1 === I2 && (I2 += e3));
            }
            const P2 = t3.terrain ? n4.projMatrix : null, S2 = p3 ? $i(t3, r4, o3, P2, c3) : qi(t3, r4, o3, P2, s4.lineClipsArray.length, c3, [M2, I2]);
            if (m3) {
              const r5 = s4.gradients[o3.id];
              let a4 = r5.texture;
              if (o3.gradientVersion !== r5.version) {
                let l3 = 256;
                if (o3.stepInterpolant) {
                  const o4 = i3.getSource().maxzoom, r6 = n4.canonical.z === o4 ? Math.ceil(1 << t3.transform.maxZoom - n4.canonical.z) : 1;
                  l3 = e2.clamp(e2.nextPowerOfTwo(s4.maxLineLength / e2.EXTENT * 1024 * r6), 256, g3.maxTextureSize);
                }
                r5.gradient = e2.renderColorRamp({ expression: o3.gradientExpression(), evaluationKey: "lineProgress", resolution: l3, image: r5.gradient || void 0, clips: s4.lineClipsArray }), r5.texture ? r5.texture.update(r5.gradient) : r5.texture = new e2.Texture(g3, r5.gradient, v3.RGBA), r5.version = o3.gradientVersion, a4 = r5.texture;
              }
              g3.activeTexture.set(v3.TEXTURE1), a4.bind(o3.stepInterpolant ? v3.NEAREST : v3.LINEAR, v3.CLAMP_TO_EDGE);
            }
            u3 && (g3.activeTexture.set(v3.TEXTURE0), r4.lineAtlasTexture.bind(v3.LINEAR, v3.REPEAT), b2.updatePaintBuffers()), p3 && (g3.activeTexture.set(v3.TEXTURE0), r4.imageAtlasTexture.bind(v3.LINEAR, v3.CLAMP_TO_EDGE), b2.updatePaintBuffers()), t3.prepareDrawProgram(g3, w2, n4.toUnwrapped());
            const D2 = (i4) => {
              w2.draw(g3, v3.TRIANGLES, a3, i4, l2, e2.CullFaceMode.disabled, S2, o3.id, s4.layoutVertexBuffer, s4.indexBuffer, s4.segments, o3.paint, t3.transform.zoom, b2, [s4.layoutVertexBuffer2]);
            };
            if (y3) {
              const i4 = t3.stencilModeForClipping(n4).ref;
              0 === i4 && t3.terrain && g3.clear({ stencil: 0 });
              const o4 = { func: v3.EQUAL, mask: 255 };
              S2.u_alpha_discard_threshold = 0.8, D2(new e2.StencilMode(o4, i4, 255, v3.KEEP, v3.KEEP, v3.INVERT)), S2.u_alpha_discard_threshold = 0, D2(new e2.StencilMode(o4, i4, 255, v3.KEEP, v3.KEEP, v3.KEEP));
            } else
              D2(t3.stencilModeForClipping(n4));
          }
          y3 && (t3.resetStencilClippingMasks(), t3.terrain && g3.clear({ stencil: 0 }));
        }, fill: function(t3, i3, o3, r3) {
          const n3 = o3.paint.get("fill-color"), s3 = o3.paint.get("fill-opacity");
          if (0 === s3.constantOr(1))
            return;
          const a3 = t3.colorModeForRenderPass(), l2 = o3.paint.get("fill-pattern"), c3 = t3.opaquePassEnabledForLayer() && !l2.constantOr(1) && 1 === n3.constantOr(e2.Color.transparent).a && 1 === s3.constantOr(0) ? "opaque" : "translucent";
          if (t3.renderPass === c3) {
            const n4 = t3.depthModeForSublayer(1, "opaque" === t3.renderPass ? e2.DepthMode.ReadWrite : e2.DepthMode.ReadOnly);
            fo(t3, i3, o3, r3, n4, a3, false);
          }
          if ("translucent" === t3.renderPass && o3.paint.get("fill-antialias")) {
            const n4 = t3.depthModeForSublayer(o3.getPaintProperty("fill-outline-color") ? 2 : 0, e2.DepthMode.ReadOnly);
            fo(t3, i3, o3, r3, n4, a3, true);
          }
        }, "fill-extrusion": function(t3, i3, o3, r3) {
          const n3 = o3.paint.get("fill-extrusion-opacity");
          if (0 !== n3 && "translucent" === t3.renderPass) {
            const s3 = new e2.DepthMode(t3.context.gl.LEQUAL, e2.DepthMode.ReadWrite, t3.depthRangeFor3D);
            if (1 !== n3 || o3.paint.get("fill-extrusion-pattern").constantOr(1))
              go(t3, i3, o3, r3, s3, e2.StencilMode.disabled, e2.ColorMode.disabled), go(t3, i3, o3, r3, s3, t3.stencilModeFor3D(), t3.colorModeForRenderPass()), t3.resetStencilClippingMasks();
            else {
              const n4 = t3.colorModeForRenderPass();
              go(t3, i3, o3, r3, s3, e2.StencilMode.disabled, n4);
            }
          }
        }, hillshade: function(t3, i3, o3, r3) {
          if ("offscreen" !== t3.renderPass && "translucent" !== t3.renderPass)
            return;
          const n3 = t3.context, s3 = t3.depthModeForSublayer(0, e2.DepthMode.ReadOnly), a3 = t3.colorModeForRenderPass(), l2 = t3.terrain && t3.terrain.renderingToTexture, [c3, h3] = "translucent" !== t3.renderPass || l2 ? [{}, r3] : t3.stencilConfigForOverlap(r3);
          for (const r4 of h3) {
            const n4 = i3.getTile(r4);
            if (n4.needsHillshadePrepare && "offscreen" === t3.renderPass)
              fi(t3, n4, o3, s3, e2.StencilMode.disabled, a3);
            else if ("translucent" === t3.renderPass) {
              const e3 = l2 && t3.terrain ? t3.terrain.stencilModeForRTTOverlap(r4) : c3[r4.overscaledZ];
              pi(t3, r4, n4, o3, s3, e3, a3);
            }
          }
          n3.viewport.set([0, 0, t3.width, t3.height]), t3.resetStencilClippingMasks();
        }, raster: function(t3, i3, o3, r3, n3, s3) {
          if ("translucent" !== t3.renderPass)
            return;
          if (0 === o3.paint.get("raster-opacity"))
            return;
          if (!r3.length)
            return;
          const a3 = t3.context, l2 = a3.gl, c3 = i3.getSource(), h3 = t3.useProgram("raster"), u3 = t3.colorModeForRenderPass(), _2 = t3.terrain && t3.terrain.renderingToTexture, [d3, p3] = c3 instanceof Pe || _2 ? [{}, r3] : t3.stencilConfigForOverlap(r3), m3 = p3[p3.length - 1].overscaledZ, f3 = !t3.options.moving;
          for (const r4 of p3) {
            const n4 = _2 ? e2.DepthMode.disabled : t3.depthModeForSublayer(r4.overscaledZ - m3, 1 === o3.paint.get("raster-opacity") ? e2.DepthMode.ReadWrite : e2.DepthMode.ReadOnly, l2.LESS), p4 = r4.toUnwrapped(), g3 = i3.getTile(r4);
            if (_2 && (!g3 || !g3.hasData()))
              continue;
            const v3 = _2 ? r4.projMatrix : t3.transform.calculateProjMatrix(p4, f3), x3 = t3.terrain && _2 ? t3.terrain.stencilModeForRTTOverlap(r4) : d3[r4.overscaledZ], y3 = s3 ? 0 : o3.paint.get("raster-fade-duration");
            g3.registerFadeDuration(y3);
            const b2 = i3.findLoadedParent(r4, 0), w2 = Mi(g3, b2, i3, t3.transform, y3);
            let T2, E3;
            t3.terrain && t3.terrain.prepareDrawTile();
            const C2 = "nearest" === o3.paint.get("raster-resampling") ? l2.NEAREST : l2.LINEAR;
            a3.activeTexture.set(l2.TEXTURE0), g3.texture.bind(C2, l2.CLAMP_TO_EDGE), a3.activeTexture.set(l2.TEXTURE1), b2 ? (b2.texture.bind(C2, l2.CLAMP_TO_EDGE), T2 = Math.pow(2, b2.tileID.overscaledZ - g3.tileID.overscaledZ), E3 = [g3.tileID.canonical.x * T2 % 1, g3.tileID.canonical.y * T2 % 1]) : g3.texture.bind(C2, l2.CLAMP_TO_EDGE), g3.texture.useMipmap && a3.extTextureFilterAnisotropic && t3.transform.pitch > 20 && l2.texParameterf(l2.TEXTURE_2D, a3.extTextureFilterAnisotropic.TEXTURE_MAX_ANISOTROPY_EXT, a3.extTextureFilterAnisotropicMax);
            const M2 = Ji(v3, E3 || [0, 0], T2 || 1, w2, o3, c3 instanceof Pe ? c3.perspectiveTransform : [0, 0]);
            if (t3.prepareDrawProgram(a3, h3, p4), c3 instanceof Pe)
              c3.boundsBuffer && c3.boundsSegments && h3.draw(a3, l2.TRIANGLES, n4, e2.StencilMode.disabled, u3, e2.CullFaceMode.disabled, M2, o3.id, c3.boundsBuffer, t3.quadTriangleIndexBuffer, c3.boundsSegments);
            else {
              const { tileBoundsBuffer: i4, tileBoundsIndexBuffer: r5, tileBoundsSegments: s4 } = t3.getTileBoundsBuffers(g3);
              h3.draw(a3, l2.TRIANGLES, n4, x3, u3, e2.CullFaceMode.disabled, M2, o3.id, i4, r5, s4);
            }
          }
          t3.resetStencilClippingMasks();
        }, background: function(t3, i3, o3, r3) {
          const n3 = o3.paint.get("background-color"), s3 = o3.paint.get("background-opacity");
          if (0 === s3)
            return;
          const a3 = t3.context, l2 = a3.gl, c3 = t3.transform, h3 = c3.tileSize, u3 = o3.paint.get("background-pattern");
          if (t3.isPatternMissing(u3))
            return;
          const _2 = !u3 && 1 === n3.a && 1 === s3 && t3.opaquePassEnabledForLayer() ? "opaque" : "translucent";
          if (t3.renderPass !== _2)
            return;
          const d3 = e2.StencilMode.disabled, p3 = t3.depthModeForSublayer(0, "opaque" === _2 ? e2.DepthMode.ReadWrite : e2.DepthMode.ReadOnly), m3 = t3.colorModeForRenderPass(), f3 = t3.useProgram(u3 ? "backgroundPattern" : "background");
          let g3, v3 = r3;
          v3 || (g3 = t3.getBackgroundTiles(), v3 = Object.values(g3).map((e3) => e3.tileID)), u3 && (a3.activeTexture.set(l2.TEXTURE0), t3.imageManager.bind(t3.context));
          for (const _3 of v3) {
            const v4 = _3.toUnwrapped(), x3 = r3 ? _3.projMatrix : t3.transform.calculateProjMatrix(v4);
            t3.prepareDrawTile();
            const y3 = i3 ? i3.getTile(_3) : g3 ? g3[_3.key] : new e2.Tile(_3, h3, c3.zoom, t3), b2 = u3 ? no(x3, s3, t3, u3, { tileID: _3, tileSize: h3 }) : ro(x3, s3, n3);
            t3.prepareDrawProgram(a3, f3, v4);
            const { tileBoundsBuffer: w2, tileBoundsIndexBuffer: T2, tileBoundsSegments: E3 } = t3.getTileBoundsBuffers(y3);
            f3.draw(a3, l2.TRIANGLES, p3, d3, m3, e2.CullFaceMode.disabled, b2, o3.id, w2, T2, E3);
          }
        }, sky: function(t3, i3, o3) {
          const r3 = t3.transform, n3 = "mercator" === r3.projection.name || "globe" === r3.projection.name ? 1 : e2.smoothstep(7, 8, r3.zoom), s3 = o3.paint.get("sky-opacity") * n3;
          if (0 === s3)
            return;
          const a3 = t3.context, l2 = o3.paint.get("sky-type"), c3 = new e2.DepthMode(a3.gl.LEQUAL, e2.DepthMode.ReadOnly, [0, 1]), h3 = t3.frameCounter / 1e3 % 1;
          "atmosphere" === l2 ? "offscreen" === t3.renderPass ? o3.needsSkyboxCapture(t3) && (function(t4, i4, o4, r4) {
            const n4 = t4.context, s4 = n4.gl;
            let a4 = i4.skyboxFbo;
            if (!a4) {
              a4 = i4.skyboxFbo = n4.createFramebuffer(32, 32, false), i4.skyboxGeometry = new Lo(n4), i4.skyboxTexture = n4.gl.createTexture(), s4.bindTexture(s4.TEXTURE_CUBE_MAP, i4.skyboxTexture), s4.texParameteri(s4.TEXTURE_CUBE_MAP, s4.TEXTURE_WRAP_S, s4.CLAMP_TO_EDGE), s4.texParameteri(s4.TEXTURE_CUBE_MAP, s4.TEXTURE_WRAP_T, s4.CLAMP_TO_EDGE), s4.texParameteri(s4.TEXTURE_CUBE_MAP, s4.TEXTURE_MIN_FILTER, s4.LINEAR), s4.texParameteri(s4.TEXTURE_CUBE_MAP, s4.TEXTURE_MAG_FILTER, s4.LINEAR);
              for (let e3 = 0; e3 < 6; ++e3)
                s4.texImage2D(s4.TEXTURE_CUBE_MAP_POSITIVE_X + e3, 0, s4.RGBA, 32, 32, 0, s4.RGBA, s4.UNSIGNED_BYTE, null);
            }
            n4.bindFramebuffer.set(a4.framebuffer), n4.viewport.set([0, 0, 32, 32]);
            const l3 = i4.getCenter(t4, true), c4 = t4.useProgram("skyboxCapture"), h4 = new Float64Array(16);
            e2.identity(h4), e2.rotateY(h4, h4, 0.5 * -Math.PI), Ao(n4, i4, c4, h4, l3, 0), e2.identity(h4), e2.rotateY(h4, h4, 0.5 * Math.PI), Ao(n4, i4, c4, h4, l3, 1), e2.identity(h4), e2.rotateX(h4, h4, 0.5 * -Math.PI), Ao(n4, i4, c4, h4, l3, 2), e2.identity(h4), e2.rotateX(h4, h4, 0.5 * Math.PI), Ao(n4, i4, c4, h4, l3, 3), e2.identity(h4), Ao(n4, i4, c4, h4, l3, 4), e2.identity(h4), e2.rotateY(h4, h4, Math.PI), Ao(n4, i4, c4, h4, l3, 5), n4.viewport.set([0, 0, t4.width, t4.height]);
          }(t3, o3), o3.markSkyboxValid(t3)) : "sky" === t3.renderPass && function(t4, i4, o4, r4, n4) {
            const s4 = t4.context, a4 = s4.gl, l3 = t4.transform, c4 = t4.useProgram("skybox");
            s4.activeTexture.set(a4.TEXTURE0), a4.bindTexture(a4.TEXTURE_CUBE_MAP, i4.skyboxTexture);
            const h4 = ((e3, t5, i5, o5, r5) => ({ u_matrix: e3, u_sun_direction: t5, u_cubemap: 0, u_opacity: o5, u_temporal_offset: r5 }))(l3.skyboxMatrix, i4.getCenter(t4, false), 0, r4, n4);
            t4.prepareDrawProgram(s4, c4), c4.draw(s4, a4.TRIANGLES, o4, e2.StencilMode.disabled, t4.colorModeForRenderPass(), e2.CullFaceMode.backCW, h4, "skybox", i4.skyboxGeometry.vertexBuffer, i4.skyboxGeometry.indexBuffer, i4.skyboxGeometry.segment);
          }(t3, o3, c3, s3, h3) : "gradient" === l2 && "sky" === t3.renderPass && function(t4, i4, o4, r4, n4) {
            const s4 = t4.context, a4 = s4.gl, l3 = t4.transform, c4 = t4.useProgram("skyboxGradient");
            i4.skyboxGeometry || (i4.skyboxGeometry = new Lo(s4)), s4.activeTexture.set(a4.TEXTURE0);
            let h4 = i4.colorRampTexture;
            h4 || (h4 = i4.colorRampTexture = new e2.Texture(s4, i4.colorRamp, a4.RGBA)), h4.bind(a4.LINEAR, a4.CLAMP_TO_EDGE);
            const u3 = ((t5, i5, o5, r5, n5) => ({ u_matrix: t5, u_color_ramp: 0, u_center_direction: i5, u_radius: e2.degToRad(o5), u_opacity: r5, u_temporal_offset: n5 }))(l3.skyboxMatrix, i4.getCenter(t4, false), i4.paint.get("sky-gradient-radius"), r4, n4);
            t4.prepareDrawProgram(s4, c4), c4.draw(s4, a4.TRIANGLES, o4, e2.StencilMode.disabled, t4.colorModeForRenderPass(), e2.CullFaceMode.backCW, u3, "skyboxGradient", i4.skyboxGeometry.vertexBuffer, i4.skyboxGeometry.indexBuffer, i4.skyboxGeometry.segment);
          }(t3, o3, c3, s3, h3);
        }, debug: function(e3, t3, i3) {
          for (let o3 = 0; o3 < i3.length; o3++)
            Eo(e3, t3, i3[o3]);
        }, custom: function(t3, i3, o3, r3) {
          const n3 = t3.context, s3 = o3.implementation;
          if (!t3.transform.projection.unsupportedLayers || !t3.transform.projection.unsupportedLayers.includes("custom") || t3.terrain && (t3.terrain.renderingToTexture || "offscreen" === t3.renderPass) && o3.isLayerDraped()) {
            if ("offscreen" === t3.renderPass) {
              const i4 = s3.prerender;
              if (i4) {
                if (t3.setCustomLayerDefaults(), n3.setColorMode(t3.colorModeForRenderPass()), "globe" === t3.transform.projection.name) {
                  const o4 = t3.transform.pointMerc;
                  i4.call(s3, n3.gl, t3.transform.customLayerMatrix(), t3.transform.getProjection(), t3.transform.globeToMercatorMatrix(), e2.globeToMercatorTransition(t3.transform.zoom), [o4.x, o4.y], t3.transform.pixelsPerMeterRatio);
                } else
                  i4.call(s3, n3.gl, t3.transform.customLayerMatrix());
                n3.setDirty(), t3.setBaseState();
              }
            } else if ("translucent" === t3.renderPass) {
              if (t3.terrain && t3.terrain.renderingToTexture) {
                const i5 = s3.renderToTile;
                if (i5) {
                  const o4 = r3[0].canonical, a3 = new e2.MercatorCoordinate(o4.x + r3[0].wrap * (1 << o4.z), o4.y, o4.z);
                  n3.setDepthMode(e2.DepthMode.disabled), n3.setStencilMode(e2.StencilMode.disabled), n3.setColorMode(t3.colorModeForRenderPass()), t3.setCustomLayerDefaults(), i5.call(s3, n3.gl, a3), n3.setDirty(), t3.setBaseState();
                }
                return;
              }
              t3.setCustomLayerDefaults(), n3.setColorMode(t3.colorModeForRenderPass()), n3.setStencilMode(e2.StencilMode.disabled);
              const i4 = "3d" === s3.renderingMode ? new e2.DepthMode(t3.context.gl.LEQUAL, e2.DepthMode.ReadWrite, t3.depthRangeFor3D) : t3.depthModeForSublayer(0, e2.DepthMode.ReadOnly);
              if (n3.setDepthMode(i4), "globe" === t3.transform.projection.name) {
                const i5 = t3.transform.pointMerc;
                s3.render(n3.gl, t3.transform.customLayerMatrix(), t3.transform.getProjection(), t3.transform.globeToMercatorMatrix(), e2.globeToMercatorTransition(t3.transform.zoom), [i5.x, i5.y], t3.transform.pixelsPerMeterRatio);
              } else
                s3.render(n3.gl, t3.transform.customLayerMatrix());
              n3.setDirty(), t3.setBaseState(), n3.bindFramebuffer.set(null);
            }
          } else
            e2.warnOnce("Custom layers are not yet supported with this projection. Use mercator or globe to enable usage of custom layers.");
        } };
        class Bo {
          constructor(t3, i3, o3 = false) {
            this.context = new Ee(t3, o3), this.transform = i3, this._tileTextures = {}, this.frameCopies = [], this.loadTimeStamps = [], this.setup(), this.numSublayers = e2.SourceCache.maxUnderzooming + e2.SourceCache.maxOverzooming + 1, this.depthEpsilon = 1 / Math.pow(2, 16), this.deferredRenderGpuTimeQueries = [], this.gpuTimers = {}, this.frameCounter = 0, this._backgroundTiles = {};
          }
          updateTerrain(e3, t3) {
            const i3 = !!e3 && !!e3.terrain && this.transform.projection.supportsTerrain;
            if (!(i3 || this._terrain && this._terrain.enabled))
              return;
            this._terrain || (this._terrain = new Di(this, e3));
            const o3 = this._terrain;
            this.transform.elevation = i3 ? o3 : null, o3.update(e3, this.transform, t3);
          }
          _updateFog(e3) {
            const t3 = e3.fog;
            if (!t3 || "globe" === this.transform.projection.name || t3.getOpacity(this.transform.pitch) < 1 || t3.properties.get("horizon-blend") < 0.03)
              return void (this.transform.fogCullDistSq = null);
            const [i3, o3] = t3.getFovAdjustedRange(this.transform._fov);
            if (i3 > o3)
              return void (this.transform.fogCullDistSq = null);
            const r3 = i3 + 0.78 * (o3 - i3);
            this.transform.fogCullDistSq = r3 * r3;
          }
          get terrain() {
            return this.transform._terrainEnabled() && this._terrain && this._terrain.enabled ? this._terrain : null;
          }
          resize(t3, i3) {
            if (this.width = t3 * e2.exported.devicePixelRatio, this.height = i3 * e2.exported.devicePixelRatio, this.context.viewport.set([0, 0, this.width, this.height]), this.style)
              for (const e3 of this.style.order)
                this.style._layers[e3].resize();
          }
          setup() {
            const t3 = this.context, i3 = new e2.StructArrayLayout2i4();
            i3.emplaceBack(0, 0), i3.emplaceBack(e2.EXTENT, 0), i3.emplaceBack(0, e2.EXTENT), i3.emplaceBack(e2.EXTENT, e2.EXTENT), this.tileExtentBuffer = t3.createVertexBuffer(i3, e2.posAttributes.members), this.tileExtentSegments = e2.SegmentVector.simpleSegment(0, 0, 4, 2);
            const o3 = new e2.StructArrayLayout2i4();
            o3.emplaceBack(0, 0), o3.emplaceBack(e2.EXTENT, 0), o3.emplaceBack(0, e2.EXTENT), o3.emplaceBack(e2.EXTENT, e2.EXTENT), this.debugBuffer = t3.createVertexBuffer(o3, e2.posAttributes.members), this.debugSegments = e2.SegmentVector.simpleSegment(0, 0, 4, 5);
            const r3 = new e2.StructArrayLayout2i4();
            r3.emplaceBack(-1, -1), r3.emplaceBack(1, -1), r3.emplaceBack(-1, 1), r3.emplaceBack(1, 1), this.viewportBuffer = t3.createVertexBuffer(r3, e2.posAttributes.members), this.viewportSegments = e2.SegmentVector.simpleSegment(0, 0, 4, 2);
            const n3 = new e2.StructArrayLayout4i8();
            n3.emplaceBack(0, 0, 0, 0), n3.emplaceBack(e2.EXTENT, 0, e2.EXTENT, 0), n3.emplaceBack(0, e2.EXTENT, 0, e2.EXTENT), n3.emplaceBack(e2.EXTENT, e2.EXTENT, e2.EXTENT, e2.EXTENT), this.mercatorBoundsBuffer = t3.createVertexBuffer(n3, e2.boundsAttributes.members), this.mercatorBoundsSegments = e2.SegmentVector.simpleSegment(0, 0, 4, 2);
            const s3 = new e2.StructArrayLayout3ui6();
            s3.emplaceBack(0, 1, 2), s3.emplaceBack(2, 1, 3), this.quadTriangleIndexBuffer = t3.createIndexBuffer(s3);
            const a3 = new e2.StructArrayLayout1ui2();
            for (const e3 of [0, 1, 3, 2, 0])
              a3.emplaceBack(e3);
            this.debugIndexBuffer = t3.createIndexBuffer(a3), this.emptyTexture = new e2.Texture(t3, new e2.RGBAImage({ width: 1, height: 1 }, Uint8Array.of(0, 0, 0, 0)), t3.gl.RGBA), this.identityMat = e2.create();
            const l2 = this.context.gl;
            this.stencilClearMode = new e2.StencilMode({ func: l2.ALWAYS, mask: 0 }, 0, 255, l2.ZERO, l2.ZERO, l2.ZERO), this.loadTimeStamps.push(e2.window.performance.now()), this.atmosphereBuffer = new Ro(this.context);
          }
          getMercatorTileBoundsBuffers() {
            return { tileBoundsBuffer: this.mercatorBoundsBuffer, tileBoundsIndexBuffer: this.quadTriangleIndexBuffer, tileBoundsSegments: this.mercatorBoundsSegments };
          }
          getTileBoundsBuffers(e3) {
            return e3._makeTileBoundsBuffers(this.context, this.transform.projection), e3._tileBoundsBuffer ? { tileBoundsBuffer: e3._tileBoundsBuffer, tileBoundsIndexBuffer: e3._tileBoundsIndexBuffer, tileBoundsSegments: e3._tileBoundsSegments } : this.getMercatorTileBoundsBuffers();
          }
          clearStencil() {
            const t3 = this.context, i3 = t3.gl;
            this.nextStencilID = 1, this.currentStencilSource = void 0, this._tileClippingMaskIDs = {}, this.useProgram("clippingMask").draw(t3, i3.TRIANGLES, e2.DepthMode.disabled, this.stencilClearMode, e2.ColorMode.disabled, e2.CullFaceMode.disabled, Ci(this.identityMat), "$clipping", this.viewportBuffer, this.quadTriangleIndexBuffer, this.viewportSegments);
          }
          resetStencilClippingMasks() {
            this.terrain || (this.currentStencilSource = void 0, this._tileClippingMaskIDs = {});
          }
          _renderTileClippingMasks(t3, i3, o3) {
            if (!i3 || this.currentStencilSource === i3.id || !t3.isTileClipped() || !o3 || 0 === o3.length)
              return;
            if (this._tileClippingMaskIDs && !this.terrain) {
              let e3 = false;
              for (const t4 of o3)
                if (void 0 === this._tileClippingMaskIDs[t4.key]) {
                  e3 = true;
                  break;
                }
              if (!e3)
                return;
            }
            this.currentStencilSource = i3.id;
            const r3 = this.context, n3 = r3.gl;
            this.nextStencilID + o3.length > 256 && this.clearStencil(), r3.setColorMode(e2.ColorMode.disabled), r3.setDepthMode(e2.DepthMode.disabled);
            const s3 = this.useProgram("clippingMask");
            this._tileClippingMaskIDs = {};
            for (const t4 of o3) {
              const o4 = i3.getTile(t4), a3 = this._tileClippingMaskIDs[t4.key] = this.nextStencilID++, { tileBoundsBuffer: l2, tileBoundsIndexBuffer: c3, tileBoundsSegments: h3 } = this.getTileBoundsBuffers(o4);
              s3.draw(r3, n3.TRIANGLES, e2.DepthMode.disabled, new e2.StencilMode({ func: n3.ALWAYS, mask: 0 }, a3, 255, n3.KEEP, n3.KEEP, n3.REPLACE), e2.ColorMode.disabled, e2.CullFaceMode.disabled, Ci(t4.projMatrix), "$clipping", l2, c3, h3);
            }
          }
          stencilModeFor3D() {
            this.currentStencilSource = void 0, this.nextStencilID + 1 > 256 && this.clearStencil();
            const t3 = this.nextStencilID++, i3 = this.context.gl;
            return new e2.StencilMode({ func: i3.NOTEQUAL, mask: 255 }, t3, 255, i3.KEEP, i3.KEEP, i3.REPLACE);
          }
          stencilModeForClipping(t3) {
            if (this.terrain)
              return this.terrain.stencilModeForRTTOverlap(t3);
            const i3 = this.context.gl;
            return new e2.StencilMode({ func: i3.EQUAL, mask: 255 }, this._tileClippingMaskIDs[t3.key], 0, i3.KEEP, i3.KEEP, i3.REPLACE);
          }
          stencilConfigForOverlap(t3) {
            const i3 = this.context.gl, o3 = t3.sort((e3, t4) => t4.overscaledZ - e3.overscaledZ), r3 = o3[o3.length - 1].overscaledZ, n3 = o3[0].overscaledZ - r3 + 1;
            if (n3 > 1) {
              this.currentStencilSource = void 0, this.nextStencilID + n3 > 256 && this.clearStencil();
              const t4 = {};
              for (let o4 = 0; o4 < n3; o4++)
                t4[o4 + r3] = new e2.StencilMode({ func: i3.GEQUAL, mask: 255 }, o4 + this.nextStencilID, 255, i3.KEEP, i3.KEEP, i3.REPLACE);
              return this.nextStencilID += n3, [t4, o3];
            }
            return [{ [r3]: e2.StencilMode.disabled }, o3];
          }
          colorModeForRenderPass() {
            const t3 = this.context.gl;
            if (this._showOverdrawInspector) {
              const i3 = 1 / 8;
              return new e2.ColorMode([t3.CONSTANT_COLOR, t3.ONE], new e2.Color(i3, i3, i3, 0), [true, true, true, true]);
            }
            return "opaque" === this.renderPass ? e2.ColorMode.unblended : e2.ColorMode.alphaBlended;
          }
          depthModeForSublayer(t3, i3, o3) {
            if (!this.opaquePassEnabledForLayer())
              return e2.DepthMode.disabled;
            const r3 = 1 - ((1 + this.currentLayer) * this.numSublayers + t3) * this.depthEpsilon;
            return new e2.DepthMode(o3 || this.context.gl.LEQUAL, i3, [r3, r3]);
          }
          opaquePassEnabledForLayer() {
            return this.currentLayer < this.opaquePassCutoff;
          }
          render(t3, i3) {
            this.style = t3, this.options = i3, this.imageManager = t3.imageManager, this.glyphManager = t3.glyphManager, this.symbolFadeChange = t3.placement.symbolFadeChange(e2.exported.now()), this.imageManager.beginFrame();
            const o3 = this.style.order, r3 = this.style._sourceCaches;
            for (const e3 in r3) {
              const t4 = r3[e3];
              t4.used && t4.prepare(this.context);
            }
            const n3 = {}, s3 = {}, a3 = {};
            for (const e3 in r3) {
              const t4 = r3[e3];
              n3[e3] = t4.getVisibleCoordinates(), s3[e3] = n3[e3].slice().reverse(), a3[e3] = t4.getVisibleCoordinates(true).reverse();
            }
            this.opaquePassCutoff = 1 / 0;
            for (let e3 = 0; e3 < o3.length; e3++)
              if (this.style._layers[o3[e3]].is3D()) {
                this.opaquePassCutoff = e3;
                break;
              }
            if (this.terrain && (this.terrain.updateTileBinding(a3), this.opaquePassCutoff = 0), "globe" !== this.transform.projection.name || this.globeSharedBuffers || (this.globeSharedBuffers = new e2.GlobeSharedBuffers(this.context)), !e2.isMapAuthenticated(this.context.gl))
              return;
            this.renderPass = "offscreen";
            for (const e3 of o3) {
              const i4 = this.style._layers[e3], o4 = t3._getLayerSourceCache(i4);
              if (!i4.hasOffscreenPass() || i4.isHidden(this.transform.zoom))
                continue;
              const r4 = o4 ? s3[o4.id] : void 0;
              ("custom" === i4.type || i4.isSky() || r4 && r4.length) && this.renderLayer(this, o4, i4, r4);
            }
            this.depthRangeFor3D = [0, 1 - (t3.order.length + 2) * this.numSublayers * this.depthEpsilon];
            const l2 = this.terrain;
            if (l2 && (this.style.hasSymbolLayers() || this.style.hasCircleLayers()) && l2.drawDepth(), this.context.bindFramebuffer.set(null), this.context.viewport.set([0, 0, this.width, this.height]), this.context.clear({ color: i3.showOverdrawInspector ? e2.Color.black : e2.Color.transparent, depth: 1 }), this.clearStencil(), this._showOverdrawInspector = i3.showOverdrawInspector, this.renderPass = "opaque", !this.terrain)
              for (this.currentLayer = o3.length - 1; this.currentLayer >= 0; this.currentLayer--) {
                const e3 = this.style._layers[o3[this.currentLayer]], i4 = t3._getLayerSourceCache(e3);
                if (e3.isSky())
                  continue;
                const r4 = i4 ? s3[i4.id] : void 0;
                this._renderTileClippingMasks(e3, i4, r4), this.renderLayer(this, i4, e3, r4);
              }
            if (this.style.fog && this.transform.projection.supportsFog && function(t4, i4) {
              const o4 = t4.context, r4 = o4.gl, n4 = t4.transform, s4 = new e2.DepthMode(r4.LEQUAL, e2.DepthMode.ReadOnly, [0, 1]), a4 = t4.useProgram("globeAtmosphere", null, "globe" === n4.projection.name ? ["PROJECTION_GLOBE_VIEW", "FOG"] : ["FOG"]), l3 = e2.globeToMercatorTransition(n4.zoom), c3 = i4.properties.get("color").toArray01(), h3 = i4.properties.get("high-color").toArray01(), u3 = i4.properties.get("space-color").toArray01PremultipliedAlpha(), _2 = e2.identity$1([]);
              e2.rotateY$1(_2, _2, -e2.degToRad(n4._center.lng)), e2.rotateX$1(_2, _2, e2.degToRad(n4._center.lat)), e2.rotateZ$1(_2, _2, n4.angle), e2.rotateX$1(_2, _2, -n4._pitch);
              const d3 = e2.fromQuat(new Float32Array(16), _2), p3 = e2.mapValue(i4.properties.get("star-intensity"), 0, 1, 0, 0.25), m3 = 5e-4, f3 = e2.mapValue(i4.properties.get("horizon-blend"), 0, 1, m3, 0.25), g3 = e2.globeUseCustomAntiAliasing(t4, o4, n4) && f3 === m3 ? n4.worldSize / (2 * Math.PI * 1.025) - 1 : n4.globeRadius, v3 = t4.frameCounter / 1e3 % 1, x3 = e2.length(n4.globeCenterInViewSpace), y3 = Math.sqrt(Math.pow(x3, 2) - Math.pow(g3, 2)), b2 = Math.acos(y3 / x3), w2 = ((t5, i5, o5, r5, n5, s5, a5, l4, c4, h4, u4, _3, d4, p4) => ({ u_frustum_tl: t5, u_frustum_tr: i5, u_frustum_br: o5, u_frustum_bl: r5, u_horizon: n5, u_transition: s5, u_fadeout_range: a5, u_color: l4, u_high_color: c4, u_space_color: h4, u_star_intensity: u4, u_star_size: 5 * e2.exported.devicePixelRatio, u_star_density: 0, u_temporal_offset: _3, u_horizon_angle: d4, u_rotation_matrix: p4 }))(n4.frustumCorners.TL, n4.frustumCorners.TR, n4.frustumCorners.BR, n4.frustumCorners.BL, n4.frustumCorners.horizon, l3, f3, c3, h3, u3, p3, v3, b2, d3);
              t4.prepareDrawProgram(o4, a4);
              const T2 = t4.atmosphereBuffer;
              T2 && a4.draw(o4, r4.TRIANGLES, s4, e2.StencilMode.disabled, e2.ColorMode.alphaBlended, e2.CullFaceMode.backCW, w2, "skybox", T2.vertexBuffer, T2.indexBuffer, T2.segments);
            }(this, this.style.fog), this.renderPass = "sky", (e2.globeToMercatorTransition(this.transform.zoom) > 0 || "globe" !== this.transform.projection.name) && this.transform.isHorizonVisible())
              for (this.currentLayer = 0; this.currentLayer < o3.length; this.currentLayer++) {
                const e3 = this.style._layers[o3[this.currentLayer]], i4 = t3._getLayerSourceCache(e3);
                e3.isSky() && this.renderLayer(this, i4, e3, i4 ? s3[i4.id] : void 0);
              }
            for (this.renderPass = "translucent", this.currentLayer = 0; this.currentLayer < o3.length; ) {
              const e3 = this.style._layers[o3[this.currentLayer]], i4 = t3._getLayerSourceCache(e3);
              if (e3.isSky()) {
                ++this.currentLayer;
                continue;
              }
              if (this.terrain && this.style.isLayerDraped(e3)) {
                if (e3.isHidden(this.transform.zoom)) {
                  ++this.currentLayer;
                  continue;
                }
                this.currentLayer = this.terrain.renderBatch(this.currentLayer);
                continue;
              }
              const r4 = i4 ? ("symbol" === e3.type ? a3 : s3)[i4.id] : void 0;
              this._renderTileClippingMasks(e3, i4, i4 ? n3[i4.id] : void 0), this.renderLayer(this, i4, e3, r4), ++this.currentLayer;
            }
            if (this.terrain && this.terrain.postRender(), this.options.showTileBoundaries || this.options.showQueryGeometry || this.options.showTileAABBs) {
              let i4 = null;
              e2.values(this.style._layers).forEach((e3) => {
                const o4 = t3._getLayerSourceCache(e3);
                o4 && !e3.isHidden(this.transform.zoom) && (!i4 || i4.getSource().maxzoom < o4.getSource().maxzoom) && (i4 = o4);
              }), i4 && this.options.showTileBoundaries && Oo.debug(this, i4, i4.getVisibleCoordinates());
            }
            this.options.showPadding && function(e3) {
              const t4 = e3.transform.padding;
              Co(e3, e3.transform.height - (t4.top || 0), 3, xo), Co(e3, t4.bottom || 0, 3, yo), Mo(e3, t4.left || 0, 3, bo), Mo(e3, e3.transform.width - (t4.right || 0), 3, wo);
              const i4 = e3.transform.centerPoint;
              !function(e4, t5, i5, o4) {
                Io(e4, t5 - 1, i5 - 10, 2, 20, o4), Io(e4, t5 - 10, i5 - 1, 20, 2, o4);
              }(e3, i4.x, e3.transform.height - i4.y, To);
            }(this), this.context.setDefault(), this.frameCounter = (this.frameCounter + 1) % Number.MAX_SAFE_INTEGER, this.tileLoaded && this.options.speedIndexTiming && (this.loadTimeStamps.push(e2.window.performance.now()), this.saveCanvasCopy());
          }
          renderLayer(e3, t3, i3, o3) {
            i3.isHidden(this.transform.zoom) || ("background" === i3.type || "sky" === i3.type || "custom" === i3.type || o3 && o3.length) && (this.id = i3.id, this.gpuTimingStart(i3), (!e3.transform.projection.unsupportedLayers || !e3.transform.projection.unsupportedLayers.includes(i3.type) || e3.terrain && "custom" === i3.type) && Oo[i3.type](e3, t3, i3, o3, this.style.placement.variableOffsets, this.options.isInitialLoad), this.gpuTimingEnd());
          }
          gpuTimingStart(e3) {
            if (!this.options.gpuTiming)
              return;
            const t3 = this.context.extTimerQuery;
            let i3 = this.gpuTimers[e3.id];
            i3 || (i3 = this.gpuTimers[e3.id] = { calls: 0, cpuTime: 0, query: t3.createQueryEXT() }), i3.calls++, t3.beginQueryEXT(t3.TIME_ELAPSED_EXT, i3.query);
          }
          gpuTimingDeferredRenderStart() {
            if (this.options.gpuTimingDeferredRender) {
              const e3 = this.context.extTimerQuery, t3 = e3.createQueryEXT();
              this.deferredRenderGpuTimeQueries.push(t3), e3.beginQueryEXT(e3.TIME_ELAPSED_EXT, t3);
            }
          }
          gpuTimingDeferredRenderEnd() {
            if (!this.options.gpuTimingDeferredRender)
              return;
            const e3 = this.context.extTimerQuery;
            e3.endQueryEXT(e3.TIME_ELAPSED_EXT);
          }
          gpuTimingEnd() {
            if (!this.options.gpuTiming)
              return;
            const e3 = this.context.extTimerQuery;
            e3.endQueryEXT(e3.TIME_ELAPSED_EXT);
          }
          collectGpuTimers() {
            const e3 = this.gpuTimers;
            return this.gpuTimers = {}, e3;
          }
          collectDeferredRenderGpuQueries() {
            const e3 = this.deferredRenderGpuTimeQueries;
            return this.deferredRenderGpuTimeQueries = [], e3;
          }
          queryGpuTimers(e3) {
            const t3 = {};
            for (const i3 in e3) {
              const o3 = e3[i3], r3 = this.context.extTimerQuery, n3 = r3.getQueryObjectEXT(o3.query, r3.QUERY_RESULT_EXT) / 1e6;
              r3.deleteQueryEXT(o3.query), t3[i3] = n3;
            }
            return t3;
          }
          queryGpuTimeDeferredRender(e3) {
            if (!this.options.gpuTimingDeferredRender)
              return 0;
            const t3 = this.context.extTimerQuery;
            let i3 = 0;
            for (const o3 of e3)
              i3 += t3.getQueryObjectEXT(o3, t3.QUERY_RESULT_EXT) / 1e6, t3.deleteQueryEXT(o3);
            return i3;
          }
          translatePosMatrix(t3, i3, o3, r3, n3) {
            if (!o3[0] && !o3[1])
              return t3;
            const s3 = n3 ? "map" === r3 ? this.transform.angle : 0 : "viewport" === r3 ? -this.transform.angle : 0;
            if (s3) {
              const e3 = Math.sin(s3), t4 = Math.cos(s3);
              o3 = [o3[0] * t4 - o3[1] * e3, o3[0] * e3 + o3[1] * t4];
            }
            const a3 = [n3 ? o3[0] : D(i3, o3[0], this.transform.zoom), n3 ? o3[1] : D(i3, o3[1], this.transform.zoom), 0], l2 = new Float32Array(16);
            return e2.translate(l2, t3, a3), l2;
          }
          saveTileTexture(e3) {
            const t3 = this._tileTextures[e3.size[0]];
            t3 ? t3.push(e3) : this._tileTextures[e3.size[0]] = [e3];
          }
          getTileTexture(e3) {
            const t3 = this._tileTextures[e3];
            return t3 && t3.length > 0 ? t3.pop() : null;
          }
          isPatternMissing(e3) {
            return null === e3 || void 0 !== e3 && !this.imageManager.getPattern(e3.toString());
          }
          terrainRenderModeElevated() {
            return this.style && !!this.style.getTerrain() && !!this.terrain && !this.terrain.renderingToTexture;
          }
          currentGlobalDefines() {
            const e3 = this.terrain && this.terrain.renderingToTexture, t3 = this.terrain && 0 === this.terrain.exaggeration(), i3 = this.style && this.style.fog, o3 = [];
            return this.terrainRenderModeElevated() && o3.push("TERRAIN"), "globe" === this.transform.projection.name && o3.push("GLOBE"), t3 && o3.push("ZERO_EXAGGERATION"), i3 && !e3 && 0 !== i3.getOpacity(this.transform.pitch) && o3.push("FOG"), e3 && o3.push("RENDER_TO_TEXTURE"), this._showOverdrawInspector && o3.push("OVERDRAW_INSPECTOR"), o3;
          }
          useProgram(e3, t3, i3) {
            this.cache = this.cache || {};
            const o3 = i3 || [], r3 = this.currentGlobalDefines().concat(o3), n3 = Li.cacheKey(ci[e3], e3, r3, t3);
            return this.cache[n3] || (this.cache[n3] = new Li(this.context, e3, ci[e3], t3, so[e3], r3)), this.cache[n3];
          }
          setCustomLayerDefaults() {
            this.context.unbindVAO(), this.context.cullFace.setDefault(), this.context.frontFace.setDefault(), this.context.cullFaceSide.setDefault(), this.context.activeTexture.setDefault(), this.context.pixelStoreUnpack.setDefault(), this.context.pixelStoreUnpackPremultiplyAlpha.setDefault(), this.context.pixelStoreUnpackFlipY.setDefault();
          }
          setBaseState() {
            const e3 = this.context.gl;
            this.context.cullFace.set(false), this.context.viewport.set([0, 0, this.width, this.height]), this.context.blendEquation.set(e3.FUNC_ADD);
          }
          initDebugOverlayCanvas() {
            null == this.debugOverlayCanvas && (this.debugOverlayCanvas = e2.window.document.createElement("canvas"), this.debugOverlayCanvas.width = 512, this.debugOverlayCanvas.height = 512, this.debugOverlayTexture = new e2.Texture(this.context, this.debugOverlayCanvas, this.context.gl.RGBA));
          }
          destroy() {
            this._terrain && this._terrain.destroy(), this.globeSharedBuffers && this.globeSharedBuffers.destroy(), this.emptyTexture.destroy(), this.debugOverlayTexture && this.debugOverlayTexture.destroy(), this.atmosphereBuffer && this.atmosphereBuffer.destroy();
          }
          prepareDrawTile() {
            this.terrain && this.terrain.prepareDrawTile();
          }
          prepareDrawProgram(t3, i3, o3) {
            if (this.terrain && this.terrain.renderingToTexture)
              return;
            const r3 = this.style.fog;
            if (r3) {
              const n3 = r3.getOpacity(this.transform.pitch), s3 = ((t4, i4, o4, r4, n4, s4, a3, l2, c3, h3, u3) => {
                const _2 = t4.transform, d3 = i4.properties.get("color").toArray01();
                d3[3] = r4;
                const p3 = t4.frameCounter / 1e3 % 1;
                return { u_fog_matrix: o4 ? _2.calculateFogTileMatrix(o4) : t4.identityMat, u_fog_range: i4.getFovAdjustedRange(_2._fov), u_fog_color: d3, u_fog_horizon_blend: i4.properties.get("horizon-blend"), u_fog_temporal_offset: p3, u_frustum_tl: n4, u_frustum_tr: s4, u_frustum_br: a3, u_frustum_bl: l2, u_globe_pos: c3, u_globe_radius: h3, u_viewport: u3, u_globe_transition: e2.globeToMercatorTransition(_2.zoom), u_is_globe: +("globe" === _2.projection.name) };
              })(this, r3, o3, n3, this.transform.frustumCorners.TL, this.transform.frustumCorners.TR, this.transform.frustumCorners.BR, this.transform.frustumCorners.BL, this.transform.globeCenterInViewSpace, this.transform.globeRadius, [this.transform.width * e2.exported.devicePixelRatio, this.transform.height * e2.exported.devicePixelRatio]);
              i3.setFogUniformValues(t3, s3);
            }
          }
          setTileLoadedFlag(e3) {
            this.tileLoaded = e3;
          }
          saveCanvasCopy() {
            const e3 = this.canvasCopy();
            e3 && (this.frameCopies.push(e3), this.tileLoaded = false);
          }
          canvasCopy() {
            const e3 = this.context.gl, t3 = e3.createTexture();
            return e3.bindTexture(e3.TEXTURE_2D, t3), e3.copyTexImage2D(e3.TEXTURE_2D, 0, e3.RGBA, 0, 0, e3.drawingBufferWidth, e3.drawingBufferHeight, 0), t3;
          }
          getCanvasCopiesAndTimestamps() {
            return { canvasCopies: this.frameCopies, timeStamps: this.loadTimeStamps };
          }
          averageElevationNeedsEasing() {
            if (!this.transform._elevation)
              return false;
            const e3 = this.style && this.style.fog;
            return !!e3 && 0 !== e3.getOpacity(this.transform.pitch);
          }
          getBackgroundTiles() {
            const t3 = this._backgroundTiles, i3 = this._backgroundTiles = {}, o3 = this.transform.coveringTiles({ tileSize: 512 });
            for (const r3 of o3)
              i3[r3.key] = t3[r3.key] || new e2.Tile(r3, 512, this.transform.tileZoom, this);
            return i3;
          }
          clearBackgroundTiles() {
            this._backgroundTiles = {};
          }
        }
        class ko {
          constructor(e3 = 0, t3 = 0, i3 = 0, o3 = 0) {
            if (isNaN(e3) || e3 < 0 || isNaN(t3) || t3 < 0 || isNaN(i3) || i3 < 0 || isNaN(o3) || o3 < 0)
              throw new Error("Invalid value for edge-insets, top, bottom, left and right must all be numbers");
            this.top = e3, this.bottom = t3, this.left = i3, this.right = o3;
          }
          interpolate(t3, i3, o3) {
            return null != i3.top && null != t3.top && (this.top = e2.number(t3.top, i3.top, o3)), null != i3.bottom && null != t3.bottom && (this.bottom = e2.number(t3.bottom, i3.bottom, o3)), null != i3.left && null != t3.left && (this.left = e2.number(t3.left, i3.left, o3)), null != i3.right && null != t3.right && (this.right = e2.number(t3.right, i3.right, o3)), this;
          }
          getCenter(t3, i3) {
            const o3 = e2.clamp((this.left + t3 - this.right) / 2, 0, t3), r3 = e2.clamp((this.top + i3 - this.bottom) / 2, 0, i3);
            return new e2.Point(o3, r3);
          }
          equals(e3) {
            return this.top === e3.top && this.bottom === e3.bottom && this.left === e3.left && this.right === e3.right;
          }
          clone() {
            return new ko(this.top, this.bottom, this.left, this.right);
          }
          toJSON() {
            return { top: this.top, bottom: this.bottom, left: this.left, right: this.right };
          }
        }
        function Fo(t3, i3) {
          const o3 = e2.getColumn(t3, 3);
          e2.fromQuat(t3, i3), e2.setColumn(t3, 3, o3);
        }
        function Uo(t3, i3) {
          const o3 = e2.identity$1([]);
          return e2.rotateZ$1(o3, o3, -i3), e2.rotateX$1(o3, o3, -t3), o3;
        }
        function No(t3, i3) {
          const o3 = [t3[0], t3[1], 0], r3 = [i3[0], i3[1], 0];
          if (e2.length(o3) >= 1e-15) {
            const t4 = e2.normalize([], o3);
            e2.scale$2(r3, t4, e2.dot(r3, t4)), i3[0] = r3[0], i3[1] = r3[1];
          }
          const n3 = e2.cross([], i3, t3);
          if (e2.len(n3) < 1e-15)
            return null;
          const s3 = Math.atan2(-n3[1], n3[0]);
          return Uo(Math.atan2(Math.sqrt(t3[0] * t3[0] + t3[1] * t3[1]), -t3[2]), s3);
        }
        class jo {
          constructor(e3, t3) {
            this.position = e3, this.orientation = t3;
          }
          get position() {
            return this._position;
          }
          set position(t3) {
            if (t3) {
              const i3 = t3 instanceof e2.MercatorCoordinate ? t3 : new e2.MercatorCoordinate(t3[0], t3[1], t3[2]);
              this._renderWorldCopies && (i3.x = e2.wrap(i3.x, 0, 1)), this._position = i3;
            } else
              this._position = null;
          }
          lookAtPoint(t3, i3) {
            if (this.orientation = null, !this.position)
              return;
            const o3 = this.position, r3 = this._elevation ? this._elevation.getAtPointOrZero(e2.MercatorCoordinate.fromLngLat(t3)) : 0, n3 = e2.MercatorCoordinate.fromLngLat(t3, r3), s3 = [n3.x - o3.x, n3.y - o3.y, n3.z - o3.z];
            i3 || (i3 = [0, 0, 1]), i3[2] = Math.abs(i3[2]), this.orientation = No(s3, i3);
          }
          setPitchBearing(t3, i3) {
            this.orientation = Uo(e2.degToRad(t3), e2.degToRad(-i3));
          }
        }
        class Go {
          constructor(t3, i3) {
            this._transform = e2.identity([]), this.orientation = i3, this.position = t3;
          }
          get mercatorPosition() {
            const t3 = this.position;
            return new e2.MercatorCoordinate(t3[0], t3[1], t3[2]);
          }
          get position() {
            const t3 = e2.getColumn(this._transform, 3);
            return [t3[0], t3[1], t3[2]];
          }
          set position(t3) {
            var i3;
            t3 && e2.setColumn(this._transform, 3, [(i3 = t3)[0], i3[1], i3[2], 1]);
          }
          get orientation() {
            return this._orientation;
          }
          set orientation(t3) {
            this._orientation = t3 || e2.identity$1([]), t3 && Fo(this._transform, this._orientation);
          }
          getPitchBearing() {
            const e3 = this.forward(), t3 = this.right();
            return { bearing: Math.atan2(-t3[1], t3[0]), pitch: Math.atan2(Math.sqrt(e3[0] * e3[0] + e3[1] * e3[1]), -e3[2]) };
          }
          setPitchBearing(e3, t3) {
            this._orientation = Uo(e3, t3), Fo(this._transform, this._orientation);
          }
          forward() {
            const t3 = e2.getColumn(this._transform, 2);
            return [-t3[0], -t3[1], -t3[2]];
          }
          up() {
            const t3 = e2.getColumn(this._transform, 1);
            return [-t3[0], -t3[1], -t3[2]];
          }
          right() {
            const t3 = e2.getColumn(this._transform, 0);
            return [t3[0], t3[1], t3[2]];
          }
          getCameraToWorld(t3, i3) {
            const o3 = new Float64Array(16);
            return e2.invert(o3, this.getWorldToCamera(t3, i3)), o3;
          }
          getWorldToCameraPosition(t3, i3, o3) {
            const r3 = this.position;
            e2.scale$2(r3, r3, -t3);
            const n3 = new Float64Array(16);
            return e2.fromScaling(n3, [o3, o3, o3]), e2.translate(n3, n3, r3), n3[10] *= i3, n3;
          }
          getWorldToCamera(t3, i3) {
            const o3 = new Float64Array(16), r3 = new Float64Array(4), n3 = this.position;
            return e2.conjugate(r3, this._orientation), e2.scale$2(n3, n3, -t3), e2.fromQuat(o3, r3), e2.translate(o3, o3, n3), o3[1] *= -1, o3[5] *= -1, o3[9] *= -1, o3[13] *= -1, o3[8] *= i3, o3[9] *= i3, o3[10] *= i3, o3[11] *= i3, o3;
          }
          getCameraToClipPerspective(t3, i3, o3, r3) {
            const n3 = new Float64Array(16);
            return e2.perspective(n3, t3, i3, o3, r3), n3;
          }
          getDistanceToElevation(t3, i3 = false) {
            const o3 = 0 === t3 ? 0 : e2.mercatorZfromAltitude(t3, i3 ? e2.latFromMercatorY(this.position[1]) : this.position[1]), r3 = this.forward();
            return (o3 - this.position[2]) / r3[2];
          }
          clone() {
            return new Go([...this.position], [...this.orientation]);
          }
        }
        function Zo(t3, i3) {
          const o3 = Wo(t3.projection, t3.zoom, t3.width, t3.height), r3 = function(t4, i4, o4, r4, n4) {
            const s3 = new e2.LngLat(o4.lng - 180 * Xo, o4.lat), a3 = new e2.LngLat(o4.lng + 180 * Xo, o4.lat), l2 = t4.project(s3.lng, s3.lat), c3 = t4.project(a3.lng, a3.lat), h3 = -Math.atan2(c3.y - l2.y, c3.x - l2.x), u3 = e2.MercatorCoordinate.fromLngLat(o4);
            u3.y = e2.clamp(u3.y, -1 + Xo, 1 - Xo);
            const _2 = u3.toLngLat(), d3 = t4.project(_2.lng, _2.lat), p3 = e2.MercatorCoordinate.fromLngLat(_2);
            p3.x += Xo;
            const m3 = p3.toLngLat(), f3 = t4.project(m3.lng, m3.lat), g3 = $o(f3.x - d3.x, f3.y - d3.y, h3), v3 = e2.MercatorCoordinate.fromLngLat(_2);
            v3.y += Xo;
            const x3 = v3.toLngLat(), y3 = t4.project(x3.lng, x3.lat), b2 = $o(y3.x - d3.x, y3.y - d3.y, h3), w2 = Math.abs(g3.x) / Math.abs(b2.y), T2 = e2.identity([]);
            e2.rotateZ(T2, T2, -h3 * (1 - (n4 ? 0 : r4)));
            const E3 = e2.identity([]);
            return e2.scale(E3, E3, [1, 1 - (1 - w2) * r4, 1]), E3[4] = -b2.x / b2.y * r4, e2.rotateZ(E3, E3, h3), e2.multiply(E3, T2, E3), E3;
          }(t3.projection, 0, t3.center, o3, i3), n3 = Vo(t3);
          return e2.scale(r3, r3, [n3, n3, 1]), r3;
        }
        function Vo(t3) {
          const i3 = t3.projection, o3 = Wo(t3.projection, t3.zoom, t3.width, t3.height), r3 = qo(i3, t3.center), n3 = qo(i3, e2.LngLat.convert(i3.center));
          return Math.pow(2, r3 * o3 + (1 - o3) * n3);
        }
        function Wo(t3, i3, o3, r3, n3 = 1 / 0) {
          const s3 = t3.range;
          if (!s3)
            return 0;
          const a3 = Math.min(n3, Math.max(o3, r3)), l2 = Math.log(a3 / 1024) / Math.LN2;
          return e2.smoothstep(s3[0] + l2, s3[1] + l2, i3);
        }
        const Xo = 1 / 4e4;
        function qo(t3, i3) {
          const o3 = e2.clamp(i3.lat, -e2.MAX_MERCATOR_LATITUDE, e2.MAX_MERCATOR_LATITUDE), r3 = new e2.LngLat(i3.lng - 180 * Xo, o3), n3 = new e2.LngLat(i3.lng + 180 * Xo, o3), s3 = t3.project(r3.lng, o3), a3 = t3.project(n3.lng, o3), l2 = e2.MercatorCoordinate.fromLngLat(r3), c3 = e2.MercatorCoordinate.fromLngLat(n3), h3 = a3.x - s3.x, u3 = a3.y - s3.y, _2 = c3.x - l2.x, d3 = c3.y - l2.y, p3 = Math.sqrt((_2 * _2 + d3 * d3) / (h3 * h3 + u3 * u3));
          return Math.log(p3) / Math.LN2;
        }
        function $o(e3, t3, i3) {
          const o3 = Math.cos(i3), r3 = Math.sin(i3);
          return { x: e3 * o3 - t3 * r3, y: e3 * r3 + t3 * o3 };
        }
        class Ho {
          constructor(t3, i3, o3, r3, n3, s3, a3) {
            this.tileSize = 512, this._renderWorldCopies = void 0 === n3 || n3, this._minZoom = t3 || 0, this._maxZoom = i3 || 22, this._minPitch = null == o3 ? 0 : o3, this._maxPitch = null == r3 ? 60 : r3, this.setProjection(s3), this.setMaxBounds(a3), this.width = 0, this.height = 0, this._center = new e2.LngLat(0, 0), this.zoom = 0, this.angle = 0, this._fov = 0.6435011087932844, this._pitch = 0, this._nearZ = 0, this._farZ = 0, this._unmodified = true, this._edgeInsets = new ko(), this._projMatrixCache = {}, this._alignedProjMatrixCache = {}, this._fogTileMatrixCache = {}, this._distanceTileDataCache = {}, this._camera = new Go(), this._centerAltitude = 0, this._averageElevation = 0, this.cameraElevationReference = "ground", this._pixelsPerMercatorPixel = 1, this.globeRadius = 0, this.globeCenterInViewSpace = [0, 0, 0], this._horizonShift = 0.1;
          }
          clone() {
            const e3 = new Ho(this._minZoom, this._maxZoom, this._minPitch, this.maxPitch, this._renderWorldCopies, this.getProjection());
            return e3._elevation = this._elevation, e3._centerAltitude = this._centerAltitude, e3._centerAltitudeValidForExaggeration = this._centerAltitudeValidForExaggeration, e3.tileSize = this.tileSize, e3.mercatorFromTransition = this.mercatorFromTransition, e3.width = this.width, e3.height = this.height, e3.cameraElevationReference = this.cameraElevationReference, e3._center = this._center, e3._setZoom(this.zoom), e3._seaLevelZoom = this._seaLevelZoom, e3.angle = this.angle, e3._fov = this._fov, e3._pitch = this._pitch, e3._nearZ = this._nearZ, e3._farZ = this._farZ, e3._averageElevation = this._averageElevation, e3._unmodified = this._unmodified, e3._edgeInsets = this._edgeInsets.clone(), e3._camera = this._camera.clone(), e3._calcMatrices(), e3.freezeTileCoverage = this.freezeTileCoverage, e3.frustumCorners = this.frustumCorners, e3;
          }
          get elevation() {
            return this._elevation;
          }
          set elevation(e3) {
            this._elevation !== e3 && (this._elevation = e3, this._updateCameraOnTerrain(), this._calcMatrices());
          }
          updateElevation(e3, t3 = false) {
            const i3 = this._elevation && this._elevation.exaggeration() !== this._centerAltitudeValidForExaggeration;
            (null == this._seaLevelZoom || i3) && this._updateCameraOnTerrain(), (e3 || i3) && this._constrainCamera(t3), this._calcMatrices();
          }
          getProjection() {
            return e2.pick(this.projection, ["name", "center", "parallels"]);
          }
          setProjection(i3) {
            this.projectionOptions = i3 || { name: "mercator" };
            const o3 = this.projection ? this.getProjection() : void 0;
            this.projection = e2.getProjection(this.projectionOptions);
            const r3 = !t2(o3, this.getProjection());
            return r3 && this._calcMatrices(), this.mercatorFromTransition = false, r3;
          }
          setMercatorFromTransition() {
            const t3 = this.projection.name;
            this.mercatorFromTransition = true, this.projectionOptions = { name: "mercator" }, this.projection = e2.getProjection({ name: "mercator" });
            const i3 = t3 !== this.projection.name;
            return i3 && this._calcMatrices(), i3;
          }
          get minZoom() {
            return this._minZoom;
          }
          set minZoom(e3) {
            this._minZoom !== e3 && (this._minZoom = e3, this.zoom = Math.max(this.zoom, e3));
          }
          get maxZoom() {
            return this._maxZoom;
          }
          set maxZoom(e3) {
            this._maxZoom !== e3 && (this._maxZoom = e3, this.zoom = Math.min(this.zoom, e3));
          }
          get minPitch() {
            return this._minPitch;
          }
          set minPitch(e3) {
            this._minPitch !== e3 && (this._minPitch = e3, this.pitch = Math.max(this.pitch, e3));
          }
          get maxPitch() {
            return this._maxPitch;
          }
          set maxPitch(e3) {
            this._maxPitch !== e3 && (this._maxPitch = e3, this.pitch = Math.min(this.pitch, e3));
          }
          get renderWorldCopies() {
            return this._renderWorldCopies && true === this.projection.supportsWorldCopies;
          }
          set renderWorldCopies(e3) {
            void 0 === e3 ? e3 = true : null === e3 && (e3 = false), this._renderWorldCopies = e3;
          }
          get worldSize() {
            return this.tileSize * this.scale;
          }
          get cameraWorldSizeForFog() {
            const e3 = Math.max(this._camera.getDistanceToElevation(this._averageElevation), Number.EPSILON);
            return this._worldSizeFromZoom(this._zoomFromMercatorZ(e3));
          }
          get cameraWorldSize() {
            const e3 = Math.max(this._camera.getDistanceToElevation(this._averageElevation, true), Number.EPSILON);
            return this._worldSizeFromZoom(this._zoomFromMercatorZ(e3));
          }
          get pixelsPerMeter() {
            return this.projection.pixelsPerMeter(this.center.lat, this.worldSize);
          }
          get cameraPixelsPerMeter() {
            return e2.mercatorZfromAltitude(this.center.lat, this.cameraWorldSizeForFog);
          }
          get centerOffset() {
            return this.centerPoint._sub(this.size._div(2));
          }
          get size() {
            return new e2.Point(this.width, this.height);
          }
          get bearing() {
            return e2.wrap(this.rotation, -180, 180);
          }
          set bearing(e3) {
            this.rotation = e3;
          }
          get rotation() {
            return -this.angle / Math.PI * 180;
          }
          set rotation(t3) {
            const i3 = -t3 * Math.PI / 180;
            var o3;
            this.angle !== i3 && (this._unmodified = false, this.angle = i3, this._calcMatrices(), this.rotationMatrix = (o3 = new e2.ARRAY_TYPE(4), e2.ARRAY_TYPE != Float32Array && (o3[1] = 0, o3[2] = 0), o3[0] = 1, o3[3] = 1, o3), function(e3, t4, i4) {
              var o4 = t4[0], r3 = t4[1], n3 = t4[2], s3 = t4[3], a3 = Math.sin(i4), l2 = Math.cos(i4);
              e3[0] = o4 * l2 + n3 * a3, e3[1] = r3 * l2 + s3 * a3, e3[2] = o4 * -a3 + n3 * l2, e3[3] = r3 * -a3 + s3 * l2;
            }(this.rotationMatrix, this.rotationMatrix, this.angle));
          }
          get pitch() {
            return this._pitch / Math.PI * 180;
          }
          set pitch(t3) {
            const i3 = e2.clamp(t3, this.minPitch, this.maxPitch) / 180 * Math.PI;
            this._pitch !== i3 && (this._unmodified = false, this._pitch = i3, this._calcMatrices());
          }
          get aspect() {
            return this.width / this.height;
          }
          get fov() {
            return this._fov / Math.PI * 180;
          }
          get fovX() {
            return this._fov;
          }
          get fovY() {
            const e3 = 1 / Math.tan(0.5 * this.fovX);
            return 2 * Math.atan(1 / this.aspect / e3);
          }
          set fov(t3) {
            t3 = Math.max(0.01, Math.min(60, t3)), this._fov !== t3 && (this._unmodified = false, this._fov = e2.degToRad(t3), this._calcMatrices());
          }
          get averageElevation() {
            return this._averageElevation;
          }
          set averageElevation(e3) {
            this._averageElevation = e3, this._calcFogMatrices(), this._distanceTileDataCache = {};
          }
          get zoom() {
            return this._zoom;
          }
          set zoom(e3) {
            const t3 = Math.min(Math.max(e3, this.minZoom), this.maxZoom);
            this._zoom !== t3 && (this._unmodified = false, this._setZoom(t3), this._updateSeaLevelZoom(), this._constrain(), this._calcMatrices());
          }
          _setZoom(e3) {
            this._zoom = e3, this.scale = this.zoomScale(e3), this.tileZoom = Math.floor(e3), this.zoomFraction = e3 - this.tileZoom;
          }
          _updateCameraOnTerrain() {
            if (!this._elevation || !this._elevation.isDataAvailableAtPoint(this.locationCoordinate(this.center)))
              return this._centerAltitude = 0, this._seaLevelZoom = null, void (this._centerAltitudeValidForExaggeration = void 0);
            const e3 = this._elevation;
            this._centerAltitude = e3.getAtPointOrZero(this.locationCoordinate(this.center)), this._centerAltitudeValidForExaggeration = e3.exaggeration(), this._updateSeaLevelZoom();
          }
          _updateSeaLevelZoom() {
            void 0 !== this._centerAltitudeValidForExaggeration && (this._seaLevelZoom = this._zoomFromMercatorZ((this.pixelsPerMeter * this._centerAltitude + this.cameraToCenterDistance) / this.worldSize));
          }
          sampleAverageElevation() {
            if (!this._elevation)
              return 0;
            const t3 = this._elevation, i3 = [[0.5, 0.2], [0.3, 0.5], [0.5, 0.5], [0.7, 0.5], [0.5, 0.8]], o3 = this.horizonLineFromTop();
            let r3 = 0, n3 = 0;
            for (let s3 = 0; s3 < i3.length; s3++) {
              const a3 = new e2.Point(i3[s3][0] * this.width, o3 + i3[s3][1] * (this.height - o3)), l2 = t3.pointCoordinate(a3);
              if (!l2)
                continue;
              const c3 = 1 / Math.hypot(l2[0] - this._camera.position[0], l2[1] - this._camera.position[1]);
              r3 += l2[3] * c3, n3 += c3;
            }
            return 0 === n3 ? NaN : r3 / n3;
          }
          get center() {
            return this._center;
          }
          set center(e3) {
            e3.lat === this._center.lat && e3.lng === this._center.lng || (this._unmodified = false, this._center = e3, this._terrainEnabled() && ("ground" === this.cameraElevationReference ? this._updateCameraOnTerrain() : this._updateZoomFromElevation()), this._constrain(), this._calcMatrices());
          }
          _updateZoomFromElevation() {
            if (null == this._seaLevelZoom || !this._elevation)
              return;
            const e3 = this._seaLevelZoom, t3 = this._elevation.getAtPointOrZero(this.locationCoordinate(this.center)), i3 = this.pixelsPerMeter / this.worldSize * t3, o3 = this._mercatorZfromZoom(e3), r3 = this._mercatorZfromZoom(this._maxZoom), n3 = Math.max(o3 - i3, r3);
            this._setZoom(this._zoomFromMercatorZ(n3));
          }
          get padding() {
            return this._edgeInsets.toJSON();
          }
          set padding(e3) {
            this._edgeInsets.equals(e3) || (this._unmodified = false, this._edgeInsets.interpolate(this._edgeInsets, e3, 1), this._calcMatrices());
          }
          computeZoomRelativeTo(t3) {
            const i3 = this.rayIntersectionCoordinate(this.pointRayIntersection(this.centerPoint, t3.toAltitude()));
            let o3;
            o3 = t3.z < this._camera.position[2] ? [i3.x, i3.y, i3.z] : [t3.x, t3.y, t3.z];
            const r3 = e2.length(e2.sub([], this._camera.position, o3));
            return e2.clamp(this._zoomFromMercatorZ(r3), this._minZoom, this._maxZoom);
          }
          setFreeCameraOptions(t3) {
            if (!this.height)
              return;
            if (!t3.position && !t3.orientation)
              return;
            this._updateCameraState();
            let i3 = false;
            if (t3.orientation && !e2.exactEquals(t3.orientation, this._camera.orientation) && (i3 = this._setCameraOrientation(t3.orientation)), t3.position) {
              const o3 = [t3.position.x, t3.position.y, t3.position.z];
              e2.exactEquals$1(o3, this._camera.position) || (this._setCameraPosition(o3), i3 = true);
            }
            i3 && (this._updateStateFromCamera(), this.recenterOnTerrain());
          }
          getFreeCameraOptions() {
            this._updateCameraState();
            const t3 = this._camera.position, i3 = new jo();
            return i3.position = new e2.MercatorCoordinate(t3[0], t3[1], t3[2]), i3.orientation = this._camera.orientation, i3._elevation = this.elevation, i3._renderWorldCopies = this.renderWorldCopies, i3;
          }
          _setCameraOrientation(t3) {
            if (!e2.length$1(t3))
              return false;
            e2.normalize$1(t3, t3);
            const i3 = e2.transformQuat([], [0, 0, -1], t3), o3 = e2.transformQuat([], [0, -1, 0], t3);
            if (o3[2] < 0)
              return false;
            const r3 = No(i3, o3);
            return !!r3 && (this._camera.orientation = r3, true);
          }
          _setCameraPosition(t3) {
            const i3 = this.zoomScale(this.minZoom) * this.tileSize, o3 = this.zoomScale(this.maxZoom) * this.tileSize, r3 = this.cameraToCenterDistance;
            t3[2] = e2.clamp(t3[2], r3 / o3, r3 / i3), this._camera.position = t3;
          }
          get centerPoint() {
            return this._edgeInsets.getCenter(this.width, this.height);
          }
          get fovAboveCenter() {
            return this._fov * (0.5 + this.centerOffset.y / this.height);
          }
          isPaddingEqual(e3) {
            return this._edgeInsets.equals(e3);
          }
          interpolatePadding(e3, t3, i3) {
            this._unmodified = false, this._edgeInsets.interpolate(e3, t3, i3), this._constrain(), this._calcMatrices();
          }
          coveringZoomLevel(e3) {
            const t3 = (e3.roundZoom ? Math.round : Math.floor)(this.zoom + this.scaleZoom(this.tileSize / e3.tileSize));
            return Math.max(0, t3);
          }
          getVisibleUnwrappedCoordinates(t3) {
            const i3 = [new e2.UnwrappedTileID(0, t3)];
            if (this.renderWorldCopies) {
              const o3 = this.pointCoordinate(new e2.Point(0, 0)), r3 = this.pointCoordinate(new e2.Point(this.width, 0)), n3 = this.pointCoordinate(new e2.Point(this.width, this.height)), s3 = this.pointCoordinate(new e2.Point(0, this.height)), a3 = Math.floor(Math.min(o3.x, r3.x, n3.x, s3.x)), l2 = Math.floor(Math.max(o3.x, r3.x, n3.x, s3.x)), c3 = 1;
              for (let o4 = a3 - c3; o4 <= l2 + c3; o4++)
                0 !== o4 && i3.push(new e2.UnwrappedTileID(o4, t3));
            }
            return i3;
          }
          coveringTiles(t3) {
            let i3 = this.coveringZoomLevel(t3);
            const o3 = i3, r3 = this.elevation && !t3.isTerrainDEM, n3 = "mercator" === this.projection.name;
            if (void 0 !== t3.minzoom && i3 < t3.minzoom)
              return [];
            void 0 !== t3.maxzoom && i3 > t3.maxzoom && (i3 = t3.maxzoom);
            const s3 = this.locationCoordinate(this.center), a3 = this.center.lat, l2 = 1 << i3, c3 = [l2 * s3.x, l2 * s3.y, 0], h3 = "globe" === this.projection.name, u3 = !h3, _2 = e2.Frustum.fromInvProjectionMatrix(this.invProjMatrix, this.worldSize, i3, u3), d3 = h3 ? this._camera.mercatorPosition : this.pointCoordinate(this.getCameraPoint()), p3 = l2 * e2.mercatorZfromAltitude(1, this.center.lat), m3 = this._camera.position[2] / e2.mercatorZfromAltitude(1, this.center.lat), f3 = [l2 * d3.x, l2 * d3.y, m3 * (u3 ? 1 : p3)], g3 = this.cameraToCenterDistance / t3.tileSize * (t3.roundZoom ? 1 : 0.502), v3 = this.pitch <= 60 && this._edgeInsets.top <= this._edgeInsets.bottom && !this._elevation && !this.projection.isReprojectedInTileSpace ? i3 : 0, x3 = t3.isTerrainDEM && this._elevation ? 1e4 * this._elevation.exaggeration() : this._centerAltitude, y3 = t3.isTerrainDEM ? -x3 : this._elevation ? this._elevation.getMinElevationBelowMSL() : 0, b2 = this.projection.isReprojectedInTileSpace ? Vo(this) : 1, w2 = (t4) => {
              const i4 = 1 / 4e4, o4 = new e2.MercatorCoordinate(t4.x + i4, t4.y, t4.z), r4 = new e2.MercatorCoordinate(t4.x, t4.y + i4, t4.z), n4 = t4.toLngLat(), s4 = o4.toLngLat(), a4 = r4.toLngLat(), l3 = this.locationCoordinate(n4), c4 = this.locationCoordinate(s4), h4 = this.locationCoordinate(a4), u4 = Math.hypot(c4.x - l3.x, c4.y - l3.y), _3 = Math.hypot(h4.x - l3.x, h4.y - l3.y);
              return Math.sqrt(u4 * _3) * b2 / i4;
            }, T2 = (t4) => {
              const i4 = x3, o4 = y3;
              return { aabb: e2.tileAABB(this, l2, 0, 0, 0, t4, o4, i4, this.projection), zoom: 0, x: 0, y: 0, minZ: o4, maxZ: i4, wrap: t4, fullyVisible: false };
            }, E3 = [];
            let C2 = [];
            const M2 = i3, I2 = t3.reparseOverscaled ? o3 : i3, P2 = (e3) => e3 * e3, S2 = P2((m3 - this._centerAltitude) * p3), D2 = (e3) => {
              if (!this._elevation || !e3.tileID || !n3)
                return;
              const t4 = this._elevation.getMinMaxForTile(e3.tileID), i4 = e3.aabb;
              t4 ? (i4.min[2] = t4.min, i4.max[2] = t4.max, i4.center[2] = (i4.min[2] + i4.max[2]) / 2) : (e3.shouldSplit = L2(e3), e3.shouldSplit || (i4.min[2] = i4.max[2] = i4.center[2] = this._centerAltitude));
            }, L2 = (t4) => {
              if (t4.zoom < v3)
                return true;
              if (t4.zoom === M2)
                return false;
              if (null != t4.shouldSplit)
                return t4.shouldSplit;
              const i4 = t4.aabb.distanceX(f3), n4 = t4.aabb.distanceY(f3);
              let s4 = S2, l3 = 1;
              if (h3) {
                s4 = P2(t4.aabb.distanceZ(f3));
                const i5 = Math.pow(2, t4.zoom), o4 = e2.latFromMercatorY((t4.y + 1) / i5), r4 = e2.latFromMercatorY(t4.y / i5), n5 = Math.min(Math.max(a3, o4), r4), c5 = e2.circumferenceAtLatitude(n5) / e2.circumferenceAtLatitude(a3);
                if (l3 = n5 === a3 ? 1 / Math.max(1, this._mercatorScaleRatio - 0.3) : Math.min(1, c5 / this._mercatorScaleRatio), this.zoom <= e2.GLOBE_ZOOM_THRESHOLD_MIN && t4.zoom === M2 - 1 && c5 >= 0.9)
                  return true;
              } else if (r3 && (s4 = P2(t4.aabb.distanceZ(f3) * p3)), this.projection.isReprojectedInTileSpace && o3 <= 5) {
                const i5 = Math.pow(2, t4.zoom), o4 = w2(new e2.MercatorCoordinate((t4.x + 0.5) / i5, (t4.y + 0.5) / i5));
                l3 = o4 > 0.85 ? 1 : o4;
              }
              const c4 = i4 * i4 + n4 * n4 + s4, u4 = P2((1 << M2 - t4.zoom) * g3 * l3 * ((e3, t5) => {
                if (t5 * P2(0.707) < e3)
                  return 1;
                const i5 = Math.sqrt(t5 / e3);
                return i5 / (1.4144271570014144 + (Math.pow(1.1, i5 - 1.4144271570014144 + 1) - 1) / (1.1 - 1) - 1);
              })(Math.max(s4, S2), c4));
              return c4 < u4;
            };
            if (this.renderWorldCopies)
              for (let e3 = 1; e3 <= 3; e3++)
                E3.push(T2(-e3)), E3.push(T2(e3));
            for (E3.push(T2(0)); E3.length > 0; ) {
              const o4 = E3.pop(), s4 = o4.x, a4 = o4.y;
              let u4 = o4.fullyVisible;
              if (!u4) {
                const e3 = o4.aabb.intersects(_2);
                if (0 === e3)
                  continue;
                u4 = 2 === e3;
              }
              if (o4.zoom !== M2 && L2(o4))
                for (let t4 = 0; t4 < 4; t4++) {
                  const i4 = (s4 << 1) + t4 % 2, c4 = (a4 << 1) + (t4 >> 1), _3 = { aabb: n3 ? o4.aabb.quadrant(t4) : e2.tileAABB(this, l2, o4.zoom + 1, i4, c4, o4.wrap, o4.minZ, o4.maxZ, this.projection), zoom: o4.zoom + 1, x: i4, y: c4, wrap: o4.wrap, fullyVisible: u4, tileID: void 0, shouldSplit: void 0, minZ: o4.minZ, maxZ: o4.maxZ };
                  r3 && !h3 && (_3.tileID = new e2.OverscaledTileID(o4.zoom + 1 === M2 ? I2 : o4.zoom + 1, o4.wrap, o4.zoom + 1, i4, c4), D2(_3)), E3.push(_3);
                }
              else {
                const r4 = o4.zoom === M2 ? I2 : o4.zoom;
                if (t3.minzoom && t3.minzoom > r4)
                  continue;
                const n4 = c3[0] - (0.5 + s4 + (o4.wrap << o4.zoom)) * (1 << i3 - o4.zoom), l3 = c3[1] - 0.5 - a4, h4 = o4.tileID ? o4.tileID : new e2.OverscaledTileID(r4, o4.wrap, o4.zoom, s4, a4);
                C2.push({ tileID: h4, distanceSq: n4 * n4 + l3 * l3 });
              }
            }
            if (this.fogCullDistSq) {
              const i4 = this.fogCullDistSq, o4 = this.horizonLineFromTop();
              C2 = C2.filter((r4) => {
                const n4 = [0, 0, 0, 1], s4 = [e2.EXTENT, e2.EXTENT, 0, 1], a4 = this.calculateFogTileMatrix(r4.tileID.toUnwrapped());
                e2.transformMat4$1(n4, n4, a4), e2.transformMat4$1(s4, s4, a4);
                const l3 = e2.getAABBPointSquareDist(n4, s4);
                if (0 === l3)
                  return true;
                let c4 = false;
                const h4 = this._elevation;
                if (h4 && l3 > i4 && 0 !== o4) {
                  const i5 = this.calculateProjMatrix(r4.tileID.toUnwrapped());
                  let n5;
                  t3.isTerrainDEM || (n5 = h4.getMinMaxForTile(r4.tileID)), n5 || (n5 = { min: y3, max: x3 });
                  const s5 = e2.furthestTileCorner(this.rotation), a5 = [s5[0] * e2.EXTENT, s5[1] * e2.EXTENT, n5.max];
                  e2.transformMat4(a5, a5, i5), c4 = (1 - a5[1]) * this.height * 0.5 < o4;
                }
                return l3 < i4 || c4;
              });
            }
            return C2.sort((e3, t4) => e3.distanceSq - t4.distanceSq).map((e3) => e3.tileID);
          }
          resize(e3, t3) {
            this.width = e3, this.height = t3, this.pixelsToGLUnits = [2 / e3, -2 / t3], this._constrain(), this._calcMatrices();
          }
          get unmodified() {
            return this._unmodified;
          }
          zoomScale(e3) {
            return Math.pow(2, e3);
          }
          scaleZoom(e3) {
            return Math.log(e3) / Math.LN2;
          }
          project(t3) {
            const i3 = e2.clamp(t3.lat, -e2.MAX_MERCATOR_LATITUDE, e2.MAX_MERCATOR_LATITUDE), o3 = this.projection.project(t3.lng, i3);
            return new e2.Point(o3.x * this.worldSize, o3.y * this.worldSize);
          }
          unproject(e3) {
            return this.projection.unproject(e3.x / this.worldSize, e3.y / this.worldSize);
          }
          get point() {
            return this.project(this.center);
          }
          get pointMerc() {
            return this.point._div(this.worldSize);
          }
          get pixelsPerMeterRatio() {
            return this.pixelsPerMeter / e2.mercatorZfromAltitude(1, this.center.lat) / this.worldSize;
          }
          setLocationAtPoint(t3, i3) {
            let o3, r3;
            const n3 = this.centerPoint;
            if ("globe" === this.projection.name) {
              const e3 = this.worldSize;
              o3 = (i3.x - n3.x) / e3, r3 = (i3.y - n3.y) / e3;
            } else {
              const e3 = this.pointCoordinate(i3), t4 = this.pointCoordinate(n3);
              o3 = e3.x - t4.x, r3 = e3.y - t4.y;
            }
            const s3 = this.locationCoordinate(t3);
            this.setLocation(new e2.MercatorCoordinate(s3.x - o3, s3.y - r3));
          }
          setLocation(e3) {
            this.center = this.coordinateLocation(e3), this.projection.wrap && (this.center = this.center.wrap());
          }
          locationPoint(e3) {
            return this.projection.locationPoint(this, e3);
          }
          locationPoint3D(e3) {
            return this.projection.locationPoint(this, e3, true);
          }
          pointLocation(e3) {
            return this.coordinateLocation(this.pointCoordinate(e3));
          }
          pointLocation3D(e3) {
            return this.coordinateLocation(this.pointCoordinate3D(e3));
          }
          locationCoordinate(t3, i3) {
            const o3 = i3 ? e2.mercatorZfromAltitude(i3, t3.lat) : void 0, r3 = this.projection.project(t3.lng, t3.lat);
            return new e2.MercatorCoordinate(r3.x, r3.y, o3);
          }
          coordinateLocation(e3) {
            return this.projection.unproject(e3.x, e3.y);
          }
          pointRayIntersection(t3, i3) {
            const o3 = null != i3 ? i3 : this._centerAltitude, r3 = [t3.x, t3.y, 0, 1], n3 = [t3.x, t3.y, 1, 1];
            e2.transformMat4$1(r3, r3, this.pixelMatrixInverse), e2.transformMat4$1(n3, n3, this.pixelMatrixInverse);
            const s3 = n3[3];
            e2.scale$1(r3, r3, 1 / r3[3]), e2.scale$1(n3, n3, 1 / s3);
            const a3 = r3[2], l2 = n3[2];
            return { p0: r3, p1: n3, t: a3 === l2 ? 0 : (o3 - a3) / (l2 - a3) };
          }
          screenPointToMercatorRay(t3) {
            const i3 = [t3.x, t3.y, 0, 1], o3 = [t3.x, t3.y, 1, 1];
            return e2.transformMat4$1(i3, i3, this.pixelMatrixInverse), e2.transformMat4$1(o3, o3, this.pixelMatrixInverse), e2.scale$1(i3, i3, 1 / i3[3]), e2.scale$1(o3, o3, 1 / o3[3]), i3[2] = e2.mercatorZfromAltitude(i3[2], this._center.lat) * this.worldSize, o3[2] = e2.mercatorZfromAltitude(o3[2], this._center.lat) * this.worldSize, e2.scale$1(i3, i3, 1 / this.worldSize), e2.scale$1(o3, o3, 1 / this.worldSize), new e2.Ray([i3[0], i3[1], i3[2]], e2.normalize([], e2.sub([], o3, i3)));
          }
          rayIntersectionCoordinate(t3) {
            const { p0: i3, p1: o3, t: r3 } = t3, n3 = e2.mercatorZfromAltitude(i3[2], this._center.lat), s3 = e2.mercatorZfromAltitude(o3[2], this._center.lat);
            return new e2.MercatorCoordinate(e2.number(i3[0], o3[0], r3) / this.worldSize, e2.number(i3[1], o3[1], r3) / this.worldSize, e2.number(n3, s3, r3));
          }
          pointCoordinate(e3, t3 = this._centerAltitude) {
            return this.projection.pointCoordinate(this, e3.x, e3.y, t3);
          }
          pointCoordinate3D(t3) {
            if (!this.elevation)
              return this.pointCoordinate(t3);
            let i3 = this.projection.pointCoordinate3D(this, t3.x, t3.y);
            if (i3)
              return new e2.MercatorCoordinate(i3[0], i3[1], i3[2]);
            let o3 = 0, r3 = this.horizonLineFromTop();
            if (t3.y > r3)
              return this.pointCoordinate(t3);
            const n3 = 0.02 * r3, s3 = t3.clone();
            for (let t4 = 0; t4 < 10 && r3 - o3 > n3; t4++) {
              s3.y = e2.number(o3, r3, 0.66);
              const t5 = this.projection.pointCoordinate3D(this, s3.x, s3.y);
              t5 ? (r3 = s3.y, i3 = t5) : o3 = s3.y;
            }
            return i3 ? new e2.MercatorCoordinate(i3[0], i3[1], i3[2]) : this.pointCoordinate(t3);
          }
          isPointAboveHorizon(e3) {
            return this.projection.isPointAboveHorizon(this, e3);
          }
          isPointOnSurface(t3) {
            if (t3.y < 0 || t3.y > this.height || t3.x < 0 || t3.x > this.width)
              return false;
            if (this.elevation || this.zoom >= e2.GLOBE_ZOOM_THRESHOLD_MAX)
              return !this.isPointAboveHorizon(t3);
            const i3 = this.pointCoordinate(t3);
            return i3.y >= 0 && i3.y <= 1;
          }
          _coordinatePoint(t3, i3) {
            const o3 = i3 && this.elevation ? this.elevation.getAtPointOrZero(t3, this._centerAltitude) : this._centerAltitude, r3 = [t3.x * this.worldSize, t3.y * this.worldSize, o3 + t3.toAltitude(), 1];
            return e2.transformMat4$1(r3, r3, this.pixelMatrix), r3[3] > 0 ? new e2.Point(r3[0] / r3[3], r3[1] / r3[3]) : new e2.Point(Number.MAX_VALUE, Number.MAX_VALUE);
          }
          _getBoundsNonRectangular() {
            const { top: t3, left: i3 } = this._edgeInsets, o3 = this.height - this._edgeInsets.bottom, r3 = this.width - this._edgeInsets.right, n3 = this.pointLocation3D(new e2.Point(i3, t3)), s3 = this.pointLocation3D(new e2.Point(r3, t3)), a3 = this.pointLocation3D(new e2.Point(r3, o3)), l2 = this.pointLocation3D(new e2.Point(i3, o3));
            let c3 = Math.min(n3.lng, s3.lng, a3.lng, l2.lng), h3 = Math.max(n3.lng, s3.lng, a3.lng, l2.lng), u3 = Math.min(n3.lat, s3.lat, a3.lat, l2.lat), _2 = Math.max(n3.lat, s3.lat, a3.lat, l2.lat);
            const d3 = Math.pow(2, -this.zoom) / 16 * 270, p3 = "globe" === this.projection.name ? 1 : 4, m3 = (t4, i4, o4, r4, n4) => {
              const s4 = (t4 + o4) / 2, a4 = (i4 + r4) / 2, l3 = new e2.Point(s4, a4), { lng: f3, lat: g3 } = this.pointLocation3D(l3), v3 = Math.max(0, c3 - f3, u3 - g3, f3 - h3, g3 - _2);
              c3 = Math.min(c3, f3), h3 = Math.max(h3, f3), u3 = Math.min(u3, g3), _2 = Math.max(_2, g3), (n4 < p3 || v3 > d3) && (m3(t4, i4, s4, a4, n4 + 1), m3(s4, a4, o4, r4, n4 + 1));
            };
            if (m3(i3, t3, r3, t3, 1), m3(r3, t3, r3, o3, 1), m3(r3, o3, i3, o3, 1), m3(i3, o3, i3, t3, 1), "globe" === this.projection.name) {
              const [t4, i4] = e2.polesInViewport(this);
              t4 ? (_2 = 90, h3 = 180, c3 = -180) : i4 && (u3 = -90, h3 = 180, c3 = -180);
            }
            return new e2.LngLatBounds(new e2.LngLat(c3, u3), new e2.LngLat(h3, _2));
          }
          _getBoundsRectangular(t3, i3) {
            const { top: o3, left: r3 } = this._edgeInsets, n3 = this.height - this._edgeInsets.bottom, s3 = this.width - this._edgeInsets.right, a3 = new e2.Point(r3, o3), l2 = new e2.Point(s3, o3), c3 = new e2.Point(s3, n3), h3 = new e2.Point(r3, n3);
            let u3 = this.pointCoordinate(a3, t3), _2 = this.pointCoordinate(l2, t3);
            const d3 = this.pointCoordinate(c3, i3), p3 = this.pointCoordinate(h3, i3), m3 = (e3, t4) => (t4.y - e3.y) / (t4.x - e3.x);
            return u3.y > 1 && _2.y >= 0 ? u3 = new e2.MercatorCoordinate((1 - p3.y) / m3(p3, u3) + p3.x, 1) : u3.y < 0 && _2.y <= 1 && (u3 = new e2.MercatorCoordinate(-p3.y / m3(p3, u3) + p3.x, 0)), _2.y > 1 && u3.y >= 0 ? _2 = new e2.MercatorCoordinate((1 - d3.y) / m3(d3, _2) + d3.x, 1) : _2.y < 0 && u3.y <= 1 && (_2 = new e2.MercatorCoordinate(-d3.y / m3(d3, _2) + d3.x, 0)), new e2.LngLatBounds().extend(this.coordinateLocation(u3)).extend(this.coordinateLocation(_2)).extend(this.coordinateLocation(p3)).extend(this.coordinateLocation(d3));
          }
          _getBoundsRectangularTerrain() {
            const e3 = this.elevation;
            if (!e3.visibleDemTiles.length || e3.isUsingMockSource())
              return this._getBoundsRectangular(0, 0);
            const t3 = e3.visibleDemTiles.reduce((e4, t4) => {
              if (t4.dem) {
                const i3 = t4.dem.tree;
                e4.min = Math.min(e4.min, i3.minimums[0]), e4.max = Math.max(e4.max, i3.maximums[0]);
              }
              return e4;
            }, { min: Number.MAX_VALUE, max: 0 });
            return this._getBoundsRectangular(t3.min * e3.exaggeration(), t3.max * e3.exaggeration());
          }
          getBounds() {
            return "mercator" === this.projection.name || "equirectangular" === this.projection.name ? this._terrainEnabled() ? this._getBoundsRectangularTerrain() : this._getBoundsRectangular(0, 0) : this._getBoundsNonRectangular();
          }
          horizonLineFromTop(e3 = true) {
            const t3 = this.height / 2 / Math.tan(this._fov / 2) / Math.tan(Math.max(this._pitch, 0.1)) + this.centerOffset.y, i3 = this.height / 2 - t3 * (1 - this._horizonShift);
            return e3 ? Math.max(0, i3) : i3;
          }
          getMaxBounds() {
            return this.maxBounds;
          }
          setMaxBounds(t3) {
            this.maxBounds = t3, this.minLat = -e2.MAX_MERCATOR_LATITUDE, this.maxLat = e2.MAX_MERCATOR_LATITUDE, this.minLng = -180, this.maxLng = 180, t3 && (this.minLat = t3.getSouth(), this.maxLat = t3.getNorth(), this.minLng = t3.getWest(), this.maxLng = t3.getEast(), this.maxLng < this.minLng && (this.maxLng += 360)), this.worldMinX = e2.mercatorXfromLng(this.minLng) * this.tileSize, this.worldMaxX = e2.mercatorXfromLng(this.maxLng) * this.tileSize, this.worldMinY = e2.mercatorYfromLat(this.maxLat) * this.tileSize, this.worldMaxY = e2.mercatorYfromLat(this.minLat) * this.tileSize, this._constrain();
          }
          calculatePosMatrix(e3, t3) {
            return this.projection.createTileMatrix(this, t3, e3);
          }
          calculateDistanceTileData(t3) {
            const i3 = t3.key, o3 = this._distanceTileDataCache;
            if (o3[i3])
              return o3[i3];
            const r3 = t3.canonical, n3 = 1 / this.height, s3 = this.cameraWorldSize, a3 = s3 / this.zoomScale(r3.z), l2 = (r3.x + Math.pow(2, r3.z) * t3.wrap) * a3, c3 = r3.y * a3, h3 = this.point;
            h3.x *= s3 / this.worldSize, h3.y *= s3 / this.worldSize;
            const u3 = this.angle, _2 = Math.sin(-u3), d3 = -Math.cos(-u3);
            return o3[i3] = { bearing: [_2, d3], center: [(h3.x - l2) * n3, (h3.y - c3) * n3], scale: a3 / e2.EXTENT * n3 }, o3[i3];
          }
          calculateFogTileMatrix(t3) {
            const i3 = t3.key, o3 = this._fogTileMatrixCache;
            if (o3[i3])
              return o3[i3];
            const r3 = this.projection.createTileMatrix(this, this.cameraWorldSizeForFog, t3);
            return e2.multiply(r3, this.worldToFogMatrix, r3), o3[i3] = new Float32Array(r3), o3[i3];
          }
          calculateProjMatrix(t3, i3 = false) {
            const o3 = t3.key, r3 = i3 ? this._alignedProjMatrixCache : this._projMatrixCache;
            if (r3[o3])
              return r3[o3];
            const n3 = this.calculatePosMatrix(t3, this.worldSize);
            return e2.multiply(n3, this.projection.isReprojectedInTileSpace ? this.mercatorMatrix : i3 ? this.alignedProjMatrix : this.projMatrix, n3), r3[o3] = new Float32Array(n3), r3[o3];
          }
          calculatePixelsToTileUnitsMatrix(t3) {
            const i3 = t3.tileID.key, o3 = this._pixelsToTileUnitsCache;
            if (o3[i3])
              return o3[i3];
            const r3 = function(t4, i4) {
              const { scale: o4 } = t4.tileTransform, r4 = o4 * e2.EXTENT / (t4.tileSize * Math.pow(2, i4.zoom - t4.tileID.overscaledZ + t4.tileID.canonical.z));
              return n3 = new Float32Array(4), l2 = (s3 = i4.inverseAdjustmentMatrix)[1], c3 = s3[2], h3 = s3[3], _2 = (a3 = [r4, r4])[1], n3[0] = s3[0] * (u3 = a3[0]), n3[1] = l2 * u3, n3[2] = c3 * _2, n3[3] = h3 * _2, n3;
              var n3, s3, a3, l2, c3, h3, u3, _2;
            }(t3, this);
            return o3[i3] = r3, o3[i3];
          }
          customLayerMatrix() {
            return this.mercatorMatrix.slice();
          }
          globeToMercatorMatrix() {
            if ("globe" === this.projection.name) {
              const t3 = 1 / this.worldSize, i3 = e2.fromScaling([], [t3, t3, t3]);
              return e2.multiply(i3, i3, this.globeMatrix), i3;
            }
          }
          recenterOnTerrain() {
            if (!this._elevation || "globe" === this.projection.name)
              return;
            const t3 = this._elevation;
            this._updateCameraState();
            const i3 = e2.mercatorZfromAltitude(1, this._center.lat) * this.worldSize, o3 = this._computeCameraPosition(i3), r3 = this._camera.forward(), n3 = e2.mercatorZfromAltitude(1, this._center.lat);
            o3[2] /= n3, r3[2] /= n3, e2.normalize(r3, r3);
            const s3 = t3.raycast(o3, r3, t3.exaggeration());
            if (s3) {
              const t4 = e2.scaleAndAdd([], o3, r3, s3), i4 = new e2.MercatorCoordinate(t4[0], t4[1], e2.mercatorZfromAltitude(t4[2], e2.latFromMercatorY(t4[1]))), a3 = (i4.z + e2.length([i4.x - o3[0], i4.y - o3[1], i4.z - o3[2] * n3])) * this._pixelsPerMercatorPixel;
              this._seaLevelZoom = this._zoomFromMercatorZ(a3), this._centerAltitude = i4.toAltitude(), this._center = this.coordinateLocation(i4), this._updateZoomFromElevation(), this._constrain(), this._calcMatrices();
            }
          }
          _constrainCamera(t3 = false) {
            if (!this._elevation)
              return;
            const i3 = this._elevation, o3 = e2.mercatorZfromAltitude(1, this._center.lat) * this.worldSize, r3 = this._computeCameraPosition(o3), n3 = i3.getAtPointOrZero(new e2.MercatorCoordinate(...r3)), s3 = this.pixelsPerMeter / this.worldSize * n3, a3 = this._minimumHeightOverTerrain(), l2 = r3[2] - s3;
            if (l2 <= a3)
              if (l2 < 0 || t3) {
                const t4 = this.locationCoordinate(this._center, this._centerAltitude), i4 = [r3[0], r3[1], t4.z - r3[2]], o4 = e2.length(i4);
                i4[2] -= (a3 - l2) / this._pixelsPerMercatorPixel;
                const n4 = e2.length(i4);
                if (0 === n4)
                  return;
                e2.scale$2(i4, i4, o4 / n4 * this._pixelsPerMercatorPixel), this._camera.position = [r3[0], r3[1], t4.z * this._pixelsPerMercatorPixel - i4[2]], this._updateStateFromCamera();
              } else
                this._isCameraConstrained = true;
          }
          _constrain() {
            if (!this.center || !this.width || !this.height || this._constraining)
              return;
            this._constraining = true;
            const t3 = "globe" === this.projection.name || this.mercatorFromTransition;
            if (this.projection.isReprojectedInTileSpace || t3) {
              const i4 = this.center;
              return i4.lat = e2.clamp(i4.lat, this.minLat, this.maxLat), (this.maxBounds || !this.renderWorldCopies && !t3) && (i4.lng = e2.clamp(i4.lng, this.minLng, this.maxLng)), this.center = i4, void (this._constraining = false);
            }
            const i3 = this._unmodified, { x: o3, y: r3 } = this.point;
            let n3 = 0, s3 = o3, a3 = r3;
            const l2 = this.width / 2, c3 = this.height / 2, h3 = this.worldMinY * this.scale, u3 = this.worldMaxY * this.scale;
            if (r3 - c3 < h3 && (a3 = h3 + c3), r3 + c3 > u3 && (a3 = u3 - c3), u3 - h3 < this.height && (n3 = Math.max(n3, this.height / (u3 - h3)), a3 = (u3 + h3) / 2), this.maxBounds || !this._renderWorldCopies || !this.projection.wrap) {
              const e3 = this.worldMinX * this.scale, t4 = this.worldMaxX * this.scale, i4 = this.worldSize / 2 - (e3 + t4) / 2;
              s3 = (o3 + i4 + this.worldSize) % this.worldSize - i4, s3 - l2 < e3 && (s3 = e3 + l2), s3 + l2 > t4 && (s3 = t4 - l2), t4 - e3 < this.width && (n3 = Math.max(n3, this.width / (t4 - e3)), s3 = (t4 + e3) / 2);
            }
            s3 === o3 && a3 === r3 || (this.center = this.unproject(new e2.Point(s3, a3))), n3 && (this.zoom += this.scaleZoom(n3)), this._constrainCamera(), this._unmodified = i3, this._constraining = false;
          }
          _minZoomForBounds() {
            let e3 = Math.max(0, this.scaleZoom(this.height / (this.worldMaxY - this.worldMinY)));
            return this.maxBounds && (e3 = Math.max(e3, this.scaleZoom(this.width / (this.worldMaxX - this.worldMinX)))), e3;
          }
          _maxCameraBoundsDistance() {
            return this._mercatorZfromZoom(this._minZoomForBounds());
          }
          _calcMatrices() {
            if (!this.height)
              return;
            const t3 = this.centerOffset, i3 = this.pixelsPerMeter;
            "globe" === this.projection.name && (this._mercatorScaleRatio = e2.mercatorZfromAltitude(1, this.center.lat) / e2.mercatorZfromAltitude(1, e2.GLOBE_SCALE_MATCH_LATITUDE));
            const o3 = Wo(this.projection, this.zoom, this.width, this.height, 1024);
            this._pixelsPerMercatorPixel = this.projection.pixelSpaceConversion(this.center.lat, this.worldSize, o3), this.cameraToCenterDistance = 0.5 / Math.tan(0.5 * this._fov) * this.height * this._pixelsPerMercatorPixel, this._updateCameraState(), this._farZ = this.projection.farthestPixelDistance(this), this._nearZ = this.height / 50;
            const r3 = "meters" === this.projection.zAxisUnit ? i3 : 1, n3 = this._camera.getWorldToCamera(this.worldSize, r3), s3 = this._camera.getCameraToClipPerspective(this._fov, this.width / this.height, this._nearZ, this._farZ);
            s3[8] = 2 * -t3.x / this.width, s3[9] = 2 * t3.y / this.height;
            let a3 = e2.mul([], s3, n3);
            if (this.projection.isReprojectedInTileSpace) {
              const t4 = this.locationCoordinate(this.center), i4 = e2.identity([]);
              e2.translate(i4, i4, [t4.x * this.worldSize, t4.y * this.worldSize, 0]), e2.multiply(i4, i4, Zo(this)), e2.translate(i4, i4, [-t4.x * this.worldSize, -t4.y * this.worldSize, 0]), e2.multiply(a3, a3, i4), this.inverseAdjustmentMatrix = function(e3) {
                const t5 = Zo(e3, true);
                return v2([], [t5[0], t5[1], t5[4], t5[5]]);
              }(this);
            } else
              this.inverseAdjustmentMatrix = [1, 0, 0, 1];
            this.mercatorMatrix = e2.scale([], a3, [this.worldSize, this.worldSize, this.worldSize / r3, 1]), this.projMatrix = a3, this.invProjMatrix = e2.invert(new Float64Array(16), this.projMatrix);
            const l2 = e2.invert([], s3);
            this.frustumCorners = e2.FrustumCorners.fromInvProjectionMatrix(l2, this.horizonLineFromTop(), this.height);
            const c3 = new Float32Array(16);
            e2.identity(c3), e2.scale(c3, c3, [1, -1, 1]), e2.rotateX(c3, c3, this._pitch), e2.rotateZ(c3, c3, this.angle);
            const h3 = e2.perspective(new Float32Array(16), this._fov, this.width / this.height, this._nearZ, this._farZ), u3 = (Math.PI / 2 - this._pitch) * (this.height / this._fov) * this._horizonShift;
            h3[8] = 2 * -t3.x / this.width, h3[9] = 2 * (t3.y + u3) / this.height, this.skyboxMatrix = e2.multiply(c3, h3, c3);
            const _2 = this.point, d3 = _2.x, p3 = _2.y, m3 = this.width % 2 / 2, f3 = this.height % 2 / 2, g3 = Math.cos(this.angle), x3 = Math.sin(this.angle), y3 = d3 - Math.round(d3) + g3 * m3 + x3 * f3, b2 = p3 - Math.round(p3) + g3 * f3 + x3 * m3, w2 = new Float64Array(a3);
            if (e2.translate(w2, w2, [y3 > 0.5 ? y3 - 1 : y3, b2 > 0.5 ? b2 - 1 : b2, 0]), this.alignedProjMatrix = w2, a3 = e2.create(), e2.scale(a3, a3, [this.width / 2, -this.height / 2, 1]), e2.translate(a3, a3, [1, -1, 0]), this.labelPlaneMatrix = a3, a3 = e2.create(), e2.scale(a3, a3, [1, -1, 1]), e2.translate(a3, a3, [-1, -1, 0]), e2.scale(a3, a3, [2 / this.width, 2 / this.height, 1]), this.glCoordMatrix = a3, this.pixelMatrix = e2.multiply(new Float64Array(16), this.labelPlaneMatrix, this.projMatrix), this._calcFogMatrices(), this._distanceTileDataCache = {}, a3 = e2.invert(new Float64Array(16), this.pixelMatrix), !a3)
              throw new Error("failed to invert matrix");
            if (this.pixelMatrixInverse = a3, "globe" === this.projection.name || this.mercatorFromTransition) {
              this.globeMatrix = e2.calculateGlobeMatrix(this);
              const t4 = [this.globeMatrix[12], this.globeMatrix[13], this.globeMatrix[14]];
              this.globeCenterInViewSpace = e2.transformMat4(t4, t4, n3), this.globeRadius = this.worldSize / 2 / Math.PI - 1;
            } else
              this.globeMatrix = a3;
            this._projMatrixCache = {}, this._alignedProjMatrixCache = {}, this._pixelsToTileUnitsCache = {};
          }
          _calcFogMatrices() {
            this._fogTileMatrixCache = {};
            const t3 = this.cameraWorldSizeForFog, i3 = this.cameraPixelsPerMeter, o3 = this._camera.position, r3 = 1 / this.height / this._pixelsPerMercatorPixel, n3 = [t3, t3, i3];
            e2.scale$2(n3, n3, r3), e2.scale$2(o3, o3, -1), e2.multiply$2(o3, o3, n3);
            const s3 = e2.create();
            e2.translate(s3, s3, o3), e2.scale(s3, s3, n3), this.mercatorFogMatrix = s3, this.worldToFogMatrix = this._camera.getWorldToCameraPosition(t3, i3, r3);
          }
          _computeCameraPosition(e3) {
            const t3 = (e3 = e3 || this.pixelsPerMeter) / this.pixelsPerMeter, i3 = this._camera.forward(), o3 = this.point, r3 = this._mercatorZfromZoom(this._seaLevelZoom ? this._seaLevelZoom : this._zoom) * t3 - e3 / this.worldSize * this._centerAltitude;
            return [o3.x / this.worldSize - i3[0] * r3, o3.y / this.worldSize - i3[1] * r3, e3 / this.worldSize * this._centerAltitude - i3[2] * r3];
          }
          _updateCameraState() {
            this.height && (this._camera.setPitchBearing(this._pitch, this.angle), this._camera.position = this._computeCameraPosition());
          }
          _translateCameraConstrained(t3) {
            const i3 = this._maxCameraBoundsDistance() * Math.cos(this._pitch), o3 = this._camera.position[2], r3 = t3[2];
            let n3 = 1;
            this.projection.wrap && (this.center = this.center.wrap()), r3 > 0 && (n3 = Math.min((i3 - o3) / r3, 1)), this._camera.position = e2.scaleAndAdd([], this._camera.position, t3, n3), this._updateStateFromCamera();
          }
          _updateStateFromCamera() {
            const t3 = this._camera.position, i3 = this._camera.forward(), { pitch: o3, bearing: r3 } = this._camera.getPitchBearing(), n3 = e2.mercatorZfromAltitude(this._centerAltitude, this.center.lat) * this._pixelsPerMercatorPixel, s3 = this._mercatorZfromZoom(this._maxZoom) * Math.cos(e2.degToRad(this._maxPitch)), a3 = Math.max((t3[2] - n3) / Math.cos(o3), s3), l2 = this._zoomFromMercatorZ(a3);
            e2.scaleAndAdd(t3, t3, i3, a3), this._pitch = e2.clamp(o3, e2.degToRad(this.minPitch), e2.degToRad(this.maxPitch)), this.angle = e2.wrap(r3, -Math.PI, Math.PI), this._setZoom(e2.clamp(l2, this._minZoom, this._maxZoom)), this._updateSeaLevelZoom(), this._center = this.coordinateLocation(new e2.MercatorCoordinate(t3[0], t3[1], t3[2])), this._unmodified = false, this._constrain(), this._calcMatrices();
          }
          _worldSizeFromZoom(e3) {
            return Math.pow(2, e3) * this.tileSize;
          }
          _mercatorZfromZoom(e3) {
            return this.cameraToCenterDistance / this._worldSizeFromZoom(e3);
          }
          _minimumHeightOverTerrain() {
            const e3 = Math.min((null != this._seaLevelZoom ? this._seaLevelZoom : this._zoom) + 4, this._maxZoom);
            return this._mercatorZfromZoom(e3);
          }
          _zoomFromMercatorZ(e3) {
            return this.scaleZoom(this.cameraToCenterDistance / (e3 * this.tileSize));
          }
          zoomFromMercatorZAdjusted(t3) {
            let i3 = 0, o3 = e2.GLOBE_ZOOM_THRESHOLD_MAX, r3 = 0, n3 = 1 / 0;
            for (; o3 - i3 > 1e-6 && o3 > i3; ) {
              const e3 = i3 + 0.5 * (o3 - i3), s3 = this.tileSize * Math.pow(2, e3), a3 = this.getCameraToCenterDistance(this.projection, e3, s3), l2 = this.scaleZoom(a3 / (t3 * this.tileSize)), c3 = Math.abs(e3 - l2);
              c3 < n3 && (n3 = c3, r3 = e3), e3 < l2 ? i3 = e3 : o3 = e3;
            }
            return r3;
          }
          _terrainEnabled() {
            return !(!this._elevation || !this.projection.supportsTerrain && (e2.warnOnce("Terrain is not yet supported with alternate projections. Use mercator or globe to enable terrain."), 1));
          }
          anyCornerOffEdge(t3, i3) {
            const o3 = Math.min(t3.x, i3.x), r3 = Math.max(t3.x, i3.x), n3 = Math.min(t3.y, i3.y), s3 = Math.max(t3.y, i3.y);
            if (n3 < this.horizonLineFromTop(false))
              return true;
            if ("mercator" !== this.projection.name)
              return false;
            const a3 = [new e2.Point(o3, n3), new e2.Point(r3, s3), new e2.Point(o3, s3), new e2.Point(r3, n3)], l2 = this.renderWorldCopies ? -3 : 0, c3 = this.renderWorldCopies ? 4 : 1;
            for (const e3 of a3) {
              const t4 = this.pointRayIntersection(e3);
              if (t4.t < 0)
                return true;
              const i4 = this.rayIntersectionCoordinate(t4);
              if (i4.x < l2 || i4.y < 0 || i4.x > c3 || i4.y > 1)
                return true;
            }
            return false;
          }
          isHorizonVisible() {
            return this.pitch + e2.radToDeg(this.fovAboveCenter) > 88 || this.anyCornerOffEdge(new e2.Point(0, 0), new e2.Point(this.width, this.height));
          }
          zoomDeltaToMovement(t3, i3) {
            const o3 = e2.length(e2.sub([], this._camera.position, t3)), r3 = this._zoomFromMercatorZ(o3) + i3;
            return o3 - this._mercatorZfromZoom(r3);
          }
          getCameraPoint() {
            if ("globe" === this.projection.name) {
              const t3 = function([t4, i3, o3], r3) {
                const n3 = [t4, i3, o3, 1];
                e2.transformMat4$1(n3, n3, r3);
                const s3 = n3[3] = Math.max(n3[3], 1e-6);
                return n3[0] /= s3, n3[1] /= s3, n3[2] /= s3, n3;
              }([this.globeMatrix[12], this.globeMatrix[13], this.globeMatrix[14]], this.pixelMatrix);
              return new e2.Point(t3[0], t3[1]);
            }
            {
              const t3 = Math.tan(this._pitch) * (this.cameraToCenterDistance || 1);
              return this.centerPoint.add(new e2.Point(0, t3));
            }
          }
          getCameraToCenterDistance(e3, t3 = this.zoom, i3 = this.worldSize) {
            const o3 = Wo(e3, t3, this.width, this.height, 1024), r3 = e3.pixelSpaceConversion(this.center.lat, i3, o3);
            return 0.5 / Math.tan(0.5 * this._fov) * this.height * r3;
          }
          getWorldToCameraMatrix() {
            const t3 = this._camera.getWorldToCamera(this.worldSize, "meters" === this.projection.zAxisUnit ? this.pixelsPerMeter : 1);
            return "globe" === this.projection.name && e2.multiply(t3, t3, this.globeMatrix), t3;
          }
        }
        function Yo(e3, t3) {
          let i3 = false, o3 = null;
          const r3 = () => {
            o3 = null, i3 && (e3(), o3 = setTimeout(r3, t3), i3 = false);
          };
          return () => (i3 = true, o3 || r3(), o3);
        }
        class Ko {
          constructor(t3) {
            this._hashName = t3 && encodeURIComponent(t3), e2.bindAll(["_getCurrentHash", "_onHashChange", "_updateHash"], this), this._updateHash = Yo(this._updateHashUnthrottled.bind(this), 300);
          }
          addTo(t3) {
            return this._map = t3, e2.window.addEventListener("hashchange", this._onHashChange, false), t3.on("moveend", this._updateHash), this;
          }
          remove() {
            return this._map ? (this._map.off("moveend", this._updateHash), e2.window.removeEventListener("hashchange", this._onHashChange, false), clearTimeout(this._updateHash()), this._map = void 0, this) : this;
          }
          getHashString() {
            const t3 = this._map;
            if (!t3)
              return "";
            const i3 = Jo(t3);
            if (this._hashName) {
              const t4 = this._hashName;
              let o3 = false;
              const r3 = e2.window.location.hash.slice(1).split("&").map((e3) => {
                const r4 = e3.split("=")[0];
                return r4 === t4 ? (o3 = true, `${r4}=${i3}`) : e3;
              }).filter((e3) => e3);
              return o3 || r3.push(`${t4}=${i3}`), `#${r3.join("&")}`;
            }
            return `#${i3}`;
          }
          _getCurrentHash() {
            const t3 = e2.window.location.hash.replace("#", "");
            if (this._hashName) {
              let e3;
              return t3.split("&").map((e4) => e4.split("=")).forEach((t4) => {
                t4[0] === this._hashName && (e3 = t4);
              }), (e3 && e3[1] || "").split("/");
            }
            return t3.split("/");
          }
          _onHashChange() {
            const e3 = this._map;
            if (!e3)
              return false;
            const t3 = this._getCurrentHash();
            if (t3.length >= 3 && !t3.some((e4) => isNaN(e4))) {
              const i3 = e3.dragRotate.isEnabled() && e3.touchZoomRotate.isEnabled() ? +(t3[3] || 0) : e3.getBearing();
              return e3.jumpTo({ center: [+t3[2], +t3[1]], zoom: +t3[0], bearing: i3, pitch: +(t3[4] || 0) }), true;
            }
            return false;
          }
          _updateHashUnthrottled() {
            const t3 = e2.window.location.href.replace(/(#.+)?$/, this.getHashString());
            e2.window.history.replaceState(e2.window.history.state, null, t3);
          }
        }
        function Jo(e3, t3) {
          const i3 = e3.getCenter(), o3 = Math.round(100 * e3.getZoom()) / 100, r3 = Math.ceil((o3 * Math.LN2 + Math.log(512 / 360 / 0.5)) / Math.LN10), n3 = Math.pow(10, r3), s3 = Math.round(i3.lng * n3) / n3, a3 = Math.round(i3.lat * n3) / n3, l2 = e3.getBearing(), c3 = e3.getPitch();
          let h3 = t3 ? `/${s3}/${a3}/${o3}` : `${o3}/${a3}/${s3}`;
          return (l2 || c3) && (h3 += "/" + Math.round(10 * l2) / 10), c3 && (h3 += `/${Math.round(c3)}`), h3;
        }
        const Qo = { linearity: 0.3, easing: e2.bezier(0, 0, 0.3, 1) }, er = e2.extend({ deceleration: 2500, maxSpeed: 1400 }, Qo), tr = e2.extend({ deceleration: 20, maxSpeed: 1400 }, Qo), ir = e2.extend({ deceleration: 1e3, maxSpeed: 360 }, Qo), or = e2.extend({ deceleration: 1e3, maxSpeed: 90 }, Qo);
        class rr {
          constructor(e3) {
            this._map = e3, this.clear();
          }
          clear() {
            this._inertiaBuffer = [];
          }
          record(t3) {
            this._drainInertiaBuffer(), this._inertiaBuffer.push({ time: e2.exported.now(), settings: t3 });
          }
          _drainInertiaBuffer() {
            const t3 = this._inertiaBuffer, i3 = e2.exported.now();
            for (; t3.length > 0 && i3 - t3[0].time > 160; )
              t3.shift();
          }
          _onMoveEnd(t3) {
            if (this._map._prefersReducedMotion())
              return;
            if (this._drainInertiaBuffer(), this._inertiaBuffer.length < 2)
              return;
            const i3 = { zoom: 0, bearing: 0, pitch: 0, pan: new e2.Point(0, 0), pinchAround: void 0, around: void 0 };
            for (const { settings: e3 } of this._inertiaBuffer)
              i3.zoom += e3.zoomDelta || 0, i3.bearing += e3.bearingDelta || 0, i3.pitch += e3.pitchDelta || 0, e3.panDelta && i3.pan._add(e3.panDelta), e3.around && (i3.around = e3.around), e3.pinchAround && (i3.pinchAround = e3.pinchAround);
            const o3 = this._inertiaBuffer[this._inertiaBuffer.length - 1].time - this._inertiaBuffer[0].time, r3 = {};
            if (i3.pan.mag()) {
              const n3 = sr(i3.pan.mag(), o3, e2.extend({}, er, t3 || {}));
              r3.offset = i3.pan.mult(n3.amount / i3.pan.mag()), r3.center = this._map.transform.center, nr(r3, n3);
            }
            if (i3.zoom) {
              const e3 = sr(i3.zoom, o3, tr);
              r3.zoom = this._map.transform.zoom + e3.amount, nr(r3, e3);
            }
            if (i3.bearing) {
              const t4 = sr(i3.bearing, o3, ir);
              r3.bearing = this._map.transform.bearing + e2.clamp(t4.amount, -179, 179), nr(r3, t4);
            }
            if (i3.pitch) {
              const e3 = sr(i3.pitch, o3, or);
              r3.pitch = this._map.transform.pitch + e3.amount, nr(r3, e3);
            }
            if (r3.zoom || r3.bearing) {
              const e3 = void 0 === i3.pinchAround ? i3.around : i3.pinchAround;
              r3.around = e3 ? this._map.unproject(e3) : this._map.getCenter();
            }
            return this.clear(), r3.noMoveStart = true, r3;
          }
        }
        function nr(e3, t3) {
          (!e3.duration || e3.duration < t3.duration) && (e3.duration = t3.duration, e3.easing = t3.easing);
        }
        function sr(t3, i3, o3) {
          const { maxSpeed: r3, linearity: n3, deceleration: s3 } = o3, a3 = e2.clamp(t3 * n3 / (i3 / 1e3), -r3, r3), l2 = Math.abs(a3) / (s3 * n3);
          return { easing: o3.easing, duration: 1e3 * l2, amount: a3 * (l2 / 2) };
        }
        class ar extends e2.Event {
          preventDefault() {
            this._defaultPrevented = true;
          }
          get defaultPrevented() {
            return this._defaultPrevented;
          }
          constructor(t3, i3, o3, r3 = {}) {
            const n3 = p2(i3.getCanvasContainer(), o3), s3 = i3.unproject(n3);
            super(t3, e2.extend({ point: n3, lngLat: s3, originalEvent: o3 }, r3)), this._defaultPrevented = false, this.target = i3;
          }
        }
        class lr extends e2.Event {
          preventDefault() {
            this._defaultPrevented = true;
          }
          get defaultPrevented() {
            return this._defaultPrevented;
          }
          constructor(t3, i3, o3) {
            const r3 = "touchend" === t3 ? o3.changedTouches : o3.touches, n3 = m2(i3.getCanvasContainer(), r3), s3 = n3.map((e3) => i3.unproject(e3)), a3 = n3.reduce((e3, t4, i4, o4) => e3.add(t4.div(o4.length)), new e2.Point(0, 0));
            super(t3, { points: n3, point: a3, lngLats: s3, lngLat: i3.unproject(a3), originalEvent: o3 }), this._defaultPrevented = false;
          }
        }
        class cr extends e2.Event {
          preventDefault() {
            this._defaultPrevented = true;
          }
          get defaultPrevented() {
            return this._defaultPrevented;
          }
          constructor(e3, t3, i3) {
            super(e3, { originalEvent: i3 }), this._defaultPrevented = false;
          }
        }
        class hr {
          constructor(e3, t3) {
            this._map = e3, this._clickTolerance = t3.clickTolerance;
          }
          reset() {
            this._mousedownPos = void 0;
          }
          wheel(e3) {
            return this._firePreventable(new cr(e3.type, this._map, e3));
          }
          mousedown(e3, t3) {
            return this._mousedownPos = t3, this._firePreventable(new ar(e3.type, this._map, e3));
          }
          mouseup(e3) {
            this._map.fire(new ar(e3.type, this._map, e3));
          }
          preclick(t3) {
            const i3 = e2.extend({}, t3);
            i3.type = "preclick", this._map.fire(new ar(i3.type, this._map, i3));
          }
          click(e3, t3) {
            this._mousedownPos && this._mousedownPos.dist(t3) >= this._clickTolerance || (this.preclick(e3), this._map.fire(new ar(e3.type, this._map, e3)));
          }
          dblclick(e3) {
            return this._firePreventable(new ar(e3.type, this._map, e3));
          }
          mouseover(e3) {
            this._map.fire(new ar(e3.type, this._map, e3));
          }
          mouseout(e3) {
            this._map.fire(new ar(e3.type, this._map, e3));
          }
          touchstart(e3) {
            return this._firePreventable(new lr(e3.type, this._map, e3));
          }
          touchmove(e3) {
            this._map.fire(new lr(e3.type, this._map, e3));
          }
          touchend(e3) {
            this._map.fire(new lr(e3.type, this._map, e3));
          }
          touchcancel(e3) {
            this._map.fire(new lr(e3.type, this._map, e3));
          }
          _firePreventable(e3) {
            if (this._map.fire(e3), e3.defaultPrevented)
              return {};
          }
          isEnabled() {
            return true;
          }
          isActive() {
            return false;
          }
          enable() {
          }
          disable() {
          }
        }
        class ur {
          constructor(e3) {
            this._map = e3;
          }
          reset() {
            this._delayContextMenu = false, this._contextMenuEvent = void 0;
          }
          mousemove(e3) {
            this._map.fire(new ar(e3.type, this._map, e3));
          }
          mousedown() {
            this._delayContextMenu = true;
          }
          mouseup() {
            this._delayContextMenu = false, this._contextMenuEvent && (this._map.fire(new ar("contextmenu", this._map, this._contextMenuEvent)), delete this._contextMenuEvent);
          }
          contextmenu(e3) {
            this._delayContextMenu ? this._contextMenuEvent = e3 : this._map.fire(new ar(e3.type, this._map, e3)), this._map.listens("contextmenu") && e3.preventDefault();
          }
          isEnabled() {
            return true;
          }
          isActive() {
            return false;
          }
          enable() {
          }
          disable() {
          }
        }
        class _r {
          constructor(e3, t3) {
            this._map = e3, this._el = e3.getCanvasContainer(), this._container = e3.getContainer(), this._clickTolerance = t3.clickTolerance || 1;
          }
          isEnabled() {
            return !!this._enabled;
          }
          isActive() {
            return !!this._active;
          }
          enable() {
            this.isEnabled() || (this._enabled = true);
          }
          disable() {
            this.isEnabled() && (this._enabled = false);
          }
          mousedown(e3, t3) {
            this.isEnabled() && e3.shiftKey && 0 === e3.button && (h2(), this._startPos = this._lastPos = t3, this._active = true);
          }
          mousemoveWindow(e3, t3) {
            if (!this._active)
              return;
            const i3 = t3, o3 = this._startPos, r3 = this._lastPos;
            if (!o3 || !r3 || r3.equals(i3) || !this._box && i3.dist(o3) < this._clickTolerance)
              return;
            this._lastPos = i3, this._box || (this._box = n2("div", "mapboxgl-boxzoom", this._container), this._container.classList.add("mapboxgl-crosshair"), this._fireEvent("boxzoomstart", e3));
            const s3 = Math.min(o3.x, i3.x), a3 = Math.max(o3.x, i3.x), l2 = Math.min(o3.y, i3.y), c3 = Math.max(o3.y, i3.y);
            this._map._requestDomTask(() => {
              this._box && (this._box.style.transform = `translate(${s3}px,${l2}px)`, this._box.style.width = a3 - s3 + "px", this._box.style.height = c3 - l2 + "px");
            });
          }
          mouseupWindow(t3, i3) {
            if (!this._active)
              return;
            const o3 = this._startPos, r3 = i3;
            if (o3 && 0 === t3.button) {
              if (this.reset(), d2(), o3.x !== r3.x || o3.y !== r3.y)
                return this._map.fire(new e2.Event("boxzoomend", { originalEvent: t3 })), { cameraAnimation: (e3) => e3.fitScreenCoordinates(o3, r3, this._map.getBearing(), { linear: false }) };
              this._fireEvent("boxzoomcancel", t3);
            }
          }
          keydown(e3) {
            this._active && 27 === e3.keyCode && (this.reset(), this._fireEvent("boxzoomcancel", e3));
          }
          blur() {
            this.reset();
          }
          reset() {
            this._active = false, this._container.classList.remove("mapboxgl-crosshair"), this._box && (this._box.remove(), this._box = null), u2(), delete this._startPos, delete this._lastPos;
          }
          _fireEvent(t3, i3) {
            return this._map.fire(new e2.Event(t3, { originalEvent: i3 }));
          }
        }
        function dr(e3, t3) {
          const i3 = {};
          for (let o3 = 0; o3 < e3.length; o3++)
            i3[e3[o3].identifier] = t3[o3];
          return i3;
        }
        class pr {
          constructor(e3) {
            this.reset(), this.numTouches = e3.numTouches;
          }
          reset() {
            this.centroid = void 0, this.startTime = 0, this.touches = {}, this.aborted = false;
          }
          touchstart(t3, i3, o3) {
            (this.centroid || o3.length > this.numTouches) && (this.aborted = true), this.aborted || (0 === this.startTime && (this.startTime = t3.timeStamp), o3.length === this.numTouches && (this.centroid = function(t4) {
              const i4 = new e2.Point(0, 0);
              for (const e3 of t4)
                i4._add(e3);
              return i4.div(t4.length);
            }(i3), this.touches = dr(o3, i3)));
          }
          touchmove(e3, t3, i3) {
            if (this.aborted || !this.centroid)
              return;
            const o3 = dr(i3, t3);
            for (const e4 in this.touches) {
              const t4 = o3[e4];
              (!t4 || t4.dist(this.touches[e4]) > 30) && (this.aborted = true);
            }
          }
          touchend(e3, t3, i3) {
            if ((!this.centroid || e3.timeStamp - this.startTime > 500) && (this.aborted = true), 0 === i3.length) {
              const e4 = !this.aborted && this.centroid;
              if (this.reset(), e4)
                return e4;
            }
          }
        }
        class mr {
          constructor(e3) {
            this.singleTap = new pr(e3), this.numTaps = e3.numTaps, this.reset();
          }
          reset() {
            this.lastTime = 1 / 0, this.lastTap = void 0, this.count = 0, this.singleTap.reset();
          }
          touchstart(e3, t3, i3) {
            this.singleTap.touchstart(e3, t3, i3);
          }
          touchmove(e3, t3, i3) {
            this.singleTap.touchmove(e3, t3, i3);
          }
          touchend(e3, t3, i3) {
            const o3 = this.singleTap.touchend(e3, t3, i3);
            if (o3) {
              const t4 = e3.timeStamp - this.lastTime < 500, i4 = !this.lastTap || this.lastTap.dist(o3) < 30;
              if (t4 && i4 || this.reset(), this.count++, this.lastTime = e3.timeStamp, this.lastTap = o3, this.count === this.numTaps)
                return this.reset(), o3;
            }
          }
        }
        class fr {
          constructor() {
            this._zoomIn = new mr({ numTouches: 1, numTaps: 2 }), this._zoomOut = new mr({ numTouches: 2, numTaps: 1 }), this.reset();
          }
          reset() {
            this._active = false, this._zoomIn.reset(), this._zoomOut.reset();
          }
          touchstart(e3, t3, i3) {
            this._zoomIn.touchstart(e3, t3, i3), this._zoomOut.touchstart(e3, t3, i3);
          }
          touchmove(e3, t3, i3) {
            this._zoomIn.touchmove(e3, t3, i3), this._zoomOut.touchmove(e3, t3, i3);
          }
          touchend(e3, t3, i3) {
            const o3 = this._zoomIn.touchend(e3, t3, i3), r3 = this._zoomOut.touchend(e3, t3, i3);
            return o3 ? (this._active = true, e3.preventDefault(), setTimeout(() => this.reset(), 0), { cameraAnimation: (t4) => t4.easeTo({ duration: 300, zoom: t4.getZoom() + 1, around: t4.unproject(o3) }, { originalEvent: e3 }) }) : r3 ? (this._active = true, e3.preventDefault(), setTimeout(() => this.reset(), 0), { cameraAnimation: (t4) => t4.easeTo({ duration: 300, zoom: t4.getZoom() - 1, around: t4.unproject(r3) }, { originalEvent: e3 }) }) : void 0;
          }
          touchcancel() {
            this.reset();
          }
          enable() {
            this._enabled = true;
          }
          disable() {
            this._enabled = false, this.reset();
          }
          isEnabled() {
            return this._enabled;
          }
          isActive() {
            return this._active;
          }
        }
        const gr = { 0: 1, 2: 2 };
        class vr {
          constructor(e3) {
            this.reset(), this._clickTolerance = e3.clickTolerance || 1;
          }
          blur() {
            this.reset();
          }
          reset() {
            this._active = false, this._moved = false, this._lastPoint = void 0, this._eventButton = void 0;
          }
          _correctButton(e3, t3) {
            return false;
          }
          _move(e3, t3) {
            return {};
          }
          mousedown(e3, t3) {
            if (this._lastPoint)
              return;
            const i3 = f2(e3);
            this._correctButton(e3, i3) && (this._lastPoint = t3, this._eventButton = i3);
          }
          mousemoveWindow(e3, t3) {
            const i3 = this._lastPoint;
            if (i3) {
              if (e3.preventDefault(), null != this._eventButton && function(e4, t4) {
                const i4 = gr[t4];
                return void 0 === e4.buttons || (e4.buttons & i4) !== i4;
              }(e3, this._eventButton))
                this.reset();
              else if (this._moved || !(t3.dist(i3) < this._clickTolerance))
                return this._moved = true, this._lastPoint = t3, this._move(i3, t3);
            }
          }
          mouseupWindow(e3) {
            this._lastPoint && f2(e3) === this._eventButton && (this._moved && d2(), this.reset());
          }
          enable() {
            this._enabled = true;
          }
          disable() {
            this._enabled = false, this.reset();
          }
          isEnabled() {
            return this._enabled;
          }
          isActive() {
            return this._active;
          }
        }
        class xr extends vr {
          mousedown(e3, t3) {
            super.mousedown(e3, t3), this._lastPoint && (this._active = true);
          }
          _correctButton(e3, t3) {
            return 0 === t3 && !e3.ctrlKey;
          }
          _move(e3, t3) {
            return { around: t3, panDelta: t3.sub(e3) };
          }
        }
        class yr extends vr {
          _correctButton(e3, t3) {
            return 0 === t3 && e3.ctrlKey || 2 === t3;
          }
          _move(e3, t3) {
            const i3 = 0.8 * (t3.x - e3.x);
            if (i3)
              return this._active = true, { bearingDelta: i3 };
          }
          contextmenu(e3) {
            e3.preventDefault();
          }
        }
        class br extends vr {
          _correctButton(e3, t3) {
            return 0 === t3 && e3.ctrlKey || 2 === t3;
          }
          _move(e3, t3) {
            const i3 = -0.5 * (t3.y - e3.y);
            if (i3)
              return this._active = true, { pitchDelta: i3 };
          }
          contextmenu(e3) {
            e3.preventDefault();
          }
        }
        class wr {
          constructor(t3, i3) {
            this._map = t3, this._el = t3.getCanvasContainer(), this._minTouches = 1, this._clickTolerance = i3.clickTolerance || 1, this.reset(), e2.bindAll(["_addTouchPanBlocker", "_showTouchPanBlockerAlert"], this);
          }
          reset() {
            this._active = false, this._touches = {}, this._sum = new e2.Point(0, 0);
          }
          touchstart(e3, t3, i3) {
            return this._calculateTransform(e3, t3, i3);
          }
          touchmove(t3, i3, o3) {
            if (this._active && !(o3.length < this._minTouches)) {
              if (this._map._cooperativeGestures && !this._map.isMoving()) {
                if (1 === o3.length && !e2.isFullscreen())
                  return void this._showTouchPanBlockerAlert();
                "hidden" !== this._alertContainer.style.visibility && (this._alertContainer.style.visibility = "hidden", clearTimeout(this._alertTimer));
              }
              return t3.cancelable && t3.preventDefault(), this._calculateTransform(t3, i3, o3);
            }
          }
          touchend(e3, t3, i3) {
            this._calculateTransform(e3, t3, i3), this._active && i3.length < this._minTouches && this.reset();
          }
          touchcancel() {
            this.reset();
          }
          _calculateTransform(t3, i3, o3) {
            o3.length > 0 && (this._active = true);
            const r3 = dr(o3, i3), n3 = new e2.Point(0, 0), s3 = new e2.Point(0, 0);
            let a3 = 0;
            for (const e3 in r3) {
              const t4 = r3[e3], i4 = this._touches[e3];
              i4 && (n3._add(t4), s3._add(t4.sub(i4)), a3++, r3[e3] = t4);
            }
            if (this._touches = r3, a3 < this._minTouches || !s3.mag())
              return;
            const l2 = s3.div(a3);
            return this._sum._add(l2), this._sum.mag() < this._clickTolerance ? void 0 : { around: n3.div(a3), panDelta: l2 };
          }
          enable() {
            this._enabled = true, this._map._cooperativeGestures && (this._addTouchPanBlocker(), this._el.classList.add("mapboxgl-touch-pan-blocker-override", "mapboxgl-scrollable-page"));
          }
          disable() {
            this._enabled = false, this._map._cooperativeGestures && (clearTimeout(this._alertTimer), this._alertContainer.remove(), this._el.classList.remove("mapboxgl-touch-pan-blocker-override", "mapboxgl-scrollable-page")), this.reset();
          }
          isEnabled() {
            return !!this._enabled;
          }
          isActive() {
            return !!this._active;
          }
          _addTouchPanBlocker() {
            this._map && !this._alertContainer && (this._alertContainer = n2("div", "mapboxgl-touch-pan-blocker", this._map._container), this._alertContainer.textContent = this._map._getUIString("TouchPanBlocker.Message"), this._alertContainer.style.fontSize = `${Math.max(10, Math.min(24, Math.floor(0.05 * this._el.clientWidth)))}px`);
          }
          _showTouchPanBlockerAlert() {
            this._alertContainer.style.visibility = "visible", this._alertContainer.classList.add("mapboxgl-touch-pan-blocker-show"), this._alertContainer.setAttribute("role", "alert"), clearTimeout(this._alertTimer), this._alertTimer = setTimeout(() => {
              this._alertContainer.classList.remove("mapboxgl-touch-pan-blocker-show"), this._alertContainer.setAttribute("role", "null");
            }, 500);
          }
        }
        class Tr {
          constructor() {
            this.reset();
          }
          reset() {
            this._active = false, this._firstTwoTouches = void 0;
          }
          _start(e3) {
          }
          _move(e3, t3, i3) {
            return {};
          }
          touchstart(e3, t3, i3) {
            this._firstTwoTouches || i3.length < 2 || (this._firstTwoTouches = [i3[0].identifier, i3[1].identifier], this._start([t3[0], t3[1]]));
          }
          touchmove(e3, t3, i3) {
            const o3 = this._firstTwoTouches;
            if (!o3)
              return;
            e3.preventDefault();
            const [r3, n3] = o3, s3 = Er(i3, t3, r3), a3 = Er(i3, t3, n3);
            if (!s3 || !a3)
              return;
            const l2 = this._aroundCenter ? null : s3.add(a3).div(2);
            return this._move([s3, a3], l2, e3);
          }
          touchend(e3, t3, i3) {
            if (!this._firstTwoTouches)
              return;
            const [o3, r3] = this._firstTwoTouches, n3 = Er(i3, t3, o3), s3 = Er(i3, t3, r3);
            n3 && s3 || (this._active && d2(), this.reset());
          }
          touchcancel() {
            this.reset();
          }
          enable(e3) {
            this._enabled = true, this._aroundCenter = !!e3 && "center" === e3.around;
          }
          disable() {
            this._enabled = false, this.reset();
          }
          isEnabled() {
            return this._enabled;
          }
          isActive() {
            return this._active;
          }
        }
        function Er(e3, t3, i3) {
          for (let o3 = 0; o3 < e3.length; o3++)
            if (e3[o3].identifier === i3)
              return t3[o3];
        }
        function Cr(e3, t3) {
          return Math.log(e3 / t3) / Math.LN2;
        }
        class Mr extends Tr {
          reset() {
            super.reset(), this._distance = 0, this._startDistance = 0;
          }
          _start(e3) {
            this._startDistance = this._distance = e3[0].dist(e3[1]);
          }
          _move(e3, t3) {
            const i3 = this._distance;
            if (this._distance = e3[0].dist(e3[1]), this._active || !(Math.abs(Cr(this._distance, this._startDistance)) < 0.1))
              return this._active = true, { zoomDelta: Cr(this._distance, i3), pinchAround: t3 };
          }
        }
        function Ir(e3, t3) {
          return 180 * e3.angleWith(t3) / Math.PI;
        }
        class Pr extends Tr {
          reset() {
            super.reset(), this._minDiameter = 0, this._startVector = void 0, this._vector = void 0;
          }
          _start(e3) {
            this._startVector = this._vector = e3[0].sub(e3[1]), this._minDiameter = e3[0].dist(e3[1]);
          }
          _move(e3, t3) {
            const i3 = this._vector;
            if (this._vector = e3[0].sub(e3[1]), i3 && (this._active || !this._isBelowThreshold(this._vector)))
              return this._active = true, { bearingDelta: Ir(this._vector, i3), pinchAround: t3 };
          }
          _isBelowThreshold(e3) {
            this._minDiameter = Math.min(this._minDiameter, e3.mag());
            const t3 = 25 / (Math.PI * this._minDiameter) * 360, i3 = this._startVector;
            if (!i3)
              return false;
            const o3 = Ir(e3, i3);
            return Math.abs(o3) < t3;
          }
        }
        function Sr(e3) {
          return Math.abs(e3.y) > Math.abs(e3.x);
        }
        class Dr extends Tr {
          constructor(e3) {
            super(), this._map = e3;
          }
          reset() {
            super.reset(), this._valid = void 0, this._firstMove = void 0, this._lastPoints = void 0;
          }
          _start(e3) {
            this._lastPoints = e3, Sr(e3[0].sub(e3[1])) && (this._valid = false);
          }
          _move(t3, i3, o3) {
            const r3 = this._lastPoints;
            if (!r3)
              return;
            const n3 = t3[0].sub(r3[0]), s3 = t3[1].sub(r3[1]);
            return this._map._cooperativeGestures && !e2.isFullscreen() && o3.touches.length < 3 || (this._valid = this.gestureBeginsVertically(n3, s3, o3.timeStamp), !this._valid) ? void 0 : (this._lastPoints = t3, this._active = true, { pitchDelta: (n3.y + s3.y) / 2 * -0.5 });
          }
          gestureBeginsVertically(e3, t3, i3) {
            if (void 0 !== this._valid)
              return this._valid;
            const o3 = e3.mag() >= 2, r3 = t3.mag() >= 2;
            if (!o3 && !r3)
              return;
            if (!o3 || !r3)
              return null == this._firstMove && (this._firstMove = i3), i3 - this._firstMove < 100 && void 0;
            const n3 = e3.y > 0 == t3.y > 0;
            return Sr(e3) && Sr(t3) && n3;
          }
        }
        const Lr = { panStep: 100, bearingStep: 15, pitchStep: 10 };
        class Ar {
          constructor() {
            const e3 = Lr;
            this._panStep = e3.panStep, this._bearingStep = e3.bearingStep, this._pitchStep = e3.pitchStep, this._rotationDisabled = false;
          }
          blur() {
            this.reset();
          }
          reset() {
            this._active = false;
          }
          keydown(e3) {
            if (e3.altKey || e3.ctrlKey || e3.metaKey)
              return;
            let t3 = 0, i3 = 0, o3 = 0, r3 = 0, n3 = 0;
            switch (e3.keyCode) {
              case 61:
              case 107:
              case 171:
              case 187:
                t3 = 1;
                break;
              case 189:
              case 109:
              case 173:
                t3 = -1;
                break;
              case 37:
                e3.shiftKey ? i3 = -1 : (e3.preventDefault(), r3 = -1);
                break;
              case 39:
                e3.shiftKey ? i3 = 1 : (e3.preventDefault(), r3 = 1);
                break;
              case 38:
                e3.shiftKey ? o3 = 1 : (e3.preventDefault(), n3 = -1);
                break;
              case 40:
                e3.shiftKey ? o3 = -1 : (e3.preventDefault(), n3 = 1);
                break;
              default:
                return;
            }
            return this._rotationDisabled && (i3 = 0, o3 = 0), { cameraAnimation: (s3) => {
              const a3 = s3.getZoom();
              s3.easeTo({ duration: 300, easeId: "keyboardHandler", easing: zr, zoom: t3 ? Math.round(a3) + t3 * (e3.shiftKey ? 2 : 1) : a3, bearing: s3.getBearing() + i3 * this._bearingStep, pitch: s3.getPitch() + o3 * this._pitchStep, offset: [-r3 * this._panStep, -n3 * this._panStep], center: s3.getCenter() }, { originalEvent: e3 });
            } };
          }
          enable() {
            this._enabled = true;
          }
          disable() {
            this._enabled = false, this.reset();
          }
          isEnabled() {
            return this._enabled;
          }
          isActive() {
            return this._active;
          }
          disableRotation() {
            this._rotationDisabled = true;
          }
          enableRotation() {
            this._rotationDisabled = false;
          }
        }
        function zr(e3) {
          return e3 * (2 - e3);
        }
        const Rr = 4.000244140625;
        class Or {
          constructor(t3, i3) {
            this._map = t3, this._el = t3.getCanvasContainer(), this._handler = i3, this._delta = 0, this._defaultZoomRate = 0.01, this._wheelZoomRate = 0.0022222222222222222, e2.bindAll(["_onTimeout", "_addScrollZoomBlocker", "_showBlockerAlert"], this);
          }
          setZoomRate(e3) {
            this._defaultZoomRate = e3;
          }
          setWheelZoomRate(e3) {
            this._wheelZoomRate = e3;
          }
          isEnabled() {
            return !!this._enabled;
          }
          isActive() {
            return this._active || void 0 !== this._finishTimeout;
          }
          isZooming() {
            return !!this._zooming;
          }
          enable(e3) {
            this.isEnabled() || (this._enabled = true, this._aroundCenter = !!e3 && "center" === e3.around, this._map._cooperativeGestures && this._addScrollZoomBlocker());
          }
          disable() {
            this.isEnabled() && (this._enabled = false, this._map._cooperativeGestures && (clearTimeout(this._alertTimer), this._alertContainer.remove()));
          }
          wheel(t3) {
            if (!this.isEnabled())
              return;
            if (this._map._cooperativeGestures) {
              if (!(t3.ctrlKey || t3.metaKey || this.isZooming() || e2.isFullscreen()))
                return void this._showBlockerAlert();
              "hidden" !== this._alertContainer.style.visibility && (this._alertContainer.style.visibility = "hidden", clearTimeout(this._alertTimer));
            }
            let i3 = t3.deltaMode === e2.window.WheelEvent.DOM_DELTA_LINE ? 40 * t3.deltaY : t3.deltaY;
            const o3 = e2.exported.now(), r3 = o3 - (this._lastWheelEventTime || 0);
            this._lastWheelEventTime = o3, 0 !== i3 && i3 % Rr == 0 ? this._type = "wheel" : 0 !== i3 && Math.abs(i3) < 4 ? this._type = "trackpad" : r3 > 400 ? (this._type = null, this._lastValue = i3, this._timeout = setTimeout(this._onTimeout, 40, t3)) : this._type || (this._type = Math.abs(r3 * i3) < 200 ? "trackpad" : "wheel", this._timeout && (clearTimeout(this._timeout), this._timeout = null, i3 += this._lastValue)), t3.shiftKey && i3 && (i3 /= 4), this._type && (this._lastWheelEvent = t3, this._delta -= i3, this._active || this._start(t3)), t3.preventDefault();
          }
          _onTimeout(e3) {
            this._type = "wheel", this._delta -= this._lastValue, this._active || this._start(e3);
          }
          _start(e3) {
            if (!this._delta)
              return;
            this._frameId && (this._frameId = null), this._active = true, this.isZooming() || (this._zooming = true), this._finishTimeout && (clearTimeout(this._finishTimeout), delete this._finishTimeout);
            const t3 = p2(this._el, e3);
            this._aroundPoint = this._aroundCenter ? this._map.transform.centerPoint : t3, this._aroundCoord = this._map.transform.pointCoordinate3D(this._aroundPoint), this._targetZoom = void 0, this._frameId || (this._frameId = true, this._handler._triggerRenderFrame());
          }
          renderFrame() {
            if (!this._frameId)
              return;
            if (this._frameId = null, !this.isActive())
              return;
            const t3 = this._map.transform;
            "wheel" === this._type && t3.projection.wrap && (t3._center.lng >= 180 || t3._center.lng <= -180) && (this._prevEase = null, this._easing = null, this._lastWheelEvent = null, this._lastWheelEventTime = 0);
            const i3 = () => t3._terrainEnabled() && this._aroundCoord ? t3.computeZoomRelativeTo(this._aroundCoord) : t3.zoom;
            if (0 !== this._delta) {
              const e3 = "wheel" === this._type && Math.abs(this._delta) > Rr ? this._wheelZoomRate : this._defaultZoomRate;
              let o4 = 2 / (1 + Math.exp(-Math.abs(this._delta * e3)));
              this._delta < 0 && 0 !== o4 && (o4 = 1 / o4);
              const r4 = i3(), n4 = Math.pow(2, r4), s4 = "number" == typeof this._targetZoom ? t3.zoomScale(this._targetZoom) : n4;
              this._targetZoom = Math.min(t3.maxZoom, Math.max(t3.minZoom, t3.scaleZoom(s4 * o4))), "wheel" === this._type && (this._startZoom = r4, this._easing = this._smoothOutEasing(200)), this._delta = 0;
            }
            const o3 = "number" == typeof this._targetZoom ? this._targetZoom : i3(), r3 = this._startZoom, n3 = this._easing;
            let s3, a3 = false;
            if ("wheel" === this._type && r3 && n3) {
              const t4 = Math.min((e2.exported.now() - this._lastWheelEventTime) / 200, 1), i4 = n3(t4);
              s3 = e2.number(r3, o3, i4), t4 < 1 ? this._frameId || (this._frameId = true) : a3 = true;
            } else
              s3 = o3, a3 = true;
            return this._active = true, a3 && (this._active = false, this._finishTimeout = setTimeout(() => {
              this._zooming = false, this._handler._triggerRenderFrame(), delete this._targetZoom, delete this._finishTimeout;
            }, 200)), { noInertia: true, needsRenderFrame: !a3, zoomDelta: s3 - i3(), around: this._aroundPoint, aroundCoord: this._aroundCoord, originalEvent: this._lastWheelEvent };
          }
          _smoothOutEasing(t3) {
            let i3 = e2.ease;
            if (this._prevEase) {
              const t4 = this._prevEase, o3 = (e2.exported.now() - t4.start) / t4.duration, r3 = t4.easing(o3 + 0.01) - t4.easing(o3), n3 = 0.27 / Math.sqrt(r3 * r3 + 1e-4) * 0.01, s3 = Math.sqrt(0.0729 - n3 * n3);
              i3 = e2.bezier(n3, s3, 0.25, 1);
            }
            return this._prevEase = { start: e2.exported.now(), duration: t3, easing: i3 }, i3;
          }
          blur() {
            this.reset();
          }
          reset() {
            this._active = false;
          }
          _addScrollZoomBlocker() {
            this._map && !this._alertContainer && (this._alertContainer = n2("div", "mapboxgl-scroll-zoom-blocker", this._map._container), this._alertContainer.textContent = /(Mac|iPad)/i.test(e2.window.navigator.userAgent) ? this._map._getUIString("ScrollZoomBlocker.CmdMessage") : this._map._getUIString("ScrollZoomBlocker.CtrlMessage"), this._alertContainer.style.fontSize = `${Math.max(10, Math.min(24, Math.floor(0.05 * this._el.clientWidth)))}px`);
          }
          _showBlockerAlert() {
            this._alertContainer.style.visibility = "visible", this._alertContainer.classList.add("mapboxgl-scroll-zoom-blocker-show"), this._alertContainer.setAttribute("role", "alert"), clearTimeout(this._alertTimer), this._alertTimer = setTimeout(() => {
              this._alertContainer.classList.remove("mapboxgl-scroll-zoom-blocker-show"), this._alertContainer.setAttribute("role", "null");
            }, 200);
          }
        }
        class Br {
          constructor(e3, t3) {
            this._clickZoom = e3, this._tapZoom = t3;
          }
          enable() {
            this._clickZoom.enable(), this._tapZoom.enable();
          }
          disable() {
            this._clickZoom.disable(), this._tapZoom.disable();
          }
          isEnabled() {
            return this._clickZoom.isEnabled() && this._tapZoom.isEnabled();
          }
          isActive() {
            return this._clickZoom.isActive() || this._tapZoom.isActive();
          }
        }
        class kr {
          constructor() {
            this.reset();
          }
          reset() {
            this._active = false;
          }
          blur() {
            this.reset();
          }
          dblclick(e3, t3) {
            return e3.preventDefault(), { cameraAnimation: (i3) => {
              i3.easeTo({ duration: 300, zoom: i3.getZoom() + (e3.shiftKey ? -1 : 1), around: i3.unproject(t3) }, { originalEvent: e3 });
            } };
          }
          enable() {
            this._enabled = true;
          }
          disable() {
            this._enabled = false, this.reset();
          }
          isEnabled() {
            return this._enabled;
          }
          isActive() {
            return this._active;
          }
        }
        class Fr {
          constructor() {
            this._tap = new mr({ numTouches: 1, numTaps: 1 }), this.reset();
          }
          reset() {
            this._active = false, this._swipePoint = void 0, this._swipeTouch = 0, this._tapTime = 0, this._tap.reset();
          }
          touchstart(e3, t3, i3) {
            this._swipePoint || (this._tapTime && e3.timeStamp - this._tapTime > 500 && this.reset(), this._tapTime ? i3.length > 0 && (this._swipePoint = t3[0], this._swipeTouch = i3[0].identifier) : this._tap.touchstart(e3, t3, i3));
          }
          touchmove(e3, t3, i3) {
            if (this._tapTime) {
              if (this._swipePoint) {
                if (i3[0].identifier !== this._swipeTouch)
                  return;
                const o3 = t3[0], r3 = o3.y - this._swipePoint.y;
                return this._swipePoint = o3, e3.preventDefault(), this._active = true, { zoomDelta: r3 / 128 };
              }
            } else
              this._tap.touchmove(e3, t3, i3);
          }
          touchend(e3, t3, i3) {
            this._tapTime ? this._swipePoint && 0 === i3.length && this.reset() : this._tap.touchend(e3, t3, i3) && (this._tapTime = e3.timeStamp);
          }
          touchcancel() {
            this.reset();
          }
          enable() {
            this._enabled = true;
          }
          disable() {
            this._enabled = false, this.reset();
          }
          isEnabled() {
            return this._enabled;
          }
          isActive() {
            return this._active;
          }
        }
        class Ur {
          constructor(e3, t3, i3) {
            this._el = e3, this._mousePan = t3, this._touchPan = i3;
          }
          enable(e3) {
            this._inertiaOptions = e3 || {}, this._mousePan.enable(), this._touchPan.enable(), this._el.classList.add("mapboxgl-touch-drag-pan");
          }
          disable() {
            this._mousePan.disable(), this._touchPan.disable(), this._el.classList.remove("mapboxgl-touch-drag-pan");
          }
          isEnabled() {
            return this._mousePan.isEnabled() && this._touchPan.isEnabled();
          }
          isActive() {
            return this._mousePan.isActive() || this._touchPan.isActive();
          }
        }
        class Nr {
          constructor(e3, t3, i3) {
            this._pitchWithRotate = e3.pitchWithRotate, this._mouseRotate = t3, this._mousePitch = i3;
          }
          enable() {
            this._mouseRotate.enable(), this._pitchWithRotate && this._mousePitch.enable();
          }
          disable() {
            this._mouseRotate.disable(), this._mousePitch.disable();
          }
          isEnabled() {
            return this._mouseRotate.isEnabled() && (!this._pitchWithRotate || this._mousePitch.isEnabled());
          }
          isActive() {
            return this._mouseRotate.isActive() || this._mousePitch.isActive();
          }
        }
        class jr {
          constructor(e3, t3, i3, o3) {
            this._el = e3, this._touchZoom = t3, this._touchRotate = i3, this._tapDragZoom = o3, this._rotationDisabled = false, this._enabled = true;
          }
          enable(e3) {
            this._touchZoom.enable(e3), this._rotationDisabled || this._touchRotate.enable(e3), this._tapDragZoom.enable(), this._el.classList.add("mapboxgl-touch-zoom-rotate");
          }
          disable() {
            this._touchZoom.disable(), this._touchRotate.disable(), this._tapDragZoom.disable(), this._el.classList.remove("mapboxgl-touch-zoom-rotate");
          }
          isEnabled() {
            return this._touchZoom.isEnabled() && (this._rotationDisabled || this._touchRotate.isEnabled()) && this._tapDragZoom.isEnabled();
          }
          isActive() {
            return this._touchZoom.isActive() || this._touchRotate.isActive() || this._tapDragZoom.isActive();
          }
          disableRotation() {
            this._rotationDisabled = true, this._touchRotate.disable();
          }
          enableRotation() {
            this._rotationDisabled = false, this._touchZoom.isEnabled() && this._touchRotate.enable();
          }
        }
        const Gr = (e3) => e3.zoom || e3.drag || e3.pitch || e3.rotate;
        class Zr extends e2.Event {
        }
        class Vr {
          constructor() {
            this.constants = [1, 1, 0.01], this.radius = 0;
          }
          setup(t3, i3) {
            const o3 = e2.sub([], i3, t3);
            this.radius = e2.length(o3[2] < 0 ? e2.div([], o3, this.constants) : [o3[0], o3[1], 0]);
          }
          projectRay(t3) {
            e2.div(t3, t3, this.constants), e2.normalize(t3, t3), e2.mul$1(t3, t3, this.constants);
            const i3 = e2.scale$2([], t3, this.radius);
            if (i3[2] > 0) {
              const t4 = e2.scale$2([], [0, 0, 1], e2.dot(i3, [0, 0, 1])), o3 = e2.scale$2([], e2.normalize([], [i3[0], i3[1], 0]), this.radius), r3 = e2.add([], i3, e2.scale$2([], e2.sub([], e2.add([], o3, t4), i3), 2));
              i3[0] = r3[0], i3[1] = r3[1];
            }
            return i3;
          }
        }
        function Wr(e3) {
          return e3.panDelta && e3.panDelta.mag() || e3.zoomDelta || e3.bearingDelta || e3.pitchDelta;
        }
        class Xr {
          constructor(t3, i3) {
            this._map = t3, this._el = this._map.getCanvasContainer(), this._handlers = [], this._handlersById = {}, this._changes = [], this._inertia = new rr(t3), this._bearingSnap = i3.bearingSnap, this._previousActiveHandlers = {}, this._trackingEllipsoid = new Vr(), this._dragOrigin = null, this._eventsInProgress = {}, this._addDefaultHandlers(i3), e2.bindAll(["handleEvent", "handleWindowEvent"], this);
            const o3 = this._el;
            this._listeners = [[o3, "touchstart", { passive: true }], [o3, "touchmove", { passive: false }], [o3, "touchend", void 0], [o3, "touchcancel", void 0], [o3, "mousedown", void 0], [o3, "mousemove", void 0], [o3, "mouseup", void 0], [e2.window.document, "mousemove", { capture: true }], [e2.window.document, "mouseup", void 0], [o3, "mouseover", void 0], [o3, "mouseout", void 0], [o3, "dblclick", void 0], [o3, "click", void 0], [o3, "keydown", { capture: false }], [o3, "keyup", void 0], [o3, "wheel", { passive: false }], [o3, "contextmenu", void 0], [e2.window, "blur", void 0]];
            for (const [t4, i4, o4] of this._listeners)
              t4.addEventListener(i4, t4 === e2.window.document ? this.handleWindowEvent : this.handleEvent, o4);
          }
          destroy() {
            for (const [t3, i3, o3] of this._listeners)
              t3.removeEventListener(i3, t3 === e2.window.document ? this.handleWindowEvent : this.handleEvent, o3);
          }
          _addDefaultHandlers(e3) {
            const t3 = this._map, i3 = t3.getCanvasContainer();
            this._add("mapEvent", new hr(t3, e3));
            const o3 = t3.boxZoom = new _r(t3, e3);
            this._add("boxZoom", o3);
            const r3 = new fr(), n3 = new kr();
            t3.doubleClickZoom = new Br(n3, r3), this._add("tapZoom", r3), this._add("clickZoom", n3);
            const s3 = new Fr();
            this._add("tapDragZoom", s3);
            const a3 = t3.touchPitch = new Dr(t3);
            this._add("touchPitch", a3);
            const l2 = new yr(e3), c3 = new br(e3);
            t3.dragRotate = new Nr(e3, l2, c3), this._add("mouseRotate", l2, ["mousePitch"]), this._add("mousePitch", c3, ["mouseRotate"]);
            const h3 = new xr(e3), u3 = new wr(t3, e3);
            t3.dragPan = new Ur(i3, h3, u3), this._add("mousePan", h3), this._add("touchPan", u3, ["touchZoom", "touchRotate"]);
            const _2 = new Pr(), d3 = new Mr();
            t3.touchZoomRotate = new jr(i3, d3, _2, s3), this._add("touchRotate", _2, ["touchPan", "touchZoom"]), this._add("touchZoom", d3, ["touchPan", "touchRotate"]), this._add("blockableMapEvent", new ur(t3));
            const p3 = t3.scrollZoom = new Or(t3, this);
            this._add("scrollZoom", p3, ["mousePan"]);
            const m3 = t3.keyboard = new Ar();
            this._add("keyboard", m3);
            for (const i4 of ["boxZoom", "doubleClickZoom", "tapDragZoom", "touchPitch", "dragRotate", "dragPan", "touchZoomRotate", "scrollZoom", "keyboard"])
              e3.interactive && e3[i4] && t3[i4].enable(e3[i4]);
          }
          _add(e3, t3, i3) {
            this._handlers.push({ handlerName: e3, handler: t3, allowed: i3 }), this._handlersById[e3] = t3;
          }
          stop(e3) {
            if (!this._updatingCamera) {
              for (const { handler: e4 } of this._handlers)
                e4.reset();
              this._inertia.clear(), this._fireEvents({}, {}, e3), this._changes = [];
            }
          }
          isActive() {
            for (const { handler: e3 } of this._handlers)
              if (e3.isActive())
                return true;
            return false;
          }
          isZooming() {
            return !!this._eventsInProgress.zoom || this._map.scrollZoom.isZooming();
          }
          isRotating() {
            return !!this._eventsInProgress.rotate;
          }
          isMoving() {
            return !!Gr(this._eventsInProgress) || this.isZooming();
          }
          _isDragging() {
            return !!this._eventsInProgress.drag;
          }
          _blockedByActive(e3, t3, i3) {
            for (const o3 in e3)
              if (o3 !== i3 && (!t3 || t3.indexOf(o3) < 0))
                return true;
            return false;
          }
          handleWindowEvent(e3) {
            this.handleEvent(e3, `${e3.type}Window`);
          }
          _getMapTouches(e3) {
            const t3 = [];
            for (const i3 of e3)
              this._el.contains(i3.target) && t3.push(i3);
            return t3;
          }
          handleEvent(e3, t3) {
            this._updatingCamera = true;
            const i3 = "renderFrame" === e3.type, o3 = i3 ? void 0 : e3, r3 = { needsRenderFrame: false }, n3 = {}, s3 = {}, a3 = e3.touches ? this._getMapTouches(e3.touches) : void 0, l2 = a3 ? m2(this._el, a3) : i3 ? void 0 : p2(this._el, e3);
            for (const { handlerName: i4, handler: c4, allowed: h4 } of this._handlers) {
              if (!c4.isEnabled())
                continue;
              let u3;
              this._blockedByActive(s3, h4, i4) ? c4.reset() : c4[t3 || e3.type] && (u3 = c4[t3 || e3.type](e3, l2, a3), this.mergeHandlerResult(r3, n3, u3, i4, o3), u3 && u3.needsRenderFrame && this._triggerRenderFrame()), (u3 || c4.isActive()) && (s3[i4] = c4);
            }
            const c3 = {};
            for (const e4 in this._previousActiveHandlers)
              s3[e4] || (c3[e4] = o3);
            this._previousActiveHandlers = s3, (Object.keys(c3).length || Wr(r3)) && (this._changes.push([r3, n3, c3]), this._triggerRenderFrame()), (Object.keys(s3).length || Wr(r3)) && this._map._stop(true), this._updatingCamera = false;
            const { cameraAnimation: h3 } = r3;
            h3 && (this._inertia.clear(), this._fireEvents({}, {}, true), this._changes = [], h3(this._map));
          }
          mergeHandlerResult(t3, i3, o3, r3, n3) {
            if (!o3)
              return;
            e2.extend(t3, o3);
            const s3 = { handlerName: r3, originalEvent: o3.originalEvent || n3 };
            void 0 !== o3.zoomDelta && (i3.zoom = s3), void 0 !== o3.panDelta && (i3.drag = s3), void 0 !== o3.pitchDelta && (i3.pitch = s3), void 0 !== o3.bearingDelta && (i3.rotate = s3);
          }
          _applyChanges() {
            const t3 = {}, i3 = {}, o3 = {};
            for (const [r3, n3, s3] of this._changes)
              r3.panDelta && (t3.panDelta = (t3.panDelta || new e2.Point(0, 0))._add(r3.panDelta)), r3.zoomDelta && (t3.zoomDelta = (t3.zoomDelta || 0) + r3.zoomDelta), r3.bearingDelta && (t3.bearingDelta = (t3.bearingDelta || 0) + r3.bearingDelta), r3.pitchDelta && (t3.pitchDelta = (t3.pitchDelta || 0) + r3.pitchDelta), void 0 !== r3.around && (t3.around = r3.around), void 0 !== r3.aroundCoord && (t3.aroundCoord = r3.aroundCoord), void 0 !== r3.pinchAround && (t3.pinchAround = r3.pinchAround), r3.noInertia && (t3.noInertia = r3.noInertia), e2.extend(i3, n3), e2.extend(o3, s3);
            this._updateMapTransform(t3, i3, o3), this._changes = [];
          }
          _updateMapTransform(t3, i3, o3) {
            const r3 = this._map, n3 = r3.transform, s3 = (e3) => [e3.x, e3.y, e3.z];
            if (((e3) => {
              const t4 = this._eventsInProgress.drag;
              return t4 && !this._handlersById[t4.handlerName].isActive();
            })() && !Wr(t3)) {
              const e3 = n3.zoom;
              n3.cameraElevationReference = "sea", n3.recenterOnTerrain(), n3.cameraElevationReference = "ground", e3 !== n3.zoom && this._map._update(true);
            }
            if (n3._isCameraConstrained && r3._stop(true), !Wr(t3))
              return void this._fireEvents(i3, o3, true);
            let { panDelta: a3, zoomDelta: l2, bearingDelta: c3, pitchDelta: h3, around: u3, aroundCoord: _2, pinchAround: d3 } = t3;
            n3._isCameraConstrained && (l2 > 0 && (l2 = 0), n3._isCameraConstrained = false), void 0 !== d3 && (u3 = d3), (l2 || ((e3) => i3[e3] && !this._eventsInProgress[e3])("drag")) && u3 && (this._dragOrigin = s3(n3.pointCoordinate3D(u3)), this._trackingEllipsoid.setup(n3._camera.position, this._dragOrigin)), n3.cameraElevationReference = "sea", r3._stop(true), u3 = u3 || r3.transform.centerPoint, c3 && (n3.bearing += c3), h3 && (n3.pitch += h3), n3._updateCameraState();
            const p3 = [0, 0, 0];
            if (a3)
              if ("mercator" === n3.projection.name) {
                const e3 = this._trackingEllipsoid.projectRay(n3.screenPointToMercatorRay(u3).dir), t4 = this._trackingEllipsoid.projectRay(n3.screenPointToMercatorRay(u3.sub(a3)).dir);
                p3[0] = t4[0] - e3[0], p3[1] = t4[1] - e3[1];
              } else {
                const t4 = n3.pointCoordinate(u3);
                if ("globe" === n3.projection.name) {
                  a3 = a3.rotate(-n3.angle);
                  const i4 = n3._pixelsPerMercatorPixel / n3.worldSize;
                  p3[0] = -a3.x * e2.mercatorScale(e2.latFromMercatorY(t4.y)) * i4, p3[1] = -a3.y * e2.mercatorScale(n3.center.lat) * i4;
                } else {
                  const e3 = n3.pointCoordinate(u3.sub(a3));
                  t4 && e3 && (p3[0] = e3.x - t4.x, p3[1] = e3.y - t4.y);
                }
              }
            const m3 = n3.zoom, f3 = [0, 0, 0];
            if (l2) {
              const t4 = s3(_2 || n3.pointCoordinate3D(u3)), i4 = { dir: e2.normalize([], e2.sub([], t4, n3._camera.position)) };
              if (i4.dir[2] < 0) {
                const o4 = n3.zoomDeltaToMovement(t4, l2);
                e2.scale$2(f3, i4.dir, o4);
              }
            }
            const g3 = e2.add(p3, p3, f3);
            n3._translateCameraConstrained(g3), l2 && Math.abs(n3.zoom - m3) > 1e-4 && n3.recenterOnTerrain(), n3.cameraElevationReference = "ground", this._map._update(), t3.noInertia || this._inertia.record(t3), this._fireEvents(i3, o3, true);
          }
          _fireEvents(t3, i3, o3) {
            const r3 = Gr(this._eventsInProgress), n3 = Gr(t3), s3 = {};
            for (const e3 in t3) {
              const { originalEvent: i4 } = t3[e3];
              this._eventsInProgress[e3] || (s3[`${e3}start`] = i4), this._eventsInProgress[e3] = t3[e3];
            }
            !r3 && n3 && this._fireEvent("movestart", n3.originalEvent);
            for (const e3 in s3)
              this._fireEvent(e3, s3[e3]);
            n3 && this._fireEvent("move", n3.originalEvent);
            for (const e3 in t3) {
              const { originalEvent: i4 } = t3[e3];
              this._fireEvent(e3, i4);
            }
            const a3 = {};
            let l2;
            for (const e3 in this._eventsInProgress) {
              const { handlerName: t4, originalEvent: o4 } = this._eventsInProgress[e3];
              this._handlersById[t4].isActive() || (delete this._eventsInProgress[e3], l2 = i3[t4] || o4, a3[`${e3}end`] = l2);
            }
            for (const e3 in a3)
              this._fireEvent(e3, a3[e3]);
            const c3 = Gr(this._eventsInProgress);
            if (o3 && (r3 || n3) && !c3) {
              this._updatingCamera = true;
              const t4 = this._inertia._onMoveEnd(this._map.dragPan._inertiaOptions), i4 = (e3) => 0 !== e3 && -this._bearingSnap < e3 && e3 < this._bearingSnap;
              t4 ? (i4(t4.bearing || this._map.getBearing()) && (t4.bearing = 0), this._map.easeTo(t4, { originalEvent: l2 })) : (this._map.fire(new e2.Event("moveend", { originalEvent: l2 })), i4(this._map.getBearing()) && this._map.resetNorth()), this._updatingCamera = false;
            }
          }
          _fireEvent(t3, i3) {
            this._map.fire(new e2.Event(t3, i3 ? { originalEvent: i3 } : {}));
          }
          _requestFrame() {
            return this._map.triggerRepaint(), this._map._renderTaskQueue.add((e3) => {
              this._frameId = void 0, this.handleEvent(new Zr("renderFrame", { timeStamp: e3 })), this._applyChanges();
            });
          }
          _triggerRenderFrame() {
            void 0 === this._frameId && (this._frameId = this._requestFrame());
          }
        }
        const qr = "map.setFreeCameraOptions(...) and map.getFreeCameraOptions() are not yet supported for non-mercator projections.";
        class $r extends e2.Evented {
          constructor(t3, i3) {
            super(), this._moving = false, this._zooming = false, this.transform = t3, this._bearingSnap = i3.bearingSnap, this._respectPrefersReducedMotion = false !== i3.respectPrefersReducedMotion, e2.bindAll(["_renderFrameCallback"], this);
          }
          getCenter() {
            return new e2.LngLat(this.transform.center.lng, this.transform.center.lat);
          }
          setCenter(e3, t3) {
            return this.jumpTo({ center: e3 }, t3);
          }
          panBy(t3, i3, o3) {
            return t3 = e2.Point.convert(t3).mult(-1), this.panTo(this.transform.center, e2.extend({ offset: t3 }, i3), o3);
          }
          panTo(t3, i3, o3) {
            return this.easeTo(e2.extend({ center: t3 }, i3), o3);
          }
          getZoom() {
            return this.transform.zoom;
          }
          setZoom(e3, t3) {
            return this.jumpTo({ zoom: e3 }, t3), this;
          }
          zoomTo(t3, i3, o3) {
            return this.easeTo(e2.extend({ zoom: t3 }, i3), o3);
          }
          zoomIn(e3, t3) {
            return this.zoomTo(this.getZoom() + 1, e3, t3), this;
          }
          zoomOut(e3, t3) {
            return this.zoomTo(this.getZoom() - 1, e3, t3), this;
          }
          getBearing() {
            return this.transform.bearing;
          }
          setBearing(e3, t3) {
            return this.jumpTo({ bearing: e3 }, t3), this;
          }
          getPadding() {
            return this.transform.padding;
          }
          setPadding(e3, t3) {
            return this.jumpTo({ padding: e3 }, t3), this;
          }
          rotateTo(t3, i3, o3) {
            return this.easeTo(e2.extend({ bearing: t3 }, i3), o3);
          }
          resetNorth(t3, i3) {
            return this.rotateTo(0, e2.extend({ duration: 1e3 }, t3), i3), this;
          }
          resetNorthPitch(t3, i3) {
            return this.easeTo(e2.extend({ bearing: 0, pitch: 0, duration: 1e3 }, t3), i3), this;
          }
          snapToNorth(e3, t3) {
            return Math.abs(this.getBearing()) < this._bearingSnap ? this.resetNorth(e3, t3) : this;
          }
          getPitch() {
            return this.transform.pitch;
          }
          setPitch(e3, t3) {
            return this.jumpTo({ pitch: e3 }, t3), this;
          }
          cameraForBounds(t3, i3) {
            t3 = e2.LngLatBounds.convert(t3);
            const o3 = i3 && i3.bearing || 0, r3 = i3 && i3.pitch || 0, n3 = t3.getNorthWest(), s3 = t3.getSouthEast();
            return this._cameraForBounds(this.transform, n3, s3, o3, r3, i3);
          }
          _extendCameraOptions(t3) {
            const i3 = { top: 0, bottom: 0, right: 0, left: 0 };
            if ("number" == typeof (t3 = e2.extend({ padding: i3, offset: [0, 0], maxZoom: this.transform.maxZoom }, t3)).padding) {
              const e3 = t3.padding;
              t3.padding = { top: e3, bottom: e3, right: e3, left: e3 };
            }
            return t3.padding = e2.extend(i3, t3.padding), t3;
          }
          _minimumAABBFrustumDistance(e3, t3) {
            const i3 = t3.max[0] - t3.min[0], o3 = t3.max[1] - t3.min[1];
            return i3 / o3 > e3.aspect ? i3 / (2 * Math.tan(0.5 * e3.fovX) * e3.aspect) : o3 / (2 * Math.tan(0.5 * e3.fovY) * e3.aspect);
          }
          _cameraForBoundsOnGlobe(t3, i3, o3, r3, n3, s3) {
            const a3 = t3.clone(), l2 = this._extendCameraOptions(s3);
            a3.bearing = r3, a3.pitch = n3;
            const c3 = e2.LngLat.convert(i3), h3 = e2.LngLat.convert(o3), u3 = 0.5 * (c3.lat + h3.lat), _2 = 0.5 * (c3.lng + h3.lng), d3 = e2.latLngToECEF(u3, _2), p3 = e2.normalize([], d3), m3 = e2.normalize([], e2.cross([], p3, [0, 1, 0])), f3 = e2.cross([], m3, p3), g3 = [m3[0], m3[1], m3[2], 0, f3[0], f3[1], f3[2], 0, p3[0], p3[1], p3[2], 0, 0, 0, 0, 1], v3 = [d3, e2.latLngToECEF(c3.lat, c3.lng), e2.latLngToECEF(h3.lat, c3.lng), e2.latLngToECEF(h3.lat, h3.lng), e2.latLngToECEF(c3.lat, h3.lng), e2.latLngToECEF(u3, c3.lng), e2.latLngToECEF(u3, h3.lng), e2.latLngToECEF(c3.lat, _2), e2.latLngToECEF(h3.lat, _2)];
            let x3 = e2.Aabb.fromPoints(v3.map((t4) => [e2.dot(m3, t4), e2.dot(f3, t4), e2.dot(p3, t4)]));
            const y3 = e2.transformMat4([], x3.center, g3);
            0 === e2.squaredLength(y3) && e2.set(y3, 0, 0, 1), e2.normalize(y3, y3), e2.scale$2(y3, y3, e2.GLOBE_RADIUS), a3.center = e2.ecefToLatLng(y3);
            const b2 = a3.getWorldToCameraMatrix(), w2 = e2.invert(new Float64Array(16), b2);
            x3 = e2.Aabb.applyTransform(x3, e2.multiply([], b2, g3)), e2.transformMat4(y3, y3, b2);
            const T2 = 0.5 * (x3.max[2] - x3.min[2]), E3 = this._minimumAABBFrustumDistance(a3, x3), C2 = e2.scale$2([], [0, 0, 1], T2), M2 = e2.add(C2, y3, C2), I2 = E3 + (0 === a3.pitch ? 0 : e2.distance(y3, M2)), P2 = a3.globeCenterInViewSpace, S2 = e2.sub([], y3, [P2[0], P2[1], P2[2]]);
            e2.normalize(S2, S2), e2.scale$2(S2, S2, I2);
            const D2 = e2.add([], y3, S2);
            e2.transformMat4(D2, D2, w2);
            const L2 = e2.earthRadius / e2.GLOBE_RADIUS, A2 = e2.length(D2), z2 = e2.mercatorZfromAltitude(Math.max(A2 * L2 - e2.earthRadius, Number.EPSILON), 0), R2 = Math.min(a3.zoomFromMercatorZAdjusted(z2), l2.maxZoom);
            return R2 > 0.5 * (e2.GLOBE_ZOOM_THRESHOLD_MIN + e2.GLOBE_ZOOM_THRESHOLD_MAX) ? (a3.setProjection({ name: "mercator" }), a3.zoom = R2, this._cameraForBounds(a3, i3, o3, r3, n3, s3)) : { center: a3.center, zoom: R2, bearing: r3, pitch: n3 };
          }
          queryTerrainElevation(t3, i3) {
            const o3 = this.transform.elevation;
            return o3 ? (i3 = e2.extend({}, { exaggerated: true }, i3), o3.getAtPoint(e2.MercatorCoordinate.fromLngLat(t3), null, i3.exaggerated)) : null;
          }
          _cameraForBounds(t3, i3, o3, r3, n3, s3) {
            if ("globe" === t3.projection.name)
              return this._cameraForBoundsOnGlobe(t3, i3, o3, r3, n3, s3);
            const a3 = t3.clone(), l2 = this._extendCameraOptions(s3), c3 = a3.padding;
            a3.bearing = r3, a3.pitch = n3;
            const h3 = e2.LngLat.convert(i3), u3 = e2.LngLat.convert(o3), _2 = new e2.LngLat(h3.lng, u3.lat), d3 = new e2.LngLat(u3.lng, h3.lat), p3 = a3.project(h3), m3 = a3.project(u3), f3 = this.queryTerrainElevation(h3), g3 = this.queryTerrainElevation(u3), v3 = this.queryTerrainElevation(_2), x3 = this.queryTerrainElevation(d3), y3 = [[p3.x, p3.y, Math.min(f3 || 0, g3 || 0, v3 || 0, x3 || 0)], [m3.x, m3.y, Math.max(f3 || 0, g3 || 0, v3 || 0, x3 || 0)]];
            let b2 = e2.Aabb.fromPoints(y3);
            const w2 = a3.getWorldToCameraMatrix(), T2 = e2.invert(new Float64Array(16), w2);
            b2 = e2.Aabb.applyTransform(b2, w2);
            const E3 = e2.sub([], b2.max, b2.min), C2 = c3.left || 0, M2 = c3.right || 0, I2 = c3.bottom || 0, P2 = c3.top || 0, { left: S2, right: D2, top: L2, bottom: A2 } = l2.padding, z2 = 0.5 * (C2 + M2), R2 = 0.5 * (P2 + I2), O2 = Math.min(a3.scaleZoom(a3.scale * Math.min((a3.width - (C2 + M2 + S2 + D2)) / E3[0], (a3.height - (I2 + P2 + A2 + L2)) / E3[1])), l2.maxZoom), B2 = a3.scale / a3.zoomScale(O2);
            b2 = new e2.Aabb([b2.min[0] - (S2 + z2) * B2, b2.min[1] - (A2 + R2) * B2, b2.min[2]], [b2.max[0] + (D2 + z2) * B2, b2.max[1] + (L2 + R2) * B2, b2.max[2]]);
            const k2 = 0.5 * E3[2], F2 = this._minimumAABBFrustumDistance(a3, b2), U2 = [0, 0, 1, 0];
            e2.transformMat4$1(U2, U2, w2), e2.normalize$2(U2, U2);
            const N2 = e2.scale$2([], U2, F2 + k2), j2 = e2.add([], b2.center, N2), G2 = ("number" == typeof l2.offset.x && "number" == typeof l2.offset.y ? new e2.Point(l2.offset.x, l2.offset.y) : e2.Point.convert(l2.offset)).rotate(-e2.degToRad(r3));
            b2.center[0] -= G2.x * B2, b2.center[1] += G2.y * B2, e2.transformMat4(b2.center, b2.center, T2), e2.transformMat4(j2, j2, T2);
            const Z2 = [b2.center[0], b2.center[1], j2[2] * a3.pixelsPerMeter];
            e2.scale$2(Z2, Z2, 1 / a3.worldSize);
            const V2 = e2.lngFromMercatorX(Z2[0]), W2 = e2.latFromMercatorY(Z2[1]), X2 = Math.min(a3._zoomFromMercatorZ(Z2[2]), l2.maxZoom), q2 = new e2.LngLat(V2, W2);
            return a3.mercatorFromTransition && X2 < 0.5 * (e2.GLOBE_ZOOM_THRESHOLD_MIN + e2.GLOBE_ZOOM_THRESHOLD_MAX) ? (a3.setProjection({ name: "globe" }), a3.zoom = X2, this._cameraForBounds(a3, i3, o3, r3, n3, s3)) : { center: q2, zoom: X2, bearing: r3, pitch: n3 };
          }
          fitBounds(e3, t3, i3) {
            const o3 = this.cameraForBounds(e3, t3);
            return this._fitInternal(o3, t3, i3);
          }
          fitScreenCoordinates(t3, i3, o3, r3, n3) {
            const s3 = e2.Point.convert(t3), a3 = e2.Point.convert(i3), l2 = new e2.Point(Math.min(s3.x, a3.x), Math.min(s3.y, a3.y)), c3 = new e2.Point(Math.max(s3.x, a3.x), Math.max(s3.y, a3.y));
            if ("mercator" === this.transform.projection.name && this.transform.anyCornerOffEdge(s3, a3))
              return this;
            const h3 = this.transform.pointLocation3D(l2), u3 = this.transform.pointLocation3D(c3), _2 = this.transform.pointLocation3D(new e2.Point(l2.x, c3.y)), d3 = this.transform.pointLocation3D(new e2.Point(c3.x, l2.y)), p3 = [Math.min(h3.lng, u3.lng, _2.lng, d3.lng), Math.min(h3.lat, u3.lat, _2.lat, d3.lat)], m3 = [Math.max(h3.lng, u3.lng, _2.lng, d3.lng), Math.max(h3.lat, u3.lat, _2.lat, d3.lat)], f3 = r3 && r3.pitch ? r3.pitch : this.getPitch(), g3 = this._cameraForBounds(this.transform, p3, m3, o3, f3, r3);
            return this._fitInternal(g3, r3, n3);
          }
          _fitInternal(t3, i3, o3) {
            return t3 ? (delete (i3 = e2.extend(t3, i3)).padding, i3.linear ? this.easeTo(i3, o3) : this.flyTo(i3, o3)) : this;
          }
          jumpTo(t3, i3) {
            this.stop();
            const o3 = t3.preloadOnly ? this.transform.clone() : this.transform;
            let r3 = false, n3 = false, s3 = false;
            return "zoom" in t3 && o3.zoom !== +t3.zoom && (r3 = true, o3.zoom = +t3.zoom), void 0 !== t3.center && (o3.center = e2.LngLat.convert(t3.center)), "bearing" in t3 && o3.bearing !== +t3.bearing && (n3 = true, o3.bearing = +t3.bearing), "pitch" in t3 && o3.pitch !== +t3.pitch && (s3 = true, o3.pitch = +t3.pitch), null == t3.padding || o3.isPaddingEqual(t3.padding) || (o3.padding = t3.padding), t3.preloadOnly ? (this._preloadTiles(o3), this) : (this.fire(new e2.Event("movestart", i3)).fire(new e2.Event("move", i3)), r3 && this.fire(new e2.Event("zoomstart", i3)).fire(new e2.Event("zoom", i3)).fire(new e2.Event("zoomend", i3)), n3 && this.fire(new e2.Event("rotatestart", i3)).fire(new e2.Event("rotate", i3)).fire(new e2.Event("rotateend", i3)), s3 && this.fire(new e2.Event("pitchstart", i3)).fire(new e2.Event("pitch", i3)).fire(new e2.Event("pitchend", i3)), this.fire(new e2.Event("moveend", i3)));
          }
          getFreeCameraOptions() {
            return this.transform.projection.supportsFreeCamera || e2.warnOnce(qr), this.transform.getFreeCameraOptions();
          }
          setFreeCameraOptions(t3, i3) {
            const o3 = this.transform;
            if (!o3.projection.supportsFreeCamera)
              return e2.warnOnce(qr), this;
            this.stop();
            const r3 = o3.zoom, n3 = o3.pitch, s3 = o3.bearing;
            o3.setFreeCameraOptions(t3);
            const a3 = r3 !== o3.zoom, l2 = n3 !== o3.pitch, c3 = s3 !== o3.bearing;
            return this.fire(new e2.Event("movestart", i3)).fire(new e2.Event("move", i3)), a3 && this.fire(new e2.Event("zoomstart", i3)).fire(new e2.Event("zoom", i3)).fire(new e2.Event("zoomend", i3)), c3 && this.fire(new e2.Event("rotatestart", i3)).fire(new e2.Event("rotate", i3)).fire(new e2.Event("rotateend", i3)), l2 && this.fire(new e2.Event("pitchstart", i3)).fire(new e2.Event("pitch", i3)).fire(new e2.Event("pitchend", i3)), this.fire(new e2.Event("moveend", i3)), this;
          }
          easeTo(t3, i3) {
            this._stop(false, t3.easeId), (false === (t3 = e2.extend({ offset: [0, 0], duration: 500, easing: e2.ease }, t3)).animate || this._prefersReducedMotion(t3)) && (t3.duration = 0);
            const o3 = this.transform, r3 = this.getZoom(), n3 = this.getBearing(), s3 = this.getPitch(), a3 = this.getPadding(), l2 = "zoom" in t3 ? +t3.zoom : r3, c3 = "bearing" in t3 ? this._normalizeBearing(t3.bearing, n3) : n3, h3 = "pitch" in t3 ? +t3.pitch : s3, u3 = "padding" in t3 ? t3.padding : o3.padding, _2 = e2.Point.convert(t3.offset);
            let d3, p3, m3;
            if ("globe" === o3.projection.name) {
              const i4 = e2.MercatorCoordinate.fromLngLat(o3.center), r4 = _2.rotate(-o3.angle);
              i4.x += r4.x / o3.worldSize, i4.y += r4.y / o3.worldSize;
              const n4 = i4.toLngLat(), s4 = e2.LngLat.convert(t3.center || n4);
              this._normalizeCenter(s4), d3 = o3.centerPoint.add(r4), p3 = new e2.Point(i4.x, i4.y).mult(o3.worldSize), m3 = new e2.Point(e2.mercatorXfromLng(s4.lng), e2.mercatorYfromLat(s4.lat)).mult(o3.worldSize).sub(p3);
            } else {
              d3 = o3.centerPoint.add(_2);
              const i4 = o3.pointLocation(d3), r4 = e2.LngLat.convert(t3.center || i4);
              this._normalizeCenter(r4), p3 = o3.project(i4), m3 = o3.project(r4).sub(p3);
            }
            const f3 = o3.zoomScale(l2 - r3);
            let g3, v3;
            t3.around && (g3 = e2.LngLat.convert(t3.around), v3 = o3.locationPoint(g3));
            const x3 = this._zooming || l2 !== r3, y3 = this._rotating || n3 !== c3, b2 = this._pitching || h3 !== s3, w2 = !o3.isPaddingEqual(u3), T2 = (o4) => (T3) => {
              if (x3 && (o4.zoom = e2.number(r3, l2, T3)), y3 && (o4.bearing = e2.number(n3, c3, T3)), b2 && (o4.pitch = e2.number(s3, h3, T3)), w2 && (o4.interpolatePadding(a3, u3, T3), d3 = o4.centerPoint.add(_2)), g3)
                o4.setLocationAtPoint(g3, v3);
              else {
                const e3 = o4.zoomScale(o4.zoom - r3), t4 = l2 > r3 ? Math.min(2, f3) : Math.max(0.5, f3), i4 = Math.pow(t4, 1 - T3), n4 = o4.unproject(p3.add(m3.mult(T3 * i4)).mult(e3));
                o4.setLocationAtPoint(o4.renderWorldCopies ? n4.wrap() : n4, d3);
              }
              return t3.preloadOnly || this._fireMoveEvents(i3), o4;
            };
            if (t3.preloadOnly) {
              const e3 = this._emulate(T2, t3.duration, o3);
              return this._preloadTiles(e3), this;
            }
            const E3 = { moving: this._moving, zooming: this._zooming, rotating: this._rotating, pitching: this._pitching };
            return this._zooming = x3, this._rotating = y3, this._pitching = b2, this._padding = w2, this._easeId = t3.easeId, this._prepareEase(i3, t3.noMoveStart, E3), this._ease(T2(o3), (e3) => {
              o3.recenterOnTerrain(), this._afterEase(i3, e3);
            }, t3), this;
          }
          _prepareEase(t3, i3, o3 = {}) {
            this._moving = true, this.transform.cameraElevationReference = "sea", i3 || o3.moving || this.fire(new e2.Event("movestart", t3)), this._zooming && !o3.zooming && this.fire(new e2.Event("zoomstart", t3)), this._rotating && !o3.rotating && this.fire(new e2.Event("rotatestart", t3)), this._pitching && !o3.pitching && this.fire(new e2.Event("pitchstart", t3));
          }
          _fireMoveEvents(t3) {
            this.fire(new e2.Event("move", t3)), this._zooming && this.fire(new e2.Event("zoom", t3)), this._rotating && this.fire(new e2.Event("rotate", t3)), this._pitching && this.fire(new e2.Event("pitch", t3));
          }
          _afterEase(t3, i3) {
            if (this._easeId && i3 && this._easeId === i3)
              return;
            this._easeId = void 0, this.transform.cameraElevationReference = "ground";
            const o3 = this._zooming, r3 = this._rotating, n3 = this._pitching;
            this._moving = false, this._zooming = false, this._rotating = false, this._pitching = false, this._padding = false, o3 && this.fire(new e2.Event("zoomend", t3)), r3 && this.fire(new e2.Event("rotateend", t3)), n3 && this.fire(new e2.Event("pitchend", t3)), this.fire(new e2.Event("moveend", t3));
          }
          flyTo(t3, i3) {
            if (this._prefersReducedMotion(t3)) {
              const o4 = e2.pick(t3, ["center", "zoom", "bearing", "pitch", "around"]);
              return this.jumpTo(o4, i3);
            }
            this.stop(), t3 = e2.extend({ offset: [0, 0], speed: 1.2, curve: 1.42, easing: e2.ease }, t3);
            const o3 = this.transform, r3 = this.getZoom(), n3 = this.getBearing(), s3 = this.getPitch(), a3 = this.getPadding(), l2 = "zoom" in t3 ? e2.clamp(+t3.zoom, o3.minZoom, o3.maxZoom) : r3, c3 = "bearing" in t3 ? this._normalizeBearing(t3.bearing, n3) : n3, h3 = "pitch" in t3 ? +t3.pitch : s3, u3 = "padding" in t3 ? t3.padding : o3.padding, _2 = o3.zoomScale(l2 - r3), d3 = e2.Point.convert(t3.offset);
            let p3 = o3.centerPoint.add(d3);
            const m3 = o3.pointLocation(p3), f3 = e2.LngLat.convert(t3.center || m3);
            this._normalizeCenter(f3);
            const g3 = o3.project(m3), v3 = o3.project(f3).sub(g3);
            let x3 = t3.curve;
            const y3 = Math.max(o3.width, o3.height), b2 = y3 / _2, w2 = v3.mag();
            if ("minZoom" in t3) {
              const i4 = e2.clamp(Math.min(t3.minZoom, r3, l2), o3.minZoom, o3.maxZoom), n4 = y3 / o3.zoomScale(i4 - r3);
              x3 = Math.sqrt(n4 / w2 * 2);
            }
            const T2 = x3 * x3;
            function E3(e3) {
              const t4 = (b2 * b2 - y3 * y3 + (e3 ? -1 : 1) * T2 * T2 * w2 * w2) / (2 * (e3 ? b2 : y3) * T2 * w2);
              return Math.log(Math.sqrt(t4 * t4 + 1) - t4);
            }
            function C2(e3) {
              return (Math.exp(e3) - Math.exp(-e3)) / 2;
            }
            function M2(e3) {
              return (Math.exp(e3) + Math.exp(-e3)) / 2;
            }
            const I2 = E3(0);
            let P2 = function(e3) {
              return M2(I2) / M2(I2 + x3 * e3);
            }, S2 = function(e3) {
              return y3 * ((M2(I2) * (C2(t4 = I2 + x3 * e3) / M2(t4)) - C2(I2)) / T2) / w2;
              var t4;
            }, D2 = (E3(1) - I2) / x3;
            if (Math.abs(w2) < 1e-6 || !isFinite(D2)) {
              if (Math.abs(y3 - b2) < 1e-6)
                return this.easeTo(t3, i3);
              const e3 = b2 < y3 ? -1 : 1;
              D2 = Math.abs(Math.log(b2 / y3)) / x3, S2 = function() {
                return 0;
              }, P2 = function(t4) {
                return Math.exp(e3 * x3 * t4);
              };
            }
            t3.duration = "duration" in t3 ? +t3.duration : 1e3 * D2 / ("screenSpeed" in t3 ? +t3.screenSpeed / x3 : +t3.speed), t3.maxDuration && t3.duration > t3.maxDuration && (t3.duration = 0);
            const L2 = n3 !== c3, A2 = h3 !== s3, z2 = !o3.isPaddingEqual(u3), R2 = (o4) => (_3) => {
              const m4 = _3 * D2, x4 = 1 / P2(m4);
              o4.zoom = 1 === _3 ? l2 : r3 + o4.scaleZoom(x4), L2 && (o4.bearing = e2.number(n3, c3, _3)), A2 && (o4.pitch = e2.number(s3, h3, _3)), z2 && (o4.interpolatePadding(a3, u3, _3), p3 = o4.centerPoint.add(d3));
              const y4 = 1 === _3 ? f3 : o4.unproject(g3.add(v3.mult(S2(m4))).mult(x4));
              return o4.setLocationAtPoint(o4.renderWorldCopies ? y4.wrap() : y4, p3), o4._updateCameraOnTerrain(), t3.preloadOnly || this._fireMoveEvents(i3), o4;
            };
            if (t3.preloadOnly) {
              const e3 = this._emulate(R2, t3.duration, o3);
              return this._preloadTiles(e3), this;
            }
            return this._zooming = true, this._rotating = L2, this._pitching = A2, this._padding = z2, this._prepareEase(i3, false), this._ease(R2(o3), () => this._afterEase(i3), t3), this;
          }
          isEasing() {
            return !!this._easeFrameId;
          }
          stop() {
            return this._stop();
          }
          _stop(e3, t3) {
            if (this._easeFrameId && (this._cancelRenderFrame(this._easeFrameId), this._easeFrameId = void 0, this._onEaseFrame = void 0), this._onEaseEnd) {
              const e4 = this._onEaseEnd;
              this._onEaseEnd = void 0, e4.call(this, t3);
            }
            if (!e3) {
              const e4 = this.handlers;
              e4 && e4.stop(false);
            }
            return this;
          }
          _ease(t3, i3, o3) {
            false === o3.animate || 0 === o3.duration ? (t3(1), i3()) : (this._easeStart = e2.exported.now(), this._easeOptions = o3, this._onEaseFrame = t3, this._onEaseEnd = i3, this._easeFrameId = this._requestRenderFrame(this._renderFrameCallback));
          }
          _renderFrameCallback() {
            const t3 = Math.min((e2.exported.now() - this._easeStart) / this._easeOptions.duration, 1), i3 = this._onEaseFrame;
            i3 && i3(this._easeOptions.easing(t3)), t3 < 1 ? this._easeFrameId = this._requestRenderFrame(this._renderFrameCallback) : this.stop();
          }
          _normalizeBearing(t3, i3) {
            t3 = e2.wrap(t3, -180, 180);
            const o3 = Math.abs(t3 - i3);
            return Math.abs(t3 - 360 - i3) < o3 && (t3 -= 360), Math.abs(t3 + 360 - i3) < o3 && (t3 += 360), t3;
          }
          _normalizeCenter(e3) {
            const t3 = this.transform;
            if (!t3.renderWorldCopies || t3.maxBounds)
              return;
            const i3 = e3.lng - t3.center.lng;
            e3.lng += i3 > 180 ? -360 : i3 < -180 ? 360 : 0;
          }
          _prefersReducedMotion(t3) {
            return this._respectPrefersReducedMotion && e2.exported.prefersReducedMotion && !(t3 && t3.essential);
          }
          _emulate(e3, t3, i3) {
            const o3 = Math.ceil(15 * t3 / 1e3), r3 = [], n3 = e3(i3.clone());
            for (let e4 = 0; e4 <= o3; e4++) {
              const t4 = n3(e4 / o3);
              r3.push(t4.clone());
            }
            return r3;
          }
        }
        class Hr {
          constructor(t3 = {}) {
            this.options = t3, e2.bindAll(["_toggleAttribution", "_updateEditLink", "_updateData", "_updateCompact"], this);
          }
          getDefaultPosition() {
            return "bottom-right";
          }
          onAdd(e3) {
            const t3 = this.options && this.options.compact;
            return this._map = e3, this._container = n2("div", "mapboxgl-ctrl mapboxgl-ctrl-attrib"), this._compactButton = n2("button", "mapboxgl-ctrl-attrib-button", this._container), n2("span", "mapboxgl-ctrl-icon", this._compactButton).setAttribute("aria-hidden", "true"), this._compactButton.type = "button", this._compactButton.addEventListener("click", this._toggleAttribution), this._setElementTitle(this._compactButton, "ToggleAttribution"), this._innerContainer = n2("div", "mapboxgl-ctrl-attrib-inner", this._container), this._innerContainer.setAttribute("role", "list"), t3 && this._container.classList.add("mapboxgl-compact"), this._updateAttributions(), this._updateEditLink(), this._map.on("styledata", this._updateData), this._map.on("sourcedata", this._updateData), this._map.on("moveend", this._updateEditLink), void 0 === t3 && (this._map.on("resize", this._updateCompact), this._updateCompact()), this._container;
          }
          onRemove() {
            this._container.remove(), this._map.off("styledata", this._updateData), this._map.off("sourcedata", this._updateData), this._map.off("moveend", this._updateEditLink), this._map.off("resize", this._updateCompact), this._map = void 0, this._attribHTML = void 0;
          }
          _setElementTitle(e3, t3) {
            const i3 = this._map._getUIString(`AttributionControl.${t3}`);
            e3.setAttribute("aria-label", i3), e3.removeAttribute("title"), e3.firstElementChild && e3.firstElementChild.setAttribute("title", i3);
          }
          _toggleAttribution() {
            this._container.classList.contains("mapboxgl-compact-show") ? (this._container.classList.remove("mapboxgl-compact-show"), this._compactButton.setAttribute("aria-expanded", "false")) : (this._container.classList.add("mapboxgl-compact-show"), this._compactButton.setAttribute("aria-expanded", "true"));
          }
          _updateEditLink() {
            let t3 = this._editLink;
            t3 || (t3 = this._editLink = this._container.querySelector(".mapbox-improve-map"));
            const i3 = [{ key: "owner", value: this.styleOwner }, { key: "id", value: this.styleId }, { key: "access_token", value: this._map._requestManager._customAccessToken || e2.config.ACCESS_TOKEN }];
            if (t3) {
              const o3 = i3.reduce((e3, t4, o4) => (t4.value && (e3 += `${t4.key}=${t4.value}${o4 < i3.length - 1 ? "&" : ""}`), e3), "?");
              t3.href = `${e2.config.FEEDBACK_URL}/${o3}#${Jo(this._map, true)}`, t3.rel = "noopener nofollow", this._setElementTitle(t3, "MapFeedback");
            }
          }
          _updateData(e3) {
            !e3 || "metadata" !== e3.sourceDataType && "visibility" !== e3.sourceDataType && "style" !== e3.dataType || (this._updateAttributions(), this._updateEditLink());
          }
          _updateAttributions() {
            if (!this._map.style)
              return;
            let e3 = [];
            if (this._map.style.stylesheet) {
              const e4 = this._map.style.stylesheet;
              this.styleOwner = e4.owner, this.styleId = e4.id;
            }
            const t3 = this._map.style._sourceCaches;
            for (const i4 in t3) {
              const o3 = t3[i4];
              if (o3.used) {
                const t4 = o3.getSource();
                t4.attribution && e3.indexOf(t4.attribution) < 0 && e3.push(t4.attribution);
              }
            }
            e3.sort((e4, t4) => e4.length - t4.length), e3 = e3.filter((t4, i4) => {
              for (let o3 = i4 + 1; o3 < e3.length; o3++)
                if (e3[o3].indexOf(t4) >= 0)
                  return false;
              return true;
            }), this.options.customAttribution && (Array.isArray(this.options.customAttribution) ? e3 = [...this.options.customAttribution, ...e3] : e3.unshift(this.options.customAttribution));
            const i3 = e3.join(" | ");
            i3 !== this._attribHTML && (this._attribHTML = i3, e3.length ? (this._innerContainer.innerHTML = i3, this._container.classList.remove("mapboxgl-attrib-empty")) : this._container.classList.add("mapboxgl-attrib-empty"), this._editLink = null);
          }
          _updateCompact() {
            this._map.getCanvasContainer().offsetWidth <= 640 ? this._container.classList.add("mapboxgl-compact") : this._container.classList.remove("mapboxgl-compact", "mapboxgl-compact-show");
          }
        }
        class Yr {
          constructor() {
            e2.bindAll(["_updateLogo", "_updateCompact"], this);
          }
          onAdd(e3) {
            this._map = e3, this._container = n2("div", "mapboxgl-ctrl");
            const t3 = n2("a", "mapboxgl-ctrl-logo");
            return t3.target = "_blank", t3.rel = "noopener nofollow", t3.href = "https://www.mapbox.com/", t3.setAttribute("aria-label", this._map._getUIString("LogoControl.Title")), t3.setAttribute("rel", "noopener nofollow"), this._container.appendChild(t3), this._container.style.display = "none", this._map.on("sourcedata", this._updateLogo), this._updateLogo(), this._map.on("resize", this._updateCompact), this._updateCompact(), this._container;
          }
          onRemove() {
            this._container.remove(), this._map.off("sourcedata", this._updateLogo), this._map.off("resize", this._updateCompact);
          }
          getDefaultPosition() {
            return "bottom-left";
          }
          _updateLogo(e3) {
            e3 && "metadata" !== e3.sourceDataType || (this._container.style.display = this._logoRequired() ? "block" : "none");
          }
          _logoRequired() {
            if (!this._map.style)
              return true;
            const e3 = this._map.style._sourceCaches;
            if (0 === Object.entries(e3).length)
              return true;
            for (const t3 in e3) {
              const i3 = e3[t3].getSource();
              if (i3.hasOwnProperty("mapbox_logo") && !i3.mapbox_logo)
                return false;
            }
            return true;
          }
          _updateCompact() {
            const e3 = this._container.children;
            if (e3.length) {
              const t3 = e3[0];
              this._map.getCanvasContainer().offsetWidth < 250 ? t3.classList.add("mapboxgl-compact") : t3.classList.remove("mapboxgl-compact");
            }
          }
        }
        class Kr {
          constructor() {
            this._queue = [], this._id = 0, this._cleared = false, this._currentlyRunning = false;
          }
          add(e3) {
            const t3 = ++this._id;
            return this._queue.push({ callback: e3, id: t3, cancelled: false }), t3;
          }
          remove(e3) {
            const t3 = this._currentlyRunning, i3 = t3 ? this._queue.concat(t3) : this._queue;
            for (const t4 of i3)
              if (t4.id === e3)
                return void (t4.cancelled = true);
          }
          run(e3 = 0) {
            const t3 = this._currentlyRunning = this._queue;
            this._queue = [];
            for (const i3 of t3)
              if (!i3.cancelled && (i3.callback(e3), this._cleared))
                break;
            this._cleared = false, this._currentlyRunning = false;
          }
          clear() {
            this._currentlyRunning && (this._cleared = true), this._queue = [];
          }
        }
        function Jr(t3, i3, o3) {
          if (t3 = new e2.LngLat(t3.lng, t3.lat), i3) {
            const r3 = new e2.LngLat(t3.lng - 360, t3.lat), n3 = new e2.LngLat(t3.lng + 360, t3.lat), s3 = 360 * Math.ceil(Math.abs(t3.lng - o3.center.lng) / 360), a3 = o3.locationPoint(t3).distSqr(i3), l2 = i3.x < 0 || i3.y < 0 || i3.x > o3.width || i3.y > o3.height;
            o3.locationPoint(r3).distSqr(i3) < a3 && (l2 || Math.abs(r3.lng - o3.center.lng) < s3) ? t3 = r3 : o3.locationPoint(n3).distSqr(i3) < a3 && (l2 || Math.abs(n3.lng - o3.center.lng) < s3) && (t3 = n3);
          }
          for (; Math.abs(t3.lng - o3.center.lng) > 180; ) {
            const e3 = o3.locationPoint(t3);
            if (e3.x >= 0 && e3.y >= 0 && e3.x <= o3.width && e3.y <= o3.height)
              break;
            t3.lng > o3.center.lng ? t3.lng -= 360 : t3.lng += 360;
          }
          return t3;
        }
        const Qr = { center: "translate(-50%,-50%)", top: "translate(-50%,0)", "top-left": "translate(0,0)", "top-right": "translate(-100%,0)", bottom: "translate(-50%,-100%)", "bottom-left": "translate(0,-100%)", "bottom-right": "translate(-100%,-100%)", left: "translate(0,-50%)", right: "translate(-100%,-50%)" };
        class en extends e2.Evented {
          constructor(t3, i3) {
            if (super(), (t3 instanceof e2.window.HTMLElement || i3) && (t3 = e2.extend({ element: t3 }, i3)), e2.bindAll(["_update", "_onMove", "_onUp", "_addDragHandler", "_onMapClick", "_onKeyPress", "_clearFadeTimer"], this), this._anchor = t3 && t3.anchor || "center", this._color = t3 && t3.color || "#3FB1CE", this._scale = t3 && t3.scale || 1, this._draggable = t3 && t3.draggable || false, this._clickTolerance = t3 && t3.clickTolerance || 0, this._isDragging = false, this._state = "inactive", this._rotation = t3 && t3.rotation || 0, this._rotationAlignment = t3 && t3.rotationAlignment || "auto", this._pitchAlignment = t3 && t3.pitchAlignment && t3.pitchAlignment || "auto", this._updateMoving = () => this._update(true), this._occludedOpacity = t3 && t3.occludedOpacity || 0.2, t3 && t3.element)
              this._element = t3.element, this._offset = e2.Point.convert(t3 && t3.offset || [0, 0]);
            else {
              this._defaultMarker = true, this._element = n2("div");
              const i4 = 41, o4 = 27, r3 = s2("svg", { display: "block", height: i4 * this._scale + "px", width: o4 * this._scale + "px", viewBox: `0 0 ${o4} ${i4}` }, this._element), a3 = s2("radialGradient", { id: "shadowGradient" }, s2("defs", {}, r3));
              s2("stop", { offset: "10%", "stop-opacity": 0.4 }, a3), s2("stop", { offset: "100%", "stop-opacity": 0.05 }, a3), s2("ellipse", { cx: 13.5, cy: 34.8, rx: 10.5, ry: 5.25, fill: "url(#shadowGradient)" }, r3), s2("path", { fill: this._color, d: "M27,13.5C27,19.07 20.25,27 14.75,34.5C14.02,35.5 12.98,35.5 12.25,34.5C6.75,27 0,19.22 0,13.5C0,6.04 6.04,0 13.5,0C20.96,0 27,6.04 27,13.5Z" }, r3), s2("path", { opacity: 0.25, d: "M13.5,0C6.04,0 0,6.04 0,13.5C0,19.22 6.75,27 12.25,34.5C13,35.52 14.02,35.5 14.75,34.5C20.25,27 27,19.07 27,13.5C27,6.04 20.96,0 13.5,0ZM13.5,1C20.42,1 26,6.58 26,13.5C26,15.9 24.5,19.18 22.22,22.74C19.95,26.3 16.71,30.14 13.94,33.91C13.74,34.18 13.61,34.32 13.5,34.44C13.39,34.32 13.26,34.18 13.06,33.91C10.28,30.13 7.41,26.31 5.02,22.77C2.62,19.23 1,15.95 1,13.5C1,6.58 6.58,1 13.5,1Z" }, r3), s2("circle", { fill: "white", cx: 13.5, cy: 13.5, r: 5.5 }, r3), this._offset = e2.Point.convert(t3 && t3.offset || [0, -14]);
            }
            this._element.hasAttribute("aria-label") || this._element.setAttribute("aria-label", "Map marker"), this._element.classList.add("mapboxgl-marker"), this._element.addEventListener("dragstart", (e3) => {
              e3.preventDefault();
            }), this._element.addEventListener("mousedown", (e3) => {
              e3.preventDefault();
            });
            const o3 = this._element.classList;
            for (const e3 in Qr)
              o3.remove(`mapboxgl-marker-anchor-${e3}`);
            o3.add(`mapboxgl-marker-anchor-${this._anchor}`), this._popup = null;
          }
          addTo(e3) {
            return e3 === this._map || (this.remove(), this._map = e3, e3.getCanvasContainer().appendChild(this._element), e3.on("move", this._updateMoving), e3.on("moveend", this._update), e3.on("remove", this._clearFadeTimer), e3._addMarker(this), this.setDraggable(this._draggable), this._update(), e3.on("click", this._onMapClick)), this;
          }
          remove() {
            const e3 = this._map;
            return e3 && (e3.off("click", this._onMapClick), e3.off("move", this._updateMoving), e3.off("moveend", this._update), e3.off("mousedown", this._addDragHandler), e3.off("touchstart", this._addDragHandler), e3.off("mouseup", this._onUp), e3.off("touchend", this._onUp), e3.off("mousemove", this._onMove), e3.off("touchmove", this._onMove), e3.off("remove", this._clearFadeTimer), e3._removeMarker(this), this._map = void 0), this._clearFadeTimer(), this._element.remove(), this._popup && this._popup.remove(), this;
          }
          getLngLat() {
            return this._lngLat;
          }
          setLngLat(t3) {
            return this._lngLat = e2.LngLat.convert(t3), this._pos = null, this._popup && this._popup.setLngLat(this._lngLat), this._update(true), this;
          }
          getElement() {
            return this._element;
          }
          setPopup(e3) {
            if (this._popup && (this._popup.remove(), this._popup = null, this._element.removeAttribute("role"), this._element.removeEventListener("keypress", this._onKeyPress), this._originalTabIndex || this._element.removeAttribute("tabindex")), e3) {
              if (!("offset" in e3.options)) {
                const t3 = 38.1, i3 = 13.5, o3 = Math.sqrt(Math.pow(i3, 2) / 2);
                e3.options.offset = this._defaultMarker ? { top: [0, 0], "top-left": [0, 0], "top-right": [0, 0], bottom: [0, -t3], "bottom-left": [o3, -1 * (t3 - i3 + o3)], "bottom-right": [-o3, -1 * (t3 - i3 + o3)], left: [i3, -1 * (t3 - i3)], right: [-i3, -1 * (t3 - i3)] } : this._offset;
              }
              this._popup = e3, e3._marker = this, this._lngLat && this._popup.setLngLat(this._lngLat), this._element.setAttribute("role", "button"), this._originalTabIndex = this._element.getAttribute("tabindex"), this._originalTabIndex || this._element.setAttribute("tabindex", "0"), this._element.addEventListener("keypress", this._onKeyPress), this._element.setAttribute("aria-expanded", "false");
            }
            return this;
          }
          _onKeyPress(e3) {
            const t3 = e3.code, i3 = e3.charCode || e3.keyCode;
            "Space" !== t3 && "Enter" !== t3 && 32 !== i3 && 13 !== i3 || this.togglePopup();
          }
          _onMapClick(e3) {
            const t3 = e3.originalEvent.target, i3 = this._element;
            this._popup && (t3 === i3 || i3.contains(t3)) && this.togglePopup();
          }
          getPopup() {
            return this._popup;
          }
          togglePopup() {
            const e3 = this._popup;
            return e3 ? (e3.isOpen() ? (e3.remove(), this._element.setAttribute("aria-expanded", "false")) : this._map && (e3.addTo(this._map), this._element.setAttribute("aria-expanded", "true")), this) : this;
          }
          _behindTerrain() {
            const e3 = this._map, t3 = this._pos;
            if (!e3 || !t3)
              return false;
            const i3 = e3.unproject(t3), o3 = e3.getFreeCameraOptions();
            if (!o3.position)
              return false;
            const r3 = o3.position.toLngLat();
            return r3.distanceTo(i3) < 0.9 * r3.distanceTo(this._lngLat);
          }
          _evaluateOpacity() {
            const t3 = this._map;
            if (!t3)
              return;
            const i3 = this._pos;
            if (!i3 || i3.x < 0 || i3.x > t3.transform.width || i3.y < 0 || i3.y > t3.transform.height)
              return void this._clearFadeTimer();
            const o3 = t3.unproject(i3);
            let r3;
            t3._showingGlobe() && e2.isLngLatBehindGlobe(t3.transform, this._lngLat) ? r3 = 0 : (r3 = 1 - t3._queryFogOpacity(o3), t3.transform._terrainEnabled() && t3.getTerrain() && this._behindTerrain() && (r3 *= this._occludedOpacity)), this._element.style.opacity = `${r3}`, this._element.style.pointerEvents = r3 > 0 ? "auto" : "none", this._popup && this._popup._setOpacity(r3), this._fadeTimer = null;
          }
          _clearFadeTimer() {
            this._fadeTimer && (clearTimeout(this._fadeTimer), this._fadeTimer = null);
          }
          _updateDOM() {
            const e3 = this._pos;
            if (!e3 || !this._map)
              return;
            const t3 = this._offset.mult(this._scale);
            this._element.style.transform = `
            translate(${e3.x}px,${e3.y}px)
            ${Qr[this._anchor]}
            ${this._calculateXYTransform()} ${this._calculateZTransform()}
            translate(${t3.x}px,${t3.y}px)
        `;
          }
          _calculateXYTransform() {
            const t3 = this._pos, i3 = this._map, o3 = this.getPitchAlignment();
            if (!i3 || !t3 || "map" !== o3)
              return "";
            if (!i3._showingGlobe()) {
              const e3 = i3.getPitch();
              return e3 ? `rotateX(${e3}deg)` : "";
            }
            const r3 = e2.radToDeg(e2.globeTiltAtLngLat(i3.transform, this._lngLat)), n3 = t3.sub(e2.globeCenterToScreenPoint(i3.transform)), s3 = Math.abs(n3.x) + Math.abs(n3.y);
            if (0 === s3)
              return "";
            const a3 = r3 / s3;
            return `rotateX(${-n3.y * a3}deg) rotateY(${n3.x * a3}deg)`;
          }
          _calculateZTransform() {
            const t3 = this._pos, i3 = this._map;
            if (!i3 || !t3)
              return "";
            let o3 = 0;
            const r3 = this.getRotationAlignment();
            if ("map" === r3)
              if (i3._showingGlobe()) {
                const t4 = i3.project(new e2.LngLat(this._lngLat.lng, this._lngLat.lat + 1e-3)), r4 = i3.project(new e2.LngLat(this._lngLat.lng, this._lngLat.lat - 1e-3)).sub(t4);
                o3 = e2.radToDeg(Math.atan2(r4.y, r4.x)) - 90;
              } else
                o3 = -i3.getBearing();
            else if ("horizon" === r3) {
              const r4 = e2.smoothstep(4, 6, i3.getZoom()), n3 = e2.globeCenterToScreenPoint(i3.transform);
              n3.y += r4 * i3.transform.height;
              const s3 = t3.sub(n3), a3 = e2.radToDeg(Math.atan2(s3.y, s3.x));
              o3 = (a3 > 90 ? a3 - 270 : a3 + 90) * (1 - r4);
            }
            return o3 += this._rotation, o3 ? `rotateZ(${o3}deg)` : "";
          }
          _update(t3) {
            e2.window.cancelAnimationFrame(this._updateFrameId);
            const i3 = this._map;
            i3 && (i3.transform.renderWorldCopies && (this._lngLat = Jr(this._lngLat, this._pos, i3.transform)), this._pos = i3.project(this._lngLat), true === t3 ? this._updateFrameId = e2.window.requestAnimationFrame(() => {
              this._element && this._pos && this._anchor && (this._pos = this._pos.round(), this._updateDOM());
            }) : this._pos = this._pos.round(), i3._requestDomTask(() => {
              this._map && (this._element && this._pos && this._anchor && this._updateDOM(), (i3._showingGlobe() || i3.getTerrain() || i3.getFog()) && !this._fadeTimer && (this._fadeTimer = setTimeout(this._evaluateOpacity.bind(this), 60)));
            }));
          }
          getOffset() {
            return this._offset;
          }
          setOffset(t3) {
            return this._offset = e2.Point.convert(t3), this._update(), this;
          }
          _onMove(t3) {
            const i3 = this._map;
            if (!i3)
              return;
            const o3 = this._pointerdownPos, r3 = this._positionDelta;
            if (o3 && r3) {
              if (!this._isDragging) {
                const e3 = this._clickTolerance || i3._clickTolerance;
                if (t3.point.dist(o3) < e3)
                  return;
                this._isDragging = true;
              }
              this._pos = t3.point.sub(r3), this._lngLat = i3.unproject(this._pos), this.setLngLat(this._lngLat), this._element.style.pointerEvents = "none", "pending" === this._state && (this._state = "active", this.fire(new e2.Event("dragstart"))), this.fire(new e2.Event("drag"));
            }
          }
          _onUp() {
            this._element.style.pointerEvents = "auto", this._positionDelta = null, this._pointerdownPos = null, this._isDragging = false;
            const t3 = this._map;
            t3 && (t3.off("mousemove", this._onMove), t3.off("touchmove", this._onMove)), "active" === this._state && this.fire(new e2.Event("dragend")), this._state = "inactive";
          }
          _addDragHandler(e3) {
            const t3 = this._map, i3 = this._pos;
            t3 && i3 && this._element.contains(e3.originalEvent.target) && (e3.preventDefault(), this._positionDelta = e3.point.sub(i3), this._pointerdownPos = e3.point, this._state = "pending", t3.on("mousemove", this._onMove), t3.on("touchmove", this._onMove), t3.once("mouseup", this._onUp), t3.once("touchend", this._onUp));
          }
          setDraggable(e3) {
            this._draggable = !!e3;
            const t3 = this._map;
            return t3 && (e3 ? (t3.on("mousedown", this._addDragHandler), t3.on("touchstart", this._addDragHandler)) : (t3.off("mousedown", this._addDragHandler), t3.off("touchstart", this._addDragHandler))), this;
          }
          isDraggable() {
            return this._draggable;
          }
          setRotation(e3) {
            return this._rotation = e3 || 0, this._update(), this;
          }
          getRotation() {
            return this._rotation;
          }
          setRotationAlignment(e3) {
            return this._rotationAlignment = e3 || "auto", this._update(), this;
          }
          getRotationAlignment() {
            return "auto" === this._rotationAlignment || "horizon" === this._rotationAlignment && this._map && !this._map._showingGlobe() ? "viewport" : this._rotationAlignment;
          }
          setPitchAlignment(e3) {
            return this._pitchAlignment = e3 || "auto", this._update(), this;
          }
          getPitchAlignment() {
            return "auto" === this._pitchAlignment ? this.getRotationAlignment() : this._pitchAlignment;
          }
          setOccludedOpacity(e3) {
            return this._occludedOpacity = e3 || 0.2, this._update(), this;
          }
          getOccludedOpacity() {
            return this._occludedOpacity;
          }
        }
        const tn = { closeButton: true, closeOnClick: true, focusAfterOpen: true, className: "", maxWidth: "240px" }, on = ["a[href]", "[tabindex]:not([tabindex='-1'])", "[contenteditable]:not([contenteditable='false'])", "button:not([disabled])", "input:not([disabled])", "select:not([disabled])", "textarea:not([disabled])"].join(", ");
        function rn(t3 = new e2.Point(0, 0), i3 = "bottom") {
          if ("number" == typeof t3) {
            const o3 = Math.round(Math.sqrt(0.5 * Math.pow(t3, 2)));
            switch (i3) {
              case "top":
                return new e2.Point(0, t3);
              case "top-left":
                return new e2.Point(o3, o3);
              case "top-right":
                return new e2.Point(-o3, o3);
              case "bottom":
                return new e2.Point(0, -t3);
              case "bottom-left":
                return new e2.Point(o3, -o3);
              case "bottom-right":
                return new e2.Point(-o3, -o3);
              case "left":
                return new e2.Point(t3, 0);
              case "right":
                return new e2.Point(-t3, 0);
            }
            return new e2.Point(0, 0);
          }
          return t3 instanceof e2.Point || Array.isArray(t3) ? e2.Point.convert(t3) : e2.Point.convert(t3[i3] || [0, 0]);
        }
        class nn {
          constructor(e3) {
            this.jumpTo(e3);
          }
          getValue(t3) {
            if (t3 <= this._startTime)
              return this._start;
            if (t3 >= this._endTime)
              return this._end;
            const i3 = e2.easeCubicInOut((t3 - this._startTime) / (this._endTime - this._startTime));
            return this._start * (1 - i3) + this._end * i3;
          }
          isEasing(e3) {
            return e3 >= this._startTime && e3 <= this._endTime;
          }
          jumpTo(e3) {
            this._startTime = -1 / 0, this._endTime = -1 / 0, this._start = e3, this._end = e3;
          }
          easeTo(e3, t3, i3) {
            this._start = this.getValue(t3), this._end = e3, this._startTime = t3, this._endTime = t3 + i3;
          }
        }
        const sn = { "AttributionControl.ToggleAttribution": "Toggle attribution", "AttributionControl.MapFeedback": "Map feedback", "FullscreenControl.Enter": "Enter fullscreen", "FullscreenControl.Exit": "Exit fullscreen", "GeolocateControl.FindMyLocation": "Find my location", "GeolocateControl.LocationNotAvailable": "Location not available", "LogoControl.Title": "Mapbox logo", "Map.Title": "Map", "NavigationControl.ResetBearing": "Reset bearing to north", "NavigationControl.ZoomIn": "Zoom in", "NavigationControl.ZoomOut": "Zoom out", "ScrollZoomBlocker.CtrlMessage": "Use ctrl + scroll to zoom the map", "ScrollZoomBlocker.CmdMessage": "Use \u2318 + scroll to zoom the map", "TouchPanBlocker.Message": "Use two fingers to move the map" }, an = { center: [0, 0], zoom: 0, bearing: 0, pitch: 0, minZoom: -2, maxZoom: 22, minPitch: 0, maxPitch: 85, interactive: true, scrollZoom: true, boxZoom: true, dragRotate: true, dragPan: true, keyboard: true, doubleClickZoom: true, touchZoomRotate: true, touchPitch: true, cooperativeGestures: false, performanceMetricsCollection: true, bearingSnap: 7, clickTolerance: 3, pitchWithRotate: true, hash: false, attributionControl: true, failIfMajorPerformanceCaveat: false, preserveDrawingBuffer: false, trackResize: true, optimizeForTerrain: true, renderWorldCopies: true, refreshExpiredTiles: true, minTileCacheSize: null, maxTileCacheSize: null, localIdeographFontFamily: "sans-serif", localFontFamily: null, transformRequest: null, accessToken: null, fadeDuration: 300, respectPrefersReducedMotion: true, crossSourceCollisions: true }, ln = { showCompass: true, showZoom: true, visualizePitch: false };
        class cn {
          constructor(t3, i3, o3 = false) {
            this._clickTolerance = 10, this.element = i3, this.mouseRotate = new yr({ clickTolerance: t3.dragRotate._mouseRotate._clickTolerance }), this.map = t3, o3 && (this.mousePitch = new br({ clickTolerance: t3.dragRotate._mousePitch._clickTolerance })), e2.bindAll(["mousedown", "mousemove", "mouseup", "touchstart", "touchmove", "touchend", "reset"], this), i3.addEventListener("mousedown", this.mousedown), i3.addEventListener("touchstart", this.touchstart, { passive: false }), i3.addEventListener("touchmove", this.touchmove), i3.addEventListener("touchend", this.touchend), i3.addEventListener("touchcancel", this.reset);
          }
          down(e3, t3) {
            this.mouseRotate.mousedown(e3, t3), this.mousePitch && this.mousePitch.mousedown(e3, t3), h2();
          }
          move(e3, t3) {
            const i3 = this.map, o3 = this.mouseRotate.mousemoveWindow(e3, t3), r3 = o3 && o3.bearingDelta;
            if (r3 && i3.setBearing(i3.getBearing() + r3), this.mousePitch) {
              const o4 = this.mousePitch.mousemoveWindow(e3, t3), r4 = o4 && o4.pitchDelta;
              r4 && i3.setPitch(i3.getPitch() + r4);
            }
          }
          off() {
            const e3 = this.element;
            e3.removeEventListener("mousedown", this.mousedown), e3.removeEventListener("touchstart", this.touchstart, { passive: false }), e3.removeEventListener("touchmove", this.touchmove), e3.removeEventListener("touchend", this.touchend), e3.removeEventListener("touchcancel", this.reset), this.offTemp();
          }
          offTemp() {
            u2(), e2.window.removeEventListener("mousemove", this.mousemove), e2.window.removeEventListener("mouseup", this.mouseup);
          }
          mousedown(t3) {
            this.down(e2.extend({}, t3, { ctrlKey: true, preventDefault: () => t3.preventDefault() }), p2(this.element, t3)), e2.window.addEventListener("mousemove", this.mousemove), e2.window.addEventListener("mouseup", this.mouseup);
          }
          mousemove(e3) {
            this.move(e3, p2(this.element, e3));
          }
          mouseup(e3) {
            this.mouseRotate.mouseupWindow(e3), this.mousePitch && this.mousePitch.mouseupWindow(e3), this.offTemp();
          }
          touchstart(e3) {
            1 !== e3.targetTouches.length ? this.reset() : (this._startPos = this._lastPos = m2(this.element, e3.targetTouches)[0], this.down({ type: "mousedown", button: 0, ctrlKey: true, preventDefault: () => e3.preventDefault() }, this._startPos));
          }
          touchmove(e3) {
            1 !== e3.targetTouches.length ? this.reset() : (this._lastPos = m2(this.element, e3.targetTouches)[0], this.move({ preventDefault: () => e3.preventDefault() }, this._lastPos));
          }
          touchend(e3) {
            0 === e3.targetTouches.length && this._startPos && this._lastPos && this._startPos.dist(this._lastPos) < this._clickTolerance && this.element.click(), this.reset();
          }
          reset() {
            this.mouseRotate.reset(), this.mousePitch && this.mousePitch.reset(), delete this._startPos, delete this._lastPos, this.offTemp();
          }
        }
        const hn = { positionOptions: { enableHighAccuracy: false, maximumAge: 0, timeout: 6e3 }, fitBoundsOptions: { maxZoom: 15 }, trackUserLocation: false, showAccuracyCircle: true, showUserLocation: true, showUserHeading: false }, un = { maxWidth: 100, unit: "metric" }, _n = { kilometer: "km", meter: "m", mile: "mi", foot: "ft", "nautical-mile": "nm" }, dn = { version: e2.version, supported: i2, setRTLTextPlugin: e2.setRTLTextPlugin, getRTLTextPluginStatus: e2.getRTLTextPluginStatus, Map: class extends $r {
          constructor(t3) {
            if (e2.LivePerformanceUtils.mark(e2.PerformanceMarkers.create), null != (t3 = e2.extend({}, an, t3)).minZoom && null != t3.maxZoom && t3.minZoom > t3.maxZoom)
              throw new Error("maxZoom must be greater than or equal to minZoom");
            if (null != t3.minPitch && null != t3.maxPitch && t3.minPitch > t3.maxPitch)
              throw new Error("maxPitch must be greater than or equal to minPitch");
            if (null != t3.minPitch && t3.minPitch < 0)
              throw new Error("minPitch must be greater than or equal to 0");
            if (null != t3.maxPitch && t3.maxPitch > 85)
              throw new Error("maxPitch must be less than or equal to 85");
            if (t3.antialias && e2.isSafariWithAntialiasingBug(e2.window) && (t3.antialias = false, e2.warnOnce("Antialiasing is disabled for this WebGL context to avoid browser bug: https://github.com/mapbox/mapbox-gl-js/issues/11609")), super(new Ho(t3.minZoom, t3.maxZoom, t3.minPitch, t3.maxPitch, t3.renderWorldCopies), t3), this._interactive = t3.interactive, this._minTileCacheSize = t3.minTileCacheSize, this._maxTileCacheSize = t3.maxTileCacheSize, this._failIfMajorPerformanceCaveat = t3.failIfMajorPerformanceCaveat, this._preserveDrawingBuffer = t3.preserveDrawingBuffer, this._antialias = t3.antialias, this._useWebGL2 = t3.useWebGL2, this._trackResize = t3.trackResize, this._bearingSnap = t3.bearingSnap, this._refreshExpiredTiles = t3.refreshExpiredTiles, this._fadeDuration = t3.fadeDuration, this._isInitialLoad = true, this._crossSourceCollisions = t3.crossSourceCollisions, this._collectResourceTiming = t3.collectResourceTiming, this._optimizeForTerrain = t3.optimizeForTerrain, this._language = this._parseLanguage(t3.language), this._worldview = t3.worldview, this._renderTaskQueue = new Kr(), this._domRenderTaskQueue = new Kr(), this._controls = [], this._markers = [], this._popups = [], this._mapId = e2.uniqueId(), this._locale = e2.extend({}, sn, t3.locale), this._clickTolerance = t3.clickTolerance, this._cooperativeGestures = t3.cooperativeGestures, this._performanceMetricsCollection = t3.performanceMetricsCollection, this._containerWidth = 0, this._containerHeight = 0, this._averageElevationLastSampledAt = -1 / 0, this._averageElevationExaggeration = 0, this._averageElevation = new nn(0), this._interactionRange = [1 / 0, -1 / 0], this._visibilityHidden = 0, this._useExplicitProjection = false, this._requestManager = new e2.RequestManager(t3.transformRequest, t3.accessToken, t3.testMode), this._silenceAuthErrors = !!t3.testMode, "string" == typeof t3.container) {
              if (this._container = e2.window.document.getElementById(t3.container), !this._container)
                throw new Error(`Container '${t3.container}' not found.`);
            } else {
              if (!(t3.container instanceof e2.window.HTMLElement))
                throw new Error("Invalid type: 'container' must be a String or HTMLElement.");
              this._container = t3.container;
            }
            if (this._container.childNodes.length > 0 && e2.warnOnce("The map container element should be empty, otherwise the map's interactivity will be negatively impacted. If you want to display a message when WebGL is not supported, use the Mapbox GL Supported plugin instead."), t3.maxBounds && this.setMaxBounds(t3.maxBounds), e2.bindAll(["_onWindowOnline", "_onWindowResize", "_onVisibilityChange", "_onMapScroll", "_contextLost", "_contextRestored"], this), this._setupContainer(), this._setupPainter(), void 0 === this.painter)
              throw new Error("Failed to initialize WebGL.");
            this.on("move", () => this._update(false)), this.on("moveend", () => this._update(false)), this.on("zoom", () => this._update(true)), void 0 !== e2.window && (e2.window.addEventListener("online", this._onWindowOnline, false), e2.window.addEventListener("resize", this._onWindowResize, false), e2.window.addEventListener("orientationchange", this._onWindowResize, false), e2.window.addEventListener("webkitfullscreenchange", this._onWindowResize, false), e2.window.addEventListener("visibilitychange", this._onVisibilityChange, false)), this.handlers = new Xr(this, t3), this._localFontFamily = t3.localFontFamily, this._localIdeographFontFamily = t3.localIdeographFontFamily, t3.style && this.setStyle(t3.style, { localFontFamily: this._localFontFamily, localIdeographFontFamily: this._localIdeographFontFamily }), t3.projection && this.setProjection(t3.projection), this._hash = t3.hash && new Ko("string" == typeof t3.hash && t3.hash || void 0).addTo(this), this._hash && this._hash._onHashChange() || (this.jumpTo({ center: t3.center, zoom: t3.zoom, bearing: t3.bearing, pitch: t3.pitch }), t3.bounds && (this.resize(), this.fitBounds(t3.bounds, e2.extend({}, t3.fitBoundsOptions, { duration: 0 })))), this.resize(), t3.attributionControl && this.addControl(new Hr({ customAttribution: t3.customAttribution })), this._logoControl = new Yr(), this.addControl(this._logoControl, t3.logoPosition), this.on("style.load", () => {
              this.transform.unmodified && this.jumpTo(this.style.stylesheet);
            }), this.on("data", (t4) => {
              this._update("style" === t4.dataType), this.fire(new e2.Event(`${t4.dataType}data`, t4));
            }), this.on("dataloading", (t4) => {
              this.fire(new e2.Event(`${t4.dataType}dataloading`, t4));
            });
          }
          _getMapId() {
            return this._mapId;
          }
          addControl(t3, i3) {
            if (void 0 === i3 && (i3 = t3.getDefaultPosition ? t3.getDefaultPosition() : "top-right"), !t3 || !t3.onAdd)
              return this.fire(new e2.ErrorEvent(new Error("Invalid argument to map.addControl(). Argument must be a control with onAdd and onRemove methods.")));
            const o3 = t3.onAdd(this);
            this._controls.push(t3);
            const r3 = this._controlPositions[i3];
            return -1 !== i3.indexOf("bottom") ? r3.insertBefore(o3, r3.firstChild) : r3.appendChild(o3), this;
          }
          removeControl(t3) {
            if (!t3 || !t3.onRemove)
              return this.fire(new e2.ErrorEvent(new Error("Invalid argument to map.removeControl(). Argument must be a control with onAdd and onRemove methods.")));
            const i3 = this._controls.indexOf(t3);
            return i3 > -1 && this._controls.splice(i3, 1), t3.onRemove(this), this;
          }
          hasControl(e3) {
            return this._controls.indexOf(e3) > -1;
          }
          getContainer() {
            return this._container;
          }
          getCanvasContainer() {
            return this._canvasContainer;
          }
          getCanvas() {
            return this._canvas;
          }
          resize(t3) {
            if (this._updateContainerDimensions(), this._containerWidth === this.transform.width && this._containerHeight === this.transform.height)
              return this;
            this._resizeCanvas(this._containerWidth, this._containerHeight), this.transform.resize(this._containerWidth, this._containerHeight), this.painter.resize(Math.ceil(this._containerWidth), Math.ceil(this._containerHeight));
            const i3 = !this._moving;
            return i3 && this.fire(new e2.Event("movestart", t3)).fire(new e2.Event("move", t3)), this.fire(new e2.Event("resize", t3)), i3 && this.fire(new e2.Event("moveend", t3)), this;
          }
          getBounds() {
            return this.transform.getBounds();
          }
          getMaxBounds() {
            return this.transform.getMaxBounds() || null;
          }
          setMaxBounds(t3) {
            return this.transform.setMaxBounds(e2.LngLatBounds.convert(t3)), this._update();
          }
          setMinZoom(t3) {
            if ((t3 = null == t3 ? -2 : t3) >= -2 && t3 <= this.transform.maxZoom)
              return this.transform.minZoom = t3, this._update(), this.getZoom() < t3 ? this.setZoom(t3) : this.fire(new e2.Event("zoomstart")).fire(new e2.Event("zoom")).fire(new e2.Event("zoomend")), this;
            throw new Error("minZoom must be between -2 and the current maxZoom, inclusive");
          }
          getMinZoom() {
            return this.transform.minZoom;
          }
          setMaxZoom(t3) {
            if ((t3 = null == t3 ? 22 : t3) >= this.transform.minZoom)
              return this.transform.maxZoom = t3, this._update(), this.getZoom() > t3 ? this.setZoom(t3) : this.fire(new e2.Event("zoomstart")).fire(new e2.Event("zoom")).fire(new e2.Event("zoomend")), this;
            throw new Error("maxZoom must be greater than the current minZoom");
          }
          getMaxZoom() {
            return this.transform.maxZoom;
          }
          setMinPitch(t3) {
            if ((t3 = null == t3 ? 0 : t3) < 0)
              throw new Error("minPitch must be greater than or equal to 0");
            if (t3 >= 0 && t3 <= this.transform.maxPitch)
              return this.transform.minPitch = t3, this._update(), this.getPitch() < t3 ? this.setPitch(t3) : this.fire(new e2.Event("pitchstart")).fire(new e2.Event("pitch")).fire(new e2.Event("pitchend")), this;
            throw new Error("minPitch must be between 0 and the current maxPitch, inclusive");
          }
          getMinPitch() {
            return this.transform.minPitch;
          }
          setMaxPitch(t3) {
            if ((t3 = null == t3 ? 85 : t3) > 85)
              throw new Error("maxPitch must be less than or equal to 85");
            if (t3 >= this.transform.minPitch)
              return this.transform.maxPitch = t3, this._update(), this.getPitch() > t3 ? this.setPitch(t3) : this.fire(new e2.Event("pitchstart")).fire(new e2.Event("pitch")).fire(new e2.Event("pitchend")), this;
            throw new Error("maxPitch must be greater than or equal to minPitch");
          }
          getMaxPitch() {
            return this.transform.maxPitch;
          }
          getRenderWorldCopies() {
            return this.transform.renderWorldCopies;
          }
          setRenderWorldCopies(e3) {
            return this.transform.renderWorldCopies = e3, this.transform.renderWorldCopies || this._forceMarkerAndPopupUpdate(true), this._update();
          }
          getLanguage() {
            return this._language;
          }
          _parseLanguage(t3) {
            return "auto" === t3 ? e2.window.navigator.language : Array.isArray(t3) ? 0 === t3.length ? void 0 : t3.map((t4) => "auto" === t4 ? e2.window.navigator.language : t4) : t3;
          }
          setLanguage(e3) {
            const t3 = this._parseLanguage(e3);
            if (!this.style || t3 === this._language)
              return this;
            this._language = t3, this.style._reloadSources();
            for (const e4 of this._controls)
              e4._setLanguage && e4._setLanguage(this._language);
            return this;
          }
          getWorldview() {
            return this._worldview;
          }
          setWorldview(e3) {
            return this.style && e3 !== this._worldview ? (this._worldview = e3, this.style._reloadSources(), this) : this;
          }
          getProjection() {
            return this.transform.mercatorFromTransition ? { name: "globe", center: [0, 0] } : this.transform.getProjection();
          }
          _showingGlobe() {
            return "globe" === this.transform.projection.name;
          }
          setProjection(e3) {
            return this._lazyInitEmptyStyle(), e3 ? "string" == typeof e3 && (e3 = { name: e3 }) : e3 = null, this._useExplicitProjection = !!e3, this._prioritizeAndUpdateProjection(e3, this.style.stylesheet ? this.style.stylesheet.projection : null);
          }
          _updateProjectionTransition() {
            if ("globe" !== this.getProjection().name)
              return;
            const t3 = this.transform, i3 = t3.projection.name;
            let o3;
            "globe" === i3 && t3.zoom >= e2.GLOBE_ZOOM_THRESHOLD_MAX ? (t3.setMercatorFromTransition(), o3 = true) : "mercator" === i3 && t3.zoom < e2.GLOBE_ZOOM_THRESHOLD_MAX && (t3.setProjection({ name: "globe" }), o3 = true), o3 && (this.style.applyProjectionUpdate(), this.style._forceSymbolLayerUpdate());
          }
          _prioritizeAndUpdateProjection(e3, t3) {
            return this._updateProjection(e3 || t3 || { name: "mercator" });
          }
          _updateProjection(t3) {
            let i3;
            if (i3 = "globe" === t3.name && this.transform.zoom >= e2.GLOBE_ZOOM_THRESHOLD_MAX ? this.transform.setMercatorFromTransition() : this.transform.setProjection(t3), this.style.applyProjectionUpdate(), i3) {
              this.painter.clearBackgroundTiles();
              for (const e3 in this.style._sourceCaches)
                this.style._sourceCaches[e3].clearTiles();
              this._update(true), this._forceMarkerAndPopupUpdate(true);
            }
            return this;
          }
          project(t3) {
            return this.transform.locationPoint3D(e2.LngLat.convert(t3));
          }
          unproject(t3) {
            return this.transform.pointLocation3D(e2.Point.convert(t3));
          }
          isMoving() {
            return this._moving || this.handlers && this.handlers.isMoving() || false;
          }
          isZooming() {
            return this._zooming || this.handlers && this.handlers.isZooming() || false;
          }
          isRotating() {
            return this._rotating || this.handlers && this.handlers.isRotating() || false;
          }
          _isDragging() {
            return this.handlers && this.handlers._isDragging() || false;
          }
          _createDelegatedListener(e3, t3, i3) {
            if ("mouseenter" === e3 || "mouseover" === e3) {
              let o3 = false;
              const r3 = (r4) => {
                const n4 = t3.filter((e4) => this.getLayer(e4)), s3 = n4.length ? this.queryRenderedFeatures(r4.point, { layers: n4 }) : [];
                s3.length ? o3 || (o3 = true, i3.call(this, new ar(e3, this, r4.originalEvent, { features: s3 }))) : o3 = false;
              }, n3 = () => {
                o3 = false;
              };
              return { layers: new Set(t3), listener: i3, delegates: { mousemove: r3, mouseout: n3 } };
            }
            if ("mouseleave" === e3 || "mouseout" === e3) {
              let o3 = false;
              const r3 = (r4) => {
                const n4 = t3.filter((e4) => this.getLayer(e4));
                (n4.length ? this.queryRenderedFeatures(r4.point, { layers: n4 }) : []).length ? o3 = true : o3 && (o3 = false, i3.call(this, new ar(e3, this, r4.originalEvent)));
              }, n3 = (t4) => {
                o3 && (o3 = false, i3.call(this, new ar(e3, this, t4.originalEvent)));
              };
              return { layers: new Set(t3), listener: i3, delegates: { mousemove: r3, mouseout: n3 } };
            }
            {
              const o3 = (e4) => {
                const o4 = t3.filter((e5) => this.getLayer(e5)), r3 = o4.length ? this.queryRenderedFeatures(e4.point, { layers: o4 }) : [];
                r3.length && (e4.features = r3, i3.call(this, e4), delete e4.features);
              };
              return { layers: new Set(t3), listener: i3, delegates: { [e3]: o3 } };
            }
          }
          on(e3, t3, i3) {
            if (void 0 === i3)
              return super.on(e3, t3);
            Array.isArray(t3) || (t3 = [t3]);
            const o3 = this._createDelegatedListener(e3, t3, i3);
            this._delegatedListeners = this._delegatedListeners || {}, this._delegatedListeners[e3] = this._delegatedListeners[e3] || [], this._delegatedListeners[e3].push(o3);
            for (const e4 in o3.delegates)
              this.on(e4, o3.delegates[e4]);
            return this;
          }
          once(e3, t3, i3) {
            if (void 0 === i3)
              return super.once(e3, t3);
            Array.isArray(t3) || (t3 = [t3]);
            const o3 = this._createDelegatedListener(e3, t3, i3);
            for (const e4 in o3.delegates)
              this.once(e4, o3.delegates[e4]);
            return this;
          }
          off(e3, t3, i3) {
            if (void 0 === i3)
              return super.off(e3, t3);
            t3 = new Set(Array.isArray(t3) ? t3 : [t3]);
            const o3 = (e4, t4) => {
              if (e4.size !== t4.size)
                return false;
              for (const i4 of e4)
                if (!t4.has(i4))
                  return false;
              return true;
            }, r3 = this._delegatedListeners ? this._delegatedListeners[e3] : void 0;
            return r3 && ((e4) => {
              for (let r4 = 0; r4 < e4.length; r4++) {
                const n3 = e4[r4];
                if (n3.listener === i3 && o3(n3.layers, t3)) {
                  for (const e5 in n3.delegates)
                    this.off(e5, n3.delegates[e5]);
                  return e4.splice(r4, 1), this;
                }
              }
            })(r3), this;
          }
          queryRenderedFeatures(t3, i3) {
            return this.style ? (void 0 !== i3 || void 0 === t3 || t3 instanceof e2.Point || Array.isArray(t3) || (i3 = t3, t3 = void 0), this.style.queryRenderedFeatures(t3 = t3 || [[0, 0], [this.transform.width, this.transform.height]], i3 = i3 || {}, this.transform)) : [];
          }
          querySourceFeatures(e3, t3) {
            return this.style.querySourceFeatures(e3, t3);
          }
          isPointOnSurface(t3) {
            const { name: i3 } = this.transform.projection;
            return "globe" !== i3 && "mercator" !== i3 && e2.warnOnce(`${i3} projection does not support isPointOnSurface, this API may behave unexpectedly.`), this.transform.isPointOnSurface(e2.Point.convert(t3));
          }
          setStyle(t3, i3) {
            return false !== (i3 = e2.extend({}, { localIdeographFontFamily: this._localIdeographFontFamily, localFontFamily: this._localFontFamily }, i3)).diff && i3.localIdeographFontFamily === this._localIdeographFontFamily && i3.localFontFamily === this._localFontFamily && this.style && t3 ? (this._diffStyle(t3, i3), this) : (this._localIdeographFontFamily = i3.localIdeographFontFamily, this._localFontFamily = i3.localFontFamily, this._updateStyle(t3, i3));
          }
          _getUIString(e3) {
            const t3 = this._locale[e3];
            if (null == t3)
              throw new Error(`Missing UI string '${e3}'`);
            return t3;
          }
          _updateStyle(e3, t3) {
            return this.style && (this.style.setEventedParent(null), this.style._remove(), this.style = void 0), e3 && (this.style = new Kt(this, t3 || {}), this.style.setEventedParent(this, { style: this.style }), "string" == typeof e3 ? this.style.loadURL(e3) : this.style.loadJSON(e3)), this._updateTerrain(), this;
          }
          _lazyInitEmptyStyle() {
            this.style || (this.style = new Kt(this, {}), this.style.setEventedParent(this, { style: this.style }), this.style.loadEmpty());
          }
          _diffStyle(t3, i3) {
            if ("string" == typeof t3) {
              const o3 = this._requestManager.normalizeStyleURL(t3), r3 = this._requestManager.transformRequest(o3, e2.ResourceType.Style);
              e2.getJSON(r3, (t4, o4) => {
                t4 ? this.fire(new e2.ErrorEvent(t4)) : o4 && this._updateDiff(o4, i3);
              });
            } else
              "object" == typeof t3 && this._updateDiff(t3, i3);
          }
          _updateDiff(t3, i3) {
            try {
              this.style.setState(t3) && this._update(true);
            } catch (o3) {
              e2.warnOnce(`Unable to perform style diff: ${o3.message || o3.error || o3}.  Rebuilding the style from scratch.`), this._updateStyle(t3, i3);
            }
          }
          getStyle() {
            if (this.style)
              return this.style.serialize();
          }
          isStyleLoaded() {
            return this.style ? this.style.loaded() : (e2.warnOnce("There is no style added to the map."), false);
          }
          addSource(e3, t3) {
            return this._lazyInitEmptyStyle(), this.style.addSource(e3, t3), this._update(true);
          }
          isSourceLoaded(e3) {
            return !!this.style && this.style._isSourceCacheLoaded(e3);
          }
          areTilesLoaded() {
            const e3 = this.style && this.style._sourceCaches;
            for (const t3 in e3) {
              const i3 = e3[t3]._tiles;
              for (const e4 in i3) {
                const t4 = i3[e4];
                if ("loaded" !== t4.state && "errored" !== t4.state)
                  return false;
              }
            }
            return true;
          }
          addSourceType(e3, t3, i3) {
            this._lazyInitEmptyStyle(), this.style.addSourceType(e3, t3, i3);
          }
          removeSource(e3) {
            return this.style.removeSource(e3), this._updateTerrain(), this._update(true);
          }
          getSource(e3) {
            return this.style.getSource(e3);
          }
          addImage(t3, i3, { pixelRatio: o3 = 1, sdf: r3 = false, stretchX: n3, stretchY: s3, content: a3 } = {}) {
            if (this._lazyInitEmptyStyle(), i3 instanceof e2.window.HTMLImageElement || e2.window.ImageBitmap && i3 instanceof e2.window.ImageBitmap) {
              const { width: l2, height: c3, data: h3 } = e2.exported.getImageData(i3);
              this.style.addImage(t3, { data: new e2.RGBAImage({ width: l2, height: c3 }, h3), pixelRatio: o3, stretchX: n3, stretchY: s3, content: a3, sdf: r3, version: 0 });
            } else if (void 0 === i3.width || void 0 === i3.height)
              this.fire(new e2.ErrorEvent(new Error("Invalid arguments to map.addImage(). The second argument must be an `HTMLImageElement`, `ImageData`, `ImageBitmap`, or object with `width`, `height`, and `data` properties with the same format as `ImageData`")));
            else {
              const { width: l2, height: c3 } = i3, h3 = i3;
              this.style.addImage(t3, { data: new e2.RGBAImage({ width: l2, height: c3 }, new Uint8Array(h3.data)), pixelRatio: o3, stretchX: n3, stretchY: s3, content: a3, sdf: r3, version: 0, userImage: h3 }), h3.onAdd && h3.onAdd(this, t3);
            }
          }
          updateImage(t3, i3) {
            const o3 = this.style.getImage(t3);
            if (!o3)
              return void this.fire(new e2.ErrorEvent(new Error("The map has no image with that id. If you are adding a new image use `map.addImage(...)` instead.")));
            const r3 = i3 instanceof e2.window.HTMLImageElement || e2.window.ImageBitmap && i3 instanceof e2.window.ImageBitmap ? e2.exported.getImageData(i3) : i3, { width: n3, height: s3 } = r3;
            void 0 !== n3 && void 0 !== s3 ? n3 === o3.data.width && s3 === o3.data.height ? (o3.data.replace(r3.data, !(i3 instanceof e2.window.HTMLImageElement || e2.window.ImageBitmap && i3 instanceof e2.window.ImageBitmap)), this.style.updateImage(t3, o3)) : this.fire(new e2.ErrorEvent(new Error(`The width and height of the updated image (${n3}, ${s3})
                must be that same as the previous version of the image
                (${o3.data.width}, ${o3.data.height})`))) : this.fire(new e2.ErrorEvent(new Error("Invalid arguments to map.updateImage(). The second argument must be an `HTMLImageElement`, `ImageData`, `ImageBitmap`, or object with `width`, `height`, and `data` properties with the same format as `ImageData`")));
          }
          hasImage(t3) {
            return t3 ? !!this.style.getImage(t3) : (this.fire(new e2.ErrorEvent(new Error("Missing required image id"))), false);
          }
          removeImage(e3) {
            this.style.removeImage(e3);
          }
          loadImage(t3, i3) {
            e2.getImage(this._requestManager.transformRequest(t3, e2.ResourceType.Image), (t4, o3) => {
              i3(t4, o3 instanceof e2.window.HTMLImageElement ? e2.exported.getImageData(o3) : o3);
            });
          }
          listImages() {
            return this.style.listImages();
          }
          addLayer(e3, t3) {
            return this._lazyInitEmptyStyle(), this.style.addLayer(e3, t3), this._update(true);
          }
          moveLayer(e3, t3) {
            return this.style.moveLayer(e3, t3), this._update(true);
          }
          removeLayer(e3) {
            return this.style.removeLayer(e3), this._update(true);
          }
          getLayer(e3) {
            return this.style.getLayer(e3);
          }
          setLayerZoomRange(e3, t3, i3) {
            return this.style.setLayerZoomRange(e3, t3, i3), this._update(true);
          }
          setFilter(e3, t3, i3 = {}) {
            return this.style.setFilter(e3, t3, i3), this._update(true);
          }
          getFilter(e3) {
            return this.style.getFilter(e3);
          }
          setPaintProperty(e3, t3, i3, o3 = {}) {
            return this.style.setPaintProperty(e3, t3, i3, o3), this._update(true);
          }
          getPaintProperty(e3, t3) {
            return this.style.getPaintProperty(e3, t3);
          }
          setLayoutProperty(e3, t3, i3, o3 = {}) {
            return this.style.setLayoutProperty(e3, t3, i3, o3), this._update(true);
          }
          getLayoutProperty(e3, t3) {
            return this.style.getLayoutProperty(e3, t3);
          }
          setLight(e3, t3 = {}) {
            return this._lazyInitEmptyStyle(), this.style.setLight(e3, t3), this._update(true);
          }
          getLight() {
            return this.style.getLight();
          }
          setTerrain(e3) {
            return this._lazyInitEmptyStyle(), !e3 && this.transform.projection.requiresDraping ? this.style.setTerrainForDraping() : this.style.setTerrain(e3), this._averageElevationLastSampledAt = -1 / 0, this._update(true);
          }
          getTerrain() {
            return this.style ? this.style.getTerrain() : null;
          }
          setFog(e3) {
            return this._lazyInitEmptyStyle(), this.style.setFog(e3), this._update(true);
          }
          getFog() {
            return this.style ? this.style.getFog() : null;
          }
          _queryFogOpacity(t3) {
            return this.style && this.style.fog ? this.style.fog.getOpacityAtLatLng(e2.LngLat.convert(t3), this.transform) : 0;
          }
          setFeatureState(e3, t3) {
            return this.style.setFeatureState(e3, t3), this._update();
          }
          removeFeatureState(e3, t3) {
            return this.style.removeFeatureState(e3, t3), this._update();
          }
          getFeatureState(e3) {
            return this.style.getFeatureState(e3);
          }
          _updateContainerDimensions() {
            if (!this._container)
              return;
            const t3 = this._container.getBoundingClientRect().width || 400, i3 = this._container.getBoundingClientRect().height || 300;
            let o3, r3, n3, s3 = this._container;
            for (; s3 && (!r3 || !n3); ) {
              const t4 = e2.window.getComputedStyle(s3).transform;
              t4 && "none" !== t4 && (o3 = t4.match(/matrix.*\((.+)\)/)[1].split(", "), o3[0] && "0" !== o3[0] && "1" !== o3[0] && (r3 = o3[0]), o3[3] && "0" !== o3[3] && "1" !== o3[3] && (n3 = o3[3])), s3 = s3.parentElement;
            }
            this._containerWidth = r3 ? Math.abs(t3 / r3) : t3, this._containerHeight = n3 ? Math.abs(i3 / n3) : i3;
          }
          _detectMissingCSS() {
            "rgb(250, 128, 114)" !== e2.window.getComputedStyle(this._missingCSSCanary).getPropertyValue("background-color") && e2.warnOnce("This page appears to be missing CSS declarations for Mapbox GL JS, which may cause the map to display incorrectly. Please ensure your page includes mapbox-gl.css, as described in https://www.mapbox.com/mapbox-gl-js/api/.");
          }
          _setupContainer() {
            const e3 = this._container;
            e3.classList.add("mapboxgl-map"), (this._missingCSSCanary = n2("div", "mapboxgl-canary", e3)).style.visibility = "hidden", this._detectMissingCSS();
            const t3 = this._canvasContainer = n2("div", "mapboxgl-canvas-container", e3);
            this._interactive && t3.classList.add("mapboxgl-interactive"), this._canvas = n2("canvas", "mapboxgl-canvas", t3), this._canvas.addEventListener("webglcontextlost", this._contextLost, false), this._canvas.addEventListener("webglcontextrestored", this._contextRestored, false), this._canvas.setAttribute("tabindex", "0"), this._canvas.setAttribute("aria-label", this._getUIString("Map.Title")), this._canvas.setAttribute("role", "region"), this._updateContainerDimensions(), this._resizeCanvas(this._containerWidth, this._containerHeight);
            const i3 = this._controlContainer = n2("div", "mapboxgl-control-container", e3), o3 = this._controlPositions = {};
            ["top-left", "top-right", "bottom-left", "bottom-right"].forEach((e4) => {
              o3[e4] = n2("div", `mapboxgl-ctrl-${e4}`, i3);
            }), this._container.addEventListener("scroll", this._onMapScroll, false);
          }
          _resizeCanvas(t3, i3) {
            const o3 = e2.exported.devicePixelRatio || 1;
            this._canvas.width = o3 * Math.ceil(t3), this._canvas.height = o3 * Math.ceil(i3), this._canvas.style.width = `${t3}px`, this._canvas.style.height = `${i3}px`;
          }
          _addMarker(e3) {
            this._markers.push(e3);
          }
          _removeMarker(e3) {
            const t3 = this._markers.indexOf(e3);
            -1 !== t3 && this._markers.splice(t3, 1);
          }
          _addPopup(e3) {
            this._popups.push(e3);
          }
          _removePopup(e3) {
            const t3 = this._popups.indexOf(e3);
            -1 !== t3 && this._popups.splice(t3, 1);
          }
          _setupPainter() {
            const t3 = e2.extend({}, i2.webGLContextAttributes, { failIfMajorPerformanceCaveat: this._failIfMajorPerformanceCaveat, preserveDrawingBuffer: this._preserveDrawingBuffer, antialias: this._antialias || false }), o3 = this._useWebGL2 && this._canvas.getContext("webgl2", t3), r3 = o3 || this._canvas.getContext("webgl", t3) || this._canvas.getContext("experimental-webgl", t3);
            r3 ? (this._useWebGL2 && !o3 && e2.warnOnce("Failed to create WebGL 2 context. Using WebGL 1."), e2.storeAuthState(r3, true), this.painter = new Bo(r3, this.transform, !!o3), this.on("data", (e3) => {
              "source" === e3.dataType && this.painter.setTileLoadedFlag(true);
            }), e2.exported$1.testSupport(r3)) : this.fire(new e2.ErrorEvent(new Error("Failed to initialize WebGL")));
          }
          _contextLost(t3) {
            t3.preventDefault(), this._frame && (this._frame.cancel(), this._frame = null), this.fire(new e2.Event("webglcontextlost", { originalEvent: t3 }));
          }
          _contextRestored(t3) {
            this._setupPainter(), this.resize(), this._update(), this.fire(new e2.Event("webglcontextrestored", { originalEvent: t3 }));
          }
          _onMapScroll(e3) {
            if (e3.target === this._container)
              return this._container.scrollTop = 0, this._container.scrollLeft = 0, false;
          }
          loaded() {
            return !this._styleDirty && !this._sourcesDirty && !!this.style && this.style.loaded();
          }
          _update(e3) {
            return this.style ? (this._styleDirty = this._styleDirty || e3, this._sourcesDirty = true, this.triggerRepaint(), this) : this;
          }
          _requestRenderFrame(e3) {
            return this._update(), this._renderTaskQueue.add(e3);
          }
          _cancelRenderFrame(e3) {
            this._renderTaskQueue.remove(e3);
          }
          _requestDomTask(e3) {
            !this.loaded() || this.loaded() && !this.isMoving() ? e3() : this._domRenderTaskQueue.add(e3);
          }
          _render(t3) {
            let i3;
            const o3 = this.painter.context.extTimerQuery, r3 = e2.exported.now();
            if (this.listens("gpu-timing-frame") && (i3 = o3.createQueryEXT(), o3.beginQueryEXT(o3.TIME_ELAPSED_EXT, i3)), this.painter.context.setDirty(), this.painter.setBaseState(), (this.isMoving() || this.isRotating() || this.isZooming()) && (this._interactionRange[0] = Math.min(this._interactionRange[0], e2.window.performance.now()), this._interactionRange[1] = Math.max(this._interactionRange[1], e2.window.performance.now())), this._renderTaskQueue.run(t3), this._domRenderTaskQueue.run(t3), this._removed)
              return;
            this._updateProjectionTransition();
            const n3 = this._isInitialLoad ? 0 : this._fadeDuration;
            if (this.style && this._styleDirty) {
              this._styleDirty = false;
              const t4 = this.transform.zoom, i4 = this.transform.pitch, o4 = e2.exported.now(), r4 = new e2.EvaluationParameters(t4, { now: o4, fadeDuration: n3, pitch: i4, transition: this.style.getTransition() });
              this.style.update(r4);
            }
            this.style && this.style.fog && this.style.fog.hasTransition() && (this.style._markersNeedUpdate = true, this._sourcesDirty = true);
            let s3 = false;
            if (this.style && this._sourcesDirty ? (this._sourcesDirty = false, this.painter._updateFog(this.style), this._updateTerrain(), s3 = this._updateAverageElevation(r3), this.style._updateSources(this.transform), this._forceMarkerAndPopupUpdate()) : s3 = this._updateAverageElevation(r3), this._placementDirty = this.style && this.style._updatePlacement(this.painter.transform, this.showCollisionBoxes, n3, this._crossSourceCollisions), this.style && this.painter.render(this.style, { showTileBoundaries: this.showTileBoundaries, showTerrainWireframe: this.showTerrainWireframe, showOverdrawInspector: this._showOverdrawInspector, showQueryGeometry: !!this._showQueryGeometry, showTileAABBs: this.showTileAABBs, rotating: this.isRotating(), zooming: this.isZooming(), moving: this.isMoving(), fadeDuration: n3, isInitialLoad: this._isInitialLoad, showPadding: this.showPadding, gpuTiming: !!this.listens("gpu-timing-layer"), gpuTimingDeferredRender: !!this.listens("gpu-timing-deferred-render"), speedIndexTiming: this.speedIndexTiming }), this.fire(new e2.Event("render")), this.loaded() && !this._loaded && (this._loaded = true, this.fire(new e2.Event("load"))), this.style && this.style.hasTransitions() && (this._styleDirty = true), this.style && !this._placementDirty && this.style._releaseSymbolFadeTiles(), i3) {
              const t4 = e2.exported.now() - r3;
              o3.endQueryEXT(o3.TIME_ELAPSED_EXT, i3), setTimeout(() => {
                const n4 = o3.getQueryObjectEXT(i3, o3.QUERY_RESULT_EXT) / 1e6;
                o3.deleteQueryEXT(i3), this.fire(new e2.Event("gpu-timing-frame", { cpuTime: t4, gpuTime: n4 })), e2.window.performance.mark("frame-gpu", { startTime: r3, detail: { gpuTime: n4 } });
              }, 50);
            }
            if (this.listens("gpu-timing-layer")) {
              const t4 = this.painter.collectGpuTimers();
              setTimeout(() => {
                const i4 = this.painter.queryGpuTimers(t4);
                this.fire(new e2.Event("gpu-timing-layer", { layerTimes: i4 }));
              }, 50);
            }
            if (this.listens("gpu-timing-deferred-render")) {
              const t4 = this.painter.collectDeferredRenderGpuQueries();
              setTimeout(() => {
                const i4 = this.painter.queryGpuTimeDeferredRender(t4);
                this.fire(new e2.Event("gpu-timing-deferred-render", { gpuTime: i4 }));
              }, 50);
            }
            const a3 = this._sourcesDirty || this._styleDirty || this._placementDirty || s3;
            if (a3 || this._repaint)
              this.triggerRepaint();
            else {
              const t4 = !this.isMoving() && this.loaded();
              if (t4 && (s3 = this._updateAverageElevation(r3, true)), s3)
                this.triggerRepaint();
              else if (this._triggerFrame(false), t4 && (this.fire(new e2.Event("idle")), this._isInitialLoad = false, this.speedIndexTiming)) {
                const t5 = this._calculateSpeedIndex();
                this.fire(new e2.Event("speedindexcompleted", { speedIndex: t5 })), this.speedIndexTiming = false;
              }
            }
            !this._loaded || this._fullyLoaded || a3 || (this._fullyLoaded = true, e2.LivePerformanceUtils.mark(e2.PerformanceMarkers.fullLoad), this._performanceMetricsCollection && e2.postPerformanceEvent(this._requestManager._customAccessToken, { width: this.painter.width, height: this.painter.height, interactionRange: this._interactionRange, visibilityHidden: this._visibilityHidden, terrainEnabled: !!this.painter.style.getTerrain(), fogEnabled: !!this.painter.style.getFog(), projection: this.getProjection().name, zoom: this.transform.zoom, renderer: this.painter.context.renderer, vendor: this.painter.context.vendor }), this._authenticate());
          }
          _forceMarkerAndPopupUpdate(e3) {
            for (const t3 of this._markers)
              e3 && !this.getRenderWorldCopies() && (t3._lngLat = t3._lngLat.wrap()), t3._update();
            for (const t3 of this._popups)
              !e3 || this.getRenderWorldCopies() || t3._trackPointer || (t3._lngLat = t3._lngLat.wrap()), t3._update();
          }
          _updateAverageElevation(e3, t3 = false) {
            const i3 = (e4) => (this.transform.averageElevation = e4, this._update(false), true);
            if (!this.painter.averageElevationNeedsEasing())
              return 0 !== this.transform.averageElevation && i3(0);
            if ((t3 || e3 - this._averageElevationLastSampledAt > 500) && !this._averageElevation.isEasing(e3)) {
              const t4 = this.transform.averageElevation;
              let o3 = this.transform.sampleAverageElevation(), r3 = false;
              this.transform.elevation && (r3 = this.transform.elevation.exaggeration() !== this._averageElevationExaggeration, this._averageElevationExaggeration = this.transform.elevation.exaggeration()), isNaN(o3) ? o3 = 0 : this._averageElevationLastSampledAt = e3;
              const n3 = Math.abs(t4 - o3);
              if (n3 > 1) {
                if (this._isInitialLoad || r3)
                  return this._averageElevation.jumpTo(o3), i3(o3);
                this._averageElevation.easeTo(o3, e3, 300);
              } else if (n3 > 1e-4)
                return this._averageElevation.jumpTo(o3), i3(o3);
            }
            return !!this._averageElevation.isEasing(e3) && i3(this._averageElevation.getValue(e3));
          }
          _authenticate() {
            e2.getMapSessionAPI(this._getMapId(), this._requestManager._skuToken, this._requestManager._customAccessToken, (t3) => {
              if (t3 && (t3.message === e2.AUTH_ERR_MSG || 401 === t3.status)) {
                const t4 = this.painter.context.gl;
                e2.storeAuthState(t4, false), this._logoControl instanceof Yr && this._logoControl._updateLogo(), t4 && t4.clear(t4.DEPTH_BUFFER_BIT | t4.COLOR_BUFFER_BIT | t4.STENCIL_BUFFER_BIT), this._silenceAuthErrors || this.fire(new e2.ErrorEvent(new Error("A valid Mapbox access token is required to use Mapbox GL JS. To create an account or a new access token, visit https://account.mapbox.com/")));
              }
            }), e2.postMapLoadEvent(this._getMapId(), this._requestManager._skuToken, this._requestManager._customAccessToken, () => {
            });
          }
          _updateTerrain() {
            const e3 = this._isDragging();
            this.painter.updateTerrain(this.style, e3);
          }
          _calculateSpeedIndex() {
            const e3 = this.painter.canvasCopy(), t3 = this.painter.getCanvasCopiesAndTimestamps();
            t3.timeStamps.push(performance.now());
            const i3 = this.painter.context.gl, o3 = i3.createFramebuffer();
            function r3(e4) {
              i3.framebufferTexture2D(i3.FRAMEBUFFER, i3.COLOR_ATTACHMENT0, i3.TEXTURE_2D, e4, 0);
              const t4 = new Uint8Array(i3.drawingBufferWidth * i3.drawingBufferHeight * 4);
              return i3.readPixels(0, 0, i3.drawingBufferWidth, i3.drawingBufferHeight, i3.RGBA, i3.UNSIGNED_BYTE, t4), t4;
            }
            return i3.bindFramebuffer(i3.FRAMEBUFFER, o3), this._canvasPixelComparison(r3(e3), t3.canvasCopies.map(r3), t3.timeStamps);
          }
          _canvasPixelComparison(e3, t3, i3) {
            let o3 = i3[1] - i3[0];
            const r3 = e3.length / 4;
            for (let n3 = 0; n3 < t3.length; n3++) {
              const s3 = t3[n3];
              let a3 = 0;
              for (let t4 = 0; t4 < s3.length; t4 += 4)
                s3[t4] === e3[t4] && s3[t4 + 1] === e3[t4 + 1] && s3[t4 + 2] === e3[t4 + 2] && s3[t4 + 3] === e3[t4 + 3] && (a3 += 1);
              o3 += (i3[n3 + 2] - i3[n3 + 1]) * (1 - a3 / r3);
            }
            return o3;
          }
          remove() {
            this._hash && this._hash.remove();
            for (const e3 of this._controls)
              e3.onRemove(this);
            this._controls = [], this._frame && (this._frame.cancel(), this._frame = null), this._renderTaskQueue.clear(), this._domRenderTaskQueue.clear(), this.style && this.style.destroy(), this.painter.destroy(), this.handlers && this.handlers.destroy(), this.handlers = void 0, this.setStyle(null), void 0 !== e2.window && (e2.window.removeEventListener("resize", this._onWindowResize, false), e2.window.removeEventListener("orientationchange", this._onWindowResize, false), e2.window.removeEventListener("webkitfullscreenchange", this._onWindowResize, false), e2.window.removeEventListener("online", this._onWindowOnline, false), e2.window.removeEventListener("visibilitychange", this._onVisibilityChange, false));
            const t3 = this.painter.context.gl.getExtension("WEBGL_lose_context");
            t3 && t3.loseContext(), this._canvas.removeEventListener("webglcontextlost", this._contextLost, false), this._canvas.removeEventListener("webglcontextrestored", this._contextRestored, false), this._canvasContainer.remove(), this._controlContainer.remove(), this._missingCSSCanary.remove(), this._canvas = void 0, this._canvasContainer = void 0, this._controlContainer = void 0, this._missingCSSCanary = void 0, this._container.classList.remove("mapboxgl-map"), this._container.removeEventListener("scroll", this._onMapScroll, false), e2.removeAuthState(this.painter.context.gl), this._removed = true, this.fire(new e2.Event("remove"));
          }
          triggerRepaint() {
            this._triggerFrame(true);
          }
          _triggerFrame(t3) {
            this._renderNextFrame = this._renderNextFrame || t3, this.style && !this._frame && (this._frame = e2.exported.frame((e3) => {
              const t4 = !!this._renderNextFrame;
              this._frame = null, this._renderNextFrame = null, t4 && this._render(e3);
            }));
          }
          _preloadTiles(t3) {
            const i3 = this.style ? Object.values(this.style._sourceCaches) : [];
            return e2.asyncAll(i3, (e3, i4) => e3._preloadTiles(t3, i4), () => {
              this.triggerRepaint();
            }), this;
          }
          _onWindowOnline() {
            this._update();
          }
          _onWindowResize(e3) {
            this._trackResize && this.resize({ originalEvent: e3 })._update();
          }
          _onVisibilityChange() {
            "hidden" === e2.window.document.visibilityState && this._visibilityHidden++;
          }
          get showTileBoundaries() {
            return !!this._showTileBoundaries;
          }
          set showTileBoundaries(e3) {
            this._showTileBoundaries !== e3 && (this._showTileBoundaries = e3, this._update());
          }
          get showTerrainWireframe() {
            return !!this._showTerrainWireframe;
          }
          set showTerrainWireframe(e3) {
            this._showTerrainWireframe !== e3 && (this._showTerrainWireframe = e3, this._update());
          }
          get speedIndexTiming() {
            return !!this._speedIndexTiming;
          }
          set speedIndexTiming(e3) {
            this._speedIndexTiming !== e3 && (this._speedIndexTiming = e3, this._update());
          }
          get showPadding() {
            return !!this._showPadding;
          }
          set showPadding(e3) {
            this._showPadding !== e3 && (this._showPadding = e3, this._update());
          }
          get showCollisionBoxes() {
            return !!this._showCollisionBoxes;
          }
          set showCollisionBoxes(e3) {
            this._showCollisionBoxes !== e3 && (this._showCollisionBoxes = e3, e3 ? this.style._generateCollisionBoxes() : this._update());
          }
          get showOverdrawInspector() {
            return !!this._showOverdrawInspector;
          }
          set showOverdrawInspector(e3) {
            this._showOverdrawInspector !== e3 && (this._showOverdrawInspector = e3, this._update());
          }
          get repaint() {
            return !!this._repaint;
          }
          set repaint(e3) {
            this._repaint !== e3 && (this._repaint = e3, this.triggerRepaint());
          }
          get vertices() {
            return !!this._vertices;
          }
          set vertices(e3) {
            this._vertices = e3, this._update();
          }
          get showTileAABBs() {
            return !!this._showTileAABBs;
          }
          set showTileAABBs(e3) {
            this._showTileAABBs !== e3 && (this._showTileAABBs = e3, e3 && this._update());
          }
          _setCacheLimits(t3, i3) {
            e2.setCacheLimits(t3, i3);
          }
          get version() {
            return e2.version;
          }
        }, NavigationControl: class {
          constructor(t3) {
            this.options = e2.extend({}, ln, t3), this._container = n2("div", "mapboxgl-ctrl mapboxgl-ctrl-group"), this._container.addEventListener("contextmenu", (e3) => e3.preventDefault()), this.options.showZoom && (e2.bindAll(["_setButtonTitle", "_updateZoomButtons"], this), this._zoomInButton = this._createButton("mapboxgl-ctrl-zoom-in", (e3) => {
              this._map && this._map.zoomIn({}, { originalEvent: e3 });
            }), n2("span", "mapboxgl-ctrl-icon", this._zoomInButton).setAttribute("aria-hidden", "true"), this._zoomOutButton = this._createButton("mapboxgl-ctrl-zoom-out", (e3) => {
              this._map && this._map.zoomOut({}, { originalEvent: e3 });
            }), n2("span", "mapboxgl-ctrl-icon", this._zoomOutButton).setAttribute("aria-hidden", "true")), this.options.showCompass && (e2.bindAll(["_rotateCompassArrow"], this), this._compass = this._createButton("mapboxgl-ctrl-compass", (e3) => {
              const t4 = this._map;
              t4 && (this.options.visualizePitch ? t4.resetNorthPitch({}, { originalEvent: e3 }) : t4.resetNorth({}, { originalEvent: e3 }));
            }), this._compassIcon = n2("span", "mapboxgl-ctrl-icon", this._compass), this._compassIcon.setAttribute("aria-hidden", "true"));
          }
          _updateZoomButtons() {
            const e3 = this._map;
            if (!e3)
              return;
            const t3 = e3.getZoom(), i3 = t3 === e3.getMaxZoom(), o3 = t3 === e3.getMinZoom();
            this._zoomInButton.disabled = i3, this._zoomOutButton.disabled = o3, this._zoomInButton.setAttribute("aria-disabled", i3.toString()), this._zoomOutButton.setAttribute("aria-disabled", o3.toString());
          }
          _rotateCompassArrow() {
            const e3 = this._map;
            if (!e3)
              return;
            const t3 = this.options.visualizePitch ? `scale(${1 / Math.pow(Math.cos(e3.transform.pitch * (Math.PI / 180)), 0.5)}) rotateX(${e3.transform.pitch}deg) rotateZ(${e3.transform.angle * (180 / Math.PI)}deg)` : `rotate(${e3.transform.angle * (180 / Math.PI)}deg)`;
            e3._requestDomTask(() => {
              this._compassIcon && (this._compassIcon.style.transform = t3);
            });
          }
          onAdd(e3) {
            return this._map = e3, this.options.showZoom && (this._setButtonTitle(this._zoomInButton, "ZoomIn"), this._setButtonTitle(this._zoomOutButton, "ZoomOut"), e3.on("zoom", this._updateZoomButtons), this._updateZoomButtons()), this.options.showCompass && (this._setButtonTitle(this._compass, "ResetBearing"), this.options.visualizePitch && e3.on("pitch", this._rotateCompassArrow), e3.on("rotate", this._rotateCompassArrow), this._rotateCompassArrow(), this._handler = new cn(e3, this._compass, this.options.visualizePitch)), this._container;
          }
          onRemove() {
            const e3 = this._map;
            e3 && (this._container.remove(), this.options.showZoom && e3.off("zoom", this._updateZoomButtons), this.options.showCompass && (this.options.visualizePitch && e3.off("pitch", this._rotateCompassArrow), e3.off("rotate", this._rotateCompassArrow), this._handler && this._handler.off(), this._handler = void 0), this._map = void 0);
          }
          _createButton(e3, t3) {
            const i3 = n2("button", e3, this._container);
            return i3.type = "button", i3.addEventListener("click", t3), i3;
          }
          _setButtonTitle(e3, t3) {
            if (!this._map)
              return;
            const i3 = this._map._getUIString(`NavigationControl.${t3}`);
            e3.setAttribute("aria-label", i3), e3.firstElementChild && e3.firstElementChild.setAttribute("title", i3);
          }
        }, GeolocateControl: class extends e2.Evented {
          constructor(t3) {
            super(), this.options = e2.extend({ geolocation: e2.window.navigator.geolocation }, hn, t3), e2.bindAll(["_onSuccess", "_onError", "_onZoom", "_finish", "_setupUI", "_updateCamera", "_updateMarker", "_updateMarkerRotation", "_onDeviceOrientation"], this), this._updateMarkerRotationThrottled = Yo(this._updateMarkerRotation, 20), this._numberOfWatches = 0;
          }
          onAdd(e3) {
            return this._map = e3, this._container = n2("div", "mapboxgl-ctrl mapboxgl-ctrl-group"), this._checkGeolocationSupport(this._setupUI), this._container;
          }
          onRemove() {
            void 0 !== this._geolocationWatchID && (this.options.geolocation.clearWatch(this._geolocationWatchID), this._geolocationWatchID = void 0), this.options.showUserLocation && this._userLocationDotMarker && this._userLocationDotMarker.remove(), this.options.showAccuracyCircle && this._accuracyCircleMarker && this._accuracyCircleMarker.remove(), this._container.remove(), this._map.off("zoom", this._onZoom), this._map = void 0, this._numberOfWatches = 0, this._noTimeout = false;
          }
          _checkGeolocationSupport(t3) {
            const i3 = (e3 = !!this.options.geolocation) => {
              this._supportsGeolocation = e3, t3(e3);
            };
            void 0 !== this._supportsGeolocation ? t3(this._supportsGeolocation) : void 0 !== e2.window.navigator.permissions ? e2.window.navigator.permissions.query({ name: "geolocation" }).then((e3) => i3("denied" !== e3.state)).catch(() => i3()) : i3();
          }
          _isOutOfMapMaxBounds(e3) {
            const t3 = this._map.getMaxBounds(), i3 = e3.coords;
            return !!t3 && (i3.longitude < t3.getWest() || i3.longitude > t3.getEast() || i3.latitude < t3.getSouth() || i3.latitude > t3.getNorth());
          }
          _setErrorState() {
            switch (this._watchState) {
              case "WAITING_ACTIVE":
                this._watchState = "ACTIVE_ERROR", this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-active"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-active-error");
                break;
              case "ACTIVE_LOCK":
                this._watchState = "ACTIVE_ERROR", this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-active"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-active-error"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-waiting");
                break;
              case "BACKGROUND":
                this._watchState = "BACKGROUND_ERROR", this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-background"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-background-error"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-waiting");
            }
          }
          _onSuccess(t3) {
            if (this._map) {
              if (this._isOutOfMapMaxBounds(t3))
                return this._setErrorState(), this.fire(new e2.Event("outofmaxbounds", t3)), this._updateMarker(), void this._finish();
              if (this.options.trackUserLocation)
                switch (this._lastKnownPosition = t3, this._watchState) {
                  case "WAITING_ACTIVE":
                  case "ACTIVE_LOCK":
                  case "ACTIVE_ERROR":
                    this._watchState = "ACTIVE_LOCK", this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-active-error"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-active");
                    break;
                  case "BACKGROUND":
                  case "BACKGROUND_ERROR":
                    this._watchState = "BACKGROUND", this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-background-error"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-background");
                }
              this.options.showUserLocation && "OFF" !== this._watchState && this._updateMarker(t3), this.options.trackUserLocation && "ACTIVE_LOCK" !== this._watchState || this._updateCamera(t3), this.options.showUserLocation && this._dotElement.classList.remove("mapboxgl-user-location-dot-stale"), this.fire(new e2.Event("geolocate", t3)), this._finish();
            }
          }
          _updateCamera(t3) {
            const i3 = new e2.LngLat(t3.coords.longitude, t3.coords.latitude), o3 = t3.coords.accuracy, r3 = this._map.getBearing(), n3 = e2.extend({ bearing: r3 }, this.options.fitBoundsOptions);
            this._map.fitBounds(i3.toBounds(o3), n3, { geolocateSource: true });
          }
          _updateMarker(t3) {
            if (t3) {
              const i3 = new e2.LngLat(t3.coords.longitude, t3.coords.latitude);
              this._accuracyCircleMarker.setLngLat(i3).addTo(this._map), this._userLocationDotMarker.setLngLat(i3).addTo(this._map), this._accuracy = t3.coords.accuracy, this.options.showUserLocation && this.options.showAccuracyCircle && this._updateCircleRadius();
            } else
              this._userLocationDotMarker.remove(), this._accuracyCircleMarker.remove();
          }
          _updateCircleRadius() {
            const t3 = this._map.transform, i3 = e2.mercatorZfromAltitude(1, t3._center.lat) * t3.worldSize, o3 = Math.ceil(2 * this._accuracy * i3);
            this._circleElement.style.width = `${o3}px`, this._circleElement.style.height = `${o3}px`;
          }
          _onZoom() {
            this.options.showUserLocation && this.options.showAccuracyCircle && this._updateCircleRadius();
          }
          _updateMarkerRotation() {
            this._userLocationDotMarker && "number" == typeof this._heading ? (this._userLocationDotMarker.setRotation(this._heading), this._dotElement.classList.add("mapboxgl-user-location-show-heading")) : (this._dotElement.classList.remove("mapboxgl-user-location-show-heading"), this._userLocationDotMarker.setRotation(0));
          }
          _onError(t3) {
            if (this._map) {
              if (this.options.trackUserLocation)
                if (1 === t3.code) {
                  this._watchState = "OFF", this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-active"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-active-error"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-background"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-background-error"), this._geolocateButton.disabled = true;
                  const e3 = this._map._getUIString("GeolocateControl.LocationNotAvailable");
                  this._geolocateButton.setAttribute("aria-label", e3), this._geolocateButton.firstElementChild && this._geolocateButton.firstElementChild.setAttribute("title", e3), void 0 !== this._geolocationWatchID && this._clearWatch();
                } else {
                  if (3 === t3.code && this._noTimeout)
                    return;
                  this._setErrorState();
                }
              "OFF" !== this._watchState && this.options.showUserLocation && this._dotElement.classList.add("mapboxgl-user-location-dot-stale"), this.fire(new e2.Event("error", t3)), this._finish();
            }
          }
          _finish() {
            this._timeoutId && clearTimeout(this._timeoutId), this._timeoutId = void 0;
          }
          _setupUI(t3) {
            if (void 0 !== this._map) {
              if (this._container.addEventListener("contextmenu", (e3) => e3.preventDefault()), this._geolocateButton = n2("button", "mapboxgl-ctrl-geolocate", this._container), n2("span", "mapboxgl-ctrl-icon", this._geolocateButton).setAttribute("aria-hidden", "true"), this._geolocateButton.type = "button", false === t3) {
                e2.warnOnce("Geolocation support is not available so the GeolocateControl will be disabled.");
                const t4 = this._map._getUIString("GeolocateControl.LocationNotAvailable");
                this._geolocateButton.disabled = true, this._geolocateButton.setAttribute("aria-label", t4), this._geolocateButton.firstElementChild && this._geolocateButton.firstElementChild.setAttribute("title", t4);
              } else {
                const e3 = this._map._getUIString("GeolocateControl.FindMyLocation");
                this._geolocateButton.setAttribute("aria-label", e3), this._geolocateButton.firstElementChild && this._geolocateButton.firstElementChild.setAttribute("title", e3);
              }
              this.options.trackUserLocation && (this._geolocateButton.setAttribute("aria-pressed", "false"), this._watchState = "OFF"), this.options.showUserLocation && (this._dotElement = n2("div", "mapboxgl-user-location"), this._dotElement.appendChild(n2("div", "mapboxgl-user-location-dot")), this._dotElement.appendChild(n2("div", "mapboxgl-user-location-heading")), this._userLocationDotMarker = new en({ element: this._dotElement, rotationAlignment: "map", pitchAlignment: "map" }), this._circleElement = n2("div", "mapboxgl-user-location-accuracy-circle"), this._accuracyCircleMarker = new en({ element: this._circleElement, pitchAlignment: "map" }), this.options.trackUserLocation && (this._watchState = "OFF"), this._map.on("zoom", this._onZoom)), this._geolocateButton.addEventListener("click", this.trigger.bind(this)), this._setup = true, this.options.trackUserLocation && this._map.on("movestart", (t4) => {
                t4.geolocateSource || "ACTIVE_LOCK" !== this._watchState || t4.originalEvent && "resize" === t4.originalEvent.type || (this._watchState = "BACKGROUND", this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-background"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-active"), this.fire(new e2.Event("trackuserlocationend")));
              });
            }
          }
          _onDeviceOrientation(e3) {
            this._userLocationDotMarker && (e3.webkitCompassHeading ? this._heading = e3.webkitCompassHeading : true === e3.absolute && (this._heading = -1 * e3.alpha), this._updateMarkerRotationThrottled());
          }
          trigger() {
            if (!this._setup)
              return e2.warnOnce("Geolocate control triggered before added to a map"), false;
            if (this.options.trackUserLocation) {
              switch (this._watchState) {
                case "OFF":
                  this._watchState = "WAITING_ACTIVE", this.fire(new e2.Event("trackuserlocationstart"));
                  break;
                case "WAITING_ACTIVE":
                case "ACTIVE_LOCK":
                case "ACTIVE_ERROR":
                case "BACKGROUND_ERROR":
                  this._numberOfWatches--, this._noTimeout = false, this._watchState = "OFF", this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-active"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-active-error"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-background"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-background-error"), this.fire(new e2.Event("trackuserlocationend"));
                  break;
                case "BACKGROUND":
                  this._watchState = "ACTIVE_LOCK", this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-background"), this._lastKnownPosition && this._updateCamera(this._lastKnownPosition), this.fire(new e2.Event("trackuserlocationstart"));
              }
              switch (this._watchState) {
                case "WAITING_ACTIVE":
                  this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-active");
                  break;
                case "ACTIVE_LOCK":
                  this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-active");
                  break;
                case "ACTIVE_ERROR":
                  this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-active-error");
                  break;
                case "BACKGROUND":
                  this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-background");
                  break;
                case "BACKGROUND_ERROR":
                  this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-background-error");
              }
              if ("OFF" === this._watchState && void 0 !== this._geolocationWatchID)
                this._clearWatch();
              else if (void 0 === this._geolocationWatchID) {
                let e3;
                this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.setAttribute("aria-pressed", "true"), this._numberOfWatches++, this._numberOfWatches > 1 ? (e3 = { maximumAge: 6e5, timeout: 0 }, this._noTimeout = true) : (e3 = this.options.positionOptions, this._noTimeout = false), this._geolocationWatchID = this.options.geolocation.watchPosition(this._onSuccess, this._onError, e3), this.options.showUserHeading && this._addDeviceOrientationListener();
              }
            } else
              this.options.geolocation.getCurrentPosition(this._onSuccess, this._onError, this.options.positionOptions), this._timeoutId = setTimeout(this._finish, 1e4);
            return true;
          }
          _addDeviceOrientationListener() {
            const t3 = () => {
              e2.window.addEventListener("ondeviceorientationabsolute" in e2.window ? "deviceorientationabsolute" : "deviceorientation", this._onDeviceOrientation);
            };
            void 0 !== e2.window.DeviceMotionEvent && "function" == typeof e2.window.DeviceMotionEvent.requestPermission ? DeviceOrientationEvent.requestPermission().then((e3) => {
              "granted" === e3 && t3();
            }).catch(console.error) : t3();
          }
          _clearWatch() {
            this.options.geolocation.clearWatch(this._geolocationWatchID), e2.window.removeEventListener("deviceorientation", this._onDeviceOrientation), e2.window.removeEventListener("deviceorientationabsolute", this._onDeviceOrientation), this._geolocationWatchID = void 0, this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.setAttribute("aria-pressed", "false"), this.options.showUserLocation && this._updateMarker(null);
          }
        }, AttributionControl: Hr, ScaleControl: class {
          constructor(t3) {
            this.options = e2.extend({}, un, t3), this._isNumberFormatSupported = function() {
              try {
                return new Intl.NumberFormat("en", { style: "unit", unitDisplay: "short", unit: "meter" }), true;
              } catch (e3) {
                return false;
              }
            }(), e2.bindAll(["_update", "_setScale", "setUnit"], this);
          }
          getDefaultPosition() {
            return "bottom-left";
          }
          _update() {
            const e3 = this.options.maxWidth || 100, t3 = this._map, i3 = t3._containerHeight / 2, o3 = t3._containerWidth / 2 - e3 / 2, r3 = t3.unproject([o3, i3]), n3 = t3.unproject([o3 + e3, i3]), s3 = r3.distanceTo(n3);
            if ("imperial" === this.options.unit) {
              const t4 = 3.2808 * s3;
              t4 > 5280 ? this._setScale(e3, t4 / 5280, "mile") : this._setScale(e3, t4, "foot");
            } else
              "nautical" === this.options.unit ? this._setScale(e3, s3 / 1852, "nautical-mile") : s3 >= 1e3 ? this._setScale(e3, s3 / 1e3, "kilometer") : this._setScale(e3, s3, "meter");
          }
          _setScale(e3, t3, i3) {
            this._map._requestDomTask(() => {
              const o3 = function(e4) {
                const t4 = Math.pow(10, `${Math.floor(e4)}`.length - 1);
                let i4 = e4 / t4;
                return i4 = i4 >= 10 ? 10 : i4 >= 5 ? 5 : i4 >= 3 ? 3 : i4 >= 2 ? 2 : i4 >= 1 ? 1 : function(e5) {
                  const t5 = Math.pow(10, Math.ceil(-Math.log(e5) / Math.LN10));
                  return Math.round(e5 * t5) / t5;
                }(i4), t4 * i4;
              }(t3), r3 = o3 / t3;
              this._container.innerHTML = this._isNumberFormatSupported && "nautical-mile" !== i3 ? new Intl.NumberFormat(this._language, { style: "unit", unitDisplay: "short", unit: i3 }).format(o3) : `${o3}&nbsp;${_n[i3]}`, this._container.style.width = e3 * r3 + "px";
            });
          }
          onAdd(e3) {
            return this._map = e3, this._language = e3.getLanguage(), this._container = n2("div", "mapboxgl-ctrl mapboxgl-ctrl-scale", e3.getContainer()), this._container.dir = "auto", this._map.on("move", this._update), this._update(), this._container;
          }
          onRemove() {
            this._container.remove(), this._map.off("move", this._update), this._map = void 0;
          }
          _setLanguage(e3) {
            this._language = e3, this._update();
          }
          setUnit(e3) {
            this.options.unit = e3, this._update();
          }
        }, FullscreenControl: class {
          constructor(t3) {
            this._fullscreen = false, t3 && t3.container && (t3.container instanceof e2.window.HTMLElement ? this._container = t3.container : e2.warnOnce("Full screen control 'container' must be a DOM element.")), e2.bindAll(["_onClickFullscreen", "_changeIcon"], this), "onfullscreenchange" in e2.window.document ? this._fullscreenchange = "fullscreenchange" : "onwebkitfullscreenchange" in e2.window.document && (this._fullscreenchange = "webkitfullscreenchange");
          }
          onAdd(t3) {
            return this._map = t3, this._container || (this._container = this._map.getContainer()), this._controlContainer = n2("div", "mapboxgl-ctrl mapboxgl-ctrl-group"), this._checkFullscreenSupport() ? this._setupUI() : (this._controlContainer.style.display = "none", e2.warnOnce("This device does not support fullscreen mode.")), this._controlContainer;
          }
          onRemove() {
            this._controlContainer.remove(), this._map = null, e2.window.document.removeEventListener(this._fullscreenchange, this._changeIcon);
          }
          _checkFullscreenSupport() {
            return !(!e2.window.document.fullscreenEnabled && !e2.window.document.webkitFullscreenEnabled);
          }
          _setupUI() {
            const t3 = this._fullscreenButton = n2("button", "mapboxgl-ctrl-fullscreen", this._controlContainer);
            n2("span", "mapboxgl-ctrl-icon", t3).setAttribute("aria-hidden", "true"), t3.type = "button", this._updateTitle(), this._fullscreenButton.addEventListener("click", this._onClickFullscreen), e2.window.document.addEventListener(this._fullscreenchange, this._changeIcon);
          }
          _updateTitle() {
            const e3 = this._getTitle();
            this._fullscreenButton.setAttribute("aria-label", e3), this._fullscreenButton.firstElementChild && this._fullscreenButton.firstElementChild.setAttribute("title", e3);
          }
          _getTitle() {
            return this._map._getUIString(this._isFullscreen() ? "FullscreenControl.Exit" : "FullscreenControl.Enter");
          }
          _isFullscreen() {
            return this._fullscreen;
          }
          _changeIcon() {
            (e2.window.document.fullscreenElement || e2.window.document.webkitFullscreenElement) === this._container !== this._fullscreen && (this._fullscreen = !this._fullscreen, this._fullscreenButton.classList.toggle("mapboxgl-ctrl-shrink"), this._fullscreenButton.classList.toggle("mapboxgl-ctrl-fullscreen"), this._updateTitle());
          }
          _onClickFullscreen() {
            this._isFullscreen() ? e2.window.document.exitFullscreen ? e2.window.document.exitFullscreen() : e2.window.document.webkitCancelFullScreen && e2.window.document.webkitCancelFullScreen() : this._container.requestFullscreen ? this._container.requestFullscreen() : this._container.webkitRequestFullscreen && this._container.webkitRequestFullscreen();
          }
        }, Popup: class extends e2.Evented {
          constructor(t3) {
            super(), this.options = e2.extend(Object.create(tn), t3), e2.bindAll(["_update", "_onClose", "remove", "_onMouseEvent"], this), this._classList = new Set(t3 && t3.className ? t3.className.trim().split(/\s+/) : []);
          }
          addTo(t3) {
            return this._map && this.remove(), this._map = t3, this.options.closeOnClick && t3.on("preclick", this._onClose), this.options.closeOnMove && t3.on("move", this._onClose), t3.on("remove", this.remove), this._update(), t3._addPopup(this), this._focusFirstElement(), this._trackPointer ? (t3.on("mousemove", this._onMouseEvent), t3.on("mouseup", this._onMouseEvent), t3._canvasContainer.classList.add("mapboxgl-track-pointer")) : t3.on("move", this._update), this.fire(new e2.Event("open")), this;
          }
          isOpen() {
            return !!this._map;
          }
          remove() {
            this._content && this._content.remove(), this._container && (this._container.remove(), this._container = void 0);
            const t3 = this._map;
            return t3 && (t3.off("move", this._update), t3.off("move", this._onClose), t3.off("preclick", this._onClose), t3.off("click", this._onClose), t3.off("remove", this.remove), t3.off("mousemove", this._onMouseEvent), t3.off("mouseup", this._onMouseEvent), t3.off("drag", this._onMouseEvent), t3._canvasContainer && t3._canvasContainer.classList.remove("mapboxgl-track-pointer"), t3._removePopup(this), this._map = void 0), this.fire(new e2.Event("close")), this;
          }
          getLngLat() {
            return this._lngLat;
          }
          setLngLat(t3) {
            this._lngLat = e2.LngLat.convert(t3), this._pos = null, this._trackPointer = false, this._update();
            const i3 = this._map;
            return i3 && (i3.on("move", this._update), i3.off("mousemove", this._onMouseEvent), i3._canvasContainer.classList.remove("mapboxgl-track-pointer")), this;
          }
          trackPointer() {
            this._trackPointer = true, this._pos = null, this._update();
            const e3 = this._map;
            return e3 && (e3.off("move", this._update), e3.on("mousemove", this._onMouseEvent), e3.on("drag", this._onMouseEvent), e3._canvasContainer.classList.add("mapboxgl-track-pointer")), this;
          }
          getElement() {
            return this._container;
          }
          setText(t3) {
            return this.setDOMContent(e2.window.document.createTextNode(t3));
          }
          setHTML(t3) {
            const i3 = e2.window.document.createDocumentFragment(), o3 = e2.window.document.createElement("body");
            let r3;
            for (o3.innerHTML = t3; r3 = o3.firstChild, r3; )
              i3.appendChild(r3);
            return this.setDOMContent(i3);
          }
          getMaxWidth() {
            return this._container && this._container.style.maxWidth;
          }
          setMaxWidth(e3) {
            return this.options.maxWidth = e3, this._update(), this;
          }
          setDOMContent(e3) {
            let t3 = this._content;
            if (t3)
              for (; t3.hasChildNodes(); )
                t3.firstChild && t3.removeChild(t3.firstChild);
            else
              t3 = this._content = n2("div", "mapboxgl-popup-content", this._container || void 0);
            if (t3.appendChild(e3), this.options.closeButton) {
              const e4 = this._closeButton = n2("button", "mapboxgl-popup-close-button", t3);
              e4.type = "button", e4.setAttribute("aria-label", "Close popup"), e4.setAttribute("aria-hidden", "true"), e4.innerHTML = "&#215;", e4.addEventListener("click", this._onClose);
            }
            return this._update(), this._focusFirstElement(), this;
          }
          addClassName(e3) {
            return this._classList.add(e3), this._updateClassList(), this;
          }
          removeClassName(e3) {
            return this._classList.delete(e3), this._updateClassList(), this;
          }
          setOffset(e3) {
            return this.options.offset = e3, this._update(), this;
          }
          toggleClassName(e3) {
            let t3;
            return this._classList.delete(e3) ? t3 = false : (this._classList.add(e3), t3 = true), this._updateClassList(), t3;
          }
          _onMouseEvent(e3) {
            this._update(e3.point);
          }
          _getAnchor(e3) {
            if (this.options.anchor)
              return this.options.anchor;
            const t3 = this._map, i3 = this._container, o3 = this._pos;
            if (!t3 || !i3 || !o3)
              return "bottom";
            const r3 = i3.offsetWidth, n3 = i3.offsetHeight, s3 = o3.x < r3 / 2, a3 = o3.x > t3.transform.width - r3 / 2;
            if (o3.y + e3 < n3)
              return s3 ? "top-left" : a3 ? "top-right" : "top";
            if (o3.y > t3.transform.height - n3) {
              if (s3)
                return "bottom-left";
              if (a3)
                return "bottom-right";
            }
            return s3 ? "left" : a3 ? "right" : "bottom";
          }
          _updateClassList() {
            const e3 = this._container;
            if (!e3)
              return;
            const t3 = [...this._classList];
            t3.push("mapboxgl-popup"), this._anchor && t3.push(`mapboxgl-popup-anchor-${this._anchor}`), this._trackPointer && t3.push("mapboxgl-popup-track-pointer"), e3.className = t3.join(" ");
          }
          _update(t3) {
            const i3 = this._map, o3 = this._content;
            if (!i3 || !this._lngLat && !this._trackPointer || !o3)
              return;
            let r3 = this._container;
            if (r3 || (r3 = this._container = n2("div", "mapboxgl-popup", i3.getContainer()), this._tip = n2("div", "mapboxgl-popup-tip", r3), r3.appendChild(o3)), this.options.maxWidth && r3.style.maxWidth !== this.options.maxWidth && (r3.style.maxWidth = this.options.maxWidth), i3.transform.renderWorldCopies && !this._trackPointer && (this._lngLat = Jr(this._lngLat, this._pos, i3.transform)), !this._trackPointer || t3) {
              const e3 = this._pos = this._trackPointer && t3 ? t3 : i3.project(this._lngLat), o4 = rn(this.options.offset), r4 = this._anchor = this._getAnchor(o4.y), n3 = rn(this.options.offset, r4), s3 = e3.add(n3).round();
              i3._requestDomTask(() => {
                this._container && r4 && (this._container.style.transform = `${Qr[r4]} translate(${s3.x}px,${s3.y}px)`);
              });
            }
            if (!this._marker && i3._showingGlobe()) {
              const t4 = e2.isLngLatBehindGlobe(i3.transform, this._lngLat) ? 0 : 1;
              this._setOpacity(t4);
            }
            this._updateClassList();
          }
          _focusFirstElement() {
            if (!this.options.focusAfterOpen || !this._container)
              return;
            const e3 = this._container.querySelector(on);
            e3 && e3.focus();
          }
          _onClose() {
            this.remove();
          }
          _setOpacity(e3) {
            this._container && (this._container.style.opacity = `${e3}`), this._content && (this._content.style.pointerEvents = e3 ? "auto" : "none");
          }
        }, Marker: en, Style: Kt, LngLat: e2.LngLat, LngLatBounds: e2.LngLatBounds, Point: e2.Point, MercatorCoordinate: e2.MercatorCoordinate, FreeCameraOptions: jo, Evented: e2.Evented, config: e2.config, prewarm: function() {
          Ue().acquire(Be);
        }, clearPrewarmedResources: function() {
          const e3 = Fe;
          e3 && (e3.isPreloaded() && 1 === e3.numActive() ? (e3.release(Be), Fe = null) : console.warn("Could not clear WebWorkers since there are active Map instances that still reference it. The pre-warmed WebWorker pool can only be cleared when all map instances have been removed with map.remove()"));
        }, get accessToken() {
          return e2.config.ACCESS_TOKEN;
        }, set accessToken(t3) {
          e2.config.ACCESS_TOKEN = t3;
        }, get baseApiUrl() {
          return e2.config.API_URL;
        }, set baseApiUrl(t3) {
          e2.config.API_URL = t3;
        }, get workerCount() {
          return ke.workerCount;
        }, set workerCount(e3) {
          ke.workerCount = e3;
        }, get maxParallelImageRequests() {
          return e2.config.MAX_PARALLEL_IMAGE_REQUESTS;
        }, set maxParallelImageRequests(t3) {
          e2.config.MAX_PARALLEL_IMAGE_REQUESTS = t3;
        }, clearStorage(t3) {
          e2.clearTileCache(t3);
        }, workerUrl: "", workerClass: null, setNow: e2.exported.setNow, restoreNow: e2.exported.restoreNow };
        return dn;
      });
      var mapboxgl$1 = mapboxgl2;
      return mapboxgl$1;
    });
  }
});

// node_modules/@yext/search-ui-react/lib/esm/components/SearchBar.js
var import_jsx_runtime14 = __toESM(require_jsx_runtime());
var import_classnames = __toESM(require_classnames());
var import_react35 = __toESM(require_react());

// node_modules/@yext/search-ui-react/lib/esm/hooks/useEntityPreviews.js
var import_react3 = __toESM(require_react());

// node_modules/@yext/search-ui-react/lib/esm/hooks/useComponentMountStatus.js
var import_react = __toESM(require_react());
function useComponentMountStatus() {
  const isMountedRef = (0, import_react.useRef)(false);
  (0, import_react.useEffect)(() => {
    isMountedRef.current = true;
    return () => {
      isMountedRef.current = false;
    };
  }, []);
  return isMountedRef;
}

// node_modules/@yext/search-ui-react/lib/esm/hooks/useDebouncedFunction.js
var import_react2 = __toESM(require_react());
function useDebouncedFunction(func, milliseconds) {
  const timeoutIdRef = (0, import_react2.useRef)();
  if (!func) {
    return void 0;
  }
  const debounced = (...args) => {
    return new Promise((resolve) => {
      if (timeoutIdRef.current !== void 0) {
        clearTimeout(timeoutIdRef.current);
      }
      timeoutIdRef.current = window.setTimeout(() => {
        resolve(func(...args));
        timeoutIdRef.current = void 0;
      }, milliseconds);
    });
  };
  return debounced;
}

// node_modules/@yext/search-ui-react/lib/esm/hooks/useEntityPreviews.js
function useEntityPreviews(entityPreviewSearcher, debounceTime) {
  const isMountedRef = useComponentMountStatus();
  const [verticalKeyToResults, setVerticalKeyToResults] = (0, import_react3.useState)({});
  const debouncedUniversalSearch = useDebouncedFunction(async () => {
    if (!entityPreviewSearcher) {
      return;
    }
    await entityPreviewSearcher.executeUniversalQuery();
    if (!isMountedRef.current) {
      return;
    }
    const results = entityPreviewSearcher.state.universal.verticals || [];
    setVerticalKeyToResults(getVerticalKeyToResults(results));
    setLoadingState(false);
  }, debounceTime);
  const [isLoading, setLoadingState] = (0, import_react3.useState)(false);
  function executeEntityPreviewsQuery(query, universalLimit, restrictVerticals) {
    if (!entityPreviewSearcher) {
      return;
    }
    if (query === entityPreviewSearcher.state.query.input) {
      return;
    }
    setLoadingState(true);
    entityPreviewSearcher.setQuery(query);
    entityPreviewSearcher.setRestrictVerticals(restrictVerticals);
    entityPreviewSearcher.setUniversalLimit(universalLimit);
    debouncedUniversalSearch === null || debouncedUniversalSearch === void 0 ? void 0 : debouncedUniversalSearch();
  }
  return [{ verticalKeyToResults, isLoading }, executeEntityPreviewsQuery];
}
function getVerticalKeyToResults(verticalResultsArray) {
  return verticalResultsArray.reduce((prev, current) => {
    prev[current.verticalKey] = current;
    return prev;
  }, {});
}

// node_modules/@yext/search-ui-react/lib/esm/hooks/useRecentSearches.js
var import_react4 = __toESM(require_react());
var import_recent_searches = __toESM(require_dist());
function useRecentSearches(recentSearchesLimit, verticalKey) {
  const recentSearchesKey = getRecentSearchesKey(verticalKey);
  const [recentSearches, setRecentSeaches] = (0, import_react4.useState)(new import_recent_searches.default({
    limit: recentSearchesLimit,
    namespace: recentSearchesKey
  }));
  const clearRecentSearches = (0, import_react4.useCallback)(() => {
    localStorage.removeItem(recentSearchesKey);
    setRecentSeaches(new import_recent_searches.default({
      limit: recentSearchesLimit,
      namespace: recentSearchesKey
    }));
    localStorage.removeItem(recentSearchesKey);
  }, [recentSearchesKey, recentSearchesLimit]);
  const setRecentSearch = (0, import_react4.useCallback)((input) => {
    recentSearches.setRecentSearch(input);
  }, [recentSearches]);
  (0, import_react4.useEffect)(() => {
    setRecentSeaches(new import_recent_searches.default({
      limit: recentSearchesLimit,
      namespace: recentSearchesKey
    }));
  }, [recentSearchesKey, recentSearchesLimit]);
  return [recentSearches === null || recentSearches === void 0 ? void 0 : recentSearches.getRecentSearches(), setRecentSearch, clearRecentSearches];
}
function getRecentSearchesKey(verticalKey) {
  if (verticalKey) {
    return `__yxt_recent_searches_${verticalKey}__`;
  } else {
    return "__yxt_recent_searches_universal__";
  }
}

// node_modules/@yext/search-ui-react/lib/esm/utils/search-operations.js
async function executeSearch(searchActions) {
  const isVertical = searchActions.state.meta.searchType === SearchTypeEnum.Vertical;
  try {
    isVertical ? searchActions.executeVerticalQuery() : searchActions.executeUniversalQuery();
  } catch (e2) {
    console.error(`Error occured executing a ${isVertical ? "vertical" : "universal"} search.
`, e2);
  }
}
async function executeAutocomplete(searchActions) {
  const isVertical = searchActions.state.meta.searchType === SearchTypeEnum.Vertical;
  try {
    return isVertical ? searchActions.executeVerticalAutocomplete() : searchActions.executeUniversalAutocomplete();
  } catch (e2) {
    console.error(`Error occured executing a ${isVertical ? "vertical" : "universal"} autocomplete search.
`, e2);
  }
}
async function getSearchIntents(searchActions) {
  const results = await executeAutocomplete(searchActions);
  return results === null || results === void 0 ? void 0 : results.inputIntents;
}

// node_modules/@yext/search-ui-react/lib/esm/utils/location-operations.js
var defaultGeolocationOptions = {
  enableHighAccuracy: false,
  timeout: 6e3,
  maximumAge: 3e5
};
async function updateLocationIfNeeded(searchActions, intents, geolocationOptions) {
  if (intents.includes(SearchIntent.NearMe) && !searchActions.state.location.userLocation) {
    try {
      const position = await getUserLocation(geolocationOptions);
      searchActions.setUserLocation({
        latitude: position.coords.latitude,
        longitude: position.coords.longitude
      });
    } catch (e2) {
      console.error(e2);
    }
  }
}
async function getUserLocation(geolocationOptions) {
  return new Promise((resolve, reject) => {
    if ("geolocation" in navigator) {
      navigator.geolocation.getCurrentPosition((position) => resolve(position), (err) => {
        console.error("Error occured using geolocation API. Unable to determine user's location.");
        reject(err);
      }, Object.assign(Object.assign({}, defaultGeolocationOptions), geolocationOptions));
    } else {
      reject("No access to geolocation API. Unable to determine user's location.");
    }
  });
}

// node_modules/@yext/search-ui-react/lib/esm/hooks/useSearchWithNearMeHandling.js
var import_react5 = __toESM(require_react());
function useSearchWithNearMeHandling(geolocationOptions, onSearch) {
  const autocompletePromiseRef = (0, import_react5.useRef)();
  const searchActions = useSearchActions();
  async function executeQuery() {
    var _a, _b;
    let intents = [];
    if (!searchActions.state.location.userLocation) {
      if (!autocompletePromiseRef.current) {
        autocompletePromiseRef.current = executeAutocomplete(searchActions);
      }
      const autocompleteResponseBeforeSearch = await autocompletePromiseRef.current;
      intents = (autocompleteResponseBeforeSearch === null || autocompleteResponseBeforeSearch === void 0 ? void 0 : autocompleteResponseBeforeSearch.inputIntents) || [];
      await updateLocationIfNeeded(searchActions, intents, geolocationOptions);
    }
    const verticalKey = (_a = searchActions.state.vertical.verticalKey) !== null && _a !== void 0 ? _a : "";
    const query = (_b = searchActions.state.query.input) !== null && _b !== void 0 ? _b : "";
    onSearch ? onSearch({ verticalKey, query }) : executeSearch(searchActions);
  }
  return [executeQuery, autocompletePromiseRef];
}

// node_modules/@yext/search-ui-react/lib/esm/hooks/useSynchronizedRequest.js
var import_react6 = __toESM(require_react());
function useSynchronizedRequest(executeRequest, handleRejectedPromise) {
  const executeRequestRef = (0, import_react6.useRef)(executeRequest);
  const handleRejectedPromiseRef = (0, import_react6.useRef)(handleRejectedPromise);
  const isMountedRef = useComponentMountStatus();
  const networkIds = (0, import_react6.useRef)({ latestRequest: 0, responseInState: 0 });
  const [synchronizedResponse, setSynchronizedResponse] = (0, import_react6.useState)();
  const executeSynchronizedRequest = (0, import_react6.useCallback)(async (data) => {
    const requestId = ++networkIds.current.latestRequest;
    return new Promise(async (resolve) => {
      let response = void 0;
      try {
        response = await executeRequestRef.current(data);
      } catch (e2) {
        handleRejectedPromiseRef.current ? handleRejectedPromiseRef.current(e2) : console.error(e2);
      }
      if (requestId >= networkIds.current.responseInState) {
        if (!isMountedRef.current) {
          return;
        }
        setSynchronizedResponse(response);
        networkIds.current.responseInState = requestId;
      }
      resolve(response);
    });
  }, [isMountedRef]);
  const clearResponseData = (0, import_react6.useCallback)(() => {
    setSynchronizedResponse(void 0);
  }, [setSynchronizedResponse]);
  (0, import_react6.useEffect)(() => {
    executeRequestRef.current = executeRequest;
    handleRejectedPromiseRef.current = handleRejectedPromise;
  });
  return [synchronizedResponse, executeSynchronizedRequest, clearResponseData];
}

// node_modules/@yext/search-ui-react/lib/esm/icons/VerticalDividerIcon.js
var import_jsx_runtime = __toESM(require_jsx_runtime());
function VerticalDividerIcon({ className }) {
  return (0, import_jsx_runtime.jsx)("svg", Object.assign({ className, width: "1", height: "24", viewBox: "0 0 1 24", fill: "none", xmlns: "http://www.w3.org/2000/svg" }, { children: (0, import_jsx_runtime.jsx)("rect", { width: "1", height: "24", rx: "0.5", fill: "#E1E5E8" }, void 0) }), void 0);
}

// node_modules/@yext/search-ui-react/lib/esm/icons/HistoryIcon.js
var import_jsx_runtime2 = __toESM(require_jsx_runtime());
function HistoryIcon() {
  return (0, import_jsx_runtime2.jsx)("svg", Object.assign({ viewBox: "0 0 14 15", fill: "currentColor", xmlns: "http://www.w3.org/2000/svg" }, { children: (0, import_jsx_runtime2.jsx)("path", { d: "M13.7813 7.75C13.7539 4.00391 10.7188 0.96875 7 0.96875C5.11328 0.96875 3.39063 1.76172 2.16016 2.99219L0.929688 1.76172C0.738281 1.57031 0.382813 1.70703 0.382813 2.00781L0.382813 5.45312C0.382813 5.64453 0.519531 5.78125 0.710938 5.78125L4.21094 5.78125C4.51172 5.78125 4.64844 5.42578 4.45703 5.23437L3.11719 3.92188C4.10156 2.91016 5.46875 2.28125 7 2.28125C10.0078 2.28125 12.4688 4.74219 12.4688 7.75C12.4688 10.7852 10.0078 13.2187 7 13.2188C5.57813 13.2188 4.32031 12.6992 3.33594 11.8516C3.22656 11.7422 3.00781 11.7422 2.89844 11.8516L2.43359 12.3164C2.29688 12.4531 2.29688 12.6719 2.43359 12.8086C3.63672 13.875 5.25 14.5586 7 14.5312C10.7188 14.5312 13.7813 11.4961 13.7813 7.75ZM9.1875 10.2109L9.59766 9.69141C9.67969 9.52734 9.65234 9.33594 9.51563 9.22656L7.65625 7.85937V3.92187C7.65625 3.75781 7.49219 3.59375 7.32813 3.59375H6.67188C6.48047 3.59375 6.34375 3.75781 6.34375 3.92187V8.54297L8.75 10.293C8.88672 10.4023 9.10547 10.375 9.1875 10.2109Z" }, void 0) }), void 0);
}

// node_modules/@yext/search-ui-react/lib/esm/icons/CloseIcon.js
var import_jsx_runtime3 = __toESM(require_jsx_runtime());
function CloseIcon() {
  return (0, import_jsx_runtime3.jsx)("svg", Object.assign({ viewBox: "0 0 18 18", xmlns: "http://www.w3.org/2000/svg", fill: "currentColor" }, { children: (0, import_jsx_runtime3.jsx)("path", { d: "M10.9095 9.00028L16.6786 3.2311L17.8684 2.04138C18.0439 1.86587 18.0439 1.58067 17.8684 1.40517L16.5954 0.132192C16.4199 -0.0433137 16.1347 -0.0433137 15.9592 0.132192L9.00028 7.0911L2.04138 0.131629C1.86587 -0.0438764 1.58067 -0.0438764 1.40517 0.131629L0.131629 1.40461C-0.0438764 1.58011 -0.0438764 1.86531 0.131629 2.04081L7.0911 9.00028L0.131629 15.9592C-0.0438764 16.1347 -0.0438764 16.4199 0.131629 16.5954L1.40461 17.8684C1.58011 18.0439 1.86531 18.0439 2.04081 17.8684L9.00028 10.9095L14.7695 16.6786L15.9592 17.8684C16.1347 18.0439 16.4199 18.0439 16.5954 17.8684L17.8684 16.5954C18.0439 16.4199 18.0439 16.1347 17.8684 15.9592L10.9095 9.00028Z", fill: "#6b7280" }, void 0) }), void 0);
}

// node_modules/@yext/search-ui-react/lib/esm/icons/MagnifyingGlassIcon.js
var import_jsx_runtime4 = __toESM(require_jsx_runtime());
function MagnifyingGlassIcon() {
  return (0, import_jsx_runtime4.jsxs)("svg", Object.assign({ xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 24 24", fill: "currentColor" }, { children: [(0, import_jsx_runtime4.jsx)("path", { d: "M0 0h24v24H0V0z", fill: "none" }, void 0), (0, import_jsx_runtime4.jsx)("path", { d: "M15.5 14h-.79l-.28-.27C15.41 12.59 16 11.11 16 9.5 16 5.91 13.09 3 9.5 3S3 5.91 3 9.5 5.91 16 9.5 16c1.61 0 3.09-.59 4.23-1.57l.27.28v.79l5 4.99L20.49 19l-4.99-5zm-6 0C7.01 14 5 11.99 5 9.5S7.01 5 9.5 5 14 7.01 14 9.5 11.99 14 9.5 14z" }, void 0)] }), void 0);
}

// node_modules/@yext/search-ui-react/lib/esm/icons/YextIcon.js
var import_jsx_runtime5 = __toESM(require_jsx_runtime());
function YextIcon() {
  return (0, import_jsx_runtime5.jsx)("svg", Object.assign({ viewBox: "0 0 30 30", xmlns: "http://www.w3.org/2000/svg" }, { children: (0, import_jsx_runtime5.jsx)("path", { d: "M25.517 28.142v.095h-.204v.905h-.066v-.905h-.197v-.095h.467zm.667 0h.066v1h-.066v-.825l-.24.595h-.013l-.24-.595v.825h-.066v-1h.066l.247.61.246-.61zM15 28.8c7.622 0 13.8-6.178 13.8-13.8 0-7.622-6.178-13.8-13.8-13.8C7.378 1.2 1.2 7.378 1.2 15c0 7.622 6.178 13.8 13.8 13.8zM15 0c8.284 0 15 6.716 15 15 0 8.284-6.716 15-15 15-8.284 0-15-6.716-15-15C0 6.716 6.716 0 15 0zm.45 16.65v-1.2h6.6v1.2h-2.7v5.4h-1.2v-5.4h-2.7zm-1.599-1.35l.849.849-2.601 2.601 2.601 2.601-.849.849-2.601-2.601L8.649 22.2l-.849-.849 2.601-2.601L7.8 16.149l.849-.849 2.601 2.601 2.601-2.601zM18.675 9a2.175 2.175 0 00-1.847 3.323l2.995-2.995A2.163 2.163 0 0018.675 9zm0 5.55a3.375 3.375 0 112.833-5.209l-3.789 3.788a2.175 2.175 0 003.13-1.954h1.201a3.375 3.375 0 01-3.375 3.375zm-7.425-3.734L13.78 7.8l.92.771-2.85 3.397v2.582h-1.2v-2.582L7.8 8.57l.92-.771 2.53 3.016z" }, void 0) }), void 0);
}

// node_modules/@yext/search-ui-react/lib/esm/components/Dropdown/Dropdown.js
var import_jsx_runtime8 = __toESM(require_jsx_runtime());
var import_react31 = __toESM(require_react());

// node_modules/@yext/search-ui-react/lib/esm/components/Dropdown/DropdownContext.js
var import_react7 = __toESM(require_react());
var DropdownContext = (0, import_react7.createContext)(null);
function useDropdownContext() {
  const dropdownContextInstance = (0, import_react7.useContext)(DropdownContext);
  if (dropdownContextInstance === null) {
    throw new Error("Tried to use DropdownContext when none exists.");
  }
  return dropdownContextInstance;
}

// node_modules/@yext/search-ui-react/lib/esm/components/Dropdown/InputContext.js
var import_react8 = __toESM(require_react());
var InputContext = (0, import_react8.createContext)(null);
function useInputContext() {
  const inputContextInstance = (0, import_react8.useContext)(InputContext);
  if (inputContextInstance === null) {
    throw new Error("Tried to use InputContext when none exists.");
  }
  return inputContextInstance;
}

// node_modules/dom-helpers/esm/canUseDOM.js
var canUseDOM_default = !!(typeof window !== "undefined" && window.document && window.document.createElement);

// node_modules/dom-helpers/esm/addEventListener.js
var optionsSupported = false;
var onceSupported = false;
try {
  options = {
    get passive() {
      return optionsSupported = true;
    },
    get once() {
      return onceSupported = optionsSupported = true;
    }
  };
  if (canUseDOM_default) {
    window.addEventListener("test", options, options);
    window.removeEventListener("test", options, true);
  }
} catch (e2) {
}
var options;
function addEventListener(node, eventName, handler, options) {
  if (options && typeof options !== "boolean" && !onceSupported) {
    var once = options.once, capture = options.capture;
    var wrappedHandler = handler;
    if (!onceSupported && once) {
      wrappedHandler = handler.__once || function onceHandler(event) {
        this.removeEventListener(eventName, onceHandler, capture);
        handler.call(this, event);
      };
      handler.__once = wrappedHandler;
    }
    node.addEventListener(eventName, wrappedHandler, optionsSupported ? options : capture);
  }
  node.addEventListener(eventName, handler, options);
}
var addEventListener_default = addEventListener;

// node_modules/dom-helpers/esm/removeEventListener.js
function removeEventListener(node, eventName, handler, options) {
  var capture = options && typeof options !== "boolean" ? options.capture : options;
  node.removeEventListener(eventName, handler, capture);
  if (handler.__once) {
    node.removeEventListener(eventName, handler.__once, capture);
  }
}
var removeEventListener_default = removeEventListener;

// node_modules/dom-helpers/esm/listen.js
function listen(node, eventName, handler, options) {
  addEventListener_default(node, eventName, handler, options);
  return function() {
    removeEventListener_default(node, eventName, handler, options);
  };
}
var listen_default = listen;

// node_modules/dom-helpers/esm/ownerDocument.js
function ownerDocument(node) {
  return node && node.ownerDocument || document;
}

// node_modules/@restart/ui/esm/useRootClose.js
var import_react12 = __toESM(require_react());

// node_modules/@restart/hooks/esm/useEventCallback.js
var import_react10 = __toESM(require_react());

// node_modules/@restart/hooks/esm/useCommittedRef.js
var import_react9 = __toESM(require_react());
function useCommittedRef(value) {
  var ref = (0, import_react9.useRef)(value);
  (0, import_react9.useEffect)(function() {
    ref.current = value;
  }, [value]);
  return ref;
}
var useCommittedRef_default = useCommittedRef;

// node_modules/@restart/hooks/esm/useEventCallback.js
function useEventCallback(fn) {
  var ref = useCommittedRef_default(fn);
  return (0, import_react10.useCallback)(function() {
    return ref.current && ref.current.apply(ref, arguments);
  }, [ref]);
}

// node_modules/dom-helpers/esm/contains.js
function contains(context, node) {
  if (context.contains)
    return context.contains(node);
  if (context.compareDocumentPosition)
    return context === node || !!(context.compareDocumentPosition(node) & 16);
}

// node_modules/@restart/ui/esm/useClickOutside.js
var import_react11 = __toESM(require_react());
var import_warning = __toESM(require_warning());
var noop = () => {
};
function isLeftClickEvent(event) {
  return event.button === 0;
}
function isModifiedEvent(event) {
  return !!(event.metaKey || event.altKey || event.ctrlKey || event.shiftKey);
}
var getRefTarget = (ref) => ref && ("current" in ref ? ref.current : ref);
var InitialTriggerEvents = {
  click: "mousedown",
  mouseup: "mousedown",
  pointerup: "pointerdown"
};
function useClickOutside(ref, onClickOutside = noop, {
  disabled,
  clickTrigger = "click"
} = {}) {
  const preventMouseClickOutsideRef = (0, import_react11.useRef)(false);
  const waitingForTrigger = (0, import_react11.useRef)(false);
  const handleMouseCapture = (0, import_react11.useCallback)((e2) => {
    const currentTarget = getRefTarget(ref);
    (0, import_warning.default)(!!currentTarget, "ClickOutside captured a close event but does not have a ref to compare it to. useClickOutside(), should be passed a ref that resolves to a DOM node");
    preventMouseClickOutsideRef.current = !currentTarget || isModifiedEvent(e2) || !isLeftClickEvent(e2) || !!contains(currentTarget, e2.target) || waitingForTrigger.current;
    waitingForTrigger.current = false;
  }, [ref]);
  const handleInitialMouse = useEventCallback((e2) => {
    const currentTarget = getRefTarget(ref);
    if (currentTarget && contains(currentTarget, e2.target)) {
      waitingForTrigger.current = true;
    }
  });
  const handleMouse = useEventCallback((e2) => {
    if (!preventMouseClickOutsideRef.current) {
      onClickOutside(e2);
    }
  });
  (0, import_react11.useEffect)(() => {
    var _ownerWindow$event, _ownerWindow$parent;
    if (disabled || ref == null)
      return void 0;
    const doc = ownerDocument(getRefTarget(ref));
    const ownerWindow = doc.defaultView || window;
    let currentEvent = (_ownerWindow$event = ownerWindow.event) != null ? _ownerWindow$event : (_ownerWindow$parent = ownerWindow.parent) == null ? void 0 : _ownerWindow$parent.event;
    let removeInitialTriggerListener = null;
    if (InitialTriggerEvents[clickTrigger]) {
      removeInitialTriggerListener = listen_default(doc, InitialTriggerEvents[clickTrigger], handleInitialMouse, true);
    }
    const removeMouseCaptureListener = listen_default(doc, clickTrigger, handleMouseCapture, true);
    const removeMouseListener = listen_default(doc, clickTrigger, (e2) => {
      if (e2 === currentEvent) {
        currentEvent = void 0;
        return;
      }
      handleMouse(e2);
    });
    let mobileSafariHackListeners = [];
    if ("ontouchstart" in doc.documentElement) {
      mobileSafariHackListeners = [].slice.call(doc.body.children).map((el) => listen_default(el, "mousemove", noop));
    }
    return () => {
      removeInitialTriggerListener == null ? void 0 : removeInitialTriggerListener();
      removeMouseCaptureListener();
      removeMouseListener();
      mobileSafariHackListeners.forEach((remove) => remove());
    };
  }, [ref, disabled, clickTrigger, handleMouseCapture, handleInitialMouse, handleMouse]);
}
var useClickOutside_default = useClickOutside;

// node_modules/@restart/ui/esm/utils.js
function isEscKey(e2) {
  return e2.code === "Escape" || e2.keyCode === 27;
}

// node_modules/@restart/ui/esm/useRootClose.js
var noop2 = () => {
};
function useRootClose(ref, onRootClose, {
  disabled,
  clickTrigger
} = {}) {
  const onClose = onRootClose || noop2;
  useClickOutside_default(ref, onClose, {
    disabled,
    clickTrigger
  });
  const handleKeyUp = useEventCallback((e2) => {
    if (isEscKey(e2)) {
      onClose(e2);
    }
  });
  (0, import_react12.useEffect)(() => {
    if (disabled || ref == null)
      return void 0;
    const doc = ownerDocument(getRefTarget(ref));
    let currentEvent = (doc.defaultView || window).event;
    const removeKeyupListener = listen_default(doc, "keyup", (e2) => {
      if (e2 === currentEvent) {
        currentEvent = void 0;
        return;
      }
      handleKeyUp(e2);
    });
    return () => {
      removeKeyupListener();
    };
  }, [ref, disabled, handleKeyUp]);
}
var useRootClose_default = useRootClose;

// node_modules/@yext/search-ui-react/lib/esm/components/Dropdown/FocusContext.js
var import_react13 = __toESM(require_react());
var FocusContext = (0, import_react13.createContext)(null);
function useFocusContext() {
  const focusContextInstance = (0, import_react13.useContext)(FocusContext);
  if (focusContextInstance === null) {
    throw new Error("Tried to use FocusContext when none exists.");
  }
  return focusContextInstance;
}

// node_modules/@yext/search-ui-react/lib/esm/components/ScreenReader.js
var import_jsx_runtime6 = __toESM(require_jsx_runtime());
function ScreenReader({ instructionsId, instructions, announcementKey, announcementText }) {
  return (0, import_jsx_runtime6.jsxs)(import_jsx_runtime6.Fragment, { children: [(0, import_jsx_runtime6.jsx)("div", Object.assign({ id: instructionsId, className: "hidden" }, { children: instructions }), void 0), (0, import_jsx_runtime6.jsx)("div", Object.assign({ className: "sr-only", "aria-live": "assertive" }, { children: announcementText }), announcementKey)] }, void 0);
}

// node_modules/@yext/search-ui-react/lib/esm/components/utils/recursivelyMapChildren.js
var import_react14 = __toESM(require_react());
function recursivelyMapChildren(children, elementReplacer) {
  return import_react14.Children.map(children, (c2, index2) => {
    if (!(0, import_react14.isValidElement)(c2)) {
      return c2;
    }
    const replacedElement = elementReplacer(c2, index2);
    if (!replacedElement || !(0, import_react14.isValidElement)(replacedElement)) {
      return replacedElement;
    }
    const grandchildren = replacedElement.props.children;
    if (!grandchildren) {
      return replacedElement;
    }
    const replacedGrandchildren = recursivelyMapChildren(grandchildren, elementReplacer);
    return (0, import_react14.cloneElement)(replacedElement, { children: replacedGrandchildren });
  });
}

// node_modules/@yext/search-ui-react/lib/esm/components/Dropdown/DropdownItem.js
var import_jsx_runtime7 = __toESM(require_jsx_runtime());
var import_react15 = __toESM(require_react());

// node_modules/@yext/search-ui-react/lib/esm/components/Dropdown/generateDropdownId.js
function generateDropdownId(screenReaderUUID, index2) {
  if (!screenReaderUUID)
    return "";
  return screenReaderUUID + "_" + index2;
}

// node_modules/@yext/search-ui-react/lib/esm/components/Dropdown/DropdownItem.js
function DropdownItem(_props) {
  return null;
}
function DropdownItemWithIndex(props) {
  const { children, value, index: index2, className, focusedClassName, itemData, onClick, ariaLabel } = props;
  const { toggleDropdown, onSelect, screenReaderUUID } = useDropdownContext();
  const { focusedIndex, updateFocusedItem } = useFocusContext();
  const { setValue, setLastTypedOrSubmittedValue } = useInputContext();
  const isFocused = focusedIndex === index2;
  const handleClick = (0, import_react15.useCallback)(() => {
    toggleDropdown(false);
    updateFocusedItem(-1);
    setLastTypedOrSubmittedValue(value);
    setValue(value);
    onSelect === null || onSelect === void 0 ? void 0 : onSelect(value, index2, itemData);
    onClick === null || onClick === void 0 ? void 0 : onClick(value, index2, itemData);
  }, [
    index2,
    itemData,
    onClick,
    onSelect,
    setLastTypedOrSubmittedValue,
    setValue,
    toggleDropdown,
    updateFocusedItem,
    value
  ]);
  return (0, import_jsx_runtime7.jsx)("div", Object.assign({ id: generateDropdownId(screenReaderUUID, index2), tabIndex: 0, className: isFocused ? focusedClassName : className, onClick: handleClick, "aria-label": typeof ariaLabel === "function" ? ariaLabel(value) : ariaLabel }, { children }), void 0);
}

// node_modules/use-isomorphic-layout-effect/dist/use-isomorphic-layout-effect.browser.esm.js
var import_react16 = __toESM(require_react());
var index = import_react16.useLayoutEffect;
var use_isomorphic_layout_effect_browser_esm_default = index;

// node_modules/@reach/auto-id/dist/reach-auto-id.mjs
var React2 = __toESM(require_react(), 1);

// node_modules/@reach/utils/dist/reach-utils.mjs
var import_react17 = __toESM(require_react(), 1);
var import_react18 = __toESM(require_react(), 1);
var React = __toESM(require_react(), 1);
var import_react19 = __toESM(require_react(), 1);
var import_react20 = __toESM(require_react(), 1);
var import_react21 = __toESM(require_react(), 1);
var import_react22 = __toESM(require_react(), 1);
var import_react23 = __toESM(require_react(), 1);
var import_react24 = __toESM(require_react(), 1);
var import_react25 = __toESM(require_react(), 1);
var import_react26 = __toESM(require_react(), 1);
var import_react27 = __toESM(require_react(), 1);
var import_react28 = __toESM(require_react(), 1);
var import_react29 = __toESM(require_react(), 1);
var import_react30 = __toESM(require_react(), 1);
function canUseDOM() {
  return !!(typeof window !== "undefined" && window.document && window.document.createElement);
}
var useIsomorphicLayoutEffect = canUseDOM() ? import_react25.useLayoutEffect : import_react25.useEffect;

// node_modules/@reach/auto-id/dist/reach-auto-id.mjs
var serverHandoffComplete = false;
var id = 0;
function genId() {
  return ++id;
}
var maybeReactUseId = React2["useId".toString()];
function useId(providedId) {
  var _a;
  if (maybeReactUseId !== void 0) {
    let generatedId = maybeReactUseId();
    return providedId != null ? providedId : generatedId;
  }
  let initialId = providedId != null ? providedId : serverHandoffComplete ? genId() : null;
  let [id2, setId] = React2.useState(initialId);
  useIsomorphicLayoutEffect(() => {
    if (id2 === null) {
      setId(genId());
    }
  }, []);
  React2.useEffect(() => {
    if (serverHandoffComplete === false) {
      serverHandoffComplete = true;
    }
  }, []);
  return (_a = providedId != null ? providedId : id2) != null ? _a : void 0;
}

// node_modules/@yext/search-ui-react/lib/esm/components/Dropdown/Dropdown.js
function Dropdown(props) {
  const { children, screenReaderText, screenReaderInstructions = "When autocomplete results are available, use up and down arrows to review and enter to select.", onSelect, onToggle, className, activeClassName, parentQuery, alwaysSelectOption = false } = props;
  const containerRef = (0, import_react31.useRef)(null);
  const screenReaderUUID = useId();
  const [screenReaderKey, setScreenReaderKey] = (0, import_react31.useState)(0);
  const [hasTyped, setHasTyped] = (0, import_react31.useState)(false);
  const [childrenWithDropdownItemsTransformed, items] = (0, import_react31.useMemo)(() => {
    return getTransformedChildrenAndItemData(children);
  }, [children]);
  const inputContext = useInputContextInstance();
  const { value, setValue, lastTypedOrSubmittedValue, setLastTypedOrSubmittedValue } = inputContext;
  const focusContext = useFocusContextInstance(items, lastTypedOrSubmittedValue, setValue, screenReaderKey, setScreenReaderKey, alwaysSelectOption);
  const { focusedIndex, focusedItemData, updateFocusedItem } = focusContext;
  const dropdownContext = useDropdownContextInstance(lastTypedOrSubmittedValue, value, focusedIndex, focusedItemData, screenReaderUUID, setHasTyped, onToggle, onSelect);
  const { toggleDropdown, isActive } = dropdownContext;
  use_isomorphic_layout_effect_browser_esm_default(() => {
    if (parentQuery !== void 0 && parentQuery !== lastTypedOrSubmittedValue) {
      setLastTypedOrSubmittedValue(parentQuery);
      updateFocusedItem(-1, parentQuery);
    }
  }, [
    parentQuery,
    lastTypedOrSubmittedValue,
    updateFocusedItem,
    setLastTypedOrSubmittedValue
  ]);
  useRootClose_default(containerRef, () => {
    toggleDropdown(false);
  }, { disabled: !isActive });
  function handleKeyDown(e2) {
    if (!isActive) {
      return;
    }
    if (e2.key === "ArrowDown" || e2.key === "ArrowUp") {
      e2.preventDefault();
    }
    if (e2.key === "ArrowDown") {
      if (alwaysSelectOption && focusedIndex === items.length - 1) {
        updateFocusedItem(0);
      } else {
        updateFocusedItem(focusedIndex + 1);
      }
    } else if (e2.key === "ArrowUp") {
      if (alwaysSelectOption && focusedIndex === 0) {
        updateFocusedItem(items.length - 1);
      } else {
        updateFocusedItem(focusedIndex - 1);
      }
    } else if (e2.key === "Tab" && !e2.shiftKey) {
      if (items.length !== 0) {
        if (focusedIndex >= items.length - 1) {
          updateFocusedItem(-1);
          toggleDropdown(false);
        } else {
          updateFocusedItem(focusedIndex + 1);
          e2.preventDefault();
        }
      }
    } else if (e2.key === "Tab" && e2.shiftKey) {
      if (focusedIndex > 0 || !alwaysSelectOption && focusedIndex === 0) {
        updateFocusedItem(focusedIndex - 1);
        e2.preventDefault();
      } else {
        updateFocusedItem(-1);
        toggleDropdown(false);
      }
    } else if (!hasTyped) {
      setHasTyped(true);
    }
  }
  return (0, import_jsx_runtime8.jsxs)("div", Object.assign({ ref: containerRef, className: isActive ? activeClassName : className, onKeyDown: handleKeyDown }, { children: [(0, import_jsx_runtime8.jsx)(DropdownContext.Provider, Object.assign({ value: dropdownContext }, { children: (0, import_jsx_runtime8.jsx)(InputContext.Provider, Object.assign({ value: inputContext }, { children: (0, import_jsx_runtime8.jsx)(FocusContext.Provider, Object.assign({ value: focusContext }, { children: childrenWithDropdownItemsTransformed }), void 0) }), void 0) }), void 0), (0, import_jsx_runtime8.jsx)(ScreenReader, { announcementKey: screenReaderKey, announcementText: isActive && (hasTyped || items.length || value) ? screenReaderText : "", instructionsId: screenReaderUUID, instructions: screenReaderInstructions }, void 0)] }), void 0);
}
function useInputContextInstance() {
  const [value, setValue] = (0, import_react31.useState)("");
  const [lastTypedOrSubmittedValue, setLastTypedOrSubmittedValue] = (0, import_react31.useState)("");
  return {
    value,
    setValue,
    lastTypedOrSubmittedValue,
    setLastTypedOrSubmittedValue
  };
}
function useFocusContextInstance(items, lastTypedOrSubmittedValue, setValue, screenReaderKey, setScreenReaderKey, alwaysSelectOption) {
  const [focusedIndex, setFocusedIndex] = (0, import_react31.useState)(-1);
  const [focusedValue, setFocusedValue] = (0, import_react31.useState)(null);
  const [focusedItemData, setFocusedItemData] = (0, import_react31.useState)(void 0);
  (0, import_react31.useEffect)(() => {
    if (alwaysSelectOption) {
      if (items.length > 0) {
        const index2 = focusedIndex === -1 || focusedIndex >= items.length ? 0 : focusedIndex;
        setFocusedIndex(index2);
        setFocusedValue(items[index2].value);
        setFocusedItemData(items[index2].itemData);
      } else {
        setFocusedIndex(-1);
        setFocusedValue(null);
        setFocusedItemData(void 0);
      }
    }
  }, [alwaysSelectOption, focusedIndex, items]);
  function updateFocusedItem(updatedFocusedIndex, value) {
    const numItems = items.length;
    let updatedValue;
    if (updatedFocusedIndex === -1 || updatedFocusedIndex >= numItems || numItems === 0) {
      updatedValue = value !== null && value !== void 0 ? value : lastTypedOrSubmittedValue;
      if (alwaysSelectOption && numItems !== 0) {
        setFocusedIndex(0);
        setFocusedItemData(items[0].itemData);
        setScreenReaderKey(screenReaderKey + 1);
      } else {
        setFocusedIndex(-1);
        setFocusedItemData(void 0);
        setScreenReaderKey(screenReaderKey + 1);
      }
    } else if (updatedFocusedIndex < -1) {
      const loopedAroundIndex = (numItems + updatedFocusedIndex + 1) % numItems;
      updatedValue = value !== null && value !== void 0 ? value : items[loopedAroundIndex].value;
      setFocusedIndex(loopedAroundIndex);
      setFocusedItemData(items[loopedAroundIndex].itemData);
    } else {
      updatedValue = value !== null && value !== void 0 ? value : items[updatedFocusedIndex].value;
      setFocusedIndex(updatedFocusedIndex);
      setFocusedItemData(items[updatedFocusedIndex].itemData);
    }
    setFocusedValue(updatedValue);
    setValue(alwaysSelectOption ? value !== null && value !== void 0 ? value : lastTypedOrSubmittedValue : updatedValue);
  }
  return {
    focusedIndex,
    focusedValue,
    focusedItemData,
    updateFocusedItem
  };
}
function useDropdownContextInstance(prevValue, value, index2, focusedItemData, screenReaderUUID, setHasTyped, onToggle, onSelect) {
  const [isActive, _toggleDropdown] = (0, import_react31.useState)(false);
  const toggleDropdown = (willBeOpen) => {
    if (!willBeOpen) {
      setHasTyped(false);
    }
    _toggleDropdown(willBeOpen);
    onToggle === null || onToggle === void 0 ? void 0 : onToggle(willBeOpen, prevValue, value, index2, focusedItemData);
  };
  return {
    isActive,
    toggleDropdown,
    onSelect,
    screenReaderUUID
  };
}
function getTransformedChildrenAndItemData(children) {
  const items = [];
  const childrenWithDropdownItemsTransformed = recursivelyMapChildren(children, (child) => {
    if (!((0, import_react31.isValidElement)(child) && child.type === DropdownItem)) {
      return child;
    }
    const props = child.props;
    items.push({
      value: props.value,
      itemData: props.itemData
    });
    const transformedItem = (0, import_react31.createElement)(DropdownItemWithIndex, Object.assign(Object.assign({}, props), { index: items.length - 1 }));
    return transformedItem;
  });
  return [childrenWithDropdownItemsTransformed, items];
}

// node_modules/@yext/search-ui-react/lib/esm/components/Dropdown/DropdownInput.js
var import_jsx_runtime9 = __toESM(require_jsx_runtime());
var import_react32 = __toESM(require_react());
function DropdownInput(props) {
  const { className, placeholder, ariaLabel, onSubmit, onFocus, onChange, submitCriteria } = props;
  const inputRef = (0, import_react32.useRef)(null);
  const { toggleDropdown, onSelect, screenReaderUUID } = useDropdownContext();
  const { value = "", setLastTypedOrSubmittedValue } = useInputContext();
  const { focusedIndex = -1, focusedItemData, focusedValue, updateFocusedItem } = useFocusContext();
  const [isTyping, setIsTyping] = (0, import_react32.useState)(true);
  const handleChange = (0, import_react32.useCallback)((e2) => {
    setIsTyping(true);
    toggleDropdown(true);
    onChange === null || onChange === void 0 ? void 0 : onChange(e2.target.value);
    updateFocusedItem(-1, e2.target.value);
    setLastTypedOrSubmittedValue(e2.target.value);
  }, [onChange, setLastTypedOrSubmittedValue, toggleDropdown, updateFocusedItem]);
  const handleKeyDown = (0, import_react32.useCallback)((e2) => {
    var _a;
    if (e2.key === "ArrowDown" || e2.key === "ArrowUp" || e2.key === "Tab") {
      setIsTyping(false);
    }
    if (e2.key === "Enter" && (!submitCriteria || submitCriteria(focusedIndex))) {
      updateFocusedItem(focusedIndex);
      toggleDropdown(false);
      (_a = inputRef.current) === null || _a === void 0 ? void 0 : _a.blur();
      onSubmit === null || onSubmit === void 0 ? void 0 : onSubmit(value, focusedIndex, focusedItemData);
      if (focusedIndex >= 0) {
        onSelect === null || onSelect === void 0 ? void 0 : onSelect(value, focusedIndex, focusedItemData);
      }
      updateFocusedItem(-1, focusedValue !== null && focusedValue !== void 0 ? focusedValue : void 0);
    }
  }, [
    focusedIndex,
    focusedValue,
    focusedItemData,
    onSelect,
    onSubmit,
    submitCriteria,
    toggleDropdown,
    updateFocusedItem,
    value
  ]);
  const handleFocus = (0, import_react32.useCallback)(() => {
    toggleDropdown(true);
    updateFocusedItem(-1);
    onFocus === null || onFocus === void 0 ? void 0 : onFocus(value);
  }, [onFocus, toggleDropdown, updateFocusedItem, value]);
  return (0, import_jsx_runtime9.jsx)("input", { ref: inputRef, className, placeholder, value, onChange: handleChange, onKeyDown: handleKeyDown, onFocus: handleFocus, id: generateDropdownId(screenReaderUUID, -1), autoComplete: "off", "aria-describedby": screenReaderUUID, "aria-activedescendant": isTyping ? "" : generateDropdownId(screenReaderUUID, focusedIndex), "aria-label": ariaLabel }, void 0);
}

// node_modules/@yext/search-ui-react/lib/esm/components/Dropdown/DropdownMenu.js
var import_jsx_runtime10 = __toESM(require_jsx_runtime());
function DropdownMenu({ children }) {
  const { isActive } = useDropdownContext();
  if (!isActive) {
    return null;
  }
  return (0, import_jsx_runtime10.jsx)(import_jsx_runtime10.Fragment, { children }, void 0);
}

// node_modules/@yext/search-ui-react/lib/esm/hooks/useComposedCssClasses.js
var import_react33 = __toESM(require_react());

// node_modules/tailwind-merge/dist/lib/tw-join.mjs
function twJoin() {
  var index2 = 0;
  var argument;
  var resolvedValue;
  var string = "";
  while (index2 < arguments.length) {
    if (argument = arguments[index2++]) {
      if (resolvedValue = toValue(argument)) {
        string && (string += " ");
        string += resolvedValue;
      }
    }
  }
  return string;
}
function toValue(mix) {
  if (typeof mix === "string") {
    return mix;
  }
  var resolvedValue;
  var string = "";
  for (var k = 0; k < mix.length; k++) {
    if (mix[k]) {
      if (resolvedValue = toValue(mix[k])) {
        string && (string += " ");
        string += resolvedValue;
      }
    }
  }
  return string;
}

// node_modules/tailwind-merge/dist/lib/class-utils.mjs
var CLASS_PART_SEPARATOR = "-";
function createClassUtils(config) {
  var classMap = createClassMap(config);
  var conflictingClassGroups = config.conflictingClassGroups, _config$conflictingCl = config.conflictingClassGroupModifiers, conflictingClassGroupModifiers = _config$conflictingCl === void 0 ? {} : _config$conflictingCl;
  function getClassGroupId(className) {
    var classParts = className.split(CLASS_PART_SEPARATOR);
    if (classParts[0] === "" && classParts.length !== 1) {
      classParts.shift();
    }
    return getGroupRecursive(classParts, classMap) || getGroupIdForArbitraryProperty(className);
  }
  function getConflictingClassGroupIds(classGroupId, hasPostfixModifier) {
    var conflicts = conflictingClassGroups[classGroupId] || [];
    if (hasPostfixModifier && conflictingClassGroupModifiers[classGroupId]) {
      return [].concat(conflicts, conflictingClassGroupModifiers[classGroupId]);
    }
    return conflicts;
  }
  return {
    getClassGroupId,
    getConflictingClassGroupIds
  };
}
function getGroupRecursive(classParts, classPartObject) {
  var _a;
  if (classParts.length === 0) {
    return classPartObject.classGroupId;
  }
  var currentClassPart = classParts[0];
  var nextClassPartObject = classPartObject.nextPart.get(currentClassPart);
  var classGroupFromNextClassPart = nextClassPartObject ? getGroupRecursive(classParts.slice(1), nextClassPartObject) : void 0;
  if (classGroupFromNextClassPart) {
    return classGroupFromNextClassPart;
  }
  if (classPartObject.validators.length === 0) {
    return void 0;
  }
  var classRest = classParts.join(CLASS_PART_SEPARATOR);
  return (_a = classPartObject.validators.find(function(_ref) {
    var validator = _ref.validator;
    return validator(classRest);
  })) == null ? void 0 : _a.classGroupId;
}
var arbitraryPropertyRegex = /^\[(.+)\]$/;
function getGroupIdForArbitraryProperty(className) {
  if (arbitraryPropertyRegex.test(className)) {
    var arbitraryPropertyClassName = arbitraryPropertyRegex.exec(className)[1];
    var property = arbitraryPropertyClassName == null ? void 0 : arbitraryPropertyClassName.substring(0, arbitraryPropertyClassName.indexOf(":"));
    if (property) {
      return "arbitrary.." + property;
    }
  }
}
function createClassMap(config) {
  var theme = config.theme, prefix = config.prefix;
  var classMap = {
    nextPart: /* @__PURE__ */ new Map(),
    validators: []
  };
  var prefixedClassGroupEntries = getPrefixedClassGroupEntries(Object.entries(config.classGroups), prefix);
  prefixedClassGroupEntries.forEach(function(_ref2) {
    var classGroupId = _ref2[0], classGroup = _ref2[1];
    processClassesRecursively(classGroup, classMap, classGroupId, theme);
  });
  return classMap;
}
function processClassesRecursively(classGroup, classPartObject, classGroupId, theme) {
  classGroup.forEach(function(classDefinition) {
    if (typeof classDefinition === "string") {
      var classPartObjectToEdit = classDefinition === "" ? classPartObject : getPart(classPartObject, classDefinition);
      classPartObjectToEdit.classGroupId = classGroupId;
      return;
    }
    if (typeof classDefinition === "function") {
      if (isThemeGetter(classDefinition)) {
        processClassesRecursively(classDefinition(theme), classPartObject, classGroupId, theme);
        return;
      }
      classPartObject.validators.push({
        validator: classDefinition,
        classGroupId
      });
      return;
    }
    Object.entries(classDefinition).forEach(function(_ref3) {
      var key = _ref3[0], classGroup2 = _ref3[1];
      processClassesRecursively(classGroup2, getPart(classPartObject, key), classGroupId, theme);
    });
  });
}
function getPart(classPartObject, path) {
  var currentClassPartObject = classPartObject;
  path.split(CLASS_PART_SEPARATOR).forEach(function(pathPart) {
    if (!currentClassPartObject.nextPart.has(pathPart)) {
      currentClassPartObject.nextPart.set(pathPart, {
        nextPart: /* @__PURE__ */ new Map(),
        validators: []
      });
    }
    currentClassPartObject = currentClassPartObject.nextPart.get(pathPart);
  });
  return currentClassPartObject;
}
function isThemeGetter(func) {
  return func.isThemeGetter;
}
function getPrefixedClassGroupEntries(classGroupEntries, prefix) {
  if (!prefix) {
    return classGroupEntries;
  }
  return classGroupEntries.map(function(_ref4) {
    var classGroupId = _ref4[0], classGroup = _ref4[1];
    var prefixedClassGroup = classGroup.map(function(classDefinition) {
      if (typeof classDefinition === "string") {
        return prefix + classDefinition;
      }
      if (typeof classDefinition === "object") {
        return Object.fromEntries(Object.entries(classDefinition).map(function(_ref5) {
          var key = _ref5[0], value = _ref5[1];
          return [prefix + key, value];
        }));
      }
      return classDefinition;
    });
    return [classGroupId, prefixedClassGroup];
  });
}

// node_modules/tailwind-merge/dist/lib/lru-cache.mjs
function createLruCache(maxCacheSize) {
  if (maxCacheSize < 1) {
    return {
      get: function get() {
        return void 0;
      },
      set: function set() {
      }
    };
  }
  var cacheSize = 0;
  var cache = /* @__PURE__ */ new Map();
  var previousCache = /* @__PURE__ */ new Map();
  function update(key, value) {
    cache.set(key, value);
    cacheSize++;
    if (cacheSize > maxCacheSize) {
      cacheSize = 0;
      previousCache = cache;
      cache = /* @__PURE__ */ new Map();
    }
  }
  return {
    get: function get(key) {
      var value = cache.get(key);
      if (value !== void 0) {
        return value;
      }
      if ((value = previousCache.get(key)) !== void 0) {
        update(key, value);
        return value;
      }
    },
    set: function set(key, value) {
      if (cache.has(key)) {
        cache.set(key, value);
      } else {
        update(key, value);
      }
    }
  };
}

// node_modules/tailwind-merge/dist/lib/modifier-utils.mjs
var IMPORTANT_MODIFIER = "!";
function createSplitModifiers(config) {
  var separator = config.separator || ":";
  var isSeparatorSingleCharacter = separator.length === 1;
  var firstSeparatorCharacter = separator[0];
  var separatorLength = separator.length;
  return function splitModifiers(className) {
    var modifiers = [];
    var bracketDepth = 0;
    var modifierStart = 0;
    var postfixModifierPosition;
    for (var index2 = 0; index2 < className.length; index2++) {
      var currentCharacter = className[index2];
      if (bracketDepth === 0) {
        if (currentCharacter === firstSeparatorCharacter && (isSeparatorSingleCharacter || className.slice(index2, index2 + separatorLength) === separator)) {
          modifiers.push(className.slice(modifierStart, index2));
          modifierStart = index2 + separatorLength;
          continue;
        }
        if (currentCharacter === "/") {
          postfixModifierPosition = index2;
          continue;
        }
      }
      if (currentCharacter === "[") {
        bracketDepth++;
      } else if (currentCharacter === "]") {
        bracketDepth--;
      }
    }
    var baseClassNameWithImportantModifier = modifiers.length === 0 ? className : className.substring(modifierStart);
    var hasImportantModifier = baseClassNameWithImportantModifier.startsWith(IMPORTANT_MODIFIER);
    var baseClassName = hasImportantModifier ? baseClassNameWithImportantModifier.substring(1) : baseClassNameWithImportantModifier;
    var maybePostfixModifierPosition = postfixModifierPosition && postfixModifierPosition > modifierStart ? postfixModifierPosition - modifierStart : void 0;
    return {
      modifiers,
      hasImportantModifier,
      baseClassName,
      maybePostfixModifierPosition
    };
  };
}
function sortModifiers(modifiers) {
  if (modifiers.length <= 1) {
    return modifiers;
  }
  var sortedModifiers = [];
  var unsortedModifiers = [];
  modifiers.forEach(function(modifier) {
    var isArbitraryVariant = modifier[0] === "[";
    if (isArbitraryVariant) {
      sortedModifiers.push.apply(sortedModifiers, unsortedModifiers.sort().concat([modifier]));
      unsortedModifiers = [];
    } else {
      unsortedModifiers.push(modifier);
    }
  });
  sortedModifiers.push.apply(sortedModifiers, unsortedModifiers.sort());
  return sortedModifiers;
}

// node_modules/tailwind-merge/dist/lib/config-utils.mjs
function createConfigUtils(config) {
  return {
    cache: createLruCache(config.cacheSize),
    splitModifiers: createSplitModifiers(config),
    ...createClassUtils(config)
  };
}

// node_modules/tailwind-merge/dist/lib/merge-classlist.mjs
var SPLIT_CLASSES_REGEX = /\s+/;
function mergeClassList(classList, configUtils) {
  var splitModifiers = configUtils.splitModifiers, getClassGroupId = configUtils.getClassGroupId, getConflictingClassGroupIds = configUtils.getConflictingClassGroupIds;
  var classGroupsInConflict = /* @__PURE__ */ new Set();
  return classList.trim().split(SPLIT_CLASSES_REGEX).map(function(originalClassName) {
    var _splitModifiers = splitModifiers(originalClassName), modifiers = _splitModifiers.modifiers, hasImportantModifier = _splitModifiers.hasImportantModifier, baseClassName = _splitModifiers.baseClassName, maybePostfixModifierPosition = _splitModifiers.maybePostfixModifierPosition;
    var classGroupId = getClassGroupId(maybePostfixModifierPosition ? baseClassName.substring(0, maybePostfixModifierPosition) : baseClassName);
    var hasPostfixModifier = Boolean(maybePostfixModifierPosition);
    if (!classGroupId) {
      if (!maybePostfixModifierPosition) {
        return {
          isTailwindClass: false,
          originalClassName
        };
      }
      classGroupId = getClassGroupId(baseClassName);
      if (!classGroupId) {
        return {
          isTailwindClass: false,
          originalClassName
        };
      }
      hasPostfixModifier = false;
    }
    var variantModifier = sortModifiers(modifiers).join(":");
    var modifierId = hasImportantModifier ? variantModifier + IMPORTANT_MODIFIER : variantModifier;
    return {
      isTailwindClass: true,
      modifierId,
      classGroupId,
      originalClassName,
      hasPostfixModifier
    };
  }).reverse().filter(function(parsed) {
    if (!parsed.isTailwindClass) {
      return true;
    }
    var modifierId = parsed.modifierId, classGroupId = parsed.classGroupId, hasPostfixModifier = parsed.hasPostfixModifier;
    var classId = modifierId + classGroupId;
    if (classGroupsInConflict.has(classId)) {
      return false;
    }
    classGroupsInConflict.add(classId);
    getConflictingClassGroupIds(classGroupId, hasPostfixModifier).forEach(function(group) {
      return classGroupsInConflict.add(modifierId + group);
    });
    return true;
  }).reverse().map(function(parsed) {
    return parsed.originalClassName;
  }).join(" ");
}

// node_modules/tailwind-merge/dist/lib/create-tailwind-merge.mjs
function createTailwindMerge() {
  for (var _len = arguments.length, createConfig = new Array(_len), _key = 0; _key < _len; _key++) {
    createConfig[_key] = arguments[_key];
  }
  var configUtils;
  var cacheGet;
  var cacheSet;
  var functionToCall = initTailwindMerge;
  function initTailwindMerge(classList) {
    var firstCreateConfig = createConfig[0], restCreateConfig = createConfig.slice(1);
    var config = restCreateConfig.reduce(function(previousConfig, createConfigCurrent) {
      return createConfigCurrent(previousConfig);
    }, firstCreateConfig());
    configUtils = createConfigUtils(config);
    cacheGet = configUtils.cache.get;
    cacheSet = configUtils.cache.set;
    functionToCall = tailwindMerge;
    return tailwindMerge(classList);
  }
  function tailwindMerge(classList) {
    var cachedResult = cacheGet(classList);
    if (cachedResult) {
      return cachedResult;
    }
    var result = mergeClassList(classList, configUtils);
    cacheSet(classList, result);
    return result;
  }
  return function callTailwindMerge() {
    return functionToCall(twJoin.apply(null, arguments));
  };
}

// node_modules/tailwind-merge/dist/lib/from-theme.mjs
function fromTheme(key) {
  var themeGetter = function themeGetter2(theme) {
    return theme[key] || [];
  };
  themeGetter.isThemeGetter = true;
  return themeGetter;
}

// node_modules/tailwind-merge/dist/lib/validators.mjs
var arbitraryValueRegex = /^\[(?:([a-z-]+):)?(.+)\]$/i;
var fractionRegex = /^\d+\/\d+$/;
var stringLengths = /* @__PURE__ */ new Set(["px", "full", "screen"]);
var tshirtUnitRegex = /^(\d+(\.\d+)?)?(xs|sm|md|lg|xl)$/;
var lengthUnitRegex = /\d+(%|px|r?em|[sdl]?v([hwib]|min|max)|pt|pc|in|cm|mm|cap|ch|ex|r?lh|cq(w|h|i|b|min|max))|^0$/;
var shadowRegex = /^-?((\d+)?\.?(\d+)[a-z]+|0)_-?((\d+)?\.?(\d+)[a-z]+|0)/;
function isLength(value) {
  return isNumber(value) || stringLengths.has(value) || fractionRegex.test(value) || isArbitraryLength(value);
}
function isArbitraryLength(value) {
  return getIsArbitraryValue(value, "length", isLengthOnly);
}
function isArbitrarySize(value) {
  return getIsArbitraryValue(value, "size", isNever);
}
function isArbitraryPosition(value) {
  return getIsArbitraryValue(value, "position", isNever);
}
function isArbitraryUrl(value) {
  return getIsArbitraryValue(value, "url", isUrl);
}
function isArbitraryNumber(value) {
  return getIsArbitraryValue(value, "number", isNumber);
}
function isNumber(value) {
  return !Number.isNaN(Number(value));
}
function isPercent(value) {
  return value.endsWith("%") && isNumber(value.slice(0, -1));
}
function isInteger(value) {
  return isIntegerOnly(value) || getIsArbitraryValue(value, "number", isIntegerOnly);
}
function isArbitraryValue(value) {
  return arbitraryValueRegex.test(value);
}
function isAny() {
  return true;
}
function isTshirtSize(value) {
  return tshirtUnitRegex.test(value);
}
function isArbitraryShadow(value) {
  return getIsArbitraryValue(value, "", isShadow);
}
function getIsArbitraryValue(value, label, testValue) {
  var result = arbitraryValueRegex.exec(value);
  if (result) {
    if (result[1]) {
      return result[1] === label;
    }
    return testValue(result[2]);
  }
  return false;
}
function isLengthOnly(value) {
  return lengthUnitRegex.test(value);
}
function isNever() {
  return false;
}
function isUrl(value) {
  return value.startsWith("url(");
}
function isIntegerOnly(value) {
  return Number.isInteger(Number(value));
}
function isShadow(value) {
  return shadowRegex.test(value);
}

// node_modules/tailwind-merge/dist/lib/default-config.mjs
function getDefaultConfig() {
  var colors = fromTheme("colors");
  var spacing = fromTheme("spacing");
  var blur = fromTheme("blur");
  var brightness = fromTheme("brightness");
  var borderColor = fromTheme("borderColor");
  var borderRadius = fromTheme("borderRadius");
  var borderSpacing = fromTheme("borderSpacing");
  var borderWidth = fromTheme("borderWidth");
  var contrast = fromTheme("contrast");
  var grayscale = fromTheme("grayscale");
  var hueRotate = fromTheme("hueRotate");
  var invert = fromTheme("invert");
  var gap = fromTheme("gap");
  var gradientColorStops = fromTheme("gradientColorStops");
  var gradientColorStopPositions = fromTheme("gradientColorStopPositions");
  var inset = fromTheme("inset");
  var margin = fromTheme("margin");
  var opacity = fromTheme("opacity");
  var padding = fromTheme("padding");
  var saturate = fromTheme("saturate");
  var scale = fromTheme("scale");
  var sepia = fromTheme("sepia");
  var skew = fromTheme("skew");
  var space = fromTheme("space");
  var translate = fromTheme("translate");
  var getOverscroll = function getOverscroll2() {
    return ["auto", "contain", "none"];
  };
  var getOverflow = function getOverflow2() {
    return ["auto", "hidden", "clip", "visible", "scroll"];
  };
  var getSpacingWithAuto = function getSpacingWithAuto2() {
    return ["auto", spacing];
  };
  var getLengthWithEmpty = function getLengthWithEmpty2() {
    return ["", isLength];
  };
  var getNumberWithAutoAndArbitrary = function getNumberWithAutoAndArbitrary2() {
    return ["auto", isNumber, isArbitraryValue];
  };
  var getPositions = function getPositions2() {
    return ["bottom", "center", "left", "left-bottom", "left-top", "right", "right-bottom", "right-top", "top"];
  };
  var getLineStyles = function getLineStyles2() {
    return ["solid", "dashed", "dotted", "double", "none"];
  };
  var getBlendModes = function getBlendModes2() {
    return ["normal", "multiply", "screen", "overlay", "darken", "lighten", "color-dodge", "color-burn", "hard-light", "soft-light", "difference", "exclusion", "hue", "saturation", "color", "luminosity", "plus-lighter"];
  };
  var getAlign = function getAlign2() {
    return ["start", "end", "center", "between", "around", "evenly", "stretch"];
  };
  var getZeroAndEmpty = function getZeroAndEmpty2() {
    return ["", "0", isArbitraryValue];
  };
  var getBreaks = function getBreaks2() {
    return ["auto", "avoid", "all", "avoid-page", "page", "left", "right", "column"];
  };
  var getNumber = function getNumber2() {
    return [isNumber, isArbitraryNumber];
  };
  var getNumberAndArbitrary = function getNumberAndArbitrary2() {
    return [isNumber, isArbitraryValue];
  };
  return {
    cacheSize: 500,
    theme: {
      colors: [isAny],
      spacing: [isLength],
      blur: ["none", "", isTshirtSize, isArbitraryLength],
      brightness: getNumber(),
      borderColor: [colors],
      borderRadius: ["none", "", "full", isTshirtSize, isArbitraryLength],
      borderSpacing: [spacing],
      borderWidth: getLengthWithEmpty(),
      contrast: getNumber(),
      grayscale: getZeroAndEmpty(),
      hueRotate: getNumberAndArbitrary(),
      invert: getZeroAndEmpty(),
      gap: [spacing],
      gradientColorStops: [colors],
      gradientColorStopPositions: [isPercent, isArbitraryLength],
      inset: getSpacingWithAuto(),
      margin: getSpacingWithAuto(),
      opacity: getNumber(),
      padding: [spacing],
      saturate: getNumber(),
      scale: getNumber(),
      sepia: getZeroAndEmpty(),
      skew: getNumberAndArbitrary(),
      space: [spacing],
      translate: [spacing]
    },
    classGroups: {
      aspect: [{
        aspect: ["auto", "square", "video", isArbitraryValue]
      }],
      container: ["container"],
      columns: [{
        columns: [isTshirtSize]
      }],
      "break-after": [{
        "break-after": getBreaks()
      }],
      "break-before": [{
        "break-before": getBreaks()
      }],
      "break-inside": [{
        "break-inside": ["auto", "avoid", "avoid-page", "avoid-column"]
      }],
      "box-decoration": [{
        "box-decoration": ["slice", "clone"]
      }],
      box: [{
        box: ["border", "content"]
      }],
      display: ["block", "inline-block", "inline", "flex", "inline-flex", "table", "inline-table", "table-caption", "table-cell", "table-column", "table-column-group", "table-footer-group", "table-header-group", "table-row-group", "table-row", "flow-root", "grid", "inline-grid", "contents", "list-item", "hidden"],
      "float": [{
        "float": ["right", "left", "none"]
      }],
      clear: [{
        clear: ["left", "right", "both", "none"]
      }],
      isolation: ["isolate", "isolation-auto"],
      "object-fit": [{
        object: ["contain", "cover", "fill", "none", "scale-down"]
      }],
      "object-position": [{
        object: [].concat(getPositions(), [isArbitraryValue])
      }],
      overflow: [{
        overflow: getOverflow()
      }],
      "overflow-x": [{
        "overflow-x": getOverflow()
      }],
      "overflow-y": [{
        "overflow-y": getOverflow()
      }],
      overscroll: [{
        overscroll: getOverscroll()
      }],
      "overscroll-x": [{
        "overscroll-x": getOverscroll()
      }],
      "overscroll-y": [{
        "overscroll-y": getOverscroll()
      }],
      position: ["static", "fixed", "absolute", "relative", "sticky"],
      inset: [{
        inset: [inset]
      }],
      "inset-x": [{
        "inset-x": [inset]
      }],
      "inset-y": [{
        "inset-y": [inset]
      }],
      start: [{
        start: [inset]
      }],
      end: [{
        end: [inset]
      }],
      top: [{
        top: [inset]
      }],
      right: [{
        right: [inset]
      }],
      bottom: [{
        bottom: [inset]
      }],
      left: [{
        left: [inset]
      }],
      visibility: ["visible", "invisible", "collapse"],
      z: [{
        z: ["auto", isInteger]
      }],
      basis: [{
        basis: getSpacingWithAuto()
      }],
      "flex-direction": [{
        flex: ["row", "row-reverse", "col", "col-reverse"]
      }],
      "flex-wrap": [{
        flex: ["wrap", "wrap-reverse", "nowrap"]
      }],
      flex: [{
        flex: ["1", "auto", "initial", "none", isArbitraryValue]
      }],
      grow: [{
        grow: getZeroAndEmpty()
      }],
      shrink: [{
        shrink: getZeroAndEmpty()
      }],
      order: [{
        order: ["first", "last", "none", isInteger]
      }],
      "grid-cols": [{
        "grid-cols": [isAny]
      }],
      "col-start-end": [{
        col: ["auto", {
          span: [isInteger]
        }, isArbitraryValue]
      }],
      "col-start": [{
        "col-start": getNumberWithAutoAndArbitrary()
      }],
      "col-end": [{
        "col-end": getNumberWithAutoAndArbitrary()
      }],
      "grid-rows": [{
        "grid-rows": [isAny]
      }],
      "row-start-end": [{
        row: ["auto", {
          span: [isInteger]
        }, isArbitraryValue]
      }],
      "row-start": [{
        "row-start": getNumberWithAutoAndArbitrary()
      }],
      "row-end": [{
        "row-end": getNumberWithAutoAndArbitrary()
      }],
      "grid-flow": [{
        "grid-flow": ["row", "col", "dense", "row-dense", "col-dense"]
      }],
      "auto-cols": [{
        "auto-cols": ["auto", "min", "max", "fr", isArbitraryValue]
      }],
      "auto-rows": [{
        "auto-rows": ["auto", "min", "max", "fr", isArbitraryValue]
      }],
      gap: [{
        gap: [gap]
      }],
      "gap-x": [{
        "gap-x": [gap]
      }],
      "gap-y": [{
        "gap-y": [gap]
      }],
      "justify-content": [{
        justify: ["normal"].concat(getAlign())
      }],
      "justify-items": [{
        "justify-items": ["start", "end", "center", "stretch"]
      }],
      "justify-self": [{
        "justify-self": ["auto", "start", "end", "center", "stretch"]
      }],
      "align-content": [{
        content: ["normal"].concat(getAlign(), ["baseline"])
      }],
      "align-items": [{
        items: ["start", "end", "center", "baseline", "stretch"]
      }],
      "align-self": [{
        self: ["auto", "start", "end", "center", "stretch", "baseline"]
      }],
      "place-content": [{
        "place-content": [].concat(getAlign(), ["baseline"])
      }],
      "place-items": [{
        "place-items": ["start", "end", "center", "baseline", "stretch"]
      }],
      "place-self": [{
        "place-self": ["auto", "start", "end", "center", "stretch"]
      }],
      p: [{
        p: [padding]
      }],
      px: [{
        px: [padding]
      }],
      py: [{
        py: [padding]
      }],
      ps: [{
        ps: [padding]
      }],
      pe: [{
        pe: [padding]
      }],
      pt: [{
        pt: [padding]
      }],
      pr: [{
        pr: [padding]
      }],
      pb: [{
        pb: [padding]
      }],
      pl: [{
        pl: [padding]
      }],
      m: [{
        m: [margin]
      }],
      mx: [{
        mx: [margin]
      }],
      my: [{
        my: [margin]
      }],
      ms: [{
        ms: [margin]
      }],
      me: [{
        me: [margin]
      }],
      mt: [{
        mt: [margin]
      }],
      mr: [{
        mr: [margin]
      }],
      mb: [{
        mb: [margin]
      }],
      ml: [{
        ml: [margin]
      }],
      "space-x": [{
        "space-x": [space]
      }],
      "space-x-reverse": ["space-x-reverse"],
      "space-y": [{
        "space-y": [space]
      }],
      "space-y-reverse": ["space-y-reverse"],
      w: [{
        w: ["auto", "min", "max", "fit", spacing]
      }],
      "min-w": [{
        "min-w": ["min", "max", "fit", isLength]
      }],
      "max-w": [{
        "max-w": ["0", "none", "full", "min", "max", "fit", "prose", {
          screen: [isTshirtSize]
        }, isTshirtSize, isArbitraryLength]
      }],
      h: [{
        h: [spacing, "auto", "min", "max", "fit"]
      }],
      "min-h": [{
        "min-h": ["min", "max", "fit", isLength]
      }],
      "max-h": [{
        "max-h": [spacing, "min", "max", "fit"]
      }],
      "font-size": [{
        text: ["base", isTshirtSize, isArbitraryLength]
      }],
      "font-smoothing": ["antialiased", "subpixel-antialiased"],
      "font-style": ["italic", "not-italic"],
      "font-weight": [{
        font: ["thin", "extralight", "light", "normal", "medium", "semibold", "bold", "extrabold", "black", isArbitraryNumber]
      }],
      "font-family": [{
        font: [isAny]
      }],
      "fvn-normal": ["normal-nums"],
      "fvn-ordinal": ["ordinal"],
      "fvn-slashed-zero": ["slashed-zero"],
      "fvn-figure": ["lining-nums", "oldstyle-nums"],
      "fvn-spacing": ["proportional-nums", "tabular-nums"],
      "fvn-fraction": ["diagonal-fractions", "stacked-fractons"],
      tracking: [{
        tracking: ["tighter", "tight", "normal", "wide", "wider", "widest", isArbitraryLength]
      }],
      "line-clamp": [{
        "line-clamp": ["none", isNumber, isArbitraryNumber]
      }],
      leading: [{
        leading: ["none", "tight", "snug", "normal", "relaxed", "loose", isLength]
      }],
      "list-image": [{
        "list-image": ["none", isArbitraryValue]
      }],
      "list-style-type": [{
        list: ["none", "disc", "decimal", isArbitraryValue]
      }],
      "list-style-position": [{
        list: ["inside", "outside"]
      }],
      "placeholder-color": [{
        placeholder: [colors]
      }],
      "placeholder-opacity": [{
        "placeholder-opacity": [opacity]
      }],
      "text-alignment": [{
        text: ["left", "center", "right", "justify", "start", "end"]
      }],
      "text-color": [{
        text: [colors]
      }],
      "text-opacity": [{
        "text-opacity": [opacity]
      }],
      "text-decoration": ["underline", "overline", "line-through", "no-underline"],
      "text-decoration-style": [{
        decoration: [].concat(getLineStyles(), ["wavy"])
      }],
      "text-decoration-thickness": [{
        decoration: ["auto", "from-font", isLength]
      }],
      "underline-offset": [{
        "underline-offset": ["auto", isLength]
      }],
      "text-decoration-color": [{
        decoration: [colors]
      }],
      "text-transform": ["uppercase", "lowercase", "capitalize", "normal-case"],
      "text-overflow": ["truncate", "text-ellipsis", "text-clip"],
      indent: [{
        indent: [spacing]
      }],
      "vertical-align": [{
        align: ["baseline", "top", "middle", "bottom", "text-top", "text-bottom", "sub", "super", isArbitraryLength]
      }],
      whitespace: [{
        whitespace: ["normal", "nowrap", "pre", "pre-line", "pre-wrap", "break-spaces"]
      }],
      "break": [{
        "break": ["normal", "words", "all", "keep"]
      }],
      hyphens: [{
        hyphens: ["none", "manual", "auto"]
      }],
      content: [{
        content: ["none", isArbitraryValue]
      }],
      "bg-attachment": [{
        bg: ["fixed", "local", "scroll"]
      }],
      "bg-clip": [{
        "bg-clip": ["border", "padding", "content", "text"]
      }],
      "bg-opacity": [{
        "bg-opacity": [opacity]
      }],
      "bg-origin": [{
        "bg-origin": ["border", "padding", "content"]
      }],
      "bg-position": [{
        bg: [].concat(getPositions(), [isArbitraryPosition])
      }],
      "bg-repeat": [{
        bg: ["no-repeat", {
          repeat: ["", "x", "y", "round", "space"]
        }]
      }],
      "bg-size": [{
        bg: ["auto", "cover", "contain", isArbitrarySize]
      }],
      "bg-image": [{
        bg: ["none", {
          "gradient-to": ["t", "tr", "r", "br", "b", "bl", "l", "tl"]
        }, isArbitraryUrl]
      }],
      "bg-color": [{
        bg: [colors]
      }],
      "gradient-from-pos": [{
        from: [gradientColorStopPositions]
      }],
      "gradient-via-pos": [{
        via: [gradientColorStopPositions]
      }],
      "gradient-to-pos": [{
        to: [gradientColorStopPositions]
      }],
      "gradient-from": [{
        from: [gradientColorStops]
      }],
      "gradient-via": [{
        via: [gradientColorStops]
      }],
      "gradient-to": [{
        to: [gradientColorStops]
      }],
      rounded: [{
        rounded: [borderRadius]
      }],
      "rounded-s": [{
        "rounded-s": [borderRadius]
      }],
      "rounded-e": [{
        "rounded-e": [borderRadius]
      }],
      "rounded-t": [{
        "rounded-t": [borderRadius]
      }],
      "rounded-r": [{
        "rounded-r": [borderRadius]
      }],
      "rounded-b": [{
        "rounded-b": [borderRadius]
      }],
      "rounded-l": [{
        "rounded-l": [borderRadius]
      }],
      "rounded-ss": [{
        "rounded-ss": [borderRadius]
      }],
      "rounded-se": [{
        "rounded-se": [borderRadius]
      }],
      "rounded-ee": [{
        "rounded-ee": [borderRadius]
      }],
      "rounded-es": [{
        "rounded-es": [borderRadius]
      }],
      "rounded-tl": [{
        "rounded-tl": [borderRadius]
      }],
      "rounded-tr": [{
        "rounded-tr": [borderRadius]
      }],
      "rounded-br": [{
        "rounded-br": [borderRadius]
      }],
      "rounded-bl": [{
        "rounded-bl": [borderRadius]
      }],
      "border-w": [{
        border: [borderWidth]
      }],
      "border-w-x": [{
        "border-x": [borderWidth]
      }],
      "border-w-y": [{
        "border-y": [borderWidth]
      }],
      "border-w-s": [{
        "border-s": [borderWidth]
      }],
      "border-w-e": [{
        "border-e": [borderWidth]
      }],
      "border-w-t": [{
        "border-t": [borderWidth]
      }],
      "border-w-r": [{
        "border-r": [borderWidth]
      }],
      "border-w-b": [{
        "border-b": [borderWidth]
      }],
      "border-w-l": [{
        "border-l": [borderWidth]
      }],
      "border-opacity": [{
        "border-opacity": [opacity]
      }],
      "border-style": [{
        border: [].concat(getLineStyles(), ["hidden"])
      }],
      "divide-x": [{
        "divide-x": [borderWidth]
      }],
      "divide-x-reverse": ["divide-x-reverse"],
      "divide-y": [{
        "divide-y": [borderWidth]
      }],
      "divide-y-reverse": ["divide-y-reverse"],
      "divide-opacity": [{
        "divide-opacity": [opacity]
      }],
      "divide-style": [{
        divide: getLineStyles()
      }],
      "border-color": [{
        border: [borderColor]
      }],
      "border-color-x": [{
        "border-x": [borderColor]
      }],
      "border-color-y": [{
        "border-y": [borderColor]
      }],
      "border-color-t": [{
        "border-t": [borderColor]
      }],
      "border-color-r": [{
        "border-r": [borderColor]
      }],
      "border-color-b": [{
        "border-b": [borderColor]
      }],
      "border-color-l": [{
        "border-l": [borderColor]
      }],
      "divide-color": [{
        divide: [borderColor]
      }],
      "outline-style": [{
        outline: [""].concat(getLineStyles())
      }],
      "outline-offset": [{
        "outline-offset": [isLength]
      }],
      "outline-w": [{
        outline: [isLength]
      }],
      "outline-color": [{
        outline: [colors]
      }],
      "ring-w": [{
        ring: getLengthWithEmpty()
      }],
      "ring-w-inset": ["ring-inset"],
      "ring-color": [{
        ring: [colors]
      }],
      "ring-opacity": [{
        "ring-opacity": [opacity]
      }],
      "ring-offset-w": [{
        "ring-offset": [isLength]
      }],
      "ring-offset-color": [{
        "ring-offset": [colors]
      }],
      shadow: [{
        shadow: ["", "inner", "none", isTshirtSize, isArbitraryShadow]
      }],
      "shadow-color": [{
        shadow: [isAny]
      }],
      opacity: [{
        opacity: [opacity]
      }],
      "mix-blend": [{
        "mix-blend": getBlendModes()
      }],
      "bg-blend": [{
        "bg-blend": getBlendModes()
      }],
      filter: [{
        filter: ["", "none"]
      }],
      blur: [{
        blur: [blur]
      }],
      brightness: [{
        brightness: [brightness]
      }],
      contrast: [{
        contrast: [contrast]
      }],
      "drop-shadow": [{
        "drop-shadow": ["", "none", isTshirtSize, isArbitraryValue]
      }],
      grayscale: [{
        grayscale: [grayscale]
      }],
      "hue-rotate": [{
        "hue-rotate": [hueRotate]
      }],
      invert: [{
        invert: [invert]
      }],
      saturate: [{
        saturate: [saturate]
      }],
      sepia: [{
        sepia: [sepia]
      }],
      "backdrop-filter": [{
        "backdrop-filter": ["", "none"]
      }],
      "backdrop-blur": [{
        "backdrop-blur": [blur]
      }],
      "backdrop-brightness": [{
        "backdrop-brightness": [brightness]
      }],
      "backdrop-contrast": [{
        "backdrop-contrast": [contrast]
      }],
      "backdrop-grayscale": [{
        "backdrop-grayscale": [grayscale]
      }],
      "backdrop-hue-rotate": [{
        "backdrop-hue-rotate": [hueRotate]
      }],
      "backdrop-invert": [{
        "backdrop-invert": [invert]
      }],
      "backdrop-opacity": [{
        "backdrop-opacity": [opacity]
      }],
      "backdrop-saturate": [{
        "backdrop-saturate": [saturate]
      }],
      "backdrop-sepia": [{
        "backdrop-sepia": [sepia]
      }],
      "border-collapse": [{
        border: ["collapse", "separate"]
      }],
      "border-spacing": [{
        "border-spacing": [borderSpacing]
      }],
      "border-spacing-x": [{
        "border-spacing-x": [borderSpacing]
      }],
      "border-spacing-y": [{
        "border-spacing-y": [borderSpacing]
      }],
      "table-layout": [{
        table: ["auto", "fixed"]
      }],
      caption: [{
        caption: ["top", "bottom"]
      }],
      transition: [{
        transition: ["none", "all", "", "colors", "opacity", "shadow", "transform", isArbitraryValue]
      }],
      duration: [{
        duration: getNumberAndArbitrary()
      }],
      ease: [{
        ease: ["linear", "in", "out", "in-out", isArbitraryValue]
      }],
      delay: [{
        delay: getNumberAndArbitrary()
      }],
      animate: [{
        animate: ["none", "spin", "ping", "pulse", "bounce", isArbitraryValue]
      }],
      transform: [{
        transform: ["", "gpu", "none"]
      }],
      scale: [{
        scale: [scale]
      }],
      "scale-x": [{
        "scale-x": [scale]
      }],
      "scale-y": [{
        "scale-y": [scale]
      }],
      rotate: [{
        rotate: [isInteger, isArbitraryValue]
      }],
      "translate-x": [{
        "translate-x": [translate]
      }],
      "translate-y": [{
        "translate-y": [translate]
      }],
      "skew-x": [{
        "skew-x": [skew]
      }],
      "skew-y": [{
        "skew-y": [skew]
      }],
      "transform-origin": [{
        origin: ["center", "top", "top-right", "right", "bottom-right", "bottom", "bottom-left", "left", "top-left", isArbitraryValue]
      }],
      accent: [{
        accent: ["auto", colors]
      }],
      appearance: ["appearance-none"],
      cursor: [{
        cursor: ["auto", "default", "pointer", "wait", "text", "move", "help", "not-allowed", "none", "context-menu", "progress", "cell", "crosshair", "vertical-text", "alias", "copy", "no-drop", "grab", "grabbing", "all-scroll", "col-resize", "row-resize", "n-resize", "e-resize", "s-resize", "w-resize", "ne-resize", "nw-resize", "se-resize", "sw-resize", "ew-resize", "ns-resize", "nesw-resize", "nwse-resize", "zoom-in", "zoom-out", isArbitraryValue]
      }],
      "caret-color": [{
        caret: [colors]
      }],
      "pointer-events": [{
        "pointer-events": ["none", "auto"]
      }],
      resize: [{
        resize: ["none", "y", "x", ""]
      }],
      "scroll-behavior": [{
        scroll: ["auto", "smooth"]
      }],
      "scroll-m": [{
        "scroll-m": [spacing]
      }],
      "scroll-mx": [{
        "scroll-mx": [spacing]
      }],
      "scroll-my": [{
        "scroll-my": [spacing]
      }],
      "scroll-ms": [{
        "scroll-ms": [spacing]
      }],
      "scroll-me": [{
        "scroll-me": [spacing]
      }],
      "scroll-mt": [{
        "scroll-mt": [spacing]
      }],
      "scroll-mr": [{
        "scroll-mr": [spacing]
      }],
      "scroll-mb": [{
        "scroll-mb": [spacing]
      }],
      "scroll-ml": [{
        "scroll-ml": [spacing]
      }],
      "scroll-p": [{
        "scroll-p": [spacing]
      }],
      "scroll-px": [{
        "scroll-px": [spacing]
      }],
      "scroll-py": [{
        "scroll-py": [spacing]
      }],
      "scroll-ps": [{
        "scroll-ps": [spacing]
      }],
      "scroll-pe": [{
        "scroll-pe": [spacing]
      }],
      "scroll-pt": [{
        "scroll-pt": [spacing]
      }],
      "scroll-pr": [{
        "scroll-pr": [spacing]
      }],
      "scroll-pb": [{
        "scroll-pb": [spacing]
      }],
      "scroll-pl": [{
        "scroll-pl": [spacing]
      }],
      "snap-align": [{
        snap: ["start", "end", "center", "align-none"]
      }],
      "snap-stop": [{
        snap: ["normal", "always"]
      }],
      "snap-type": [{
        snap: ["none", "x", "y", "both"]
      }],
      "snap-strictness": [{
        snap: ["mandatory", "proximity"]
      }],
      touch: [{
        touch: ["auto", "none", "pinch-zoom", "manipulation", {
          pan: ["x", "left", "right", "y", "up", "down"]
        }]
      }],
      select: [{
        select: ["none", "text", "all", "auto"]
      }],
      "will-change": [{
        "will-change": ["auto", "scroll", "contents", "transform", isArbitraryValue]
      }],
      fill: [{
        fill: [colors, "none"]
      }],
      "stroke-w": [{
        stroke: [isLength, isArbitraryNumber]
      }],
      stroke: [{
        stroke: [colors, "none"]
      }],
      sr: ["sr-only", "not-sr-only"]
    },
    conflictingClassGroups: {
      overflow: ["overflow-x", "overflow-y"],
      overscroll: ["overscroll-x", "overscroll-y"],
      inset: ["inset-x", "inset-y", "start", "end", "top", "right", "bottom", "left"],
      "inset-x": ["right", "left"],
      "inset-y": ["top", "bottom"],
      flex: ["basis", "grow", "shrink"],
      gap: ["gap-x", "gap-y"],
      p: ["px", "py", "ps", "pe", "pt", "pr", "pb", "pl"],
      px: ["pr", "pl"],
      py: ["pt", "pb"],
      m: ["mx", "my", "ms", "me", "mt", "mr", "mb", "ml"],
      mx: ["mr", "ml"],
      my: ["mt", "mb"],
      "font-size": ["leading"],
      "fvn-normal": ["fvn-ordinal", "fvn-slashed-zero", "fvn-figure", "fvn-spacing", "fvn-fraction"],
      "fvn-ordinal": ["fvn-normal"],
      "fvn-slashed-zero": ["fvn-normal"],
      "fvn-figure": ["fvn-normal"],
      "fvn-spacing": ["fvn-normal"],
      "fvn-fraction": ["fvn-normal"],
      rounded: ["rounded-s", "rounded-e", "rounded-t", "rounded-r", "rounded-b", "rounded-l", "rounded-ss", "rounded-se", "rounded-ee", "rounded-es", "rounded-tl", "rounded-tr", "rounded-br", "rounded-bl"],
      "rounded-s": ["rounded-ss", "rounded-es"],
      "rounded-e": ["rounded-se", "rounded-ee"],
      "rounded-t": ["rounded-tl", "rounded-tr"],
      "rounded-r": ["rounded-tr", "rounded-br"],
      "rounded-b": ["rounded-br", "rounded-bl"],
      "rounded-l": ["rounded-tl", "rounded-bl"],
      "border-spacing": ["border-spacing-x", "border-spacing-y"],
      "border-w": ["border-w-s", "border-w-e", "border-w-t", "border-w-r", "border-w-b", "border-w-l"],
      "border-w-x": ["border-w-r", "border-w-l"],
      "border-w-y": ["border-w-t", "border-w-b"],
      "border-color": ["border-color-t", "border-color-r", "border-color-b", "border-color-l"],
      "border-color-x": ["border-color-r", "border-color-l"],
      "border-color-y": ["border-color-t", "border-color-b"],
      "scroll-m": ["scroll-mx", "scroll-my", "scroll-ms", "scroll-me", "scroll-mt", "scroll-mr", "scroll-mb", "scroll-ml"],
      "scroll-mx": ["scroll-mr", "scroll-ml"],
      "scroll-my": ["scroll-mt", "scroll-mb"],
      "scroll-p": ["scroll-px", "scroll-py", "scroll-ps", "scroll-pe", "scroll-pt", "scroll-pr", "scroll-pb", "scroll-pl"],
      "scroll-px": ["scroll-pr", "scroll-pl"],
      "scroll-py": ["scroll-pt", "scroll-pb"]
    },
    conflictingClassGroupModifiers: {
      "font-size": ["leading"]
    }
  };
}

// node_modules/tailwind-merge/dist/lib/tw-merge.mjs
var twMerge = createTailwindMerge(getDefaultConfig);

// node_modules/tailwind-merge/dist/lib/merge-configs.mjs
function mergeConfigs(baseConfig, configExtension) {
  for (var key in configExtension) {
    mergePropertyRecursively(baseConfig, key, configExtension[key]);
  }
  return baseConfig;
}
var hasOwnProperty = Object.prototype.hasOwnProperty;
var overrideTypes = /* @__PURE__ */ new Set(["string", "number", "boolean"]);
function mergePropertyRecursively(baseObject, mergeKey, mergeValue) {
  if (!hasOwnProperty.call(baseObject, mergeKey) || overrideTypes.has(typeof mergeValue) || mergeValue === null) {
    baseObject[mergeKey] = mergeValue;
    return;
  }
  if (Array.isArray(mergeValue) && Array.isArray(baseObject[mergeKey])) {
    baseObject[mergeKey] = baseObject[mergeKey].concat(mergeValue);
    return;
  }
  if (typeof mergeValue === "object" && typeof baseObject[mergeKey] === "object") {
    if (baseObject[mergeKey] === null) {
      baseObject[mergeKey] = mergeValue;
      return;
    }
    for (var nextKey in mergeValue) {
      mergePropertyRecursively(baseObject[mergeKey], nextKey, mergeValue[nextKey]);
    }
  }
}

// node_modules/tailwind-merge/dist/lib/extend-tailwind-merge.mjs
function extendTailwindMerge(configExtension) {
  for (var _len = arguments.length, createConfig = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    createConfig[_key - 1] = arguments[_key];
  }
  return typeof configExtension === "function" ? createTailwindMerge.apply(void 0, [getDefaultConfig, configExtension].concat(createConfig)) : createTailwindMerge.apply(void 0, [function() {
    return mergeConfigs(getDefaultConfig(), configExtension);
  }].concat(createConfig));
}

// node_modules/@yext/search-ui-react/lib/esm/hooks/useComposedCssClasses.js
var twMerge2 = extendTailwindMerge({
  classGroups: {
    form: ["input", "checkbox", "textarea", "select", "multiselect", "radio"].map((v2) => "form-" + v2)
  }
});
function useComposedCssClasses(builtInClasses, customClasses) {
  return (0, import_react33.useMemo)(() => {
    const mergedCssClasses = Object.assign({}, builtInClasses);
    if (!customClasses) {
      return mergedCssClasses;
    }
    Object.keys(customClasses).forEach((key) => {
      const builtIn = builtInClasses[key];
      const custom = customClasses[key];
      if (!builtIn || !custom) {
        mergedCssClasses[key] = custom || builtIn;
      } else {
        mergedCssClasses[key] = twMerge2(builtIn, custom);
      }
    });
    return mergedCssClasses;
  }, [builtInClasses, customClasses]);
}

// node_modules/@yext/search-ui-react/lib/esm/components/SearchButton.js
var import_jsx_runtime11 = __toESM(require_jsx_runtime());
function SearchButton({ handleClick, className }) {
  return (0, import_jsx_runtime11.jsx)("button", Object.assign({ className, onClick: handleClick, "aria-label": "Submit Search" }, { children: (0, import_jsx_runtime11.jsx)(MagnifyingGlassIcon, {}, void 0) }), void 0);
}

// node_modules/@yext/search-ui-react/lib/esm/components/utils/processTranslation.js
function processTranslation(args) {
  if (args.count != null && args.pluralForm && args.count !== 1) {
    return args.pluralForm;
  } else {
    return args.phrase;
  }
}

// node_modules/@yext/search-ui-react/lib/esm/components/utils/renderAutocompleteResult.js
var import_jsx_runtime13 = __toESM(require_jsx_runtime());

// node_modules/@yext/search-ui-react/lib/esm/components/utils/renderHighlightedValue.js
var import_jsx_runtime12 = __toESM(require_jsx_runtime());
var defaultCssClasses = {
  highlighted: "font-normal",
  nonHighlighted: "font-semibold"
};
function renderHighlightedValue(highlightedValueOrString, customCssClasses) {
  const { value = "", matchedSubstrings } = typeof highlightedValueOrString === "string" ? { value: highlightedValueOrString, matchedSubstrings: [] } : highlightedValueOrString;
  const cssClasses = Object.assign(Object.assign({}, defaultCssClasses), customCssClasses);
  if (!matchedSubstrings || matchedSubstrings.length === 0) {
    return (0, import_jsx_runtime12.jsx)("span", { children: value }, void 0);
  }
  const substrings = [...matchedSubstrings];
  substrings.sort((a2, b) => a2.offset - b.offset);
  const highlightedJSX = [];
  let curr = 0;
  for (const { offset, length } of substrings) {
    if (offset > curr) {
      highlightedJSX.push((0, import_jsx_runtime12.jsx)("span", Object.assign({ className: cssClasses.nonHighlighted }, { children: value.substring(curr, offset) }), curr));
    }
    highlightedJSX.push((0, import_jsx_runtime12.jsx)("span", Object.assign({ className: cssClasses.highlighted }, { children: value.substring(offset, offset + length) }), offset));
    curr = offset + length;
  }
  if (curr < value.length) {
    highlightedJSX.push((0, import_jsx_runtime12.jsx)("span", Object.assign({ className: cssClasses.nonHighlighted }, { children: value.substring(curr) }), curr));
  }
  return (0, import_jsx_runtime12.jsx)(import_jsx_runtime12.Fragment, { children: highlightedJSX }, void 0);
}

// node_modules/@yext/search-ui-react/lib/esm/components/utils/renderAutocompleteResult.js
var builtInCssClasses = {
  option: "flex whitespace-pre-wrap h-6.5 pl-3 text-neutral-dark",
  icon: "w-6 text-gray-400"
};
function renderAutocompleteResult(result, cssClasses = {}, Icon, ariaLabel) {
  return (0, import_jsx_runtime13.jsxs)(import_jsx_runtime13.Fragment, { children: [Icon && (0, import_jsx_runtime13.jsx)("div", Object.assign({ className: cssClasses.icon }, { children: (0, import_jsx_runtime13.jsx)(Icon, {}, void 0) }), void 0), (0, import_jsx_runtime13.jsx)("div", Object.assign({ "aria-label": ariaLabel || "", className: cssClasses.option }, { children: renderHighlightedValue(result, cssClasses) }), void 0)] }, void 0);
}

// node_modules/@yext/search-ui-react/lib/esm/hooks/useAnalytics.js
var import_react34 = __toESM(require_react());
var AnalyticsContext = (0, import_react34.createContext)(null);
function useAnalytics() {
  return (0, import_react34.useContext)(AnalyticsContext);
}

// node_modules/@yext/search-ui-react/lib/esm/hooks/useSearchBarAnalytics.js
function useSearchBarAnalytics() {
  const analytics = useAnalytics();
  const verticalKey = useSearchState((state) => state.vertical.verticalKey);
  const queryId = useSearchState((state) => state.query.queryId);
  const reportAutocompleteEvent = (suggestedSearchText) => {
    analytics === null || analytics === void 0 ? void 0 : analytics.report(Object.assign(Object.assign({ type: "AUTO_COMPLETE_SELECTION" }, queryId && { queryId }), { suggestedSearchText }));
  };
  const reportSearchClearEvent = () => {
    if (!queryId) {
      console.error("Unable to report a search clear event. Missing field: queryId.");
      return;
    }
    analytics === null || analytics === void 0 ? void 0 : analytics.report({
      type: "SEARCH_CLEAR_BUTTON",
      queryId,
      verticalKey
    });
  };
  const reportAnalyticsEvent = (analyticsEventType, suggestedSearchText) => {
    if (!analytics) {
      return;
    }
    analyticsEventType === "AUTO_COMPLETE_SELECTION" ? reportAutocompleteEvent(suggestedSearchText || "") : reportSearchClearEvent();
  };
  return reportAnalyticsEvent;
}

// node_modules/@yext/search-ui-react/lib/esm/models/verticalLink.js
var isVerticalLink = (obj) => {
  return typeof obj === "object" && !!obj && "verticalKey" in obj;
};

// node_modules/@yext/search-ui-react/lib/esm/utils/filterutils.js
var import_lodash = __toESM(require_lodash());

// node_modules/@yext/search-ui-react/lib/esm/models/NumberRangeFilter.js
function isNumberRangeFilter(unknownFilter = {}) {
  const filter = unknownFilter;
  return filter.matcher === Matcher.Between && isNumberRangeValue(filter.value);
}

// node_modules/@yext/search-ui-react/lib/esm/utils/filterutils.js
var __rest = function(s2, e2) {
  var t2 = {};
  for (var p2 in s2)
    if (Object.prototype.hasOwnProperty.call(s2, p2) && e2.indexOf(p2) < 0)
      t2[p2] = s2[p2];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s2); i2 < p2.length; i2++) {
      if (e2.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i2]))
        t2[p2[i2]] = s2[p2[i2]];
    }
  return t2;
};
function isNearFilterValue(obj) {
  return typeof obj === "object" && !!obj && "radius" in obj && "lat" in obj && "long" in obj;
}
function isNumberRangeValue(obj) {
  return typeof obj === "object" && !!obj && ("start" in obj || "end" in obj);
}
function isStringFacet(facet) {
  return facet.options.length > 0 && typeof facet.options[0].value === "string";
}
function isNumericalFacet(facet) {
  return facet.options.length > 0 && facet.options.some((option) => isNumberRangeFilter(option));
}
function isDuplicateFieldValueFilter(thisFilter, otherFilter) {
  if (thisFilter.fieldId !== otherFilter.fieldId) {
    return false;
  }
  if (thisFilter.matcher !== otherFilter.matcher) {
    return false;
  }
  if (!(0, import_lodash.isEqual)(thisFilter.value, otherFilter.value)) {
    return false;
  }
  return true;
}
function isDuplicateStaticFilter(thisFilter, otherFilter) {
  if (thisFilter.kind === "fieldValue") {
    return otherFilter.kind === "fieldValue" ? isDuplicateFieldValueFilter(thisFilter, otherFilter) : false;
  }
  if (otherFilter.kind === "fieldValue") {
    return false;
  }
  return thisFilter.combinator === otherFilter.combinator && thisFilter.filters.length === otherFilter.filters.length && thisFilter.filters.every((t2) => otherFilter.filters.some((o2) => isDuplicateStaticFilter(t2, o2))) && otherFilter.filters.every((o2) => thisFilter.filters.some((t2) => isDuplicateStaticFilter(o2, t2)));
}
function findSelectableFieldValueFilter(filter, selectableFilters) {
  return selectableFilters.find((selectableFilter) => {
    const { displayName: _ } = selectableFilter, storedFilter = __rest(selectableFilter, ["displayName"]);
    return isDuplicateFieldValueFilter(storedFilter, filter);
  });
}
function parseNumberRangeInput(minRangeInput, maxRangeInput) {
  const minRange = parseNumber(minRangeInput);
  const maxRange = parseNumber(maxRangeInput);
  return Object.assign(Object.assign({}, minRange !== void 0 && {
    start: {
      matcher: Matcher.GreaterThanOrEqualTo,
      value: minRange
    }
  }), maxRange !== void 0 && {
    end: {
      matcher: Matcher.LessThanOrEqualTo,
      value: maxRange
    }
  });
}
function parseNumber(num) {
  const parsedNum = parseFloat(num);
  if (isNaN(parsedNum)) {
    return void 0;
  }
  return parsedNum;
}
function clearStaticRangeFilters(searchActions, fieldIds) {
  var _a, _b, _c;
  const selectedStaticRangeFilters = (_c = (_b = (_a = searchActions.state) === null || _a === void 0 ? void 0 : _a.filters) === null || _b === void 0 ? void 0 : _b.static) === null || _c === void 0 ? void 0 : _c.filter((filter) => isNumberRangeFilter(filter) && filter.selected === true && (!fieldIds || fieldIds.has(filter.fieldId)));
  selectedStaticRangeFilters === null || selectedStaticRangeFilters === void 0 ? void 0 : selectedStaticRangeFilters.forEach((filter) => {
    searchActions.setFilterOption(Object.assign(Object.assign({}, filter), { selected: false }));
  });
}
function getSelectedNumericalFacetFields(searchActions) {
  var _a, _b;
  const selectedNumericalFacets = (_b = (_a = searchActions.state.filters.facets) === null || _a === void 0 ? void 0 : _a.filter((f2) => isNumericalFacet(f2) && f2.options.some((o2) => o2.selected))) !== null && _b !== void 0 ? _b : [];
  return new Set(selectedNumericalFacets.map((f2) => f2.fieldId));
}
function getSelectableFieldValueFilters(staticFilters) {
  return staticFilters.map((s2) => {
    const _a = s2.filter, { kind } = _a, filterFields = __rest(_a, ["kind"]), displayFields = __rest(s2, ["filter"]);
    if (kind === "fieldValue") {
      return Object.assign(Object.assign({}, displayFields), filterFields);
    }
    return void 0;
  }).filter((s2) => !!s2);
}

// node_modules/@yext/search-ui-react/lib/esm/components/SearchBar.js
var builtInCssClasses2 = Object.assign({ searchBarContainer: "h-12 mb-6", inputDivider: "border-t border-gray-200 mx-2.5", inputElement: "outline-none flex-grow border-none h-full pl-0.5 pr-2 text-neutral-dark text-base placeholder:text-neutral-light", searchButtonContainer: " w-8 h-full mx-2 flex flex-col justify-center items-center", searchButton: "h-7 w-7", focusedOption: "bg-gray-100", clearButton: "h-3 w-3 mr-3.5", verticalDivider: "mr-0.5", recentSearchesIcon: "w-5 mr-1 text-gray-400", recentSearchesOption: "pl-3 text-neutral-dark", recentSearchesNonHighlighted: "font-normal", verticalLink: "ml-12 pl-1 text-neutral italic", entityPreviewsDivider: "h-px bg-gray-200 mt-1 mb-4 mx-3.5" }, builtInCssClasses);
function SearchBar({ placeholder, geolocationOptions, hideRecentSearches, visualAutocompleteConfig, showVerticalLinks = false, onSelectVerticalLink, verticalKeyToLabel, recentSearchesLimit = 5, customCssClasses, onSearch }) {
  var _a;
  const { entityPreviewSearcher, renderEntityPreviews, includedVerticals, universalLimit, entityPreviewsDebouncingTime = 500 } = visualAutocompleteConfig !== null && visualAutocompleteConfig !== void 0 ? visualAutocompleteConfig : {};
  const searchActions = useSearchActions();
  const searchUtilities = useSearchUtilities();
  const reportAnalyticsEvent = useSearchBarAnalytics();
  const query = (_a = useSearchState((state) => state.query.input)) !== null && _a !== void 0 ? _a : "";
  const cssClasses = useComposedCssClasses(builtInCssClasses2, customCssClasses);
  const isVertical = useSearchState((state) => state.meta.searchType) === SearchTypeEnum.Vertical;
  const verticalKey = useSearchState((state) => state.vertical.verticalKey);
  const [autocompleteResponse, executeAutocomplete2, clearAutocompleteData] = useSynchronizedRequest(() => executeAutocomplete(searchActions));
  const [executeQueryWithNearMeHandling, autocompletePromiseRef] = useSearchWithNearMeHandling(geolocationOptions, onSearch);
  const [recentSearches, setRecentSearch, clearRecentSearches] = useRecentSearches(recentSearchesLimit, verticalKey);
  const filteredRecentSearches = recentSearches === null || recentSearches === void 0 ? void 0 : recentSearches.filter((search) => searchUtilities.isCloseMatch(search.query, query));
  (0, import_react35.useEffect)(() => {
    if (hideRecentSearches) {
      clearRecentSearches();
    }
  }, [clearRecentSearches, hideRecentSearches]);
  const clearAutocomplete = (0, import_react35.useCallback)(() => {
    clearAutocompleteData();
    autocompletePromiseRef.current = void 0;
  }, [autocompletePromiseRef, clearAutocompleteData]);
  const executeQuery = (0, import_react35.useCallback)(() => {
    if (!hideRecentSearches) {
      const input = searchActions.state.query.input;
      input && setRecentSearch(input);
    }
    executeQueryWithNearMeHandling();
  }, [
    searchActions.state.query.input,
    executeQueryWithNearMeHandling,
    hideRecentSearches,
    setRecentSearch
  ]);
  const handleSubmit = (0, import_react35.useCallback)((value, index2, itemData) => {
    value !== void 0 && searchActions.setQuery(value);
    searchActions.setOffset(0);
    searchActions.setFacets([]);
    clearStaticRangeFilters(searchActions);
    if (itemData && isVerticalLink(itemData.verticalLink) && onSelectVerticalLink) {
      onSelectVerticalLink({ verticalLink: itemData.verticalLink, querySource: QuerySource.Autocomplete });
    } else {
      executeQuery();
    }
    if (typeof index2 === "number" && index2 >= 0 && !(itemData === null || itemData === void 0 ? void 0 : itemData.isEntityPreview)) {
      reportAnalyticsEvent("AUTO_COMPLETE_SELECTION", value);
    }
  }, [searchActions, executeQuery, onSelectVerticalLink, reportAnalyticsEvent]);
  const [entityPreviewsState, executeEntityPreviewsQuery] = useEntityPreviews(entityPreviewSearcher, entityPreviewsDebouncingTime);
  const { verticalKeyToResults, isLoading: entityPreviewsLoading } = entityPreviewsState;
  const entityPreviews = renderEntityPreviews === null || renderEntityPreviews === void 0 ? void 0 : renderEntityPreviews(entityPreviewsLoading, verticalKeyToResults, { onClick: handleSubmit, ariaLabel: getAriaLabel });
  const updateEntityPreviews = (0, import_react35.useCallback)((query2) => {
    if (!renderEntityPreviews || !includedVerticals) {
      return;
    }
    executeEntityPreviewsQuery(query2, universalLimit !== null && universalLimit !== void 0 ? universalLimit : {}, includedVerticals);
  }, [executeEntityPreviewsQuery, renderEntityPreviews, includedVerticals, universalLimit]);
  const handleInputFocus = (0, import_react35.useCallback)((value = "") => {
    searchActions.setQuery(value);
    updateEntityPreviews(value);
    autocompletePromiseRef.current = executeAutocomplete2();
  }, [searchActions, autocompletePromiseRef, executeAutocomplete2, updateEntityPreviews]);
  const handleInputChange = (0, import_react35.useCallback)((value = "") => {
    searchActions.setQuery(value);
    updateEntityPreviews(value);
    autocompletePromiseRef.current = executeAutocomplete2();
  }, [searchActions, autocompletePromiseRef, executeAutocomplete2, updateEntityPreviews]);
  const handleClickClearButton = (0, import_react35.useCallback)(() => {
    updateEntityPreviews("");
    handleSubmit("");
    reportAnalyticsEvent("SEARCH_CLEAR_BUTTON");
  }, [handleSubmit, reportAnalyticsEvent, updateEntityPreviews]);
  function renderInput() {
    return (0, import_jsx_runtime14.jsx)(DropdownInput, { className: cssClasses.inputElement, placeholder, onSubmit: handleSubmit, onFocus: handleInputFocus, onChange: handleInputChange, ariaLabel: "Conduct a search" }, void 0);
  }
  function renderRecentSearches() {
    const recentSearchesCssClasses = {
      icon: cssClasses.recentSearchesIcon,
      option: cssClasses.recentSearchesOption,
      nonHighlighted: cssClasses.recentSearchesNonHighlighted
    };
    return filteredRecentSearches === null || filteredRecentSearches === void 0 ? void 0 : filteredRecentSearches.map((result, i2) => (0, import_jsx_runtime14.jsx)(DropdownItem, Object.assign({ className: "flex items-center h-6.5 px-3.5 py-1.5 cursor-pointer hover:bg-gray-100", focusedClassName: twMerge2("flex items-center h-6.5 px-3.5 py-1.5 cursor-pointer hover:bg-gray-100", cssClasses.focusedOption), value: result.query, onClick: handleSubmit }, { children: renderAutocompleteResult({ value: result.query, inputIntents: [] }, recentSearchesCssClasses, HistoryIcon, `recent search: ${result.query}`) }), i2));
  }
  const itemDataMatrix = (0, import_react35.useMemo)(() => {
    var _a2;
    return (_a2 = autocompleteResponse === null || autocompleteResponse === void 0 ? void 0 : autocompleteResponse.results.map((result) => {
      var _a3, _b;
      return (_b = (_a3 = result.verticalKeys) === null || _a3 === void 0 ? void 0 : _a3.map((verticalKey2) => ({
        verticalLink: { verticalKey: verticalKey2, query: result.value }
      }))) !== null && _b !== void 0 ? _b : [];
    })) !== null && _a2 !== void 0 ? _a2 : [];
  }, [autocompleteResponse === null || autocompleteResponse === void 0 ? void 0 : autocompleteResponse.results]);
  function renderQuerySuggestions() {
    return autocompleteResponse === null || autocompleteResponse === void 0 ? void 0 : autocompleteResponse.results.map((result, i2) => {
      var _a2;
      return (0, import_jsx_runtime14.jsxs)(import_react35.Fragment, { children: [(0, import_jsx_runtime14.jsx)(DropdownItem, Object.assign({ className: "flex items-stretch py-1.5 px-3.5 cursor-pointer hover:bg-gray-100", focusedClassName: twMerge2("flex items-stretch py-1.5 px-3.5 cursor-pointer hover:bg-gray-100", cssClasses.focusedOption), value: result.value, onClick: handleSubmit }, { children: renderAutocompleteResult(result, cssClasses, MagnifyingGlassIcon, `autocomplete suggestion: ${result.value}`) }), void 0), showVerticalLinks && !isVertical && ((_a2 = result.verticalKeys) === null || _a2 === void 0 ? void 0 : _a2.map((verticalKey2, j) => (0, import_jsx_runtime14.jsx)(DropdownItem, Object.assign({ className: "flex items-stretch py-1.5 px-3.5 cursor-pointer hover:bg-gray-100", focusedClassName: twMerge2("flex items-stretch py-1.5 px-3.5 cursor-pointer hover:bg-gray-100", cssClasses.focusedOption), value: result.value, itemData: itemDataMatrix[i2][j], onClick: handleSubmit }, { children: renderAutocompleteResult({
        value: `in ${verticalKeyToLabel ? verticalKeyToLabel(verticalKey2) : verticalKey2}`,
        inputIntents: []
      }, Object.assign(Object.assign({}, cssClasses), { option: cssClasses.verticalLink })) }), j)))] }, i2);
    });
  }
  function renderClearButton() {
    return (0, import_jsx_runtime14.jsxs)(import_jsx_runtime14.Fragment, { children: [(0, import_jsx_runtime14.jsx)("button", Object.assign({ "aria-label": "Clear the search bar", className: cssClasses.clearButton, onClick: handleClickClearButton }, { children: (0, import_jsx_runtime14.jsx)(CloseIcon, {}, void 0) }), void 0), (0, import_jsx_runtime14.jsx)(VerticalDividerIcon, { className: cssClasses.verticalDivider }, void 0)] }, void 0);
  }
  const entityPreviewsCount = calculateEntityPreviewsCount(entityPreviews);
  const showEntityPreviewsDivider = entityPreviews && !!((autocompleteResponse === null || autocompleteResponse === void 0 ? void 0 : autocompleteResponse.results.length) || (filteredRecentSearches === null || filteredRecentSearches === void 0 ? void 0 : filteredRecentSearches.length));
  const hasItems = !!((autocompleteResponse === null || autocompleteResponse === void 0 ? void 0 : autocompleteResponse.results.length) || (filteredRecentSearches === null || filteredRecentSearches === void 0 ? void 0 : filteredRecentSearches.length) || entityPreviews);
  const screenReaderText = getScreenReaderText(autocompleteResponse === null || autocompleteResponse === void 0 ? void 0 : autocompleteResponse.results.length, filteredRecentSearches === null || filteredRecentSearches === void 0 ? void 0 : filteredRecentSearches.length, entityPreviewsCount);
  const activeClassName = (0, import_classnames.default)("relative z-10 bg-white border rounded-3xl border-gray-200 w-full overflow-hidden", {
    ["shadow-lg" !== null && "shadow-lg" !== void 0 ? "shadow-lg" : ""]: hasItems
  });
  const handleToggleDropdown = (0, import_react35.useCallback)((isActive) => {
    if (!isActive) {
      clearAutocomplete();
    }
  }, [clearAutocomplete]);
  return (0, import_jsx_runtime14.jsx)("div", Object.assign({ className: cssClasses.searchBarContainer }, { children: (0, import_jsx_runtime14.jsxs)(Dropdown, Object.assign({ className: "relative bg-white border rounded-3xl border-gray-200 w-full overflow-hidden", activeClassName, screenReaderText, parentQuery: query, onToggle: handleToggleDropdown }, { children: [(0, import_jsx_runtime14.jsxs)("div", Object.assign({ className: "inline-flex items-center justify-between w-full" }, { children: [(0, import_jsx_runtime14.jsx)("div", Object.assign({ className: "w-7 mx-2.5 my-2" }, { children: (0, import_jsx_runtime14.jsx)(YextIcon, {}, void 0) }), void 0), renderInput(), query && renderClearButton(), (0, import_jsx_runtime14.jsx)(DropdownSearchButton, { handleSubmit, cssClasses }, void 0)] }), void 0), hasItems && (0, import_jsx_runtime14.jsxs)(StyledDropdownMenu, Object.assign({ cssClasses }, { children: [renderRecentSearches(), renderQuerySuggestions(), showEntityPreviewsDivider && (0, import_jsx_runtime14.jsx)("div", { className: cssClasses.entityPreviewsDivider }, void 0), entityPreviews] }), void 0)] }), void 0) }), void 0);
}
function StyledDropdownMenu({ cssClasses, children }) {
  return (0, import_jsx_runtime14.jsxs)(DropdownMenu, { children: [(0, import_jsx_runtime14.jsx)("div", { className: cssClasses.inputDivider }, void 0), (0, import_jsx_runtime14.jsx)("div", Object.assign({ className: "bg-white py-4" }, { children }), void 0)] }, void 0);
}
function getScreenReaderText(autocompleteOptions = 0, recentSearchesOptions = 0, entityPreviewsCount = 0) {
  const recentSearchesText = recentSearchesOptions > 0 ? processTranslation({
    phrase: `${recentSearchesOptions} recent search found.`,
    pluralForm: `${recentSearchesOptions} recent searches found.`,
    count: recentSearchesOptions
  }) : "";
  const entityPreviewsText = entityPreviewsCount > 0 ? " " + processTranslation({
    phrase: `${entityPreviewsCount} result preview found.`,
    pluralForm: `${entityPreviewsCount} result previews found.`,
    count: entityPreviewsCount
  }) : "";
  const autocompleteText = autocompleteOptions > 0 ? " " + processTranslation({
    phrase: `${autocompleteOptions} autocomplete suggestion found.`,
    pluralForm: `${autocompleteOptions} autocomplete suggestions found.`,
    count: autocompleteOptions
  }) : "";
  const text = recentSearchesText + autocompleteText + entityPreviewsText;
  if (text === "") {
    return processTranslation({
      phrase: "0 autocomplete suggestion found.",
      pluralForm: "0 autocomplete suggestions found.",
      count: 0
    });
  }
  return text.trim();
}
function DropdownSearchButton({ handleSubmit, cssClasses }) {
  const { toggleDropdown } = useDropdownContext();
  const handleClick = (0, import_react35.useCallback)(() => {
    handleSubmit();
    toggleDropdown(false);
  }, [handleSubmit, toggleDropdown]);
  return (0, import_jsx_runtime14.jsx)("div", Object.assign({ className: cssClasses.searchButtonContainer }, { children: (0, import_jsx_runtime14.jsx)(SearchButton, { className: cssClasses.searchButton, handleClick }, void 0) }), void 0);
}
function getAriaLabel(value) {
  return "result preview: " + value;
}
function calculateEntityPreviewsCount(children) {
  let count = 0;
  recursivelyMapChildren(children, (c2) => {
    if ((0, import_react35.isValidElement)(c2) && c2.type === DropdownItem) {
      count++;
    }
    return c2;
  });
  return count;
}

// node_modules/@yext/search-ui-react/lib/esm/components/SpellCheck.js
var import_jsx_runtime15 = __toESM(require_jsx_runtime());
var import_classnames2 = __toESM(require_classnames());
var import_react36 = __toESM(require_react());
var builtInCssClasses3 = {
  spellCheckLoading: "opacity-50",
  spellCheckContainer: "text-lg pb-3",
  helpText: "text-neutral",
  link: "text-primary font-bold hover:underline focus:underline"
};
function SpellCheck({ customCssClasses, onClick }) {
  var _a, _b, _c;
  const verticalKey = (_a = useSearchState((state) => state.vertical.verticalKey)) !== null && _a !== void 0 ? _a : "";
  const cssClasses = useComposedCssClasses(builtInCssClasses3, customCssClasses);
  const correctedQuery = (_b = useSearchState((state) => state.spellCheck.correctedQuery)) !== null && _b !== void 0 ? _b : "";
  const isLoading = useSearchState((state) => state.searchStatus.isLoading);
  const containerClassNames = (0, import_classnames2.default)(cssClasses.spellCheckContainer, {
    [(_c = cssClasses.spellCheckLoading) !== null && _c !== void 0 ? _c : ""]: isLoading
  });
  const searchActions = useSearchActions();
  const handleClickSuggestion = (0, import_react36.useCallback)(() => {
    searchActions.setQuery(correctedQuery);
    onClick ? onClick({ correctedQuery, verticalKey }) : executeSearch(searchActions);
  }, [searchActions, correctedQuery, onClick, verticalKey]);
  if (!correctedQuery) {
    return null;
  }
  return (0, import_jsx_runtime15.jsxs)("div", Object.assign({ className: containerClassNames }, { children: [(0, import_jsx_runtime15.jsx)("span", Object.assign({ className: cssClasses.helpText }, { children: "Did you mean " }), void 0), (0, import_jsx_runtime15.jsx)("button", Object.assign({ className: cssClasses.link, onClick: handleClickSuggestion }, { children: correctedQuery }), void 0)] }), void 0);
}

// node_modules/@yext/search-ui-react/lib/esm/components/DirectAnswer.js
var import_jsx_runtime20 = __toESM(require_jsx_runtime());

// node_modules/@yext/search-ui-react/lib/esm/components/ThumbsFeedback.js
var import_jsx_runtime17 = __toESM(require_jsx_runtime());
var import_react37 = __toESM(require_react());

// node_modules/@yext/search-ui-react/lib/esm/icons/ThumbIcon.js
var import_jsx_runtime16 = __toESM(require_jsx_runtime());
function ThumbIcon({ className }) {
  return (0, import_jsx_runtime16.jsx)("svg", Object.assign({ className, viewBox: "0 0 18 18", fill: "none", stroke: "currentColor", xmlns: "http://www.w3.org/2000/svg" }, { children: (0, import_jsx_runtime16.jsx)("path", { d: "M10.6667 7.33333H14.6366C15.8756 7.33333 16.6814 8.63719 16.1273 9.74536L13.2107 15.5787C12.9283 16.1433 12.3512 16.5 11.7199 16.5H8.37184C8.23557 16.5 8.09982 16.4833 7.96762 16.4502L4.83333 15.6667M10.6667 7.33333V3.16667C10.6667 2.24619 9.92047 1.5 9 1.5H8.92044C8.50414 1.5 8.16667 1.83748 8.16667 2.25377C8.16667 2.84903 7.99047 3.43096 7.66028 3.92624L4.83333 8.16667V15.6667M10.6667 7.33333H9M4.83333 15.6667H3.16667C2.24619 15.6667 1.5 14.9205 1.5 14V9C1.5 8.07953 2.24619 7.33333 3.16667 7.33333H5.25", strokeWidth: "2", strokeLinecap: "round", strokeLinejoin: "round" }, void 0) }), void 0);
}

// node_modules/@yext/search-ui-react/lib/esm/components/ThumbsFeedback.js
var builtInCssClasses4 = {
  thumbsFeedbackContainer: "flex justify-end mt-2 text-sm text-gray-500 font-medium",
  thumbsUpIcon: "ml-3 w-5",
  thumbsDownIcon: "w-5 ml-1 transform rotate-180"
};
function ThumbsFeedback(props) {
  const { onClick, feedbackText = "Feedback", feedbackTextOnSubmission = "Thank you for your feedback!" } = props;
  const cssClasses = useComposedCssClasses(builtInCssClasses4, props.customCssClasses);
  const query = useSearchState((state) => state.query.mostRecentSearch);
  const [isFeedbackProvided, setIsFeedbackProvided] = (0, import_react37.useState)(false);
  const handleClickThumbsUp = (0, import_react37.useCallback)(() => {
    onClick("THUMBS_UP");
    setIsFeedbackProvided(true);
  }, [onClick]);
  const handleClickThumbsDown = (0, import_react37.useCallback)(() => {
    onClick("THUMBS_DOWN");
    setIsFeedbackProvided(true);
  }, [onClick]);
  use_isomorphic_layout_effect_browser_esm_default(() => {
    setIsFeedbackProvided(false);
  }, [query]);
  return (0, import_jsx_runtime17.jsx)("div", Object.assign({ className: cssClasses.thumbsFeedbackContainer }, { children: isFeedbackProvided ? feedbackTextOnSubmission : (0, import_jsx_runtime17.jsxs)(import_jsx_runtime17.Fragment, { children: [feedbackText, (0, import_jsx_runtime17.jsx)("button", Object.assign({ className: cssClasses.thumbsUpIcon, onClick: handleClickThumbsUp, "aria-label": "This answered my question" }, { children: (0, import_jsx_runtime17.jsx)(ThumbIcon, {}, void 0) }), void 0), (0, import_jsx_runtime17.jsx)("button", Object.assign({ className: cssClasses.thumbsDownIcon, onClick: handleClickThumbsDown, "aria-label": "This did not answer my question" }, { children: (0, import_jsx_runtime17.jsx)(ThumbIcon, {}, void 0) }), void 0)] }, void 0) }), void 0);
}

// node_modules/@yext/search-ui-react/lib/esm/hooks/useCardAnalyticsCallback.js
var import_react39 = __toESM(require_react());

// node_modules/@yext/search-ui-react/lib/esm/hooks/useCardAnalytics.js
var import_react38 = __toESM(require_react());
function isDirectAnswer(data) {
  var _a, _b;
  return ((_a = data) === null || _a === void 0 ? void 0 : _a.type) === DirectAnswerType.FeaturedSnippet || ((_b = data) === null || _b === void 0 ? void 0 : _b.type) === DirectAnswerType.FieldValue;
}
function useCardAnalytics() {
  const analytics = useAnalytics();
  const verticalKey = useSearchState((state) => state.vertical.verticalKey);
  const queryId = useSearchState((state) => state.query.queryId);
  const reportCtaEvent = (0, import_react38.useCallback)((result, eventType) => {
    let url, entityId, fieldName;
    let directAnswer = false;
    if (isDirectAnswer(result)) {
      url = result.relatedResult.link;
      entityId = result.relatedResult.id;
      fieldName = result.type === DirectAnswerType.FeaturedSnippet ? void 0 : result.fieldName;
      directAnswer = true;
    } else {
      url = result.link;
      entityId = result.id;
    }
    if (!queryId) {
      console.error("Unable to report a CTA event. Missing field: queryId.");
      return;
    }
    if (!entityId) {
      console.error("Unable to report a CTA event. Missing field: entityId.");
      return;
    }
    analytics === null || analytics === void 0 ? void 0 : analytics.report({
      type: eventType,
      entityId,
      searcher: verticalKey ? "VERTICAL" : "UNIVERSAL",
      queryId,
      verticalKey: verticalKey || "",
      url,
      fieldName,
      directAnswer
    });
  }, [analytics, queryId, verticalKey]);
  const reportFeedbackEvent = (0, import_react38.useCallback)((result, feedbackType) => {
    if (!queryId) {
      console.error("Unable to report a result feedback event. Missing field: queryId.");
      return;
    }
    let directAnswer = false;
    let entityId;
    if (isDirectAnswer(result)) {
      directAnswer = true;
      entityId = result.relatedResult.id;
    } else {
      entityId = result.id;
    }
    analytics === null || analytics === void 0 ? void 0 : analytics.report({
      type: feedbackType,
      entityId,
      searcher: verticalKey ? "VERTICAL" : "UNIVERSAL",
      queryId,
      verticalKey: verticalKey || "",
      directAnswer
    });
  }, [analytics, queryId, verticalKey]);
  const reportAnalyticsEvent = (0, import_react38.useCallback)((cardResult, analyticsEventType) => {
    if (!analytics) {
      return;
    }
    if (analyticsEventType === "TITLE_CLICK" || analyticsEventType === "CTA_CLICK") {
      reportCtaEvent(cardResult, analyticsEventType);
    }
    if (analyticsEventType === "THUMBS_DOWN" || analyticsEventType === "THUMBS_UP") {
      reportFeedbackEvent(cardResult, analyticsEventType);
    }
  }, [analytics, reportCtaEvent, reportFeedbackEvent]);
  return reportAnalyticsEvent;
}

// node_modules/@yext/search-ui-react/lib/esm/hooks/useCardAnalyticsCallback.js
function useCardAnalyticsCallback(result, analyticsType) {
  const reportAnalyticsEvent = useCardAnalytics();
  return (0, import_react39.useCallback)(() => {
    reportAnalyticsEvent(result, analyticsType);
  }, [analyticsType, reportAnalyticsEvent, result]);
}

// node_modules/@yext/search-ui-react/lib/esm/hooks/useCardFeedbackCallback.js
var import_react40 = __toESM(require_react());
function useCardFeedbackCallback(result) {
  const reportAnalyticsEvent = useCardAnalytics();
  return (0, import_react40.useCallback)((analyticsType) => {
    reportAnalyticsEvent(result, analyticsType);
  }, [reportAnalyticsEvent, result]);
}

// node_modules/@yext/search-ui-react/lib/esm/components/FieldValueDirectAnswer.js
var import_jsx_runtime18 = __toESM(require_jsx_runtime());
var import_react41 = __toESM(require_react());
function FieldValueDirectAnswer({ result, viewDetailsClickHandler, UnknownFieldTypeDisplay, cssClasses = {} }) {
  var _a;
  const title = `${result.entityName} / ${result.fieldName}`;
  const link = (_a = result.relatedResult.link) !== null && _a !== void 0 ? _a : result.relatedResult.rawData.landingPageUrl;
  const resultContent = (0, import_react41.useMemo)(() => {
    return getResultContent(result, UnknownFieldTypeDisplay);
  }, [result, UnknownFieldTypeDisplay]);
  return (0, import_jsx_runtime18.jsxs)("div", Object.assign({ className: cssClasses.answerContainer }, { children: [title && (0, import_jsx_runtime18.jsx)("div", Object.assign({ className: cssClasses.header }, { children: title }), void 0), (0, import_jsx_runtime18.jsxs)("div", Object.assign({ className: cssClasses.content }, { children: [(0, import_jsx_runtime18.jsx)("div", Object.assign({ className: cssClasses.body }, { children: resultContent }), void 0), link && (0, import_jsx_runtime18.jsx)("div", Object.assign({ className: "mt-4" }, { children: (0, import_jsx_runtime18.jsx)("a", Object.assign({ href: link, className: "text-primary", onClick: viewDetailsClickHandler }, { children: "View Details" }), void 0) }), void 0)] }), void 0)] }), void 0);
}
function DefaultUnknownFieldTypeDisplay({ result }) {
  let val;
  if (typeof result.value !== "string" && typeof result.value !== "number") {
    console.warn(`Unknown field type for direct answer with "${result.fieldApiName}" fieldApiName. Rendering result's value as a string.
Consider using prop "UnknownFieldTypeDisplay" in DirectAnswer component to properly render result of unknown field type.`);
    val = JSON.stringify(result.value);
  } else {
    val = result.value;
  }
  return getTextJsxElement(val);
}
function getResultContent(result, UnknownFieldTypeDisplay = DefaultUnknownFieldTypeDisplay) {
  switch (result.fieldType) {
    case BuiltInFieldType.InstagramHandle:
      return getAnchorTagJsxElement(`https://www.instagram.com/${result.value}`, result.value);
    case BuiltInFieldType.TwitterHandle:
      return getAnchorTagJsxElement(`https://twitter.com/${result.value}`, `@${result.value}`);
    case BuiltInFieldType.FacebookURL:
    case BuiltInFieldType.AndroidAppURL:
    case BuiltInFieldType.IOSAppURL:
      return getAnchorTagJsxElement(result.value);
    case BuiltInFieldType.ComplexURL:
      const url = result.value.url;
      const displayUrl = result.value.preferDisplayUrl ? result.value.displayUrl : url;
      return getAnchorTagJsxElement(url, displayUrl);
    case BuiltInFieldType.URL:
      return Array.isArray(result.value) ? getListJsxElement(result.value, (url2) => getAnchorTagJsxElement(url2)) : getAnchorTagJsxElement(result.value);
    case BuiltInFieldType.Phone:
      return getAnchorTagJsxElement(`tel:${result.value}`, result.value);
    case BuiltInFieldType.Email:
      return getListJsxElement(result.value, (e2) => getAnchorTagJsxElement(`mailto:${e2}`, e2));
    case BuiltInFieldType.Address:
      return getAddressJsxElement(result.value);
    case BuiltInFieldType.RichText:
      console.warn("Rendering markdown for rich text direct answer is currently not supported. Displaying the unrendered markdown string(s) as is.");
      return Array.isArray(result.value) ? getListJsxElement(result.value, (val) => getTextJsxElement(val)) : getTextJsxElement(result.value);
    case BuiltInFieldType.Hours:
      return (0, import_jsx_runtime18.jsx)("div", { children: JSON.stringify(result.value) }, void 0);
    case "unknown":
      return (0, import_jsx_runtime18.jsx)(UnknownFieldTypeDisplay, { result }, void 0);
    default:
      return Array.isArray(result.value) ? getListJsxElement(result.value, (val) => getTextJsxElement(val)) : getTextJsxElement(result.value);
  }
}
function getListJsxElement(list, getItemJsxElement) {
  return (0, import_jsx_runtime18.jsx)("ul", Object.assign({ className: "list-disc list-inside" }, { children: list.map((el, i2) => (0, import_jsx_runtime18.jsx)("li", { children: getItemJsxElement(el) }, i2)) }), void 0);
}
function getTextJsxElement(text) {
  return (0, import_jsx_runtime18.jsx)("p", Object.assign({ className: "whitespace-pre-wrap" }, { children: text }), void 0);
}
function getAnchorTagJsxElement(href, displayText) {
  return (0, import_jsx_runtime18.jsx)("a", Object.assign({ href, className: "text-primary" }, { children: displayText !== null && displayText !== void 0 ? displayText : href }), void 0);
}
function getAddressJsxElement(address) {
  if (address.extraDescription) {
    return (0, import_jsx_runtime18.jsx)("div", { children: address.extraDescription }, void 0);
  }
  const formattedCity = address.city ? address.city + "," : "";
  const formattedCityRegionPostalCode = [formattedCity, address.region, address.postalCode].join(" ").trim();
  return (0, import_jsx_runtime18.jsxs)("div", { children: [address.line1 && (0, import_jsx_runtime18.jsx)("p", { children: address.line1 }, void 0), address.line2 && (0, import_jsx_runtime18.jsx)("p", { children: address.line2 }, void 0), address.line3 && (0, import_jsx_runtime18.jsx)("p", { children: address.line3 }, void 0), formattedCityRegionPostalCode && (0, import_jsx_runtime18.jsx)("p", { children: formattedCityRegionPostalCode }, void 0), (0, import_jsx_runtime18.jsx)("p", { children: address.countryCode }, void 0)] }, void 0);
}

// node_modules/@yext/search-ui-react/lib/esm/components/FeaturedSnippetDirectAnswer.js
var import_jsx_runtime19 = __toESM(require_jsx_runtime());
function FeaturedSnippetDirectAnswer({ result, readMoreClickHandler, cssClasses = {} }) {
  const answer = result.fieldType === "multi_line_text" && result.value;
  if (result.fieldType === "rich_text") {
    console.warn("Rendering markdown for rich text direct answer is currently not supported. Displaying the unrendered markdown string as is.");
  }
  const snippet = renderHighlightedValue(result.snippet, { highlighted: cssClasses.highlighted });
  const link = result.relatedResult.link || result.relatedResult.rawData.landingPageUrl;
  const name = result.relatedResult.name;
  const snippetLinkMessage = "Read more about ";
  return (0, import_jsx_runtime19.jsxs)("div", Object.assign({ className: cssClasses.answerContainer }, { children: [answer && (0, import_jsx_runtime19.jsx)("div", Object.assign({ className: cssClasses.header }, { children: answer }), void 0), (0, import_jsx_runtime19.jsxs)("div", Object.assign({ className: cssClasses.content }, { children: [(0, import_jsx_runtime19.jsx)("div", Object.assign({ className: cssClasses.body }, { children: snippet }), void 0), link && name && (0, import_jsx_runtime19.jsxs)("div", Object.assign({ className: "pt-4 text-neutral" }, { children: [snippetLinkMessage, (0, import_jsx_runtime19.jsx)("a", Object.assign({ className: "text-primary", href: link, onClick: readMoreClickHandler }, { children: name }), void 0)] }), void 0)] }), void 0)] }), void 0);
}

// node_modules/@yext/search-ui-react/lib/esm/components/DirectAnswer.js
var builtInCssClasses5 = {
  directAnswerContainer: "",
  directAnswerLoading: "opacity-50",
  answer: "font-bold text-xl text-neutral-dark",
  description: "text-neutral",
  content: "mt-4",
  highlighted: "bg-primary-light",
  answerContainer: "p-4 border border-gray-200 rounded-lg shadow-sm",
  thumbsFeedbackContainer: builtInCssClasses4.thumbsFeedbackContainer,
  thumbsUpIcon: builtInCssClasses4.thumbsUpIcon,
  thumbsDownIcon: builtInCssClasses4.thumbsDownIcon
};
function DirectAnswer({ customCssClasses, UnknownFieldTypeDisplay }) {
  const directAnswerResult = useSearchState((state) => state.directAnswer.result);
  const isLoading = useSearchState((state) => state.searchStatus.isLoading || false);
  const composedCssClasses = useComposedCssClasses(builtInCssClasses5, customCssClasses);
  const handleClickViewDetails = useCardAnalyticsCallback(directAnswerResult, "CTA_CLICK");
  const handleClickFeedbackButton = useCardFeedbackCallback(directAnswerResult);
  if (!directAnswerResult) {
    return null;
  }
  const cssClasses = getCssClassesForAnswerType(composedCssClasses, directAnswerResult.type);
  const containerCssClasses = twMerge2(cssClasses.directAnswerContainer, isLoading && cssClasses.directAnswerLoading);
  return (0, import_jsx_runtime20.jsxs)("div", Object.assign({ className: containerCssClasses }, { children: [directAnswerResult.type === DirectAnswerType.FieldValue ? (0, import_jsx_runtime20.jsx)(FieldValueDirectAnswer, { result: directAnswerResult, cssClasses, viewDetailsClickHandler: handleClickViewDetails, UnknownFieldTypeDisplay }, void 0) : (0, import_jsx_runtime20.jsx)(FeaturedSnippetDirectAnswer, { result: directAnswerResult, readMoreClickHandler: handleClickViewDetails, cssClasses }, void 0), (0, import_jsx_runtime20.jsx)(ThumbsFeedback, { onClick: handleClickFeedbackButton, customCssClasses: composedCssClasses }, void 0)] }), void 0);
}
function getCssClassesForAnswerType(cssClasses, type) {
  const isSnippet = type === DirectAnswerType.FeaturedSnippet;
  return Object.assign(Object.assign({}, cssClasses), { header: isSnippet ? cssClasses.answer : cssClasses.description, body: isSnippet ? cssClasses.description : cssClasses.answer });
}

// node_modules/@yext/search-ui-react/lib/esm/components/FilterSearch.js
var import_jsx_runtime21 = __toESM(require_jsx_runtime());
var import_react42 = __toESM(require_react());
var builtInCssClasses6 = {
  filterSearchContainer: "relative mb-2",
  label: "mb-4 text-sm font-medium text-neutral-dark",
  inputElement: "text-sm bg-white outline-none h-9 w-full p-2 rounded-md border border-gray-300 focus:border-primary text-neutral-dark placeholder:text-neutral",
  sectionLabel: "text-sm text-neutral-dark font-semibold py-2 px-4",
  focusedOption: "bg-gray-100",
  option: "text-sm text-neutral-dark py-1 cursor-pointer hover:bg-gray-100 px-4"
};
function FilterSearch({ searchFields, label, placeholder = "Search here...", searchOnSelect, onSelect, sectioned = false, customCssClasses }) {
  const searchActions = useSearchActions();
  const searchParamFields = searchFields.map((searchField) => {
    return Object.assign(Object.assign({}, searchField), { fetchEntities: false });
  });
  const matchingFieldIds = (0, import_react42.useMemo)(() => {
    const fieldIds = new Set(searchFields.map((s2) => s2.fieldApiName));
    if (fieldIds.has("builtin.location")) {
      ["builtin.region", "address.countryCode"].forEach((s2) => fieldIds.add(s2));
    }
    return fieldIds;
  }, [searchFields]);
  const cssClasses = useComposedCssClasses(builtInCssClasses6, customCssClasses);
  const [currentFilter, setCurrentFilter] = (0, import_react42.useState)();
  const [filterQuery, setFilterQuery] = (0, import_react42.useState)();
  const staticFilters = useSearchState((state) => state.filters.static);
  const matchingFilters = (0, import_react42.useMemo)(() => {
    var _a;
    return (_a = staticFilters === null || staticFilters === void 0 ? void 0 : staticFilters.filter(({ filter, selected }) => selected && filter.kind === "fieldValue" && matchingFieldIds.has(filter.fieldId))) !== null && _a !== void 0 ? _a : [];
  }, [staticFilters, matchingFieldIds]);
  const [filterSearchResponse, executeFilterSearch, clearFilterSearchResponse] = useSynchronizedRequest((inputValue) => {
    setFilterQuery(inputValue);
    return searchActions.executeFilterSearch(inputValue !== null && inputValue !== void 0 ? inputValue : "", sectioned, searchParamFields);
  }, (e2) => console.error("Error occured executing a filter search request.\n", e2));
  (0, import_react42.useEffect)(() => {
    if (matchingFilters.length > 1 && !onSelect) {
      console.warn("More than one selected static filter found that matches the filter search fields: [" + [...matchingFieldIds].join(", ") + "]. Please update the state to remove the extra filters. Picking one filter to display in the input.");
    }
    if (currentFilter && (staticFilters === null || staticFilters === void 0 ? void 0 : staticFilters.find((f2) => isDuplicateStaticFilter(f2.filter, currentFilter) && f2.selected))) {
      return;
    }
    if (matchingFilters.length === 0) {
      clearFilterSearchResponse();
      setCurrentFilter(void 0);
      setFilterQuery("");
    } else {
      setCurrentFilter(matchingFilters[0].filter);
      executeFilterSearch(matchingFilters[0].displayName);
    }
  }, [
    clearFilterSearchResponse,
    currentFilter,
    staticFilters,
    executeFilterSearch,
    onSelect,
    matchingFilters,
    matchingFieldIds
  ]);
  const sections = (0, import_react42.useMemo)(() => {
    var _a;
    return (_a = filterSearchResponse === null || filterSearchResponse === void 0 ? void 0 : filterSearchResponse.sections.filter((section) => section.results.length > 0)) !== null && _a !== void 0 ? _a : [];
  }, [filterSearchResponse === null || filterSearchResponse === void 0 ? void 0 : filterSearchResponse.sections]);
  const hasResults = sections.flatMap((s2) => s2.results).length > 0;
  const handleSelectDropdown = (0, import_react42.useCallback)((_value, _index, itemData) => {
    const newFilter = itemData === null || itemData === void 0 ? void 0 : itemData.filter;
    const newDisplayName = itemData === null || itemData === void 0 ? void 0 : itemData.displayName;
    if (!newFilter || !newDisplayName) {
      return;
    }
    if (onSelect) {
      if (searchOnSelect) {
        console.warn("Both searchOnSelect and onSelect props were passed to the component. Using onSelect instead of searchOnSelect as the latter is deprecated.");
      }
      return onSelect({
        newFilter,
        newDisplayName,
        currentFilter,
        setCurrentFilter,
        executeFilterSearch
      });
    }
    if (matchingFilters.length > 1) {
      console.warn("More than one selected static filter found that matches the filter search fields: [" + [...matchingFieldIds].join(", ") + "]. Unselecting all existing matching filters and selecting the new filter.");
    }
    matchingFilters.forEach((f2) => searchActions.setFilterOption({ filter: f2.filter, selected: false }));
    if (currentFilter) {
      searchActions.setFilterOption({ filter: currentFilter, selected: false });
    }
    searchActions.setFilterOption({ filter: newFilter, displayName: newDisplayName, selected: true });
    setCurrentFilter(newFilter);
    executeFilterSearch(newDisplayName);
    if (searchOnSelect) {
      searchActions.setOffset(0);
      searchActions.resetFacets();
      executeSearch(searchActions);
    }
  }, [
    currentFilter,
    searchActions,
    executeFilterSearch,
    onSelect,
    searchOnSelect,
    matchingFilters,
    matchingFieldIds
  ]);
  const meetsSubmitCritera = (0, import_react42.useCallback)((index2) => index2 >= 0, []);
  const itemDataMatrix = (0, import_react42.useMemo)(() => {
    return sections.map((section) => {
      return section.results.map((result) => ({
        filter: Object.assign(Object.assign({}, result.filter), { kind: "fieldValue" }),
        displayName: result.value
      }));
    });
  }, [sections]);
  function renderDropdownItems() {
    return sections.map((section, sectionIndex) => {
      return (0, import_jsx_runtime21.jsxs)("div", Object.assign({ className: "pb-2" }, { children: [section.label && (0, import_jsx_runtime21.jsx)("div", Object.assign({ className: cssClasses.sectionLabel }, { children: section.label }), void 0), (0, import_jsx_runtime21.jsx)("div", Object.assign({ className: cssClasses.optionsContainer }, { children: section.results.map((result, index2) => (0, import_jsx_runtime21.jsx)(DropdownItem, Object.assign({ focusedClassName: cssClasses.focusedOption, value: result.value, itemData: itemDataMatrix[sectionIndex][index2] }, { children: renderAutocompleteResult(result, cssClasses) }), index2)) }), void 0)] }), sectionIndex);
    });
  }
  const handleInputFocus = (0, import_react42.useCallback)((value = "") => {
    if (value) {
      executeFilterSearch(value);
    }
  }, [executeFilterSearch]);
  return (0, import_jsx_runtime21.jsxs)("div", Object.assign({ className: cssClasses.filterSearchContainer }, { children: [label && (0, import_jsx_runtime21.jsx)("h1", Object.assign({ className: cssClasses.label }, { children: label }), void 0), (0, import_jsx_runtime21.jsxs)(Dropdown, Object.assign({ screenReaderText: getScreenReaderText2(sections), onSelect: handleSelectDropdown, alwaysSelectOption: true, parentQuery: filterQuery }, { children: [(0, import_jsx_runtime21.jsx)(DropdownInput, { className: cssClasses.inputElement, placeholder, onChange: executeFilterSearch, onFocus: handleInputFocus, submitCriteria: meetsSubmitCritera }, void 0), (0, import_jsx_runtime21.jsx)(DropdownMenu, { children: hasResults && (0, import_jsx_runtime21.jsx)("div", Object.assign({ className: "absolute z-10 w-full shadow-lg rounded-md border border-gray-300 bg-white pt-3 pb-1 mt-1" }, { children: renderDropdownItems() }), void 0) }, void 0)] }), void 0)] }), void 0);
}
function getScreenReaderText2(sections) {
  let screenReaderText = processTranslation({
    phrase: "0 autocomplete option found.",
    pluralForm: "0 autocomplete options found.",
    count: 0
  });
  if (sections.length === 0) {
    return screenReaderText;
  }
  const screenReaderPhrases = sections.map((section) => {
    const optionInfo = section.label ? `${section.results.length} ${section.label}` : `${section.results.length}`;
    return processTranslation({
      phrase: `${optionInfo} autocomplete option found.`,
      pluralForm: `${optionInfo} autocomplete options found.`,
      count: section.results.length
    });
  });
  screenReaderText = screenReaderPhrases.join(" ");
  return screenReaderText;
}

// node_modules/@yext/search-ui-react/lib/esm/components/LocationBias.js
var import_jsx_runtime23 = __toESM(require_jsx_runtime());
var import_react43 = __toESM(require_react());

// node_modules/@yext/search-ui-react/lib/esm/icons/LoadingIndicator.js
var import_jsx_runtime22 = __toESM(require_jsx_runtime());
function LoadingIndicator() {
  return (0, import_jsx_runtime22.jsx)("div", Object.assign({ className: "animate-[rotate_1.4s_linear_infinite]" }, { children: (0, import_jsx_runtime22.jsx)("svg", Object.assign({ className: "[stroke-dasharray:208] origin-[50%_50%] animate-[dash_1.4s_ease-in-out_infinite]", viewBox: "0 0 72 72" }, { children: (0, import_jsx_runtime22.jsx)("circle", { className: "", cx: "36", cy: "36", r: "33", stroke: "black", strokeWidth: "3", fill: "none" }, void 0) }), void 0) }), void 0);
}

// node_modules/@yext/search-ui-react/lib/esm/components/LocationBias.js
var builtInCssClasses7 = {
  locationBiasContainer: "text-sm text-neutral text-center justify-center items-center flex flex-col lg:flex-row",
  location: "font-semibold lg:ml-7",
  source: "ml-3 lg:ml-0 whitespace-pre",
  button: "text-primary hover:underline focus:underline ml-7 lg:ml-0",
  loadingIndicatorContainer: "w-4 h-4 ml-3 shrink-0"
};
function LocationBias({ geolocationOptions, customCssClasses }) {
  const searchActions = useSearchActions();
  const locationBias = useSearchState((s2) => s2.location.locationBias);
  const [isFetchingLocation, setIsFetchingLocation] = (0, import_react43.useState)(false);
  const cssClasses = useComposedCssClasses(builtInCssClasses7, customCssClasses);
  const loadingIndicatorCss = twMerge2(cssClasses.loadingIndicatorContainer, !isFetchingLocation && "invisible");
  if (!(locationBias === null || locationBias === void 0 ? void 0 : locationBias.displayName))
    return null;
  const attributionMessage = (locationBias === null || locationBias === void 0 ? void 0 : locationBias.method) === LocationBiasMethod.Ip ? " (based on your internet address)" : (locationBias === null || locationBias === void 0 ? void 0 : locationBias.method) === LocationBiasMethod.Device ? " (based on your device)" : "";
  async function handleGeolocationClick() {
    setIsFetchingLocation(true);
    try {
      const position = await getUserLocation(geolocationOptions);
      searchActions.setUserLocation({
        latitude: position.coords.latitude,
        longitude: position.coords.longitude
      });
    } catch (e2) {
      console.error(e2);
    } finally {
      setIsFetchingLocation(false);
    }
    executeSearch(searchActions);
  }
  return (0, import_jsx_runtime23.jsxs)("div", Object.assign({ className: cssClasses.locationBiasContainer }, { children: [(0, import_jsx_runtime23.jsx)("span", Object.assign({ className: cssClasses.location }, { children: locationBias.displayName }), void 0), (0, import_jsx_runtime23.jsxs)("span", Object.assign({ className: cssClasses.source }, { children: [attributionMessage, (0, import_jsx_runtime23.jsx)("span", Object.assign({ className: "invisible lg:visible" }, { children: " - " }), void 0)] }), void 0), (0, import_jsx_runtime23.jsxs)("div", Object.assign({ className: "flex flex-row items-center" }, { children: [(0, import_jsx_runtime23.jsx)("button", Object.assign({ className: cssClasses.button, onClick: handleGeolocationClick }, { children: "Update your location" }), void 0), (0, import_jsx_runtime23.jsx)("div", Object.assign({ className: loadingIndicatorCss }, { children: (0, import_jsx_runtime23.jsx)(LoadingIndicator, {}, void 0) }), void 0)] }), void 0)] }), void 0);
}

// node_modules/@yext/search-ui-react/lib/esm/components/Geolocation.js
var import_jsx_runtime24 = __toESM(require_jsx_runtime());

// node_modules/@yext/search-ui-react/lib/esm/hooks/useGeolocationHandler.js
var import_react44 = __toESM(require_react());
var GEOLOCATION_FIELD_ID = "builtin.location";
var LOCATION_FIELD_IDS = [GEOLOCATION_FIELD_ID, "builtin.region", "address.countryCode"];
var METERS_PER_MILE = 1609.344;
function useGeolocationHandler({ geolocationOptions, radius = 50, handleUserPosition }) {
  const [isFetchingUserLocation, setIsFetchingUserLocation] = (0, import_react44.useState)(false);
  const searchActions = useSearchActions();
  const staticFilters = useSearchState((s2) => s2.filters.static || []);
  const defaultHandleUserPosition = (0, import_react44.useCallback)((position) => {
    const { latitude, longitude, accuracy } = position.coords;
    const locationFilter = {
      displayName: "Current Location",
      selected: true,
      filter: {
        kind: "fieldValue",
        fieldId: GEOLOCATION_FIELD_ID,
        matcher: Matcher.Near,
        value: {
          lat: latitude,
          lng: longitude,
          radius: Math.max(accuracy, radius * METERS_PER_MILE)
        }
      }
    };
    const nonLocationFilters = staticFilters.filter((filter) => {
      return !(filter.filter.kind === "fieldValue" && LOCATION_FIELD_IDS.includes(filter.filter.fieldId));
    });
    searchActions.setStaticFilters([...nonLocationFilters, locationFilter]);
    executeSearch(searchActions);
  }, [radius, searchActions, staticFilters]);
  const geolocationHandler = (0, import_react44.useCallback)(async () => {
    setIsFetchingUserLocation(true);
    try {
      const position = await getUserLocation(geolocationOptions);
      (handleUserPosition !== null && handleUserPosition !== void 0 ? handleUserPosition : defaultHandleUserPosition)(position);
    } catch (e2) {
      console.warn(e2);
    } finally {
      setIsFetchingUserLocation(false);
    }
  }, [setIsFetchingUserLocation, geolocationOptions, handleUserPosition, defaultHandleUserPosition]);
  return [geolocationHandler, isFetchingUserLocation];
}

// node_modules/@yext/search-ui-react/lib/esm/components/Geolocation.js
var builtInCssClasses8 = {
  geolocationContainer: "text-sm text-neutral text-center justify-center items-center flex flex-row",
  button: "text-primary font-semibold hover:underline focus:underline",
  iconContainer: "w-4 ml-2"
};
function Geolocation({
  geolocationOptions,
  radius = 50,
  label = "Use my location",
  GeolocationIcon = YextIcon,
  handleClick,
  customCssClasses
}) {
  const cssClasses = useComposedCssClasses(builtInCssClasses8, customCssClasses);
  const [handleGeolocationClick, isFetchingUserLocation] = useGeolocationHandler({
    geolocationOptions,
    radius,
    handleUserPosition: handleClick
  });
  return (0, import_jsx_runtime24.jsxs)("div", Object.assign({ className: cssClasses.geolocationContainer }, { children: [(0, import_jsx_runtime24.jsx)("button", Object.assign({ className: cssClasses.button, onClick: handleGeolocationClick }, { children: label }), void 0), (0, import_jsx_runtime24.jsx)("div", Object.assign({ className: cssClasses.iconContainer }, { children: isFetchingUserLocation ? (0, import_jsx_runtime24.jsx)(LoadingIndicator, {}, void 0) : (0, import_jsx_runtime24.jsx)(GeolocationIcon, {}, void 0) }), void 0)] }), void 0);
}

// node_modules/@yext/search-ui-react/lib/esm/components/AppliedFilters.js
var import_jsx_runtime27 = __toESM(require_jsx_runtime());
var import_classnames3 = __toESM(require_classnames());

// node_modules/@yext/search-ui-react/lib/esm/components/AppliedFiltersDisplay.js
var import_jsx_runtime25 = __toESM(require_jsx_runtime());

// node_modules/@yext/search-ui-react/lib/esm/hooks/useClearFiltersCallback.js
var import_react45 = __toESM(require_react());
function useClearFiltersCallback() {
  const searchActions = useSearchActions();
  const staticFilters = useSearchState((state) => state.filters.static);
  return (0, import_react45.useCallback)(() => {
    searchActions.setOffset(0);
    searchActions.resetFacets();
    staticFilters && searchActions.setStaticFilters(staticFilters.map((f2) => {
      return Object.assign(Object.assign({}, f2), { selected: false });
    }));
    executeSearch(searchActions);
  }, [searchActions, staticFilters]);
}

// node_modules/@yext/search-ui-react/lib/esm/components/AppliedFiltersDisplay.js
function AppliedFiltersDisplay(props) {
  const { nlpFilterDisplayNames = [], removableFilters = [], cssClasses = {} } = props;
  const handleClickClearAllButton = useClearFiltersCallback();
  const searchActions = useSearchActions();
  if (removableFilters.length + nlpFilterDisplayNames.length === 0) {
    return null;
  }
  const dedupedNlpFilterDisplayNames = nlpFilterDisplayNames.filter((displayName) => {
    return !removableFilters.some((f2) => f2.displayName === displayName);
  });
  const dedupedRemovableFilters = getDedupedRemovableFilters(removableFilters);
  function handleRemoveDedupedFilter(dedupedFilter) {
    var _a;
    dedupedFilter.handleRemove();
    for (const f2 of (_a = dedupedFilter.duplicates) !== null && _a !== void 0 ? _a : []) {
      f2.handleRemove();
    }
    searchActions.setOffset(0);
    executeSearch(searchActions);
  }
  return (0, import_jsx_runtime25.jsxs)("div", Object.assign({ className: cssClasses.appliedFiltersContainer, "aria-label": "Applied filters to current search" }, { children: [dedupedNlpFilterDisplayNames.map((displayName, i2) => renderNlpFilter(displayName, i2, cssClasses)), dedupedRemovableFilters.map((f2, i2) => {
    return renderRemovableFilter(f2.displayName, () => handleRemoveDedupedFilter(f2), i2, cssClasses);
  }), removableFilters.length > 0 && (0, import_jsx_runtime25.jsx)("button", Object.assign({ onClick: handleClickClearAllButton, className: cssClasses.clearAllButton }, { children: "Clear All" }), void 0)] }), void 0);
}
function getDedupedRemovableFilters(filters) {
  const dedupedFilters = [];
  for (const f2 of filters) {
    const preexistingDupe = dedupedFilters.find((d2) => isDuplicateFieldValueFilter(d2.filter, f2.filter));
    if (!preexistingDupe) {
      dedupedFilters.push(f2);
    } else {
      if (!preexistingDupe.duplicates) {
        preexistingDupe.duplicates = [f2];
      } else {
        preexistingDupe.duplicates.push(f2);
      }
    }
  }
  return dedupedFilters;
}
function renderRemovableFilter(displayName, handleRemove, index2, cssClasses) {
  return (0, import_jsx_runtime25.jsxs)("div", Object.assign({ className: cssClasses.removableFilter }, { children: [(0, import_jsx_runtime25.jsx)("div", Object.assign({ className: cssClasses.filterLabel }, { children: displayName }), void 0), (0, import_jsx_runtime25.jsx)("button", Object.assign({ className: "w-2 h-2 text-neutral m-1.5", onClick: handleRemove, "aria-label": `Remove "${displayName}" filter` }, { children: (0, import_jsx_runtime25.jsx)(CloseIcon, {}, void 0) }), void 0)] }), `${displayName}-${index2}`);
}
function renderNlpFilter(displayName, index2, cssClasses) {
  return (0, import_jsx_runtime25.jsx)("div", Object.assign({ className: cssClasses.nlpFilter }, { children: (0, import_jsx_runtime25.jsx)("span", Object.assign({ className: cssClasses.filterLabel }, { children: displayName }), void 0) }), `${displayName}-${index2}`);
}

// node_modules/@yext/search-ui-react/lib/esm/components/Filters/HierarchicalFacetDisplay.js
var import_jsx_runtime26 = __toESM(require_jsx_runtime());
var import_react48 = __toESM(require_react());

// node_modules/@yext/search-ui-react/lib/esm/hooks/useHierarchicalFacetTree.js
var import_react46 = __toESM(require_react());
function useHierarchicalFacetTree(hierarchicalFacet, delimiter) {
  return (0, import_react46.useMemo)(() => {
    return parseHierarchicalFacetTree(hierarchicalFacet, delimiter);
  }, [delimiter, hierarchicalFacet]);
}
function parseHierarchicalFacetTree(hierarchicalFacet, delimiter) {
  const optionsInAscendingLength = (hierarchicalFacet === null || hierarchicalFacet === void 0 ? void 0 : hierarchicalFacet.options.map((o2) => {
    const displayNameTokens = o2.displayName.split(delimiter).map((s2) => s2.trim());
    return Object.assign(Object.assign({}, o2), { displayNameTokens });
  }).sort((a2, b) => a2.displayNameTokens.length - b.displayNameTokens.length)) || [];
  const tree = {};
  optionsInAscendingLength.forEach((o2) => {
    const { displayNameTokens, displayName } = o2;
    let currentTree = tree;
    let parentNode = void 0;
    for (const token of displayNameTokens.slice(0, -1)) {
      if (!(token in currentTree)) {
        console.error(`Error parsing hierarchical facet option "${displayName}" at token "${token}". Current tree:`, JSON.stringify(tree));
        return;
      }
      if (o2.selected) {
        currentTree[token].hasSelectedChild = true;
      }
      parentNode = currentTree[token];
      currentTree = currentTree[token].childTree;
    }
    const lastDisplayNameToken = displayNameTokens[displayNameTokens.length - 1];
    currentTree[lastDisplayNameToken] = {
      selected: o2.selected,
      displayNameTokens,
      lastDisplayNameToken,
      facetOption: {
        value: o2.value,
        matcher: o2.matcher
      },
      hasSelectedChild: false,
      childTree: {},
      parentNode
    };
  });
  return tree;
}

// node_modules/@yext/search-ui-react/lib/esm/components/Filters/FiltersContext.js
var import_react47 = __toESM(require_react());
var FiltersContext = (0, import_react47.createContext)(null);
function useFiltersContext() {
  const filtersContextInstance = (0, import_react47.useContext)(FiltersContext);
  if (filtersContextInstance === null) {
    throw new Error("Tried to use FiltersContext when none exists.");
  }
  return filtersContextInstance;
}

// node_modules/@yext/search-ui-react/lib/esm/components/Filters/HierarchicalFacetDisplay.js
var DEFAULT_HIERARCHICAL_DELIMITER = ">";
var builtInCssClasses9 = {
  treeContainer: "flex flex-col items-start",
  allCategoriesOption___active: "font-semibold mb-2 text-sm",
  allCategoriesOption___inactive: "mb-2 text-sm",
  availableOption__active: "font-semibold ml-4 mb-2 text-sm",
  availableOption__inactive: "ml-4 mb-2 text-sm",
  parentCategory: "mb-2 text-sm",
  currentCategory: "font-semibold mb-2 text-sm",
  showMoreButton: "ml-4 text-sm font-medium text-primary"
};
function HierarchicalFacetDisplay({ facet, delimiter = DEFAULT_HIERARCHICAL_DELIMITER, showMoreLimit = 4, customCssClasses }) {
  const cssClasses = useComposedCssClasses(builtInCssClasses9, customCssClasses);
  const tree = useHierarchicalFacetTree(facet, delimiter);
  const [isShowingMore, setIsShowingMore] = (0, import_react48.useState)(false);
  const resetShowMore = (0, import_react48.useCallback)(() => setIsShowingMore(false), []);
  const toggleShowMore = (0, import_react48.useCallback)(() => {
    setIsShowingMore(!isShowingMore);
  }, [isShowingMore]);
  function renderTree() {
    let treePointer = tree;
    const renderedNodesAndShowMoreButton = [renderAllCategoriesButton()];
    while (treePointer) {
      const currentNodes = Object.values(treePointer);
      const selectedChildNode = currentNodes.find((n2) => n2.selected);
      const selectedHasNoChildren = selectedChildNode && Object.values(selectedChildNode.childTree).length === 0;
      const activeParentNode = currentNodes.find((n2) => n2.hasSelectedChild);
      if (!selectedChildNode && !activeParentNode || selectedHasNoChildren) {
        renderedNodesAndShowMoreButton.push(...renderAvailableOptions(currentNodes));
        if (currentNodes.length > showMoreLimit) {
          renderedNodesAndShowMoreButton.push(renderShowMoreButton());
        }
        break;
      }
      const activeNode = selectedChildNode !== null && selectedChildNode !== void 0 ? selectedChildNode : activeParentNode;
      if (!activeNode) {
        break;
      }
      renderedNodesAndShowMoreButton.push(renderCategory(activeNode, facet.fieldId));
      treePointer = activeNode.childTree;
    }
    return renderedNodesAndShowMoreButton;
  }
  function renderAllCategoriesButton() {
    return (0, import_jsx_runtime26.jsx)(AllCategories, { activeClassName: cssClasses.allCategoriesOption___active, inactiveClassName: cssClasses.allCategoriesOption___inactive, facet, resetShowMore }, "_AllCategories");
  }
  function renderAvailableOptions(nodes) {
    const nodesToRender = isShowingMore ? nodes : nodes.slice(0, showMoreLimit);
    return nodesToRender.map((n2) => (0, import_jsx_runtime26.jsx)(AvailableOption, { activeClassName: cssClasses.availableOption__active, inactiveClassName: cssClasses.availableOption__inactive, fieldId: facet.fieldId, currentNode: n2, resetShowMore, siblingNodes: nodes.filter((siblingNode) => siblingNode !== n2) }, n2.lastDisplayNameToken));
  }
  function renderShowMoreButton() {
    return (0, import_jsx_runtime26.jsx)(ShowMoreButton, { className: cssClasses.showMoreButton, isShowingMore, toggleShowMore }, "_ShowMoreButton");
  }
  function renderCategory(selectedNode, fieldId) {
    const sharedProps = {
      key: selectedNode.lastDisplayNameToken,
      resetShowMore,
      selectedNode,
      fieldId
    };
    if (selectedNode.hasSelectedChild) {
      return (0, import_jsx_runtime26.jsx)(ParentCategory, Object.assign({ className: cssClasses.parentCategory }, sharedProps), void 0);
    } else {
      return (0, import_jsx_runtime26.jsx)(CurrentCategory, Object.assign({ className: cssClasses.currentCategory }, sharedProps), void 0);
    }
  }
  return (0, import_jsx_runtime26.jsx)("div", Object.assign({ className: cssClasses.treeContainer }, { children: renderTree() }), void 0);
}
function AllCategories({ facet, inactiveClassName, activeClassName, resetShowMore }) {
  const { applyFilters, selectFilter } = useFiltersContext();
  const handleClickAllCategories = (0, import_react48.useCallback)(() => {
    facet.options.filter((o2) => o2.selected).forEach((o2) => selectFilter(Object.assign(Object.assign({}, o2), { fieldId: facet.fieldId, selected: false })));
    applyFilters();
    resetShowMore();
  }, [applyFilters, facet.fieldId, facet.options, resetShowMore, selectFilter]);
  if (facet.options.find((o2) => o2.selected)) {
    return (0, import_jsx_runtime26.jsx)("button", Object.assign({ className: inactiveClassName, onClick: handleClickAllCategories }, { children: "All Categories /" }), void 0);
  }
  return (0, import_jsx_runtime26.jsx)("div", Object.assign({ className: activeClassName }, { children: "All Categories" }), void 0);
}
function AvailableOption(props) {
  var _a;
  const { fieldId, currentNode, activeClassName, inactiveClassName, resetShowMore, siblingNodes } = props;
  const { applyFilters, selectFilter } = useFiltersContext();
  const { selected, lastDisplayNameToken, facetOption } = currentNode;
  const handleClickAvailableOptions = (0, import_react48.useCallback)(() => {
    var _a2;
    siblingNodes.filter((n2) => n2.selected).forEach((n2) => selectFilter(Object.assign(Object.assign({}, n2.facetOption), { selected: false, fieldId })));
    selectFilter(Object.assign(Object.assign({}, facetOption), { selected: !selected, fieldId }));
    const parentFacetOption = (_a2 = currentNode.parentNode) === null || _a2 === void 0 ? void 0 : _a2.facetOption;
    parentFacetOption && selectFilter(Object.assign(Object.assign({}, parentFacetOption), {
      selected,
      fieldId
    }));
    applyFilters();
    resetShowMore();
  }, [
    applyFilters,
    (_a = currentNode.parentNode) === null || _a === void 0 ? void 0 : _a.facetOption,
    facetOption,
    fieldId,
    resetShowMore,
    selectFilter,
    selected,
    siblingNodes
  ]);
  return (0, import_jsx_runtime26.jsx)("button", Object.assign({ className: selected ? activeClassName : inactiveClassName, onClick: handleClickAvailableOptions }, { children: lastDisplayNameToken }), void 0);
}
function ParentCategory({ fieldId, selectedNode, className, resetShowMore }) {
  const { applyFilters, selectFilter } = useFiltersContext();
  const deselectChildOptions = (0, import_react48.useCallback)((node) => {
    const tree = node.childTree;
    Object.values(tree).forEach((n2) => {
      selectFilter(Object.assign(Object.assign({}, n2.facetOption), { selected: false, fieldId }));
      deselectChildOptions(n2);
    });
  }, [fieldId, selectFilter]);
  const handleClickParentCategory = (0, import_react48.useCallback)(() => {
    selectFilter(Object.assign(Object.assign({}, selectedNode.facetOption), { selected: true, fieldId }));
    deselectChildOptions(selectedNode);
    applyFilters();
    resetShowMore();
  }, [applyFilters, deselectChildOptions, fieldId, resetShowMore, selectFilter, selectedNode]);
  return (0, import_jsx_runtime26.jsx)("button", Object.assign({ className, onClick: handleClickParentCategory }, { children: selectedNode.lastDisplayNameToken + " /" }), void 0);
}
function CurrentCategory({ fieldId, selectedNode, className, resetShowMore }) {
  var _a;
  const { applyFilters, selectFilter } = useFiltersContext();
  const handleClickCurrentCategory = (0, import_react48.useCallback)(() => {
    var _a2;
    selectFilter(Object.assign(Object.assign({}, selectedNode.facetOption), { selected: false, fieldId }));
    const parentFacetOption = (_a2 = selectedNode.parentNode) === null || _a2 === void 0 ? void 0 : _a2.facetOption;
    parentFacetOption && selectFilter(Object.assign(Object.assign({}, parentFacetOption), { selected: true, fieldId }));
    applyFilters();
    resetShowMore();
  }, [
    applyFilters,
    fieldId,
    resetShowMore,
    selectFilter,
    selectedNode.facetOption,
    (_a = selectedNode.parentNode) === null || _a === void 0 ? void 0 : _a.facetOption
  ]);
  return (0, import_jsx_runtime26.jsx)("button", Object.assign({ className, onClick: handleClickCurrentCategory }, { children: selectedNode.lastDisplayNameToken }), void 0);
}
function ShowMoreButton({ className, isShowingMore, toggleShowMore }) {
  return (0, import_jsx_runtime26.jsx)("button", Object.assign({ className, onClick: toggleShowMore }, { children: isShowingMore ? "Show less" : "Show more" }), void 0);
}

// node_modules/@yext/search-ui-react/lib/esm/hooks/useNlpFilterDisplayNames.js
var import_react49 = __toESM(require_react());
function useNlpFilterDisplayNames(removableFilters, hiddenFields) {
  const nlpFilters = useSearchState((state) => state.vertical.appliedQueryFilters);
  return (0, import_react49.useMemo)(() => {
    var _a;
    return (_a = nlpFilters === null || nlpFilters === void 0 ? void 0 : nlpFilters.filter(({ filter }) => {
      if (hiddenFields.includes(filter.fieldId)) {
        return false;
      }
      const duplicateFilter = removableFilters.find((f2) => isDuplicateFieldValueFilter(f2, filter));
      return !duplicateFilter;
    }).map((f2) => f2.displayValue)) !== null && _a !== void 0 ? _a : [];
  }, [hiddenFields, nlpFilters, removableFilters]);
}

// node_modules/@yext/search-ui-react/lib/esm/hooks/useRemovableFilters.js
var import_lodash2 = __toESM(require_lodash());
var import_react52 = __toESM(require_react());

// node_modules/@yext/search-ui-react/lib/esm/utils/isDescendantHierarchicalFacet.js
function isDescendantHierarchicalFacet(descendantTokens, parentTokens) {
  if (descendantTokens.length <= parentTokens.length) {
    return false;
  }
  for (let i2 = 0; i2 < parentTokens.length; i2++) {
    if (descendantTokens[i2] !== parentTokens[i2]) {
      return false;
    }
  }
  return true;
}

// node_modules/@yext/search-ui-react/lib/esm/hooks/useStateUpdatedOnSearch.js
var import_react50 = __toESM(require_react());
function useStateUpdatedOnSearch(stateSelector) {
  const isLoading = useSearchState((state) => state.searchStatus.isLoading);
  const wasLoading = (0, import_react50.useRef)(isLoading);
  const currentState = useSearchState(stateSelector);
  const snapshottedState = (0, import_react50.useRef)(currentState);
  if (!isLoading && wasLoading.current) {
    snapshottedState.current = currentState;
  }
  wasLoading.current = isLoading;
  return snapshottedState.current;
}

// node_modules/@yext/search-ui-react/lib/esm/hooks/useRemovableStaticFilters.js
var import_react51 = __toESM(require_react());
function useRemovableStaticFilters(hiddenFields) {
  const staticFilters = useStateUpdatedOnSearch((state) => state.filters.static);
  const hasResults = !!useSearchState((state) => state.vertical.results);
  const searchActions = useSearchActions();
  return (0, import_react51.useMemo)(() => {
    if (!hasResults || !staticFilters) {
      return [];
    }
    function handleRemoveStaticFilterOption(filter) {
      searchActions.setFilterOption({
        filter: Object.assign(Object.assign({}, filter), { kind: "fieldValue" }),
        selected: false
      });
    }
    return getSelectableFieldValueFilters(staticFilters).filter((f2) => f2.selected && !hiddenFields.includes(f2.fieldId)).map((f2) => {
      var _a;
      return {
        displayName: (_a = f2.displayName) !== null && _a !== void 0 ? _a : "",
        handleRemove: () => handleRemoveStaticFilterOption(f2),
        filter: f2
      };
    });
  }, [hasResults, hiddenFields, searchActions, staticFilters]);
}

// node_modules/@yext/search-ui-react/lib/esm/hooks/useRemovableFilters.js
function useRemovableFilters(hierarchicalFieldIds, hierarchicalDelimiter, hiddenFields) {
  const facets = useStateUpdatedOnSearch((state) => state.filters.facets);
  const hasResults = !!useSearchState((state) => state.vertical.results);
  const searchActions = useSearchActions();
  const removableStaticFilters = useRemovableStaticFilters(hiddenFields);
  return (0, import_react52.useMemo)(() => {
    var _a;
    if (!hasResults) {
      return [];
    }
    const removableFacets = (_a = facets === null || facets === void 0 ? void 0 : facets.filter((f2) => !hiddenFields.includes(f2.fieldId)).flatMap((f2) => {
      if (hierarchicalFieldIds === null || hierarchicalFieldIds === void 0 ? void 0 : hierarchicalFieldIds.includes(f2.fieldId)) {
        return processHierarchicalFacet(f2, hierarchicalDelimiter, searchActions, facets);
      }
      return processRegularFacet(f2, searchActions);
    })) !== null && _a !== void 0 ? _a : [];
    return [...removableStaticFilters, ...removableFacets];
  }, [
    facets,
    hasResults,
    hiddenFields,
    hierarchicalDelimiter,
    hierarchicalFieldIds,
    searchActions,
    removableStaticFilters
  ]);
}
function processRegularFacet(f2, searchActions) {
  return f2.options.filter((o2) => o2.selected).map((option) => {
    const filter = {
      value: option.value,
      matcher: option.matcher,
      fieldId: f2.fieldId
    };
    return {
      displayName: option.displayName,
      handleRemove: () => handleRemoveFacetOption(filter, searchActions),
      filter
    };
  });
}
function processHierarchicalFacet(f2, delimiter, searchActions, facets) {
  function createAppliedFilter(o2, tokens) {
    const filter = {
      matcher: o2.matcher,
      value: o2.value,
      fieldId: f2.fieldId
    };
    const handleRemove = () => handleRemoveHierarchicalFacetOption(filter, tokens, delimiter, searchActions, facets);
    return {
      displayName: tokens[tokens.length - 1],
      handleRemove,
      filter,
      tokens
    };
  }
  return f2.options.filter((o2) => o2.selected).flatMap((selectedOption) => {
    const displayNameTokens = splitDisplayName(selectedOption.displayName, delimiter);
    const appliedFacets = [createAppliedFilter(selectedOption, displayNameTokens)];
    f2.options.forEach((option) => {
      const tokens = splitDisplayName(option.displayName, delimiter);
      const isDescendant = isDescendantHierarchicalFacet(displayNameTokens, tokens);
      if (!isDescendant) {
        return;
      }
      appliedFacets.push(createAppliedFilter(option, tokens));
    });
    appliedFacets.sort((a2, b) => a2.tokens.length - b.tokens.length);
    return appliedFacets;
  });
}
function handleRemoveHierarchicalFacetOption(filter, displayNameTokens, delimiter, searchActions, facets) {
  searchActions.setFacetOption(filter.fieldId, {
    matcher: filter.matcher,
    value: filter.value
  }, false);
  facets === null || facets === void 0 ? void 0 : facets.filter((f2) => f2.fieldId === filter.fieldId).flatMap((f2) => f2.options).forEach((o2) => {
    if (!o2.selected) {
      return;
    }
    const tokensToCheck = splitDisplayName(o2.displayName, delimiter);
    if (isDescendantHierarchicalFacet(tokensToCheck, displayNameTokens)) {
      searchActions.setFacetOption(filter.fieldId, {
        matcher: o2.matcher,
        value: o2.value
      }, false);
    }
  });
  const parentTokens = displayNameTokens.slice(0, -1);
  const parentOption = facets === null || facets === void 0 ? void 0 : facets.filter((f2) => f2.fieldId === filter.fieldId).flatMap((f2) => f2.options).find((o2) => {
    const tokens = splitDisplayName(o2.displayName, delimiter);
    return (0, import_lodash2.isEqual)(tokens, parentTokens);
  });
  parentOption && searchActions.setFacetOption(filter.fieldId, {
    matcher: parentOption.matcher,
    value: parentOption.value
  }, true);
}
function handleRemoveFacetOption({ fieldId, matcher, value }, searchActions) {
  if (isNearFilterValue(value)) {
    console.error("A FieldValueFilter with a NearFilterValue is not a supported RemovableFilter.");
    return;
  }
  searchActions.setFacetOption(fieldId, { matcher, value }, false);
}
function splitDisplayName(displayName, delimiter) {
  return displayName.split(delimiter).map((s2) => s2.trim());
}

// node_modules/@yext/search-ui-react/lib/esm/components/AppliedFilters.js
var builtInCssClasses10 = {
  appliedFiltersContainer: "flex flex-wrap -mt-3 md:mt-0 mb-2",
  appliedFiltersLoading: "opacity-50",
  nlpFilter: "border border-gray-200 rounded-3xl px-3 py-1.5 text-sm font-medium text-neutral-dark mr-2 mb-2",
  removableFilter: "flex items-center border border-gray-200 rounded-3xl px-3 py-1.5 text-sm font-medium text-neutral-dark mr-2 mb-2",
  clearAllButton: "text-sm font-medium text-primary hover:underline focus:underline mb-2"
};
var DEFAULT_HIDDEN_FIELDS = ["builtin.entityType"];
function AppliedFilters(props) {
  var _a;
  const isLoading = useSearchState((state) => state.searchStatus.isLoading);
  const { hiddenFields = DEFAULT_HIDDEN_FIELDS, customCssClasses = {}, hierarchicalFacetsDelimiter = DEFAULT_HIERARCHICAL_DELIMITER, hierarchicalFacetsFieldIds } = props;
  const removableFilters = useRemovableFilters(hierarchicalFacetsFieldIds, hierarchicalFacetsDelimiter, hiddenFields);
  const nlpFilterDisplayNames = useNlpFilterDisplayNames(removableFilters.map((f2) => f2.filter), hiddenFields);
  const cssClasses = useComposedCssClasses(builtInCssClasses10, customCssClasses);
  cssClasses.appliedFiltersContainer = (0, import_classnames3.default)(cssClasses.appliedFiltersContainer, {
    [(_a = cssClasses.appliedFiltersLoading) !== null && _a !== void 0 ? _a : ""]: isLoading
  });
  return (0, import_jsx_runtime27.jsx)(AppliedFiltersDisplay, { removableFilters, nlpFilterDisplayNames, cssClasses }, void 0);
}

// node_modules/@yext/search-ui-react/lib/esm/components/UniversalResults.js
var import_jsx_runtime34 = __toESM(require_jsx_runtime());

// node_modules/@yext/search-ui-react/lib/esm/components/sections/StandardSection.js
var import_jsx_runtime31 = __toESM(require_jsx_runtime());

// node_modules/@yext/search-ui-react/lib/esm/components/VerticalResultsDisplay.js
var import_jsx_runtime28 = __toESM(require_jsx_runtime());
var import_classnames4 = __toESM(require_classnames());
var builtInCssClasses11 = {
  verticalResultsLoading: "opacity-50"
};
function VerticalResultsDisplay(props) {
  var _a;
  const { CardComponent, results, isLoading = false, customCssClasses } = props;
  const cssClasses = useComposedCssClasses(builtInCssClasses11, customCssClasses);
  if (results.length === 0) {
    return null;
  }
  const resultsClassNames = (0, import_classnames4.default)(cssClasses.verticalResultsContainer, {
    [(_a = cssClasses.verticalResultsLoading) !== null && _a !== void 0 ? _a : ""]: isLoading
  });
  return (0, import_jsx_runtime28.jsx)("div", Object.assign({ className: resultsClassNames }, { children: results === null || results === void 0 ? void 0 : results.map((result) => renderResult(CardComponent, result)) }), void 0);
}
function renderResult(CardComponent, result) {
  return (0, import_jsx_runtime28.jsx)(CardComponent, { result }, result.id || result.index);
}

// node_modules/@yext/search-ui-react/lib/esm/components/cards/standard/StandardCard.js
var import_jsx_runtime30 = __toESM(require_jsx_runtime());

// node_modules/@yext/search-ui-react/lib/esm/components/cards/standard/StandardCardDisplay.js
var import_jsx_runtime29 = __toESM(require_jsx_runtime());
var import_prop_types = __toESM(require_prop_types());
var builtInCssClasses12 = {
  container: "flex flex-col justify-between border border-gray-200 rounded-lg mb-4 p-4 shadow-sm",
  header: "flex text-neutral-dark",
  body: "flex justify-end pt-2.5 text-base",
  cta1: "whitespace-nowrap bg-primary text-white font-medium rounded-lg py-2 px-5 shadow",
  cta2: "whitespace-nowrap bg-white text-primary font-medium rounded-lg py-2 px-5 mt-2 shadow",
  title: "text-lg font-medium",
  thumbsFeedbackContainer: "flex justify-end mt-4 text-sm text-gray-500 font-medium",
  thumbsUpIcon: builtInCssClasses4.thumbsUpIcon,
  thumbsDownIcon: builtInCssClasses4.thumbsDownIcon
};
function StandardCardDisplay(props) {
  var _a;
  const { title, link, description, customCssClasses, clickHandlers, showFeedbackButtons, cta1, cta2 } = props;
  const cssClasses = useComposedCssClasses(builtInCssClasses12, customCssClasses);
  function renderTitle(title2, link2) {
    const titleJsx = renderHighlightedValue(title2, { highlighted: "font-bold", nonHighlighted: "font-medium" });
    return link2 ? (0, import_jsx_runtime29.jsx)("a", Object.assign({ href: link2, className: "text-lg font-medium text-primary hover:underline focus:underline", onClick: clickHandlers.handleTitleClick }, { children: titleJsx }), void 0) : (0, import_jsx_runtime29.jsx)("div", Object.assign({ className: cssClasses.title }, { children: titleJsx }), void 0);
  }
  function renderCTAs(cta12, cta22) {
    if (cta12 || cta22) {
      return (0, import_jsx_runtime29.jsxs)("div", Object.assign({ className: "flex flex-col justify-end ml-4" }, { children: [cta12 && (0, import_jsx_runtime29.jsx)("button", Object.assign({ className: cssClasses.cta1, onClick: clickHandlers.handleCtaClick }, { children: cta12.label }), void 0), cta22 && (0, import_jsx_runtime29.jsx)("button", Object.assign({ className: cssClasses.cta2, onClick: clickHandlers.handleCtaClick }, { children: cta22.label }), void 0)] }), void 0);
    }
    return null;
  }
  function renderDescription(text) {
    if (text) {
      return (0, import_jsx_runtime29.jsx)("div", Object.assign({ className: "w-full" }, { children: renderHighlightedValue(text, { highlighted: "font-semibold", nonHighlighted: "font-normal" }) }), void 0);
    }
    return null;
  }
  function renderFeedbackIcons() {
    if (showFeedbackButtons) {
      return (0, import_jsx_runtime29.jsx)(ThumbsFeedback, { feedbackText: "", onClick: clickHandlers.handleFeedbackClick, customCssClasses: cssClasses }, void 0);
    }
    return null;
  }
  return (0, import_jsx_runtime29.jsxs)("div", Object.assign({ className: cssClasses.container }, { children: [(0, import_jsx_runtime29.jsx)("div", Object.assign({ className: cssClasses.header }, { children: renderTitle(title, link) }), void 0), ((_a = description !== null && description !== void 0 ? description : cta1) !== null && _a !== void 0 ? _a : cta2) && (0, import_jsx_runtime29.jsxs)("div", Object.assign({ className: cssClasses.body }, { children: [renderDescription(description), renderCTAs(cta1, cta2)] }), void 0), renderFeedbackIcons()] }), void 0);
}
StandardCardDisplay.propTypes = {
  title: import_prop_types.default.oneOfType([
    import_prop_types.default.string,
    import_prop_types.default.shape({
      value: import_prop_types.default.string.isRequired,
      matchedSubstrings: import_prop_types.default.arrayOf(import_prop_types.default.shape({
        length: import_prop_types.default.number.isRequired,
        offset: import_prop_types.default.number.isRequired
      })).isRequired
    })
  ]).isRequired,
  link: import_prop_types.default.string,
  description: import_prop_types.default.string,
  cta1: import_prop_types.default.shape({
    label: import_prop_types.default.string.isRequired,
    link: import_prop_types.default.string.isRequired,
    linkType: import_prop_types.default.string.isRequired
  }),
  cta2: import_prop_types.default.shape({
    label: import_prop_types.default.string.isRequired,
    link: import_prop_types.default.string.isRequired,
    linkType: import_prop_types.default.string.isRequired
  })
};

// node_modules/@yext/search-ui-react/lib/esm/components/cards/standard/StandardCard.js
function StandardCard(props) {
  var _a, _b, _c, _d, _e;
  const { result, customCssClasses, showFeedbackButtons } = props;
  const data = {
    title: (_c = (_b = (_a = result.highlightedFields) === null || _a === void 0 ? void 0 : _a.name) !== null && _b !== void 0 ? _b : result.name) !== null && _c !== void 0 ? _c : result.rawData.name,
    description: (_e = (_d = result.highlightedFields) === null || _d === void 0 ? void 0 : _d.description) !== null && _e !== void 0 ? _e : result.rawData.description,
    cta1: result.rawData.c_primaryCTA,
    cta2: result.rawData.c_secondaryCTA
  };
  const clickHandlers = {
    handleCtaClick: useCardAnalyticsCallback(result, "CTA_CLICK"),
    handleTitleClick: useCardAnalyticsCallback(result, "TITLE_CLICK"),
    handleFeedbackClick: useCardFeedbackCallback(result)
  };
  return (0, import_jsx_runtime30.jsx)(StandardCardDisplay, { customCssClasses, showFeedbackButtons, clickHandlers, title: data.title, link: result.link, description: data.description, cta1: data.cta1, cta2: data.cta2 }, void 0);
}

// node_modules/@yext/search-ui-react/lib/esm/components/sections/StandardSection.js
var builtInCssClasses13 = {
  section: ""
};
function StandardSection(props) {
  const cssClasses = useComposedCssClasses(builtInCssClasses13, props.customCssClasses);
  const { results, CardComponent = StandardCard, header } = props;
  if (results.length === 0) {
    return null;
  }
  return (0, import_jsx_runtime31.jsxs)("section", Object.assign({ className: cssClasses.section }, { children: [header, (0, import_jsx_runtime31.jsx)(VerticalResultsDisplay, { results, CardComponent, customCssClasses: cssClasses }, void 0)] }), void 0);
}

// node_modules/@yext/search-ui-react/lib/esm/components/sections/SectionHeader.js
var import_jsx_runtime33 = __toESM(require_jsx_runtime());

// node_modules/@yext/search-ui-react/lib/esm/icons/CollectionIcon.js
var import_jsx_runtime32 = __toESM(require_jsx_runtime());
function CollectionIcon() {
  return (0, import_jsx_runtime32.jsx)("svg", Object.assign({ viewBox: "0 0 24 24", fill: "none", xmlns: "http://www.w3.org/2000/svg" }, { children: (0, import_jsx_runtime32.jsx)("path", { d: "M19 11H5M19 11C20.1046 11 21 11.8954 21 13V19C21 20.1046 20.1046 21 19 21H5C3.89543 21 3 20.1046 3 19V13C3 11.8954 3.89543 11 5 11M19 11V9C19 7.89543 18.1046 7 17 7M5 11V9C5 7.89543 5.89543 7 7 7M7 7V5C7 3.89543 7.89543 3 9 3H15C16.1046 3 17 3.89543 17 5V7M7 7H17", stroke: "#1f2937", strokeWidth: "2", strokeLinecap: "round", strokeLinejoin: "round" }, void 0) }), void 0);
}

// node_modules/@yext/search-ui-react/lib/esm/components/sections/SectionHeader.js
var import_classnames5 = __toESM(require_classnames());
var import_react53 = __toESM(require_react());
var FALLBACK_CSS_CLASSES = {};
var builtInCssClasses14 = {
  sectionHeaderContainer: "flex items-center w-full pl-1 mb-4",
  sectionHeaderIconContainer: "w-5 h-5",
  sectionHeaderLabel: "font-bold text-neutral-dark text-base pl-3",
  viewMoreContainer: "flex justify-end flex-grow ml-auto font-medium text-neutral-dark",
  viewMoreLink: "text-primary pr-1 pl-3",
  appliedFiltersContainer: "ml-3 flex flex-wrap",
  nlpFilter: "border border-gray-200 rounded-3xl px-3 py-1.5 text-sm font-medium text-neutral-dark mr-2",
  removableFilter: "flex items-center border border-gray-200 rounded-3xl px-3 py-1.5 text-sm font-medium text-neutral-dark mr-2"
};
function SectionHeader(props) {
  var _a;
  const { label, verticalKey, viewAllButton = false, appliedQueryFilters, cssClasses = FALLBACK_CSS_CLASSES, getViewAllUrl } = props;
  const latestQuery = useSearchState((state) => state.query.mostRecentSearch);
  const nlpFilterDisplayNames = appliedQueryFilters === null || appliedQueryFilters === void 0 ? void 0 : appliedQueryFilters.map((f2) => f2.displayValue);
  const analytics = useAnalytics();
  const queryId = useSearchState((state) => state.query.queryId);
  const isLoading = useSearchState((state) => state.searchStatus.isLoading);
  cssClasses.appliedFiltersContainer = (0, import_classnames5.default)(cssClasses.appliedFiltersContainer, {
    [(_a = cssClasses.appliedFiltersLoading) !== null && _a !== void 0 ? _a : ""]: isLoading
  });
  const href = getViewAllUrl ? getViewAllUrl({ verticalKey, query: latestQuery }) : `/${verticalKey}?query=${latestQuery}`;
  const handleClickViewAllButton = (0, import_react53.useCallback)(() => {
    if (!analytics) {
      return;
    }
    if (!queryId) {
      console.error("Unable to report a vertical view all event. Missing field: queryId.");
      return;
    }
    analytics === null || analytics === void 0 ? void 0 : analytics.report({
      type: "VERTICAL_VIEW_ALL",
      queryId,
      verticalKey
    });
  }, [analytics, queryId, verticalKey]);
  return (0, import_jsx_runtime33.jsxs)("div", Object.assign({ className: cssClasses.sectionHeaderContainer }, { children: [(0, import_jsx_runtime33.jsx)("div", Object.assign({ className: cssClasses.sectionHeaderIconContainer }, { children: (0, import_jsx_runtime33.jsx)(CollectionIcon, {}, void 0) }), void 0), (0, import_jsx_runtime33.jsx)("h2", Object.assign({ className: cssClasses.sectionHeaderLabel }, { children: label }), void 0), appliedQueryFilters && (0, import_jsx_runtime33.jsx)(AppliedFiltersDisplay, { nlpFilterDisplayNames, cssClasses }, void 0), viewAllButton && (0, import_jsx_runtime33.jsx)("div", Object.assign({ className: cssClasses.viewMoreContainer }, { children: (0, import_jsx_runtime33.jsx)("a", Object.assign({ className: cssClasses.viewMoreLink, href }, { children: (0, import_jsx_runtime33.jsx)("button", Object.assign({ onClick: handleClickViewAllButton }, { children: "View all" }), void 0) }), void 0) }), void 0)] }), void 0);
}

// node_modules/@yext/search-ui-react/lib/esm/components/UniversalResults.js
var import_classnames6 = __toESM(require_classnames());
var builtInCssClasses15 = Object.assign({ universalResultsContainer: "space-y-8", universalResultsLoading: "opacity-50" }, builtInCssClasses14);
function UniversalResults({ verticalConfigMap, showAppliedFilters, customCssClasses }) {
  var _a;
  const cssClasses = useComposedCssClasses(builtInCssClasses15, customCssClasses);
  const resultsFromAllVerticals = useSearchState((state) => {
    var _a2;
    return (_a2 = state === null || state === void 0 ? void 0 : state.universal) === null || _a2 === void 0 ? void 0 : _a2.verticals;
  }) || [];
  const isLoading = useSearchState((state) => state.searchStatus.isLoading);
  if (resultsFromAllVerticals.length === 0) {
    return null;
  }
  const resultsClassNames = (0, import_classnames6.default)(cssClasses.universalResultsContainer, {
    [(_a = cssClasses.universalResultsLoading) !== null && _a !== void 0 ? _a : ""]: isLoading
  });
  return (0, import_jsx_runtime34.jsx)("div", Object.assign({ className: resultsClassNames }, { children: renderVerticalSections({ resultsFromAllVerticals, showAppliedFilters, verticalConfigMap, cssClasses }) }), void 0);
}
function renderVerticalSections(props) {
  const { resultsFromAllVerticals, verticalConfigMap, cssClasses } = props;
  return (0, import_jsx_runtime34.jsx)(import_jsx_runtime34.Fragment, { children: resultsFromAllVerticals.filter((verticalResults) => verticalResults.results).map((verticalResults) => {
    var _a;
    const verticalKey = verticalResults.verticalKey;
    const verticalConfig = verticalConfigMap[verticalKey] || {};
    const label = (_a = verticalConfig.label) !== null && _a !== void 0 ? _a : verticalKey;
    const results = verticalResults.results;
    const SectionComponent = verticalConfig.SectionComponent || StandardSection;
    const appliedQueryFilters = props.showAppliedFilters ? verticalResults.appliedQueryFilters : void 0;
    return (0, import_jsx_runtime34.jsx)(SectionComponent, { results, verticalKey, header: (0, import_jsx_runtime34.jsx)(SectionHeader, Object.assign({}, {
      label,
      appliedQueryFilters,
      verticalKey,
      viewAllButton: verticalConfig.viewAllButton,
      getViewAllUrl: verticalConfig.getViewAllUrl,
      cssClasses
    }), void 0), CardComponent: verticalConfig.CardComponent }, verticalKey);
  }) }, void 0);
}

// node_modules/@yext/search-ui-react/lib/esm/components/VerticalResults.js
var import_jsx_runtime35 = __toESM(require_jsx_runtime());
var __rest2 = function(s2, e2) {
  var t2 = {};
  for (var p2 in s2)
    if (Object.prototype.hasOwnProperty.call(s2, p2) && e2.indexOf(p2) < 0)
      t2[p2] = s2[p2];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s2); i2 < p2.length; i2++) {
      if (e2.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i2]))
        t2[p2[i2]] = s2[p2[i2]];
    }
  return t2;
};
function VerticalResults(props) {
  const { displayAllOnNoResults = true } = props, otherProps = __rest2(props, ["displayAllOnNoResults"]);
  const verticalResults = useSearchState((state) => state.vertical.results) || [];
  const allResultsForVertical = useSearchState((state) => {
    var _a, _b;
    return (_b = (_a = state.vertical) === null || _a === void 0 ? void 0 : _a.noResults) === null || _b === void 0 ? void 0 : _b.allResultsForVertical.results;
  }) || [];
  const isLoading = useSearchState((state) => state.searchStatus.isLoading);
  let results = verticalResults;
  if (verticalResults.length === 0 && displayAllOnNoResults) {
    results = allResultsForVertical;
  }
  return (0, import_jsx_runtime35.jsx)(VerticalResultsDisplay, Object.assign({ results, isLoading }, otherProps), void 0);
}

// node_modules/@yext/search-ui-react/lib/esm/components/Pagination.js
var import_jsx_runtime37 = __toESM(require_jsx_runtime());

// node_modules/@yext/search-ui-react/lib/esm/icons/ChevronIcon.js
var import_jsx_runtime36 = __toESM(require_jsx_runtime());
function ChevronIcon({ className }) {
  return (0, import_jsx_runtime36.jsx)("svg", Object.assign({ viewBox: "0 0 12 8", fill: "none", stroke: "currentColor", xmlns: "http://www.w3.org/2000/svg", className }, { children: (0, import_jsx_runtime36.jsx)("path", { d: "M1.33341 6.5L6.00008 1.83333L10.6667 6.5", strokeWidth: "2", strokeLinecap: "round", strokeLinejoin: "round" }, void 0) }), void 0);
}

// node_modules/@yext/search-ui-react/lib/esm/hooks/usePaginationAnalytics.js
function usePaginationAnalytics() {
  const analytics = useAnalytics();
  const verticalKey = useSearchState((state) => state.vertical.verticalKey);
  const queryId = useSearchState((state) => state.query.queryId);
  const reportPaginateEvent = (newPage, currentPage, totalPageCount) => {
    if (!analytics) {
      return;
    }
    if (!queryId) {
      console.error("Unable to report a pagination event. Missing field: queryId.");
      return;
    }
    if (!verticalKey) {
      console.error("Unable to report a pagination event. Missing field: verticalKey.");
      return;
    }
    analytics.report({
      type: "PAGINATE",
      queryId,
      verticalKey,
      newPage,
      currentPage,
      totalPageCount
    });
  };
  return reportPaginateEvent;
}

// node_modules/@yext/search-ui-react/lib/esm/components/Pagination.js
var import_react54 = __toESM(require_react());
var import_classnames7 = __toESM(require_classnames());
var builtInPaginationCssClasses = {
  paginationContainer: "flex justify-center mb-4",
  paginationLoading: "opacity-50",
  label: "z-0 inline-flex items-center px-4 py-2 text-sm font-semibold border border-gray-300 text-neutral",
  selectedLabel: "z-10 inline-flex items-center px-4 py-2 text-sm font-semibold border border-primary text-primary bg-primary-light",
  leftIconContainer: "inline-flex items-center px-3.5 py-2 border border-gray-300 rounded-l-md",
  rightIconContainer: "inline-flex items-center px-3.5 py-2 border border-gray-300 rounded-r-md",
  icon: "w-3 text-gray-600"
};
function Pagination(props) {
  var _a;
  const { customCssClasses = {}, paginateAllOnNoResults = false } = props;
  const cssClasses = useComposedCssClasses(builtInPaginationCssClasses, customCssClasses);
  const searchActions = useSearchActions();
  const verticalResultsCount = useSearchState((state) => state.vertical.resultsCount) || 0;
  const allResultsCountForVertical = useSearchState((state) => {
    var _a2, _b;
    return (_b = (_a2 = state.vertical) === null || _a2 === void 0 ? void 0 : _a2.noResults) === null || _b === void 0 ? void 0 : _b.allResultsForVertical.resultsCount;
  }) || 0;
  const isLoading = useSearchState((state) => state.searchStatus.isLoading);
  let resultsCount = verticalResultsCount;
  if (verticalResultsCount === 0 && paginateAllOnNoResults) {
    resultsCount = allResultsCountForVertical;
  }
  const offset = useSearchState((state) => state.vertical.offset) || 0;
  const limit = useSearchState((state) => state.vertical.limit) || 20;
  const currentPageNumber = offset / limit + 1;
  const maxPageCount = Math.ceil(resultsCount / limit);
  const reportAnalyticsEvent = usePaginationAnalytics();
  const navigateToPage = (0, import_react54.useCallback)((newPageNumber) => {
    const newOffset = limit * (newPageNumber - 1);
    searchActions.setOffset(newOffset);
    executeSearch(searchActions);
    reportAnalyticsEvent(newPageNumber, currentPageNumber, maxPageCount);
  }, [searchActions, limit, maxPageCount, currentPageNumber, reportAnalyticsEvent]);
  if (maxPageCount <= 1) {
    return null;
  }
  const paginationLabels = generatePaginationLabels(currentPageNumber, maxPageCount);
  const paginationContainerClassNames = (0, import_classnames7.default)(cssClasses.paginationContainer, {
    [(_a = cssClasses.paginationLoading) !== null && _a !== void 0 ? _a : ""]: isLoading
  });
  return (0, import_jsx_runtime37.jsx)("div", Object.assign({ className: paginationContainerClassNames }, { children: (0, import_jsx_runtime37.jsxs)("nav", Object.assign({ className: "inline-flex shadow-sm -space-x-px", "aria-label": "Pagination" }, { children: [(0, import_jsx_runtime37.jsx)(PaginationButton, Object.assign({ ariaLabel: "Navigate to the previous results page", className: cssClasses.leftIconContainer, navigateToPage, newPageNumber: currentPageNumber - 1, disabled: currentPageNumber === 1 }, { children: (0, import_jsx_runtime37.jsx)(ChevronIcon, { className: cssClasses.icon + " transform -rotate-90" }, void 0) }), void 0), paginationLabels.map((label, index2) => {
    switch (label) {
      case "...":
        return (0, import_jsx_runtime37.jsx)("div", Object.assign({ className: cssClasses.label }, { children: label }), index2);
      case `${currentPageNumber}`:
        return (0, import_jsx_runtime37.jsx)(PaginationButton, Object.assign({ className: cssClasses.selectedLabel, navigateToPage, newPageNumber: currentPageNumber }, { children: label }), index2);
      default:
        return (0, import_jsx_runtime37.jsx)(PaginationButton, Object.assign({ className: cssClasses.label, navigateToPage, newPageNumber: Number(label) }, { children: label }), index2);
    }
  }), (0, import_jsx_runtime37.jsx)(PaginationButton, Object.assign({ ariaLabel: "Navigate to the next results page", className: cssClasses.rightIconContainer, navigateToPage, newPageNumber: currentPageNumber + 1, disabled: currentPageNumber === maxPageCount }, { children: (0, import_jsx_runtime37.jsx)(ChevronIcon, { className: cssClasses.icon + " transform rotate-90" }, void 0) }), void 0)] }), void 0) }), void 0);
}
function PaginationButton(props) {
  const { navigateToPage, newPageNumber } = props;
  const handleClick = (0, import_react54.useCallback)(() => {
    navigateToPage(newPageNumber);
  }, [navigateToPage, newPageNumber]);
  return (0, import_jsx_runtime37.jsx)("button", Object.assign({ "aria-label": props.ariaLabel, className: props.className, onClick: handleClick, disabled: props.disabled }, { children: props.children }), void 0);
}
function generatePaginationLabels(currentPageNumber, maxPageCount) {
  const paginationLabels = [];
  const previousPageNumber = currentPageNumber - 1;
  const nextPageNumber = currentPageNumber + 1;
  if (previousPageNumber > 3) {
    paginationLabels.push("1", "...", `${previousPageNumber}`);
  } else if (previousPageNumber !== 0) {
    [...Array(previousPageNumber)].forEach((_, index2) => paginationLabels.push(`${index2 + 1}`));
  }
  paginationLabels.push(`${currentPageNumber}`);
  if (maxPageCount - nextPageNumber > 2) {
    paginationLabels.push(`${nextPageNumber}`, "...", `${maxPageCount}`);
  } else if (nextPageNumber <= maxPageCount) {
    [...Array(maxPageCount - nextPageNumber + 1)].forEach((_, index2) => paginationLabels.push(`${nextPageNumber + index2}`));
  }
  return paginationLabels;
}

// node_modules/@yext/search-ui-react/lib/esm/components/AlternativeVerticals.js
var import_jsx_runtime39 = __toESM(require_jsx_runtime());

// node_modules/@yext/search-ui-react/lib/esm/icons/StarIcon.js
var import_jsx_runtime38 = __toESM(require_jsx_runtime());
function StarIcon({ className }) {
  return (0, import_jsx_runtime38.jsx)("svg", Object.assign({ fill: "currentColor", xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 18 18", className }, { children: (0, import_jsx_runtime38.jsx)("path", { d: "M8.991 0C4.023 0 0 4.032 0 9s4.023 9 8.991 9C13.968 18 18 13.968 18 9s-4.032-9-9.009-9zm3.816 14.4L9 12.105 5.193 14.4l1.008-4.329-3.357-2.907 4.428-.378L9 2.7l1.728 4.077 4.428.378-3.357 2.907z" }, void 0) }), void 0);
}

// node_modules/@yext/search-ui-react/lib/esm/components/AlternativeVerticals.js
var import_classnames8 = __toESM(require_classnames());
var builtInCssClasses16 = {
  alternativeVerticalsContainer: "flex flex-col justify-between border border-gray-200 rounded-lg mb-4 p-4 shadow-sm",
  alternativeVerticalsLoading: "opacity-50",
  noResultsText: "text-lg text-neutral-dark pb-2",
  categoriesText: "text-neutral",
  suggestion: "pb-4 flex items-center",
  verticalIcon: "w-4 mr-2"
};
function isVerticalSuggestion(suggestion) {
  var _a, _b;
  return ((_a = suggestion) === null || _a === void 0 ? void 0 : _a.resultsCount) !== void 0 && ((_b = suggestion) === null || _b === void 0 ? void 0 : _b.verticalKey) !== void 0;
}
function AlternativeVerticals({ currentVerticalLabel, verticalConfigMap, displayAllOnNoResults = true, customCssClasses }) {
  var _a;
  const cssClasses = useComposedCssClasses(builtInCssClasses16, customCssClasses);
  const alternativeVerticals = useSearchState((state) => {
    var _a2;
    return (_a2 = state.vertical.noResults) === null || _a2 === void 0 ? void 0 : _a2.alternativeVerticals;
  }) || [];
  const allResultsForVertical = useSearchState((state) => {
    var _a2;
    return (_a2 = state.vertical.noResults) === null || _a2 === void 0 ? void 0 : _a2.allResultsForVertical.results;
  }) || [];
  const query = useSearchState((state) => state.query.mostRecentSearch);
  const verticalSuggestions = buildVerticalSuggestions(verticalConfigMap, alternativeVerticals);
  const isShowingAllResults = displayAllOnNoResults && allResultsForVertical.length > 0;
  const isLoading = useSearchState((state) => state.searchStatus.isLoading);
  const containerClassNames = (0, import_classnames8.default)(cssClasses.alternativeVerticalsContainer, {
    [(_a = cssClasses.alternativeVerticalsLoading) !== null && _a !== void 0 ? _a : ""]: isLoading
  });
  function buildVerticalSuggestions(verticalConfigMap2, alternativeVerticals2) {
    return alternativeVerticals2.filter((alternativeResults) => {
      return !!verticalConfigMap2[alternativeResults.verticalKey];
    }).map((alternativeResults) => {
      return {
        label: verticalConfigMap2[alternativeResults.verticalKey].label,
        verticalKey: alternativeResults.verticalKey,
        resultsCount: alternativeResults.resultsCount
      };
    }).filter(isVerticalSuggestion).filter((verticalSuggestion) => verticalSuggestion.resultsCount > 0);
  }
  if (verticalSuggestions.length <= 0) {
    return null;
  }
  return (0, import_jsx_runtime39.jsxs)("div", Object.assign({ className: containerClassNames }, { children: [renderNoResultsInfo(), verticalSuggestions && (0, import_jsx_runtime39.jsxs)("div", Object.assign({ className: "pt-4 text-neutral-dark" }, { children: [(0, import_jsx_runtime39.jsxs)("div", Object.assign({ className: cssClasses.categoriesText }, { children: [(0, import_jsx_runtime39.jsx)("span", { children: processTranslation({
    phrase: "The following category yielded results for - ",
    pluralForm: "The following categories yielded results for - ",
    count: verticalSuggestions.length
  }) }, void 0), (0, import_jsx_runtime39.jsx)("strong", { children: query }, void 0)] }), void 0), (0, import_jsx_runtime39.jsx)("ul", Object.assign({ className: "pt-4" }, { children: verticalSuggestions.map(renderSuggestion) }), void 0)] }), void 0)] }), void 0);
  function renderNoResultsInfo() {
    return (0, import_jsx_runtime39.jsxs)("div", Object.assign({ className: cssClasses.noResultsText }, { children: [(0, import_jsx_runtime39.jsxs)("span", { children: ["No results found in ", currentVerticalLabel, "."] }, void 0), isShowingAllResults && (0, import_jsx_runtime39.jsxs)("span", { children: [" Showing all ", currentVerticalLabel, " instead."] }, void 0)] }), void 0);
  }
  function renderSuggestion(suggestion) {
    const resultsCountText = processTranslation({
      phrase: `${suggestion.resultsCount} result`,
      pluralForm: `${suggestion.resultsCount} results`,
      count: suggestion.resultsCount
    });
    return (0, import_jsx_runtime39.jsxs)("li", Object.assign({ className: cssClasses.suggestion }, { children: [(0, import_jsx_runtime39.jsx)("div", Object.assign({ className: cssClasses.verticalIcon }, { children: (0, import_jsx_runtime39.jsx)(StarIcon, {}, void 0) }), void 0), (0, import_jsx_runtime39.jsxs)("span", Object.assign({ className: "font-bold" }, { children: [suggestion.label, " - ", resultsCountText] }), void 0)] }), suggestion.verticalKey);
  }
}

// node_modules/@yext/search-ui-react/lib/esm/components/ResultsCount.js
var import_jsx_runtime40 = __toESM(require_jsx_runtime());
var import_classnames9 = __toESM(require_classnames());
var builtInCssClasses17 = {
  resultsCountContainer: "font-semibold text-neutral mb-4 py-2 mr-2.5 whitespace-nowrap",
  resultsCountLoading: "opacity-50"
};
function ResultsCount({ customCssClasses }) {
  var _a;
  const cssClasses = useComposedCssClasses(builtInCssClasses17, customCssClasses);
  const isLoading = useSearchState((state) => state.searchStatus.isLoading);
  const resultsCountText = useResultsCount();
  const resultsCountClassnames = (0, import_classnames9.default)(cssClasses.resultsCountContainer, {
    [(_a = cssClasses.resultsCountLoading) !== null && _a !== void 0 ? _a : ""]: isLoading
  });
  return (0, import_jsx_runtime40.jsx)("div", Object.assign({ className: resultsCountClassnames }, { children: resultsCountText }), void 0);
}
function useResultsCount() {
  var _a;
  const isVertical = useSearchState((state) => state.meta.searchType) === SearchTypeEnum.Vertical;
  const results = useSearchState((state) => isVertical ? state.vertical : state.universal.verticals);
  const offset = useSearchState((state) => state.vertical.offset) || 0;
  const limit = useSearchState((state) => state.vertical.limit) || 20;
  let resultsCount = 0;
  if (results) {
    if (isUniversalSearchResults(results)) {
      results.forEach((resultsOfAVertical) => resultsCount += resultsOfAVertical.resultsCount);
    } else {
      resultsCount = (_a = results.resultsCount) !== null && _a !== void 0 ? _a : 0;
    }
  }
  if (resultsCount === 0) {
    return null;
  }
  const resultsCountText = processTranslation({
    phrase: `${resultsCount} Result`,
    pluralForm: `${resultsCount} Results`,
    count: resultsCount
  });
  if (resultsCount > limit && isVertical) {
    const paginateStart = offset + 1;
    const paginateEnd = Math.min(offset + limit, resultsCount);
    const paginateRange = `${paginateStart} - ${paginateEnd}`;
    const resultCountWithPaginationText = `${paginateRange} of ${resultsCount} Results`;
    return resultCountWithPaginationText;
  } else {
    return resultsCountText;
  }
}
function isUniversalSearchResults(data) {
  return Array.isArray(data);
}

// node_modules/@yext/search-ui-react/lib/esm/components/StaticFilters.js
var import_jsx_runtime52 = __toESM(require_jsx_runtime());

// node_modules/@yext/search-ui-react/lib/esm/components/FilterGroup.js
var import_react64 = __toESM(require_react());
var import_jsx_runtime51 = __toESM(require_jsx_runtime());
var import_react65 = __toESM(require_react());

// node_modules/@yext/search-ui-react/lib/esm/components/Filters/CheckboxOption.js
var import_jsx_runtime41 = __toESM(require_jsx_runtime());
var import_react56 = __toESM(require_react());

// node_modules/@yext/search-ui-react/lib/esm/components/Filters/FilterGroupContext.js
var import_react55 = __toESM(require_react());
var FilterGroupContext = (0, import_react55.createContext)(null);
function useFilterGroupContext() {
  const filterGroupContextInstance = (0, import_react55.useContext)(FilterGroupContext);
  if (filterGroupContextInstance === null) {
    throw new Error("Tried to use FilterGroupContext when none exists.");
  }
  return filterGroupContextInstance;
}

// node_modules/@yext/search-ui-react/lib/esm/components/Filters/CheckboxOption.js
var import_classnames10 = __toESM(require_classnames());
var builtInCssClasses18 = {
  label: "text-neutral text-sm font-normal cursor-pointer",
  label___disabled: "opacity-50 cursor-not-allowed",
  input: "w-3.5 h-3.5 form-checkbox cursor-pointer border border-gray-300 rounded-sm text-primary focus:ring-primary",
  input___disabled: "border-gray-200 bg-gray-50 cursor-not-allowed",
  container: "flex items-center",
  optionContainer: "flex items-center space-x-3 peer",
  tooltipContainer: "invisible peer-hover:visible relative -right-5 -top-5",
  tooltip: "absolute z-10 left-0 -top-0.5 whitespace-nowrap rounded shadow-lg p-3 text-sm bg-neutral-dark text-white"
};
function CheckboxOption(props) {
  var _a, _b;
  const { fieldId, isOptionsDisabled } = useFilterGroupContext();
  const { value, matcher = Matcher.Equals, selectedByDefault = false, displayName = props.value, resultsCount } = props;
  const cssClasses = useComposedCssClasses(builtInCssClasses18, props.customCssClasses);
  const optionId = useId();
  const { selectFilter, filters, applyFilters } = useFiltersContext();
  const handleClick = (0, import_react56.useCallback)((checked) => {
    selectFilter({
      matcher,
      fieldId,
      value,
      displayName: typeof displayName === "string" ? displayName : void 0,
      selected: checked
    });
    applyFilters();
  }, [applyFilters, fieldId, displayName, selectFilter, value, matcher]);
  const handleChange = (0, import_react56.useCallback)((evt) => {
    handleClick(evt.target.checked);
  }, [handleClick]);
  const optionFilter = (0, import_react56.useMemo)(() => {
    return {
      fieldId,
      matcher,
      value
    };
  }, [fieldId, value, matcher]);
  const existingStoredFilter = findSelectableFieldValueFilter(optionFilter, filters);
  (0, import_react56.useEffect)(() => {
    if (!existingStoredFilter && selectedByDefault) {
      selectFilter(Object.assign(Object.assign({}, optionFilter), { displayName: typeof displayName === "string" ? displayName : void 0, selected: true }));
    }
  }, [displayName, selectFilter, selectedByDefault, existingStoredFilter, optionFilter]);
  const isSelected = existingStoredFilter ? existingStoredFilter.selected : false;
  const labelText = resultsCount ? `${displayName} (${resultsCount})` : displayName;
  const inputClasses = (0, import_classnames10.default)(cssClasses.input, {
    [(_a = cssClasses.input___disabled) !== null && _a !== void 0 ? _a : ""]: isOptionsDisabled
  });
  const labelClasses = (0, import_classnames10.default)(cssClasses.label, {
    [(_b = cssClasses.label___disabled) !== null && _b !== void 0 ? _b : ""]: isOptionsDisabled
  });
  return (0, import_jsx_runtime41.jsxs)("div", Object.assign({ className: cssClasses.container }, { children: [(0, import_jsx_runtime41.jsxs)("div", Object.assign({ className: cssClasses.optionContainer }, { children: [(0, import_jsx_runtime41.jsx)("input", { type: "checkbox", id: optionId, checked: isSelected, className: inputClasses, onChange: handleChange, disabled: isOptionsDisabled }, void 0), (0, import_jsx_runtime41.jsx)("label", Object.assign({ className: labelClasses, htmlFor: optionId }, { children: labelText }), void 0)] }), void 0), isOptionsDisabled && (0, import_jsx_runtime41.jsx)("div", Object.assign({ className: cssClasses.tooltipContainer }, { children: (0, import_jsx_runtime41.jsx)("div", Object.assign({ className: cssClasses.tooltip }, { children: "Clear the range to select options." }), void 0) }), void 0)] }), void 0);
}

// node_modules/@yext/search-ui-react/lib/esm/components/Filters/CollapsibleLabel.js
var import_jsx_runtime42 = __toESM(require_jsx_runtime());
var import_classnames11 = __toESM(require_classnames());
var builtInCssClasses19 = {
  label: "text-neutral-dark text-sm font-medium text-left"
};
function CollapsibleLabel({ label, customCssClasses }) {
  const { isExpanded, getToggleProps } = useFilterGroupContext();
  const iconClassName = (0, import_classnames11.default)("w-3 text-gray-400", {
    "transform rotate-180": !isExpanded
  });
  const cssClasses = useComposedCssClasses(builtInCssClasses19, customCssClasses);
  return (0, import_jsx_runtime42.jsxs)("button", Object.assign({ className: "w-full flex justify-between items-center mb-4" }, getToggleProps(), { children: [(0, import_jsx_runtime42.jsx)("div", Object.assign({ className: cssClasses.label }, { children: label }), void 0), (0, import_jsx_runtime42.jsx)(ChevronIcon, { className: iconClassName }, void 0)] }), void 0);
}

// node_modules/@yext/search-ui-react/lib/esm/components/Filters/CollapsibleSection.js
var import_jsx_runtime43 = __toESM(require_jsx_runtime());
function CollapsibleSection(props) {
  const { className = "space-y-3", children } = props;
  const { getCollapseProps } = useFilterGroupContext();
  return (0, import_jsx_runtime43.jsx)("div", Object.assign({ className }, getCollapseProps(), { children }), void 0);
}

// node_modules/@yext/search-ui-react/lib/esm/components/Filters/FacetsProvider.js
var import_jsx_runtime44 = __toESM(require_jsx_runtime());
var import_react57 = __toESM(require_react());
function FacetsProvider({ children, className = "w-full", searchOnChange = true }) {
  const searchActions = useSearchActions();
  const facetsInState = useSearchState((state) => state.filters.facets);
  const facets = (0, import_react57.useMemo)(() => facetsInState !== null && facetsInState !== void 0 ? facetsInState : [], [facetsInState]);
  const filters = (0, import_react57.useMemo)(() => {
    return facets.flatMap((f2) => f2.options.map((o2) => {
      return {
        fieldId: f2.fieldId,
        value: o2.value,
        matcher: o2.matcher,
        selected: o2.selected,
        displayName: o2.displayName
      };
    }));
  }, [facets]);
  const filtersContextInstance = (0, import_react57.useMemo)(() => {
    return {
      selectFilter(filter) {
        if (typeof filter.value === "object" && !isNumberRangeValue(filter.value)) {
          console.error("Facets only support string, number, boolean, and NumberRangeValue. Found the following object value instead:", filter.value);
          return;
        }
        const facetOption = {
          matcher: filter.matcher,
          value: filter.value
        };
        searchActions.setFacetOption(filter.fieldId, facetOption, filter.selected);
      },
      applyFilters() {
        if (searchOnChange) {
          searchActions.setOffset(0);
          clearStaticRangeFilters(searchActions, getSelectedNumericalFacetFields(searchActions));
          executeSearch(searchActions);
        }
      },
      filters
    };
  }, [searchActions, filters, searchOnChange]);
  return (0, import_jsx_runtime44.jsx)("div", Object.assign({ className }, { children: (0, import_jsx_runtime44.jsx)(FiltersContext.Provider, Object.assign({ value: filtersContextInstance }, { children: children === null || children === void 0 ? void 0 : children(facets) }), void 0) }), void 0);
}

// node_modules/@yext/search-ui-react/lib/esm/components/Filters/FilterGroupProvider.js
var import_jsx_runtime45 = __toESM(require_jsx_runtime());
var import_react59 = __toESM(require_react());

// node_modules/react-collapsed/dist/react-collapsed.esm.js
var import_react58 = __toESM(require_react());
var import_react_dom = __toESM(require_react_dom());

// node_modules/tiny-warning/dist/tiny-warning.esm.js
var isProduction = false;
function warning2(condition, message) {
  if (!isProduction) {
    if (condition) {
      return;
    }
    var text = "Warning: " + message;
    if (typeof console !== "undefined") {
      console.warn(text);
    }
    try {
      throw Error(text);
    } catch (x2) {
    }
  }
}
var tiny_warning_esm_default = warning2;

// node_modules/react-collapsed/dist/react-collapsed.esm.js
function a() {
  return a = Object.assign || function(n2) {
    for (var e2 = 1; e2 < arguments.length; e2++) {
      var t2 = arguments[e2];
      for (var o2 in t2)
        Object.prototype.hasOwnProperty.call(t2, o2) && (n2[o2] = t2[o2]);
    }
    return n2;
  }, a.apply(this, arguments);
}
function u(n2, e2) {
  if (null == n2)
    return {};
  var t2, o2, r2 = {}, i2 = Object.keys(n2);
  for (o2 = 0; o2 < i2.length; o2++)
    e2.indexOf(t2 = i2[o2]) >= 0 || (r2[t2] = n2[t2]);
  return r2;
}
var c = function() {
};
function d(n2) {
  return null != n2 && n2.current ? n2.current.scrollHeight : (tiny_warning_esm_default(true, "useCollapse was not able to find a ref to the collapse element via `getCollapseProps`. Ensure that the element exposes its `ref` prop. If it exposes the ref prop under a different name (like `innerRef`), use the `refKey` property to change it. Example:\n\n{...getCollapseProps({refKey: 'innerRef'})}"), "auto");
}
var s = function() {
  var n2 = arguments;
  return function() {
    var e2 = arguments;
    return [].slice.call(n2).forEach(function(n3) {
      return n3 && n3.apply(void 0, [].slice.call(e2));
    });
  };
};
function f(n2, e2) {
  if (null != n2)
    if ("function" == typeof n2)
      n2(e2);
    else
      try {
        n2.current = e2;
      } catch (t2) {
        throw new Error('Cannot assign value "' + e2 + '" to ref "' + n2 + '"');
      }
}
var p = "undefined" != typeof window ? import_react58.useLayoutEffect : import_react58.useEffect;
var h = false;
var v = 0;
var g = function() {
  return ++v;
};
var m = ["duration", "easing", "collapseStyles", "expandStyles", "onExpandStart", "onExpandEnd", "onCollapseStart", "onCollapseEnd", "isExpanded", "defaultExpanded", "hasDisabledAnimation"];
var x = ["disabled", "onClick"];
var y = ["style", "onTransitionEnd", "refKey"];
function E(r2) {
  var v2, E2, b = void 0 === r2 ? {} : r2, C = b.duration, w = b.easing, S = void 0 === w ? "cubic-bezier(0.4, 0, 0.2, 1)" : w, k = b.collapseStyles, A = void 0 === k ? {} : k, O = b.expandStyles, P = void 0 === O ? {} : O, T = b.onExpandStart, q = void 0 === T ? c : T, D = b.onExpandEnd, F = void 0 === D ? c : D, K = b.onCollapseStart, j = void 0 === K ? c : K, N = b.onCollapseEnd, z = void 0 === N ? c : N, H = b.isExpanded, I = b.defaultExpanded, M = void 0 !== I && I, R = b.hasDisabledAnimation, B = void 0 !== R && R, V = u(b, m), _ = function(r3, i2) {
    var a2 = (0, import_react58.useState)(i2 || false), u2 = a2[0], c2 = a2[1], d2 = (0, import_react58.useRef)(null != r3), s2 = d2.current ? r3 : u2, f2 = (0, import_react58.useCallback)(function(n2) {
      d2.current || c2(n2);
    }, []);
    return (0, import_react58.useEffect)(function() {
      tiny_warning_esm_default(!(d2.current && null == r3), "useCollapse is changing from controlled to uncontrolled. useCollapse should not switch from controlled to uncontrolled (or vice versa). Decide between using a controlled or uncontrolled collapse for the lifetime of the component. Check the `isExpanded` prop."), tiny_warning_esm_default(!(!d2.current && null != r3), "useCollapse is changing from uncontrolled to controlled. useCollapse should not switch from uncontrolled to controlled (or vice versa). Decide between using a controlled or uncontrolled collapse for the lifetime of the component. Check the `isExpanded` prop.");
    }, [r3]), [s2, f2];
  }(H, M), G = _[0], J = _[1], L = function(e2) {
    var t2 = h ? g() : null, r3 = (0, import_react58.useState)(t2), i2 = r3[0], l = r3[1];
    return p(function() {
      null === i2 && l(g());
    }, []), (0, import_react58.useEffect)(function() {
      false === h && (h = true);
    }, []), null != i2 ? String(i2) : void 0;
  }(), Q = (0, import_react58.useRef)(null);
  v2 = Q, E2 = function(n2) {
  }, E2 = function(n2) {
    if (null != n2 && n2.current) {
      var e2 = window.getComputedStyle(n2.current), t2 = e2.paddingTop, o2 = e2.paddingBottom;
      tiny_warning_esm_default(!(t2 && "0px" !== t2 || o2 && "0px" !== o2), "react-collapsed: Padding applied to the collapse element will cause the animation to break and not perform as expected. To fix, apply equivalent padding to the direct descendent of the collapse element.");
    }
  }, (0, import_react58.useEffect)(function() {
    E2(v2);
  }, [v2]);
  var U, W, X, Y = (V.collapsedHeight || 0) + "px", Z = { display: "0px" === Y ? "none" : "block", height: Y, overflow: "hidden" }, $ = (0, import_react58.useState)(G ? {} : Z), nn = $[0], en = $[1], tn = function(n2) {
    (0, import_react_dom.flushSync)(function() {
      en(n2);
    });
  }, on = function(n2) {
    tn(function(e2) {
      return a({}, e2, n2);
    });
  };
  function rn(n2) {
    if (B)
      return {};
    var e2 = C || function(n3) {
      if (!n3 || "string" == typeof n3)
        return 0;
      var e3 = n3 / 36;
      return Math.round(10 * (4 + 15 * Math.pow(e3, 0.25) + e3 / 5));
    }(n2);
    return { transition: "height " + e2 + "ms " + S };
  }
  U = function() {
    G ? requestAnimationFrame(function() {
      q(), on(a({}, P, { willChange: "height", display: "block", overflow: "hidden" })), requestAnimationFrame(function() {
        var n2 = d(Q);
        on(a({}, rn(n2), { height: n2 }));
      });
    }) : requestAnimationFrame(function() {
      j();
      var n2 = d(Q);
      on(a({}, A, rn(n2), { willChange: "height", height: n2 })), requestAnimationFrame(function() {
        on({ height: Y, overflow: "hidden" });
      });
    });
  }, W = [G, Y], X = (0, import_react58.useRef)(true), (0, import_react58.useEffect)(function() {
    if (!X.current)
      return U();
    X.current = false;
  }, W);
  var ln = function(n2) {
    if (n2.target === Q.current && "height" === n2.propertyName)
      if (G) {
        var e2 = d(Q);
        e2 === nn.height ? tn({}) : on({ height: e2 }), F();
      } else
        nn.height === Y && (tn(Z), z());
  };
  return { getToggleProps: function(n2) {
    var e2 = void 0 === n2 ? {} : n2, t2 = e2.disabled, o2 = void 0 !== t2 && t2, r3 = e2.onClick, i2 = void 0 === r3 ? c : r3, l = u(e2, x);
    return a({ type: "button", role: "button", id: "react-collapsed-toggle-" + L, "aria-controls": "react-collapsed-panel-" + L, "aria-expanded": G, tabIndex: 0, disabled: o2 }, l, { onClick: o2 ? c : s(i2, function() {
      return J(function(n3) {
        return !n3;
      });
    }) });
  }, getCollapseProps: function(n2) {
    var e2, t2 = void 0 === n2 ? {} : n2, o2 = t2.style, r3 = void 0 === o2 ? {} : o2, i2 = t2.onTransitionEnd, l = void 0 === i2 ? c : i2, d2 = t2.refKey, p2 = void 0 === d2 ? "ref" : d2, h2 = u(t2, y);
    return a({ id: "react-collapsed-panel-" + L, "aria-hidden": !G }, h2, ((e2 = {})[p2] = function() {
      var n3 = [].slice.call(arguments);
      return n3.every(function(n4) {
        return null == n4;
      }) ? null : function(e3) {
        n3.forEach(function(n4) {
          f(n4, e3);
        });
      };
    }(Q, h2[p2]), e2.onTransitionEnd = s(ln, l), e2.style = a({ boxSizing: "border-box" }, r3, nn), e2));
  }, isExpanded: G, setExpanded: J };
}

// node_modules/@yext/search-ui-react/lib/esm/components/Filters/FilterGroupProvider.js
function FilterGroupProvider(props) {
  const { children, defaultExpanded = true, fieldId } = props;
  const [searchValue, setSearchValue] = (0, import_react59.useState)("");
  const [isOptionsDisabled, setIsOptionsDisabled] = (0, import_react59.useState)(false);
  const { getCollapseProps, getToggleProps, isExpanded } = E({ defaultExpanded });
  const FilterGroupContextInstance = (0, import_react59.useMemo)(() => {
    return {
      fieldId,
      searchValue,
      setSearchValue,
      getCollapseProps,
      getToggleProps,
      isExpanded,
      isOptionsDisabled,
      setIsOptionsDisabled
    };
  }, [
    fieldId,
    getCollapseProps,
    getToggleProps,
    isExpanded,
    searchValue,
    isOptionsDisabled
  ]);
  return (0, import_jsx_runtime45.jsx)(FilterGroupContext.Provider, Object.assign({ value: FilterGroupContextInstance }, { children }), void 0);
}

// node_modules/@yext/search-ui-react/lib/esm/components/Filters/SearchInput.js
var import_jsx_runtime46 = __toESM(require_jsx_runtime());
var import_react60 = __toESM(require_react());
function SearchInput(props) {
  const { className = "text-sm form-input bg-white h-9 w-full outline-none p-2 mb-2 rounded-md border border-gray-300 focus:ring-primary focus:ring-0 text-neutral-dark placeholder:text-neutral", placeholder = "Search here..." } = props;
  const { searchValue, setSearchValue } = useFilterGroupContext();
  const handleChange = (0, import_react60.useCallback)((e2) => {
    setSearchValue(e2.target.value);
  }, [setSearchValue]);
  return (0, import_jsx_runtime46.jsx)("input", { className, type: "text", placeholder, value: searchValue, onChange: handleChange }, void 0);
}

// node_modules/@yext/search-ui-react/lib/esm/components/Filters/StaticFiltersProvider.js
var import_jsx_runtime47 = __toESM(require_jsx_runtime());
var import_react61 = __toESM(require_react());
var __rest3 = function(s2, e2) {
  var t2 = {};
  for (var p2 in s2)
    if (Object.prototype.hasOwnProperty.call(s2, p2) && e2.indexOf(p2) < 0)
      t2[p2] = s2[p2];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s2); i2 < p2.length; i2++) {
      if (e2.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i2]))
        t2[p2[i2]] = s2[p2[i2]];
    }
  return t2;
};
function StaticFiltersProvider({ children, className = "w-full", searchOnChange = true }) {
  const searchActions = useSearchActions();
  const displayableFilters = useSearchState((state) => state.filters.static);
  const filtersContextInstance = (0, import_react61.useMemo)(() => {
    return {
      selectFilter(filter) {
        const { selected, displayName } = filter, fieldValueFilter = __rest3(filter, ["selected", "displayName"]);
        searchActions.setFilterOption({
          filter: Object.assign({ kind: "fieldValue" }, fieldValueFilter),
          selected,
          displayName
        });
      },
      applyFilters() {
        if (searchOnChange) {
          searchActions.setOffset(0);
          searchActions.resetFacets();
          executeSearch(searchActions);
        }
      },
      filters: getSelectableFieldValueFilters(displayableFilters !== null && displayableFilters !== void 0 ? displayableFilters : [])
    };
  }, [searchActions, displayableFilters, searchOnChange]);
  return (0, import_jsx_runtime47.jsx)("div", Object.assign({ className }, { children: (0, import_jsx_runtime47.jsx)(FiltersContext.Provider, Object.assign({ value: filtersContextInstance }, { children }), void 0) }), void 0);
}

// node_modules/@yext/search-ui-react/lib/esm/components/Filters/RangeInput.js
var import_jsx_runtime49 = __toESM(require_jsx_runtime());
var import_react62 = __toESM(require_react());
var import_classnames12 = __toESM(require_classnames());

// node_modules/@yext/search-ui-react/lib/esm/icons/InvalidIcon.js
var import_jsx_runtime48 = __toESM(require_jsx_runtime());
function InvalidIcon() {
  return (0, import_jsx_runtime48.jsx)("svg", Object.assign({ width: "20", height: "18", viewBox: "0 0 20 18", fill: "none", xmlns: "http://www.w3.org/2000/svg" }, { children: (0, import_jsx_runtime48.jsx)("path", { d: "M9.99955 7V9M9.99955 13H10.0095M3.07134 17H16.9277C18.4673 17 19.4296 15.3333 18.6598 14L11.7316 2C10.9618 0.666667 9.0373 0.666667 8.2675 2L1.33929 14C0.569492 15.3333 1.53174 17 3.07134 17Z", stroke: "#B91C1C", strokeWidth: "2", strokeLinecap: "round", strokeLinejoin: "round" }, void 0) }), void 0);
}

// node_modules/@yext/search-ui-react/lib/esm/components/Filters/RangeInput.js
var builtInCssClasses20 = {
  rangeInputContainer: "flex flex-col",
  input: "w-full h-9 form-input cursor-pointer border rounded-md focus:ring-0 text-neutral-dark text-sm text-right appearance-none leading-9",
  input___withPrefix: "pl-[2.5rem]",
  input___withoutPrefix: "px-2",
  input___disabled: "bg-gray-50 placeholder:text-neutral-light cursor-not-allowed",
  input___enabled: "placeholder:text-neutral",
  input___valid: "border-gray-300 focus:border-primary",
  input___invalid: "border-red-700 focus:border-red-700",
  inputContainer: "relative",
  inputRowContainer: "flex flex-row items-center space-x-3 group",
  buttonsContainer: "flex flex-row items-center justify-between pt-2",
  inputPrefix: "absolute left-2 top-2 text-sm",
  inputPrefix___disabled: "text-neutral-light cursor-not-allowed",
  inputPrefix___enabled: "text-neutral",
  applyButton: "text-sm text-primary font-medium",
  clearButton: "text-sm text-neutral font-medium",
  tooltipContainer: "invisible group-hover:visible relative -top-6",
  tooltip: "absolute z-10 left-0 whitespace-nowrap rounded shadow-lg p-3 text-sm bg-neutral-dark text-white",
  invalidMessage: "pl-3 text-sm text-red-700",
  invalidRowContainer: "pt-2 flex flex-row items-center"
};
function RangeInput(props) {
  var _a, _b, _c, _d, _e, _f, _g, _h;
  const { filters } = useFiltersContext();
  const { fieldId, setIsOptionsDisabled } = useFilterGroupContext();
  const { getFilterDisplayName = getDefaultFilterDisplayName, inputPrefix } = props;
  const cssClasses = useComposedCssClasses(builtInCssClasses20, props.customCssClasses);
  const searchActions = useSearchActions();
  const [minRangeInput, setMinRangeInput] = (0, import_react62.useState)("");
  const [maxRangeInput, setMaxRangeInput] = (0, import_react62.useState)("");
  const staticFilters = useSearchState((state) => state.filters.static);
  const fieldValueFilters = (0, import_react62.useMemo)(() => getSelectableFieldValueFilters(staticFilters !== null && staticFilters !== void 0 ? staticFilters : []), [staticFilters]);
  const isDisabled = filters.some((filter) => filter.selected && filter.fieldId === fieldId);
  const rangeFilter = (0, import_react62.useMemo)(() => {
    return {
      kind: "fieldValue",
      fieldId,
      matcher: Matcher.Between,
      value: parseNumberRangeInput(minRangeInput, maxRangeInput)
    };
  }, [fieldId, maxRangeInput, minRangeInput]);
  const isValid = isValidRange(rangeFilter.value);
  const matchingFilter = findSelectableFieldValueFilter(rangeFilter, fieldValueFilters);
  const isSelectedInAnswersState = (matchingFilter === null || matchingFilter === void 0 ? void 0 : matchingFilter.selected) === true;
  const hasUserInput = !!(minRangeInput || maxRangeInput);
  const shouldRenderApplyButton = hasUserInput && !isSelectedInAnswersState;
  (0, import_react62.useEffect)(() => {
    setIsOptionsDisabled(hasUserInput);
  }, [hasUserInput, setIsOptionsDisabled]);
  const handleMinChange = (0, import_react62.useCallback)((event) => {
    var _a2;
    const input = (_a2 = event === null || event === void 0 ? void 0 : event.target) === null || _a2 === void 0 ? void 0 : _a2.value;
    validateNumericInput(input) && setMinRangeInput(input);
  }, []);
  const handleMaxChange = (0, import_react62.useCallback)((event) => {
    var _a2;
    const input = (_a2 = event === null || event === void 0 ? void 0 : event.target) === null || _a2 === void 0 ? void 0 : _a2.value;
    validateNumericInput(input) && setMaxRangeInput(input);
  }, []);
  const handleClickApply = (0, import_react62.useCallback)(() => {
    if (!rangeFilter.value.start && !rangeFilter.value.end) {
      return;
    }
    if (!isValid) {
      return;
    }
    const displayName = getFilterDisplayName(rangeFilter.value);
    clearStaticRangeFilters(searchActions, /* @__PURE__ */ new Set([fieldId]));
    searchActions.setFilterOption({
      filter: rangeFilter,
      selected: true,
      displayName
    });
    searchActions.setOffset(0);
    executeSearch(searchActions);
  }, [searchActions, fieldId, getFilterDisplayName, isValid, rangeFilter]);
  const handleClickClear = (0, import_react62.useCallback)(() => {
    const displayName = getFilterDisplayName(rangeFilter.value);
    searchActions.setFilterOption({
      filter: rangeFilter,
      selected: false,
      displayName
    });
    setMinRangeInput("");
    setMaxRangeInput("");
    searchActions.setOffset(0);
    executeSearch(searchActions);
  }, [searchActions, getFilterDisplayName, rangeFilter]);
  const inputClasses = (0, import_classnames12.default)(cssClasses.input, {
    [(_a = cssClasses.input___withPrefix) !== null && _a !== void 0 ? _a : ""]: !!inputPrefix,
    [(_b = cssClasses.input___withoutPrefix) !== null && _b !== void 0 ? _b : ""]: !inputPrefix,
    [(_c = cssClasses.input___disabled) !== null && _c !== void 0 ? _c : ""]: isDisabled,
    [(_d = cssClasses.input___enabled) !== null && _d !== void 0 ? _d : ""]: !isDisabled,
    [(_e = cssClasses.input___invalid) !== null && _e !== void 0 ? _e : ""]: !isValid,
    [(_f = cssClasses.input___valid) !== null && _f !== void 0 ? _f : ""]: isValid
  });
  const inputPrefixClasses = (0, import_classnames12.default)(cssClasses.inputPrefix, {
    [(_g = cssClasses.inputPrefix___disabled) !== null && _g !== void 0 ? _g : ""]: isDisabled,
    [(_h = cssClasses.inputPrefix___enabled) !== null && _h !== void 0 ? _h : ""]: !isDisabled
  });
  function renderInput(value, onChange, placeholder) {
    return (0, import_jsx_runtime49.jsxs)("div", Object.assign({ className: cssClasses.inputContainer }, { children: [inputPrefix && (0, import_jsx_runtime49.jsx)("span", Object.assign({ className: inputPrefixClasses, "aria-hidden": "true" }, { children: inputPrefix }), void 0), (0, import_jsx_runtime49.jsx)("input", { type: "text", inputMode: "decimal", value, placeholder, disabled: isDisabled, className: inputClasses, onChange }, void 0)] }), void 0);
  }
  return (0, import_jsx_runtime49.jsxs)("div", Object.assign({ className: cssClasses.rangeInputContainer }, { children: [(0, import_jsx_runtime49.jsxs)("div", Object.assign({ className: cssClasses.inputRowContainer }, { children: [renderInput(minRangeInput, handleMinChange, "Min"), (0, import_jsx_runtime49.jsx)("div", Object.assign({ className: "w-2.5 text-sm text-neutral" }, { children: "-" }), void 0), renderInput(maxRangeInput, handleMaxChange, "Max"), isDisabled && (0, import_jsx_runtime49.jsx)("div", Object.assign({ className: cssClasses.tooltipContainer }, { children: (0, import_jsx_runtime49.jsx)("div", Object.assign({ className: cssClasses.tooltip }, { children: "Unselect an option to enter in a range." }), void 0) }), void 0)] }), void 0), !isValid && (0, import_jsx_runtime49.jsxs)("div", Object.assign({ className: cssClasses.invalidRowContainer }, { children: [(0, import_jsx_runtime49.jsx)(InvalidIcon, {}, void 0), (0, import_jsx_runtime49.jsx)("div", Object.assign({ className: cssClasses.invalidMessage }, { children: "Invalid range" }), void 0)] }), void 0), hasUserInput && (0, import_jsx_runtime49.jsxs)("div", Object.assign({ className: cssClasses.buttonsContainer }, { children: [(0, import_jsx_runtime49.jsx)("button", Object.assign({ className: cssClasses.clearButton, onClick: handleClickClear }, { children: "Clear min and max" }), void 0), shouldRenderApplyButton && (0, import_jsx_runtime49.jsx)("button", Object.assign({ className: cssClasses.applyButton, onClick: handleClickApply }, { children: "Apply" }), void 0)] }), void 0)] }), void 0);
}
function getDefaultFilterDisplayName(numberRange) {
  const start = numberRange.start;
  const end = numberRange.end;
  if (start && end) {
    return `${start.value} - ${end.value}`;
  } else if (start && !end) {
    return `Over ${start.value}`;
  } else if (end && !start) {
    return `Up to ${end.value}`;
  }
  return "";
}
function validateNumericInput(str) {
  const numberRegex = new RegExp(/^\d*\.?\d*$/);
  return numberRegex.test(str);
}
function isValidRange(range) {
  if (range.start && range.end) {
    return range.start.value <= range.end.value;
  }
  return true;
}

// node_modules/@yext/search-ui-react/lib/esm/components/FacetTiltle.js
var import_jsx_runtime50 = __toESM(require_jsx_runtime());
var import_react63 = __toESM(require_react());
function FacetTitle({ label, customCssClasses, collapsible = true }) {
  const collapsibleLabelCssClasses = (0, import_react63.useMemo)(() => {
    return {
      label: customCssClasses === null || customCssClasses === void 0 ? void 0 : customCssClasses.titleLabel
    };
  }, [customCssClasses]);
  return (0, import_jsx_runtime50.jsx)(import_react63.Fragment, { children: collapsible ? (0, import_jsx_runtime50.jsx)(CollapsibleLabel, { label, customCssClasses: collapsibleLabelCssClasses }, void 0) : label && (0, import_jsx_runtime50.jsx)("div", Object.assign({ className: twMerge2("mb-4", builtInCssClasses19.label, collapsibleLabelCssClasses.label) }, { children: label }), void 0) }, void 0);
}

// node_modules/@yext/search-ui-react/lib/esm/components/FilterGroup.js
var __rest4 = function(s2, e2) {
  var t2 = {};
  for (var p2 in s2)
    if (Object.prototype.hasOwnProperty.call(s2, p2) && e2.indexOf(p2) < 0)
      t2[p2] = s2[p2];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s2); i2 < p2.length; i2++) {
      if (e2.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i2]))
        t2[p2[i2]] = s2[p2[i2]];
    }
  return t2;
};
function FilterGroup({ fieldId, filterOptions, title, collapsible = true, defaultExpanded = true, searchable, customCssClasses = {}, showMoreLimit = filterOptions.length, children }) {
  const cssClasses = (0, import_react65.useMemo)(() => {
    const { option, optionLabel, optionInput } = customCssClasses, remainingClasses = __rest4(customCssClasses, ["option", "optionLabel", "optionInput"]);
    return Object.assign(Object.assign(Object.assign(Object.assign({}, remainingClasses), option && { optionContainer: option }), optionLabel && { label: optionLabel }), optionInput && { input: optionInput });
  }, [customCssClasses]);
  return (0, import_jsx_runtime51.jsxs)(FilterGroupProvider, Object.assign({ fieldId, defaultExpanded: !collapsible || defaultExpanded }, { children: [(0, import_jsx_runtime51.jsx)(FacetTitle, { label: title, customCssClasses, collapsible }, void 0), (0, import_jsx_runtime51.jsxs)(CollapsibleSection, Object.assign({ className: cssClasses.optionsContainer }, { children: [searchable && (0, import_jsx_runtime51.jsx)(SearchInput, { className: cssClasses.searchInput }, void 0), (0, import_jsx_runtime51.jsx)(CheckboxOptions, { filterOptions, showMoreLimit, cssClasses }, void 0), children] }), void 0)] }), void 0);
}
function CheckboxOptions({ filterOptions, showMoreLimit, cssClasses }) {
  const searchUtilities = useSearchUtilities();
  const { searchValue } = useFilterGroupContext();
  const shouldRenderOption = (option) => {
    return searchUtilities.isCloseMatch(option.displayName || option.value.toString(), searchValue);
  };
  let displayedOptions = filterOptions.filter(shouldRenderOption).map((o2) => {
    return (0, import_react64.createElement)(CheckboxOption, Object.assign({}, o2, { key: o2.displayName || o2.value.toString(), customCssClasses: cssClasses }));
  });
  const isLimited = displayedOptions.length > showMoreLimit;
  const [showAll, setShowAll] = (0, import_react65.useState)(!isLimited);
  displayedOptions = displayedOptions.slice(0, showAll ? displayedOptions.length : showMoreLimit);
  return (0, import_jsx_runtime51.jsxs)(import_jsx_runtime51.Fragment, { children: [displayedOptions, isLimited && (0, import_jsx_runtime51.jsx)("button", Object.assign({ className: "text-primary py-1 text-sm", onClick: () => setShowAll(!showAll) }, { children: showAll ? "Show Less" : "Show More" }), void 0)] }, void 0);
}

// node_modules/@yext/search-ui-react/lib/esm/components/StaticFilters.js
var __rest5 = function(s2, e2) {
  var t2 = {};
  for (var p2 in s2)
    if (Object.prototype.hasOwnProperty.call(s2, p2) && e2.indexOf(p2) < 0)
      t2[p2] = s2[p2];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s2); i2 < p2.length; i2++) {
      if (e2.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i2]))
        t2[p2[i2]] = s2[p2[i2]];
    }
  return t2;
};
function StaticFilters(props) {
  const { searchOnChange, customCssClasses = {} } = props, filterGroupProps = __rest5(props, ["searchOnChange", "customCssClasses"]);
  const { staticFiltersContainer: containerClassName } = customCssClasses, filterGroupCssClasses = __rest5(customCssClasses, ["staticFiltersContainer"]);
  return (0, import_jsx_runtime52.jsx)(StaticFiltersProvider, Object.assign({ searchOnChange, className: containerClassName }, { children: (0, import_jsx_runtime52.jsx)(FilterGroup, Object.assign({ customCssClasses: filterGroupCssClasses }, filterGroupProps), filterGroupProps.fieldId) }), void 0);
}

// node_modules/@yext/search-ui-react/lib/esm/components/StandardFacets.js
var import_jsx_runtime54 = __toESM(require_jsx_runtime());
var import_react66 = __toESM(require_react());

// node_modules/@yext/search-ui-react/lib/esm/components/FilterDivider.js
var import_jsx_runtime53 = __toESM(require_jsx_runtime());
function FilterDivider({ className }) {
  return (0, import_jsx_runtime53.jsx)("div", { className: twMerge2("w-full h-px bg-gray-200 my-4", className) }, void 0);
}

// node_modules/@yext/search-ui-react/lib/esm/components/StandardFacets.js
var __rest6 = function(s2, e2) {
  var t2 = {};
  for (var p2 in s2)
    if (Object.prototype.hasOwnProperty.call(s2, p2) && e2.indexOf(p2) < 0)
      t2[p2] = s2[p2];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s2); i2 < p2.length; i2++) {
      if (e2.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i2]))
        t2[p2[i2]] = s2[p2[i2]];
    }
  return t2;
};
function StandardFacets(props) {
  const { searchOnChange, excludedFieldIds = [], customCssClasses = {}, showMoreLimit = 10, showOptionCounts = true } = props, filterGroupProps = __rest6(props, ["searchOnChange", "excludedFieldIds", "customCssClasses", "showMoreLimit", "showOptionCounts"]);
  return (0, import_jsx_runtime54.jsx)(FacetsProvider, Object.assign({ searchOnChange, className: customCssClasses.standardFacetsContainer }, { children: (facets) => facets.filter((f2) => !excludedFieldIds.includes(f2.fieldId) && isStringFacet(f2)).map((f2, i2) => {
    return (0, import_jsx_runtime54.jsxs)(import_react66.Fragment, { children: [(0, import_jsx_runtime54.jsx)(FilterGroup, Object.assign({ fieldId: f2.fieldId, filterOptions: f2.options.map((o2) => {
      return showOptionCounts ? Object.assign(Object.assign({}, o2), { resultsCount: o2.count }) : o2;
    }), title: f2.displayName, customCssClasses, showMoreLimit, searchable: f2.options.length > showMoreLimit }, filterGroupProps), void 0), i2 < facets.length - 1 && (0, import_jsx_runtime54.jsx)(FilterDivider, { className: customCssClasses.divider }, void 0)] }, f2.fieldId);
  }) }), void 0);
}

// node_modules/@yext/search-ui-react/lib/esm/components/HierarchicalFacets.js
var import_jsx_runtime55 = __toESM(require_jsx_runtime());
var import_react67 = __toESM(require_react());
function HierarchicalFacets({ searchOnChange, collapsible, defaultExpanded, includedFieldIds, customCssClasses = {}, delimiter, showMoreLimit }) {
  return (0, import_jsx_runtime55.jsx)(FacetsProvider, Object.assign({ searchOnChange, className: customCssClasses.hierarchicalFacetsContainer }, { children: (facets) => facets.filter((f2) => f2.options.length > 0 && includedFieldIds.includes(f2.fieldId)).map((f2, i2) => {
    return (0, import_jsx_runtime55.jsxs)(import_react67.Fragment, { children: [(0, import_jsx_runtime55.jsxs)(FilterGroupProvider, Object.assign({ fieldId: f2.fieldId, defaultExpanded: !collapsible || defaultExpanded }, { children: [collapsible ? (0, import_jsx_runtime55.jsx)(CollapsibleLabel, { label: f2.displayName }, void 0) : f2.displayName && (0, import_jsx_runtime55.jsx)("div", Object.assign({ className: "text-neutral-dark text-sm font-medium text-left mb-4" }, { children: f2.displayName }), void 0), (0, import_jsx_runtime55.jsx)(CollapsibleSection, { children: (0, import_jsx_runtime55.jsx)(HierarchicalFacetDisplay, { facet: f2, delimiter, showMoreLimit, customCssClasses }, void 0) }, void 0)] }), void 0), i2 < facets.length - 1 && (0, import_jsx_runtime55.jsx)(FilterDivider, { className: customCssClasses.divider }, void 0)] }, f2.fieldId);
  }) }), void 0);
}

// node_modules/@yext/search-ui-react/lib/esm/components/NumericalFacets.js
var import_jsx_runtime56 = __toESM(require_jsx_runtime());
var import_react68 = __toESM(require_react());
var __rest7 = function(s2, e2) {
  var t2 = {};
  for (var p2 in s2)
    if (Object.prototype.hasOwnProperty.call(s2, p2) && e2.indexOf(p2) < 0)
      t2[p2] = s2[p2];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s2); i2 < p2.length; i2++) {
      if (e2.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i2]))
        t2[p2[i2]] = s2[p2[i2]];
    }
  return t2;
};
var DEFAULT_RANGE_INPUT_PREFIX = (0, import_jsx_runtime56.jsx)(import_jsx_runtime56.Fragment, { children: "$" }, void 0);
function NumericalFacets(_a) {
  var { searchOnChange, includedFieldIds = [], getFilterDisplayName, inputPrefix = DEFAULT_RANGE_INPUT_PREFIX, customCssClasses = {} } = _a, filterGroupProps = __rest7(_a, ["searchOnChange", "includedFieldIds", "getFilterDisplayName", "inputPrefix", "customCssClasses"]);
  return (0, import_jsx_runtime56.jsx)(FacetsProvider, Object.assign({ searchOnChange, className: customCssClasses.numericalFacetsContainer }, { children: (facets) => facets.filter((f2) => isNumericalFacet(f2) && (includedFieldIds.length === 0 || includedFieldIds.includes(f2.fieldId))).map((f2, i2) => {
    return (0, import_jsx_runtime56.jsxs)(import_react68.Fragment, { children: [(0, import_jsx_runtime56.jsx)(FilterGroup, Object.assign({ fieldId: f2.fieldId, filterOptions: f2.options, title: f2.displayName, customCssClasses }, filterGroupProps, { children: (0, import_jsx_runtime56.jsx)(RangeInput, { getFilterDisplayName, inputPrefix, customCssClasses }, void 0) }), void 0), i2 < facets.length - 1 && (0, import_jsx_runtime56.jsx)(FilterDivider, { className: customCssClasses.divider }, void 0)] }, f2.fieldId);
  }) }), void 0);
}

// node_modules/@yext/search-ui-react/lib/esm/components/Facets.js
var import_jsx_runtime60 = __toESM(require_jsx_runtime());

// node_modules/@yext/search-ui-react/lib/esm/components/StandardFacetContent.js
var import_jsx_runtime57 = __toESM(require_jsx_runtime());
var __rest8 = function(s2, e2) {
  var t2 = {};
  for (var p2 in s2)
    if (Object.prototype.hasOwnProperty.call(s2, p2) && e2.indexOf(p2) < 0)
      t2[p2] = s2[p2];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s2); i2 < p2.length; i2++) {
      if (e2.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i2]))
        t2[p2[i2]] = s2[p2[i2]];
    }
  return t2;
};
function StandardFacetContent(_a) {
  var { fieldId, label, transformOptions, customCssClasses, facet, showMoreLimit = 10, showOptionCounts = true } = _a, filterGroupProps = __rest8(_a, ["fieldId", "label", "transformOptions", "customCssClasses", "facet", "showMoreLimit", "showOptionCounts"]);
  const options = facet.options || [];
  const transformedOptions = transformOptions ? transformOptions(options) || [] : options;
  return (0, import_jsx_runtime57.jsx)(FilterGroup, Object.assign({ fieldId, filterOptions: transformedOptions.map((o2) => {
    return showOptionCounts ? Object.assign(Object.assign({}, o2), { resultsCount: o2.count }) : o2;
  }), title: label || facet.displayName, customCssClasses, showMoreLimit, searchable: (facet === null || facet === void 0 ? void 0 : facet.options.length) > showMoreLimit }, filterGroupProps), void 0);
}

// node_modules/@yext/search-ui-react/lib/esm/components/Facets.js
var import_react69 = __toESM(require_react());

// node_modules/@yext/search-ui-react/lib/esm/components/NumericalFacetContent.js
var import_jsx_runtime58 = __toESM(require_jsx_runtime());
var __rest9 = function(s2, e2) {
  var t2 = {};
  for (var p2 in s2)
    if (Object.prototype.hasOwnProperty.call(s2, p2) && e2.indexOf(p2) < 0)
      t2[p2] = s2[p2];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s2); i2 < p2.length; i2++) {
      if (e2.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i2]))
        t2[p2[i2]] = s2[p2[i2]];
    }
  return t2;
};
var DEFAULT_RANGE_INPUT_PREFIX2 = (0, import_jsx_runtime58.jsx)(import_jsx_runtime58.Fragment, { children: "$" }, void 0);
function NumericalFacetContent(_a) {
  var { fieldId, label, transformOptions, customCssClasses, getFilterDisplayName, facet, showMoreLimit = 10, showOptionCounts = false, inputPrefix = DEFAULT_RANGE_INPUT_PREFIX2 } = _a, filterGroupProps = __rest9(_a, ["fieldId", "label", "transformOptions", "customCssClasses", "getFilterDisplayName", "facet", "showMoreLimit", "showOptionCounts", "inputPrefix"]);
  const options = facet.options || [];
  const transformedOptions = transformOptions ? transformOptions(options) || [] : options;
  return (0, import_jsx_runtime58.jsx)(FilterGroup, Object.assign({ fieldId, filterOptions: transformedOptions.map((o2) => {
    return showOptionCounts ? Object.assign(Object.assign({}, o2), { resultsCount: o2.count }) : o2;
  }), title: label || facet.displayName, customCssClasses, showMoreLimit, searchable: (facet === null || facet === void 0 ? void 0 : facet.options.length) > showMoreLimit }, filterGroupProps, { children: (0, import_jsx_runtime58.jsx)(RangeInput, { getFilterDisplayName, inputPrefix, customCssClasses }, void 0) }), void 0);
}

// node_modules/@yext/search-ui-react/lib/esm/components/HierarchicalFacetContent.js
var import_jsx_runtime59 = __toESM(require_jsx_runtime());
function HierarchicalFacetContent({ fieldId, label, transformOptions, customCssClasses, delimiter, facet, collapsible = true, defaultExpanded = true, showMoreLimit = 4 }) {
  const options = facet.options || [];
  const transformedOptions = transformOptions ? transformOptions(options) || [] : options;
  return (0, import_jsx_runtime59.jsxs)(FilterGroupProvider, Object.assign({ fieldId, defaultExpanded: !collapsible || defaultExpanded }, { children: [(0, import_jsx_runtime59.jsx)(FacetTitle, { label: label || facet.displayName, customCssClasses, collapsible }, void 0), (0, import_jsx_runtime59.jsx)(CollapsibleSection, { children: (0, import_jsx_runtime59.jsx)(
    HierarchicalFacetDisplay,
    {
      facet: Object.assign(Object.assign({}, facet), { options: transformedOptions }),
      delimiter,
      showMoreLimit,
      customCssClasses
    },
    void 0
  ) }, void 0)] }), void 0);
}

// node_modules/@yext/search-ui-react/lib/esm/components/Facets.js
var FacetType;
(function(FacetType2) {
  FacetType2["STANDARD"] = "STANDARD";
  FacetType2["NUMERICAL"] = "NUMERICAL";
  FacetType2["HIERARCHICAL"] = "HIERARCHICAL";
})(FacetType || (FacetType = {}));
function Facets(props) {
  const { searchOnChange, onlyRenderChildren = false, children, hierarchicalFieldIds, excludedFieldIds = [], customCssClasses = {} } = props;
  const fieldIdToCustomFacetProps = /* @__PURE__ */ new Map();
  const fieldIds = [];
  if (children) {
    (Array.isArray(children) ? children : [children]).filter((child) => {
      var _a;
      return (_a = child === null || child === void 0 ? void 0 : child.props) === null || _a === void 0 ? void 0 : _a.fieldId;
    }).forEach((child) => {
      fieldIdToCustomFacetProps.set(child.props.fieldId, child);
      fieldIds.push(child.props.fieldId);
    });
  }
  return (0, import_jsx_runtime60.jsx)("div", { children: (0, import_jsx_runtime60.jsx)(FacetsProvider, Object.assign({ searchOnChange, className: customCssClasses.facetsContainer }, { children: (facets) => {
    if (!facets || !facets.length) {
      return;
    }
    if (!onlyRenderChildren) {
      facets.forEach((facet) => {
        if (!fieldIds.includes(facet.fieldId)) {
          fieldIds.push(facet.fieldId);
        }
      });
    }
    const fieldIdToFacet = /* @__PURE__ */ new Map();
    facets.forEach((facet) => fieldIdToFacet.set(facet.fieldId, facet));
    return fieldIds.filter((fieldId) => !excludedFieldIds.includes(fieldId) && fieldIdToFacet.get(fieldId).options.length > 0 && (!onlyRenderChildren || fieldIdToCustomFacetProps.has(fieldId))).map((fieldId, i2) => {
      const facet = fieldIdToFacet.get(fieldId);
      return (0, import_jsx_runtime60.jsxs)(import_react69.Fragment, { children: [(0, import_jsx_runtime60.jsx)(Facet, { facet, facetsCustomCssClasses: customCssClasses, fieldIdToCustomFacetProps, hierarchicalFieldIds }, void 0), i2 < facets.length - 1 && (0, import_jsx_runtime60.jsx)(FilterDivider, { className: customCssClasses === null || customCssClasses === void 0 ? void 0 : customCssClasses.divider }, void 0)] }, facet.fieldId);
    });
  } }), void 0) }, void 0);
}
function StandardFacet(props) {
  return null;
}
function NumericalFacet(props) {
  return null;
}
function HierarchicalFacet(props) {
  return null;
}
function Facet({ facet, facetsCustomCssClasses, fieldIdToCustomFacetProps, hierarchicalFieldIds }) {
  let facetType;
  let facetProps = {
    fieldId: facet.fieldId,
    label: facet.displayName
  };
  if (fieldIdToCustomFacetProps.has(facet.fieldId)) {
    const customFacetElement = fieldIdToCustomFacetProps.get(facet.fieldId);
    facetProps = Object.assign(Object.assign({}, facetProps), customFacetElement.props);
    facetType = getFacetTypeFromReactElementType(typeof customFacetElement.type === "function" ? customFacetElement.type.name : "");
  } else {
    facetType = getFacetTypeFromFacet(facet, hierarchicalFieldIds);
  }
  facetProps = Object.assign(Object.assign({}, facetProps), { customCssClasses: Object.assign(Object.assign({}, facetsCustomCssClasses), facetProps.customCssClasses) });
  switch (facetType) {
    case FacetType.NUMERICAL:
      return (0, import_jsx_runtime60.jsx)(NumericalFacetContent, Object.assign({ facet }, facetProps), void 0);
    case FacetType.HIERARCHICAL:
      return (0, import_jsx_runtime60.jsx)(HierarchicalFacetContent, Object.assign({ facet }, facetProps), void 0);
    case FacetType.STANDARD:
    default:
      return (0, import_jsx_runtime60.jsx)(StandardFacetContent, Object.assign({ facet }, facetProps), void 0);
  }
}
function getFacetTypeFromReactElementType(elementType) {
  switch (elementType) {
    case NumericalFacet.name.toString():
      return FacetType.NUMERICAL;
    case HierarchicalFacet.name.toString():
      return FacetType.HIERARCHICAL;
    case StandardFacet.name.toString():
    default:
      return FacetType.STANDARD;
  }
}
function getFacetTypeFromFacet(facet, hierarchicalFieldIds = []) {
  if (hierarchicalFieldIds.includes(facet.fieldId)) {
    return FacetType.HIERARCHICAL;
  } else if (isStringFacet(facet)) {
    return FacetType.STANDARD;
  } else if (isNumericalFacet(facet)) {
    return FacetType.NUMERICAL;
  }
  return FacetType.STANDARD;
}

// node_modules/@yext/search-ui-react/lib/esm/components/ApplyFiltersButton.js
var import_jsx_runtime61 = __toESM(require_jsx_runtime());
var import_react70 = __toESM(require_react());
var builtInCssClasses21 = {
  button: "border border-gray-300 px-2.5 py-1 rounded-md text-primary bg-white shadow-md sticky bottom-3"
};
function ApplyFiltersButton({ customCssClasses, label = "Apply Filters" }) {
  const cssClasses = useComposedCssClasses(builtInCssClasses21, customCssClasses);
  const searchActions = useSearchActions();
  const handleClick = (0, import_react70.useCallback)(() => {
    searchActions.setOffset(0);
    clearStaticRangeFilters(searchActions, getSelectedNumericalFacetFields(searchActions));
    executeSearch(searchActions);
  }, [searchActions]);
  return (0, import_jsx_runtime61.jsx)("button", Object.assign({ onClick: handleClick, className: cssClasses.button }, { children: label }), void 0);
}

// node_modules/@yext/search-ui-react/lib/esm/components/MapboxMap.js
var import_jsx_runtime62 = __toESM(require_jsx_runtime());
var import_react71 = __toESM(require_react());
var import_mapbox_gl = __toESM(require_mapbox_gl());
var import_react_dom2 = __toESM(require_react_dom());
function MapboxMap({ mapboxAccessToken, mapboxOptions, PinComponent, getCoordinate = getDefaultCoordinate, onDrag }) {
  (0, import_react71.useEffect)(() => {
    import_mapbox_gl.default.accessToken = mapboxAccessToken;
  }, [mapboxAccessToken]);
  const mapContainer = (0, import_react71.useRef)(null);
  const map = (0, import_react71.useRef)(null);
  const markers = (0, import_react71.useRef)([]);
  const locationResults = useSearchState((state) => state.vertical.results);
  const onDragDebounced = useDebouncedFunction(onDrag, 100);
  (0, import_react71.useEffect)(() => {
    if (mapContainer.current && !map.current) {
      const options = Object.assign({ container: mapContainer.current, style: "mapbox://styles/mapbox/streets-v11", center: [-74.005371, 40.741611], zoom: 9 }, mapboxOptions);
      map.current = new import_mapbox_gl.Map(options);
      const mapbox = map.current;
      mapbox.resize();
      if (onDragDebounced) {
        mapbox.on("drag", () => {
          onDragDebounced(mapbox.getCenter(), mapbox.getBounds());
        });
      }
    }
  }, [mapboxOptions, onDragDebounced]);
  (0, import_react71.useEffect)(() => {
    markers.current.forEach((marker) => marker.remove());
    markers.current = [];
    const mapbox = map.current;
    if (mapbox && (locationResults === null || locationResults === void 0 ? void 0 : locationResults.length) > 0) {
      const bounds = new import_mapbox_gl.LngLatBounds();
      locationResults.forEach((result, i2) => {
        const markerLocation = getCoordinate(result);
        if (markerLocation) {
          const { latitude, longitude } = markerLocation;
          const el = document.createElement("div");
          const markerOptions = {};
          if (PinComponent) {
            import_react_dom2.default.render((0, import_jsx_runtime62.jsx)(PinComponent, { index: i2, mapbox, result }, void 0), el);
            markerOptions.element = el;
          }
          const marker = new import_mapbox_gl.Marker(markerOptions).setLngLat({ lat: latitude, lng: longitude }).addTo(mapbox);
          markers.current.push(marker);
          bounds.extend([longitude, latitude]);
        }
      });
      if (!bounds.isEmpty()) {
        mapbox.fitBounds(bounds, {
          padding: { top: 50, bottom: 50, left: 50, right: 50 },
          maxZoom: 15
        });
      }
    }
  }, [PinComponent, getCoordinate, locationResults]);
  return (0, import_jsx_runtime62.jsx)("div", { ref: mapContainer, className: "h-full w-full" }, void 0);
}
function isCoordinate(data) {
  return typeof data == "object" && typeof (data === null || data === void 0 ? void 0 : data["latitude"]) === "number" && typeof (data === null || data === void 0 ? void 0 : data["longitude"]) === "number";
}
function getDefaultCoordinate(result) {
  const yextDisplayCoordinate = result.rawData["yextDisplayCoordinate"];
  if (!yextDisplayCoordinate) {
    console.error(`Unable to use the default "yextDisplayCoordinate" field as the result's coordinate to display on map.
Consider providing the "getCoordinate" prop to MapboxMap component to fetch the desire coordinate from result.`);
    return void 0;
  }
  if (!isCoordinate(yextDisplayCoordinate)) {
    console.error('The default `yextDisplayCoordinate` field from result is not of type "Coordinate".');
    return void 0;
  }
  return yextDisplayCoordinate;
}

// node_modules/@yext/search-ui-react/lib/esm/components/AnalyticsProvider.js
var import_jsx_runtime63 = __toESM(require_jsx_runtime());

// node_modules/@yext/search-ui-react/node_modules/@yext/analytics/lib/esm/infra/HttpRequester.js
var import_cross_fetch = __toESM(require_browser_ponyfill());
var HttpRequester = function() {
  function HttpRequester2() {
  }
  HttpRequester2.prototype.post = function(url, body) {
    var data = JSON.stringify(body);
    var fetchInit = {
      method: "POST",
      body: data,
      keepalive: true
    };
    if (typeof window !== "undefined" && window.fetch) {
      return window.fetch(url, fetchInit);
    }
    return (0, import_cross_fetch.default)(url, fetchInit);
  };
  HttpRequester2.prototype.get = function(url) {
    var fetchInit = {
      method: "GET",
      mode: "no-cors"
    };
    if (typeof window !== "undefined" && window.fetch) {
      return window.fetch(url, fetchInit);
    }
    return (0, import_cross_fetch.default)(url, fetchInit);
  };
  return HttpRequester2;
}();

// node_modules/@yext/search-ui-react/node_modules/@yext/analytics/lib/esm/infra/SearchAnalyticsReporter.js
var __assign = function() {
  __assign = Object.assign || function(t2) {
    for (var s2, i2 = 1, n2 = arguments.length; i2 < n2; i2++) {
      s2 = arguments[i2];
      for (var p2 in s2)
        if (Object.prototype.hasOwnProperty.call(s2, p2))
          t2[p2] = s2[p2];
    }
    return t2;
  };
  return __assign.apply(this, arguments);
};
var __awaiter = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e2) {
        reject(e2);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e2) {
        reject(e2);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var __generator = function(thisArg, body) {
  var _ = { label: 0, sent: function() {
    if (t2[0] & 1)
      throw t2[1];
    return t2[1];
  }, trys: [], ops: [] }, f2, y2, t2, g2;
  return g2 = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g2[Symbol.iterator] = function() {
    return this;
  }), g2;
  function verb(n2) {
    return function(v2) {
      return step([n2, v2]);
    };
  }
  function step(op) {
    if (f2)
      throw new TypeError("Generator is already executing.");
    while (_)
      try {
        if (f2 = 1, y2 && (t2 = op[0] & 2 ? y2["return"] : op[0] ? y2["throw"] || ((t2 = y2["return"]) && t2.call(y2), 0) : y2.next) && !(t2 = t2.call(y2, op[1])).done)
          return t2;
        if (y2 = 0, t2)
          op = [op[0] & 2, t2.value];
        switch (op[0]) {
          case 0:
          case 1:
            t2 = op;
            break;
          case 4:
            _.label++;
            return { value: op[1], done: false };
          case 5:
            _.label++;
            y2 = op[1];
            op = [0];
            continue;
          case 7:
            op = _.ops.pop();
            _.trys.pop();
            continue;
          default:
            if (!(t2 = _.trys, t2 = t2.length > 0 && t2[t2.length - 1]) && (op[0] === 6 || op[0] === 2)) {
              _ = 0;
              continue;
            }
            if (op[0] === 3 && (!t2 || op[1] > t2[0] && op[1] < t2[3])) {
              _.label = op[1];
              break;
            }
            if (op[0] === 6 && _.label < t2[1]) {
              _.label = t2[1];
              t2 = op;
              break;
            }
            if (t2 && _.label < t2[2]) {
              _.label = t2[2];
              _.ops.push(op);
              break;
            }
            if (t2[2])
              _.ops.pop();
            _.trys.pop();
            continue;
        }
        op = body.call(thisArg, _);
      } catch (e2) {
        op = [6, e2];
        y2 = 0;
      } finally {
        f2 = t2 = 0;
      }
    if (op[0] & 5)
      throw op[1];
    return { value: op[0] ? op[1] : void 0, done: true };
  }
};
var __rest10 = function(s2, e2) {
  var t2 = {};
  for (var p2 in s2)
    if (Object.prototype.hasOwnProperty.call(s2, p2) && e2.indexOf(p2) < 0)
      t2[p2] = s2[p2];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s2); i2 < p2.length; i2++) {
      if (e2.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i2]))
        t2[p2[i2]] = s2[p2[i2]];
    }
  return t2;
};
var DEFAULT_DOMAIN = "https://answers.yext-pixel.com";
var SearchAnalyticsReporter = function() {
  function SearchAnalyticsReporter2(config, httpRequesterService) {
    this.config = config;
    this.httpRequesterService = httpRequesterService;
    this.setVisitor(config.visitor);
    this._debug = config.debug;
  }
  SearchAnalyticsReporter2.prototype.printEvent = function(event) {
    if (!this._debug)
      return;
    console.log("%c[YextAnalytics]%c- Tracked Search event: ".concat(event.type), "background: white; color: blue;", "");
  };
  SearchAnalyticsReporter2.prototype.report = function(event, additionalRequestAttributes) {
    var _a;
    return __awaiter(this, void 0, void 0, function() {
      var domain, url, type, eventData, data, res, errorMessage;
      return __generator(this, function(_b) {
        switch (_b.label) {
          case 0:
            domain = (_a = this.config.domain) !== null && _a !== void 0 ? _a : DEFAULT_DOMAIN;
            url = "".concat(domain, "/realtimeanalytics/data/answers/").concat(this.config.businessId);
            type = event.type, eventData = __rest10(event, ["type"]);
            data = __assign(__assign({ eventType: type, businessId: this.config.businessId, experienceKey: this.config.experienceKey, experienceVersion: this.config.experienceVersion }, this._visitor && { visitor: __assign({}, this._visitor) }), SearchAnalyticsReporter2._formatForApi(eventData));
            return [4, this.httpRequesterService.post(url, __assign({ data }, additionalRequestAttributes))];
          case 1:
            res = _b.sent();
            if (!(res.status !== 200))
              return [3, 3];
            return [4, res.text()];
          case 2:
            errorMessage = _b.sent();
            throw new Error(errorMessage);
          case 3:
            this.printEvent(event);
            return [2];
        }
      });
    });
  };
  SearchAnalyticsReporter2.prototype.setVisitor = function(visitor) {
    this._visitor = visitor;
  };
  SearchAnalyticsReporter2._formatForApi = function(event) {
    var transformedEvent = __assign({}, event);
    if (transformedEvent.verticalKey) {
      transformedEvent.verticalConfigId = transformedEvent.verticalKey;
      delete transformedEvent.verticalKey;
    }
    return transformedEvent;
  };
  SearchAnalyticsReporter2.prototype.setDebugEnabled = function(enabled) {
    this._debug = enabled;
  };
  return SearchAnalyticsReporter2;
}();

// node_modules/@yext/search-ui-react/node_modules/@yext/analytics/lib/esm/models/search/SearchAnalyticsEventType.js
var SearchAnalyticsEventType;
(function(SearchAnalyticsEventType2) {
  SearchAnalyticsEventType2["AllTabNavigation"] = "ALL_TAB_NAVIGATION";
  SearchAnalyticsEventType2["VerticalTabNavigation"] = "VERTICAL_TAB_NAVIGATION";
  SearchAnalyticsEventType2["ScrollToBottomOfPage"] = "SCROLL_TO_BOTTOM_OF_PAGE";
  SearchAnalyticsEventType2["QuestionFocus"] = "QUESTION_FOCUS";
  SearchAnalyticsEventType2["QuestionSubmit"] = "QUESTION_SUBMIT";
  SearchAnalyticsEventType2["RowExpand"] = "ROW_EXPAND";
  SearchAnalyticsEventType2["RowCollapse"] = "ROW_COLLAPSE";
  SearchAnalyticsEventType2["ThumbsUp"] = "THUMBS_UP";
  SearchAnalyticsEventType2["ThumbsDown"] = "THUMBS_DOWN";
  SearchAnalyticsEventType2["VoiceStart"] = "VOICE_START";
  SearchAnalyticsEventType2["VoiceStop"] = "VOICE_STOP";
  SearchAnalyticsEventType2["SearchBarImpression"] = "SEARCH_BAR_IMPRESSION";
  SearchAnalyticsEventType2["SearchClearButton"] = "SEARCH_CLEAR_BUTTON";
  SearchAnalyticsEventType2["Paginate"] = "PAGINATE";
  SearchAnalyticsEventType2["AutocompleteSelection"] = "AUTO_COMPLETE_SELECTION";
  SearchAnalyticsEventType2["VerticalViewAll"] = "VERTICAL_VIEW_ALL";
  SearchAnalyticsEventType2["CtaClick"] = "CTA_CLICK";
  SearchAnalyticsEventType2["TitleClick"] = "TITLE_CLICK";
  SearchAnalyticsEventType2["TapToCall"] = "TAP_TO_CALL";
  SearchAnalyticsEventType2["OrderNow"] = "ORDER_NOW";
  SearchAnalyticsEventType2["AddToCart"] = "ADD_TO_CART";
  SearchAnalyticsEventType2["ApplyNow"] = "APPLY_NOW";
  SearchAnalyticsEventType2["DrivingDirections"] = "DRIVING_DIRECTIONS";
  SearchAnalyticsEventType2["ViewWebsite"] = "VIEW_WEBSITE";
  SearchAnalyticsEventType2["Email"] = "EMAIL";
  SearchAnalyticsEventType2["BookAppointment"] = "BOOK_APPOINTMENT";
  SearchAnalyticsEventType2["Rsvp"] = "RSVP";
  SearchAnalyticsEventType2["ResultsHidden"] = "RESULTS_HIDDEN";
  SearchAnalyticsEventType2["ResultsUnhidden"] = "RESULTS_UNHIDDEN";
  SearchAnalyticsEventType2["FollowUpQuery"] = "FOLLOW_UP_QUERY";
})(SearchAnalyticsEventType || (SearchAnalyticsEventType = {}));

// node_modules/@yext/search-ui-react/node_modules/@yext/analytics/lib/esm/models/pages/events/DefaultPagesEventNames.js
var DefaultPagesEventNames;
(function(DefaultPagesEventNames2) {
  DefaultPagesEventNames2["PageView"] = "PAGE_VIEW";
  DefaultPagesEventNames2["CTA"] = "CTA_CLICK";
  DefaultPagesEventNames2["Website"] = "WEBSITE";
  DefaultPagesEventNames2["DrivingDirection"] = "DRIVING_DIRECTIONS";
  DefaultPagesEventNames2["PhoneCall"] = "CALL";
})(DefaultPagesEventNames || (DefaultPagesEventNames = {}));

// node_modules/@yext/search-ui-react/node_modules/@yext/analytics/lib/esm/models/pages/events/CtaClick.js
var CtaClick = {
  eventType: DefaultPagesEventNames.CTA
};

// node_modules/@yext/search-ui-react/node_modules/@yext/analytics/lib/esm/models/pages/events/WebsiteEvent.js
var WebsiteEvent = {
  eventType: DefaultPagesEventNames.Website
};

// node_modules/@yext/search-ui-react/node_modules/@yext/analytics/lib/esm/models/pages/events/DrivingDirectionEvent.js
var DrivingDirectionEvent = {
  eventType: DefaultPagesEventNames.DrivingDirection
};

// node_modules/@yext/search-ui-react/node_modules/@yext/analytics/lib/esm/models/pages/events/PageViewEvent.js
var PageViewEvent = {
  eventType: DefaultPagesEventNames.PageView
};

// node_modules/@yext/search-ui-react/node_modules/@yext/analytics/lib/esm/models/pages/events/PhoneCallEvent.js
var PhoneCallEvent = {
  eventType: DefaultPagesEventNames.PhoneCall
};

// node_modules/@yext/search-ui-react/node_modules/@yext/analytics/lib/esm/models/constants.js
var COOKIE_PARAM = "_yfpc";
var COOKIE_REMOVAL_VALUE = "__temp__";
var LISTINGS_SOURCE_PARAM = "y_source";
var DEFAULT_CONVERSION_TRACKING_DOMAIN = "realtimeanalytics.yext.com";

// node_modules/@yext/search-ui-react/node_modules/@yext/analytics/lib/esm/infra/CalculateSeed.js
function calculateSeed() {
  return Date.now() + Math.floor(1e3 * Math.random());
}

// node_modules/@yext/search-ui-react/node_modules/@yext/analytics/lib/esm/infra/ConversionTrackingReporter.js
var __awaiter2 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e2) {
        reject(e2);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e2) {
        reject(e2);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var __generator2 = function(thisArg, body) {
  var _ = { label: 0, sent: function() {
    if (t2[0] & 1)
      throw t2[1];
    return t2[1];
  }, trys: [], ops: [] }, f2, y2, t2, g2;
  return g2 = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g2[Symbol.iterator] = function() {
    return this;
  }), g2;
  function verb(n2) {
    return function(v2) {
      return step([n2, v2]);
    };
  }
  function step(op) {
    if (f2)
      throw new TypeError("Generator is already executing.");
    while (_)
      try {
        if (f2 = 1, y2 && (t2 = op[0] & 2 ? y2["return"] : op[0] ? y2["throw"] || ((t2 = y2["return"]) && t2.call(y2), 0) : y2.next) && !(t2 = t2.call(y2, op[1])).done)
          return t2;
        if (y2 = 0, t2)
          op = [op[0] & 2, t2.value];
        switch (op[0]) {
          case 0:
          case 1:
            t2 = op;
            break;
          case 4:
            _.label++;
            return { value: op[1], done: false };
          case 5:
            _.label++;
            y2 = op[1];
            op = [0];
            continue;
          case 7:
            op = _.ops.pop();
            _.trys.pop();
            continue;
          default:
            if (!(t2 = _.trys, t2 = t2.length > 0 && t2[t2.length - 1]) && (op[0] === 6 || op[0] === 2)) {
              _ = 0;
              continue;
            }
            if (op[0] === 3 && (!t2 || op[1] > t2[0] && op[1] < t2[3])) {
              _.label = op[1];
              break;
            }
            if (op[0] === 6 && _.label < t2[1]) {
              _.label = t2[1];
              t2 = op;
              break;
            }
            if (t2 && _.label < t2[2]) {
              _.label = t2[2];
              _.ops.push(op);
              break;
            }
            if (t2[2])
              _.ops.pop();
            _.trys.pop();
            continue;
        }
        op = body.call(thisArg, _);
      } catch (e2) {
        op = [6, e2];
        y2 = 0;
      } finally {
        f2 = t2 = 0;
      }
    if (op[0] & 5)
      throw op[1];
    return { value: op[0] ? op[1] : void 0, done: true };
  }
};
var conversionEndpoint = "conversiontracking/conversion";
var listingsEndpoint = "listings";
var ConversionTrackingReporter = function() {
  function ConversionTrackingReporter2(httpRequesterService, debug) {
    this.httpRequesterService = httpRequesterService;
    this.debug = debug;
    this._debug = debug;
  }
  ConversionTrackingReporter2.prototype.printEvent = function(event, type) {
    if (!this._debug)
      return;
    console.log("%c[YextAnalytics]%c- Tracked ".concat(type, " event: ").concat(event), "background: white; color: blue;", "");
  };
  ConversionTrackingReporter2.prototype.handleRequest = function(url) {
    return __awaiter2(this, void 0, void 0, function() {
      var res, errorMessage;
      return __generator2(this, function(_a) {
        switch (_a.label) {
          case 0:
            return [4, this.httpRequesterService.get(url.toString())];
          case 1:
            res = _a.sent();
            if (!(res.status !== 200 && !(res.type === "opaqueredirect" || res.type === "opaque")))
              return [3, 3];
            return [4, res.text()];
          case 2:
            errorMessage = _a.sent();
            throw new Error(errorMessage);
          case 3:
            return [2];
        }
      });
    });
  };
  ConversionTrackingReporter2.formatBaseEvent = function(event, params) {
    params.set(COOKIE_PARAM, event.cookieId);
    if (event.referrer)
      params.set("referrer", event.referrer);
    params.set("v", calculateSeed().toString());
    params.set("location", event.location);
  };
  ConversionTrackingReporter2.prototype.trackConversion = function(event) {
    return __awaiter2(this, void 0, void 0, function() {
      var url, params;
      return __generator2(this, function(_a) {
        switch (_a.label) {
          case 0:
            url = new URL("https://".concat(DEFAULT_CONVERSION_TRACKING_DOMAIN, "/").concat(conversionEndpoint));
            params = new URLSearchParams();
            params.set("cid", event.cid);
            if (event.cv)
              params.set("cv", event.cv);
            ConversionTrackingReporter2.formatBaseEvent(event, params);
            url.search = params.toString();
            return [4, this.handleRequest(url.toString())];
          case 1:
            _a.sent();
            this.printEvent(event.cid, "Conversion");
            return [2];
        }
      });
    });
  };
  ConversionTrackingReporter2.prototype.trackListings = function(event) {
    return __awaiter2(this, void 0, void 0, function() {
      var url, params;
      return __generator2(this, function(_a) {
        switch (_a.label) {
          case 0:
            url = new URL("https://".concat(DEFAULT_CONVERSION_TRACKING_DOMAIN, "/").concat(listingsEndpoint));
            params = new URLSearchParams();
            params.set(LISTINGS_SOURCE_PARAM, event.source);
            ConversionTrackingReporter2.formatBaseEvent(event, params);
            url.search = params.toString();
            return [4, this.handleRequest(url.toString())];
          case 1:
            _a.sent();
            this.printEvent(event.source, "Listings Click");
            return [2];
        }
      });
    });
  };
  ConversionTrackingReporter2.prototype.setDebugEnabled = function(enabled) {
    this._debug = enabled;
  };
  return ConversionTrackingReporter2;
}();

// node_modules/@yext/search-ui-react/node_modules/@yext/analytics/lib/esm/infra/PagesAnalyticsReporter.js
var __awaiter3 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e2) {
        reject(e2);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e2) {
        reject(e2);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var __generator3 = function(thisArg, body) {
  var _ = { label: 0, sent: function() {
    if (t2[0] & 1)
      throw t2[1];
    return t2[1];
  }, trys: [], ops: [] }, f2, y2, t2, g2;
  return g2 = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g2[Symbol.iterator] = function() {
    return this;
  }), g2;
  function verb(n2) {
    return function(v2) {
      return step([n2, v2]);
    };
  }
  function step(op) {
    if (f2)
      throw new TypeError("Generator is already executing.");
    while (_)
      try {
        if (f2 = 1, y2 && (t2 = op[0] & 2 ? y2["return"] : op[0] ? y2["throw"] || ((t2 = y2["return"]) && t2.call(y2), 0) : y2.next) && !(t2 = t2.call(y2, op[1])).done)
          return t2;
        if (y2 = 0, t2)
          op = [op[0] & 2, t2.value];
        switch (op[0]) {
          case 0:
          case 1:
            t2 = op;
            break;
          case 4:
            _.label++;
            return { value: op[1], done: false };
          case 5:
            _.label++;
            y2 = op[1];
            op = [0];
            continue;
          case 7:
            op = _.ops.pop();
            _.trys.pop();
            continue;
          default:
            if (!(t2 = _.trys, t2 = t2.length > 0 && t2[t2.length - 1]) && (op[0] === 6 || op[0] === 2)) {
              _ = 0;
              continue;
            }
            if (op[0] === 3 && (!t2 || op[1] > t2[0] && op[1] < t2[3])) {
              _.label = op[1];
              break;
            }
            if (op[0] === 6 && _.label < t2[1]) {
              _.label = t2[1];
              t2 = op;
              break;
            }
            if (t2 && _.label < t2[2]) {
              _.label = t2[2];
              _.ops.push(op);
              break;
            }
            if (t2[2])
              _.ops.pop();
            _.trys.pop();
            continue;
        }
        op = body.call(thisArg, _);
      } catch (e2) {
        op = [6, e2];
        y2 = 0;
      } finally {
        f2 = t2 = 0;
      }
    if (op[0] & 5)
      throw op[1];
    return { value: op[0] ? op[1] : void 0, done: true };
  }
};
var DEFAULT_DOMAIN_PAGES = "www.yext-pixel.com";
var PRODUCT_NAME = "sites";
var ENDPOINT = "store_pagespixel";
var urlParamNames;
(function(urlParamNames2) {
  urlParamNames2["BusinessId"] = "businessids";
  urlParamNames2["Product"] = "product";
  urlParamNames2["SiteId"] = "siteId";
  urlParamNames2["IsStaging"] = "isStaging";
  urlParamNames2["CacheBuster"] = "v";
  urlParamNames2["UrlPath"] = "pageurl";
  urlParamNames2["Referrer"] = "pagesReferrer";
  urlParamNames2["EventType"] = "eventType";
  urlParamNames2["PageSetId"] = "pageSetId";
  urlParamNames2["EntityInternalId"] = "ids";
  urlParamNames2["DirectoryId"] = "directoryId";
  urlParamNames2["SearchId"] = "searchId";
  urlParamNames2["StaticPageId"] = "staticPageId";
  urlParamNames2["PageType"] = "pageType";
  urlParamNames2["VisitorId"] = "visitorId";
  urlParamNames2["VisitorMethod"] = "visitorIdMethod";
})(urlParamNames || (urlParamNames = {}));
var eventTypeNameMapping = /* @__PURE__ */ new Map();
eventTypeNameMapping.set(DefaultPagesEventNames.PageView, "pageview");
eventTypeNameMapping.set(DefaultPagesEventNames.CTA, "calltoactionclick");
eventTypeNameMapping.set(DefaultPagesEventNames.PhoneCall, "phonecall");
eventTypeNameMapping.set(DefaultPagesEventNames.DrivingDirection, "drivingdirection");
eventTypeNameMapping.set(DefaultPagesEventNames.Website, "clicktowebsite");
function getEventName(name) {
  var mappedName = eventTypeNameMapping.get(name);
  if (typeof mappedName === "string") {
    return mappedName;
  }
  return name;
}
var PagesAnalyticsReporter = function() {
  function PagesAnalyticsReporter2(config, httpRequesterService) {
    this.config = config;
    this.httpRequesterService = httpRequesterService;
    this.setVisitor(config.visitor);
    this._debug = config.debug;
    this._conversionTracker = new ConversionTrackingReporter(this.httpRequesterService, this._debug);
    this._hasTrackedListings = false;
    try {
      this._pageUrl = new URL(config.pageUrl);
    } catch (_a) {
      throw new Error("pageUrl property must be a valid URL, was: '".concat(config.pageUrl, "'"));
    }
  }
  PagesAnalyticsReporter2.prototype.printEvent = function(event) {
    if (!this._debug)
      return;
    console.log("%c[YextAnalytics]%c- Tracked Pages event: ".concat(event.eventType), "background: white; color: blue;", "");
  };
  PagesAnalyticsReporter2.prototype.urlParameters = function(event) {
    var params = new URLSearchParams();
    params.set(urlParamNames.BusinessId, this.config.businessId.toString());
    params.set(urlParamNames.Product, PRODUCT_NAME);
    params.set(urlParamNames.SiteId, this.config.siteId.toString());
    params.set(urlParamNames.IsStaging, (!this.config.production).toString());
    params.set(urlParamNames.EventType, getEventName(event.eventType));
    params.set(urlParamNames.PageType, this.config.pageType.name);
    if (this.config.pageType.name === "entity") {
      params.set(urlParamNames.PageSetId, this.config.pageType.pageSetId);
      params.set(urlParamNames.EntityInternalId, this.config.pageType.id.toString());
    } else if (this.config.pageType.name === "directory") {
      params.set(urlParamNames.DirectoryId, this.config.pageType.directoryId);
      params.set(urlParamNames.EntityInternalId, this.config.pageType.id.toString());
    } else if (this.config.pageType.name === "locator") {
      params.set(urlParamNames.SearchId, this.config.pageType.searchId);
    } else if (urlParamNames.StaticPageId in this.config.pageType) {
      params.set(urlParamNames.StaticPageId, this.config.pageType.staticPageId);
    }
    params.set(urlParamNames.CacheBuster, calculateSeed().toString());
    params.set(urlParamNames.UrlPath, this._pageUrl.pathname);
    params.set(urlParamNames.Referrer, this.config.referrer);
    if (this._conversionTrackingEnabled && this._cookieID) {
      params.set(COOKIE_PARAM, this._cookieID);
    }
    if (this._visitor) {
      params.set(urlParamNames.VisitorId, this._visitor.id);
      if (this._visitor.idMethod)
        params.set(urlParamNames.VisitorMethod, this._visitor.idMethod);
    }
    return params;
  };
  PagesAnalyticsReporter2.prototype.pageView = function() {
    return __awaiter3(this, void 0, void 0, function() {
      var sourceValue;
      return __generator3(this, function(_a) {
        switch (_a.label) {
          case 0:
            sourceValue = this._pageUrl.searchParams.get(LISTINGS_SOURCE_PARAM);
            if (!(this._conversionTrackingEnabled && this._cookieID && !this._hasTrackedListings && sourceValue))
              return [3, 2];
            return [4, this._conversionTracker.trackListings({
              cookieId: this._cookieID,
              location: this._pageUrl.toString(),
              source: sourceValue
            })];
          case 1:
            _a.sent();
            this._hasTrackedListings = true;
            _a.label = 2;
          case 2:
            return [2, this.track(PageViewEvent)];
        }
      });
    });
  };
  PagesAnalyticsReporter2.prototype.endpoint = function() {
    if (this._conversionTrackingEnabled) {
      return "https://".concat(DEFAULT_CONVERSION_TRACKING_DOMAIN, "/").concat(ENDPOINT);
    }
    return "https://".concat(DEFAULT_DOMAIN_PAGES, "/").concat(ENDPOINT);
  };
  PagesAnalyticsReporter2.prototype.track = function(event, conversionInfo) {
    return __awaiter3(this, void 0, void 0, function() {
      var url, res, errorMessage;
      return __generator3(this, function(_a) {
        switch (_a.label) {
          case 0:
            url = new URL(this.endpoint());
            url.search = this.urlParameters(event).toString();
            return [4, this.httpRequesterService.get(url.toString())];
          case 1:
            res = _a.sent();
            if (!(res.status !== 200 && !(res.type == "opaque" || res.type == "opaqueredirect")))
              return [3, 3];
            return [4, res.text()];
          case 2:
            errorMessage = _a.sent();
            throw new Error(errorMessage);
          case 3:
            this.printEvent(event);
            if (!(this._conversionTrackingEnabled && this._cookieID && conversionInfo))
              return [3, 5];
            return [4, this._conversionTracker.trackConversion({
              cid: conversionInfo.cid,
              cv: conversionInfo.cv,
              cookieId: this._cookieID,
              location: this._pageUrl.toString()
            })];
          case 4:
            _a.sent();
            _a.label = 5;
          case 5:
            return [2];
        }
      });
    });
  };
  PagesAnalyticsReporter2.prototype.setDebugEnabled = function(enabled) {
    this._debug = enabled;
    if (this._conversionTracker) {
      this._conversionTracker.setDebugEnabled(enabled);
    }
  };
  PagesAnalyticsReporter2.prototype.setVisitor = function(visitor) {
    this._visitor = visitor;
  };
  PagesAnalyticsReporter2.prototype.setConversionTrackingEnabled = function(enabled, cookieId) {
    this._conversionTrackingEnabled = enabled;
    this._cookieID = cookieId;
  };
  return PagesAnalyticsReporter2;
}();

// node_modules/@yext/search-ui-react/node_modules/@yext/analytics/lib/esm/utils/CookieManager.js
var CookieManager = function() {
  function CookieManager2(_outerWindow, _outerDocument) {
    if (_outerWindow === void 0) {
      _outerWindow = window;
    }
    if (_outerDocument === void 0) {
      _outerDocument = document;
    }
    this._outerWindow = _outerWindow;
    this._outerDocument = _outerDocument;
  }
  CookieManager2.prototype.setAndGetYextCookie = function() {
    var cookieValue = this.fetchCookie();
    if (!cookieValue) {
      cookieValue = CookieManager2.generateRandomCookie().toString();
    }
    this.setCookieAndRemoveOldCookies(cookieValue);
    return cookieValue;
  };
  CookieManager2.generateRandomCookie = function() {
    return Math.floor(Math.random() * new Date().getTime());
  };
  CookieManager2.prototype.fetchCookie = function() {
    var _this = this;
    var cookieValue = "";
    var checkDomain = function(domain) {
      if (_this.canSetCookieWithDomain(domain)) {
        var removedValue = _this.removeCookieByDomain(domain);
        if (removedValue) {
          cookieValue = removedValue;
          _this.setCookie(cookieValue, domain);
        }
        return true;
      }
    };
    this.forEachDomainIncreasingSpecificity(checkDomain);
    if (!cookieValue)
      checkDomain("");
    return cookieValue;
  };
  CookieManager2.prototype.forEachDomainIncreasingSpecificity = function(func) {
    var exitedLoop = false;
    var domainParts = this._outerDocument.location.hostname.split(".").reverse();
    var currDomain = "";
    for (var i2 = 0; i2 < domainParts.length; i2++) {
      currDomain = "." + domainParts[i2] + currDomain;
      if (func(currDomain)) {
        exitedLoop = true;
        break;
      }
    }
    if (!exitedLoop)
      func("");
  };
  CookieManager2.prototype.removeCookieByDomain = function(cookieDomain) {
    var prevRemainingCookies = this.persistentCookies();
    this.clearCookie(cookieDomain);
    var remainingCookies = this.persistentCookies();
    if (remainingCookies.length < prevRemainingCookies.length) {
      return CookieManager2.listDifference(prevRemainingCookies, remainingCookies)[0] || "";
    }
    return "";
  };
  CookieManager2.listDifference = function(superlist, sublist) {
    var superlistCopy = Array.from(superlist);
    for (var i2 = 0; i2 < sublist.length; i2++) {
      var index2 = superlistCopy.indexOf(sublist[i2]);
      if (index2 !== -1) {
        superlistCopy.splice(index2, 1);
      }
    }
    return superlistCopy;
  };
  CookieManager2.prototype.persistentCookies = function() {
    return this.allCookies().filter(function(val) {
      return val !== COOKIE_REMOVAL_VALUE;
    });
  };
  CookieManager2.prototype.allCookies = function() {
    var arr = [];
    this.forEachCookieNameValue(function(name, value) {
      if (name === COOKIE_PARAM) {
        arr.push(value);
      }
    });
    return arr;
  };
  CookieManager2.prototype.forEachCookieNameValue = function(nameValueFunc) {
    this._outerDocument.cookie.split(";").forEach(function(cookie) {
      var keyValue = cookie.split("="), key = keyValue[0], value = keyValue[1];
      if (key && value) {
        nameValueFunc(key.trim(), value.trim());
      }
    });
  };
  CookieManager2.prototype.setCookieAndRemoveOldCookies = function(cookieValue) {
    var _this = this;
    var rootDomainReached = false;
    var totalCookies = this.allCookies().length;
    var numCookiesEncountered = 0;
    this.forEachDomainIncreasingSpecificity(function(domain) {
      if (rootDomainReached) {
        if (_this.removeCookieByDomain(domain))
          numCookiesEncountered++;
      } else {
        if (_this.canSetCookieWithDomain(domain)) {
          if (_this.removeCookieByDomain(domain))
            numCookiesEncountered++;
          _this.setCookie(cookieValue, domain);
          rootDomainReached = true;
        }
      }
      if (numCookiesEncountered >= totalCookies && rootDomainReached) {
        return true;
      }
    });
  };
  CookieManager2.prototype.canSetCookieWithDomain = function(domain) {
    var lostCookie = this.removeCookieByDomain(domain);
    var existingCookies = this.allCookies();
    this.setCookie(COOKIE_REMOVAL_VALUE, domain);
    var newCookies = this.allCookies();
    if (existingCookies.length < newCookies.length) {
      if (lostCookie) {
        this.setCookie(lostCookie, domain);
      } else {
        this.clearCookie(domain);
      }
      return true;
    }
    return false;
  };
  CookieManager2.prototype.setCookie = function(cookieValue, cookieDomain) {
    this._outerDocument.cookie = this.formatCookie(COOKIE_PARAM, cookieValue, cookieDomain);
  };
  CookieManager2.prototype.formatCookie = function(cookieName, cookieValue, domain, path) {
    if (path === void 0) {
      path = "/";
    }
    var cookieString = cookieName + "=" + cookieValue;
    var now = new Date();
    now.setTime(now.getTime() + 90 * 24 * 60 * 60 * 1e3);
    cookieString += ";path=" + path;
    cookieString += ";expires=" + now.toUTCString();
    if (domain)
      cookieString += ";domain=" + domain;
    cookieString += ";samesite=None;";
    if (this._outerWindow.location.protocol === "https:") {
      cookieString += " Secure ";
    }
    return cookieString;
  };
  CookieManager2.prototype.clearCookie = function(cookieDomain, cookiePath) {
    if (cookieDomain === void 0) {
      cookieDomain = "";
    }
    if (cookiePath === void 0) {
      cookiePath = "/";
    }
    var epoch = new Date(0);
    var cookieString = COOKIE_PARAM + "=" + COOKIE_REMOVAL_VALUE;
    cookieString += ";path=" + cookiePath;
    cookieString += ";expires=" + epoch.toUTCString();
    if (cookieDomain)
      cookieString += ";domain=" + cookieDomain + ";";
    cookieString += ";samesite=None;";
    if (this._outerWindow.location.protocol === "https:") {
      cookieString += " Secure ";
    }
    this._outerDocument.cookie = cookieString;
  };
  return CookieManager2;
}();

// node_modules/@yext/search-ui-react/node_modules/@yext/analytics/lib/esm/index.js
function provideAnalytics(config) {
  var httpRequester = new HttpRequester();
  return new SearchAnalyticsReporter(config, httpRequester);
}

// node_modules/@yext/search-ui-react/lib/esm/components/AnalyticsProvider.js
var __rest11 = function(s2, e2) {
  var t2 = {};
  for (var p2 in s2)
    if (Object.prototype.hasOwnProperty.call(s2, p2) && e2.indexOf(p2) < 0)
      t2[p2] = s2[p2];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s2); i2 < p2.length; i2++) {
      if (e2.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i2]))
        t2[p2[i2]] = s2[p2[i2]];
    }
  return t2;
};
function AnalyticsProvider(props) {
  const { children } = props, analyticsConfig = __rest11(props, ["children"]);
  const analyticsReporter = provideAnalytics(analyticsConfig);
  return (0, import_jsx_runtime63.jsx)(AnalyticsContext.Provider, Object.assign({ value: analyticsReporter }, { children }), void 0);
}

// node_modules/@yext/search-ui-react/lib/esm/models/StandardCardData.js
function isCtaData(data) {
  if (typeof data !== "object" || data === null) {
    return false;
  }
  const expectedKeys = ["label", "link", "linkType"];
  return expectedKeys.every((key) => {
    return key in data;
  });
}

// node_modules/@yext/search-ui-react/lib/esm/index.js
var ComponentsContentPath = "node_modules/@yext/search-ui-react/lib/**/*.{js,jsx}";
export {
  AlternativeVerticals,
  AnalyticsProvider,
  AppliedFilters,
  ApplyFiltersButton,
  ComponentsContentPath,
  DirectAnswer,
  DropdownItem,
  Facets,
  FilterDivider,
  FilterSearch,
  Geolocation,
  HierarchicalFacet,
  HierarchicalFacets,
  LocationBias,
  MapboxMap,
  NumericalFacet,
  NumericalFacets,
  Pagination,
  ResultsCount,
  SearchBar,
  SpellCheck,
  StandardCard,
  StandardFacet,
  StandardFacets,
  StandardSection,
  StaticFilters,
  ThumbsFeedback,
  UniversalResults,
  VerticalResults,
  executeAutocomplete,
  executeSearch,
  getSearchIntents,
  getUserLocation,
  isCtaData,
  renderHighlightedValue,
  updateLocationIfNeeded,
  useAnalytics,
  useCardAnalyticsCallback,
  useCardFeedbackCallback,
  useComposedCssClasses
};
/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
/**
  * @reach/auto-id v0.18.0
  *
  * Copyright (c) 2018-2022, React Training LLC
  *
  * This source code is licensed under the MIT license found in the
  * LICENSE.md file in the root directory of this source tree.
  *
  * @license MIT
  */
/**
  * @reach/utils v0.18.0
  *
  * Copyright (c) 2018-2022, React Training LLC
  *
  * This source code is licensed under the MIT license found in the
  * LICENSE.md file in the root directory of this source tree.
  *
  * @license MIT
  */
/**
 * @license
 * Lodash <https://lodash.com/>
 * Copyright OpenJS Foundation and other contributors <https://openjsf.org/>
 * Released under MIT license <https://lodash.com/license>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 */
/** @license React v16.13.1
 * react-is.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
//# sourceMappingURL=@yext_search-ui-react.js.map
